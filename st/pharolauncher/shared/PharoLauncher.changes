----QUIT----2022-04-25T09:45:08.329775+02:00 Pharo10-SNAPSHOT-64bit-0618067.image priorSource: 0!----QUIT----2022-04-25T09:45:38.294568+02:00 Pharo10-SNAPSHOT-64bit-0618067.image priorSource: 0!----SNAPSHOT----2022-04-28T15:10:30.015035+02:00 PharoLauncher.image priorSource: 99!!BaselineOfPharoLauncher methodsFor: 'baselines'!baseline: spec	<baseline>	spec for: #'common' do: [		self ston: spec.		self osSubprocess: spec.		self osWinSubprocess: spec.		self xmlParser: spec.		spec			package: 'PharoLauncher-100Compatibility'; 			package: 'PharoLauncher-Core' with: [				spec requires: #(					'XMLParser' 					'OSSubprocess' 					'OSWinSubprocess' 					'Ston' 					'PharoLauncher-100Compatibility'). ];			package: 'PharoLauncher-Spec2' with: [ 				spec requires: #('PharoLauncher-Core') ];			package: 'PharoLauncher-GToolkit' with: [ 				spec requires: #('PharoLauncher-Core') ];			package: 'PharoLauncher-Squeak' with: [ 				spec requires: #('PharoLauncher-Core') ];			package: 'PharoLauncher-Tests-Core' with: [				spec requires: #('PharoLauncher-Core' ) ];			package: 'PharoLauncher-Tests-Commands' with: [				spec requires: #('PharoLauncher-Spec2' ). ];			package: 'PharoLauncher-Tests-SpecUI' with: [				spec requires: #('PharoLauncher-Core' 'PharoLauncher-Spec2'). ];			package: 'PharoLauncher-Tests-Download' with: [				spec requires: #('PharoLauncher-Tests-Core' ). ];			package: 'PharoLauncher-Tests-Functional' with: [				spec requires: #('PharoLauncher-Core' 'PharoLauncher-Tests-Download'). ].		spec 			group: 'Default' with: #(				'PharoLauncher-Tests-Core' 				'PharoLauncher-Tests-Download' 				'PharoLauncher-Core' 				'PharoLauncher-Spec2' 				'PharoLauncher-Tests-SpecUI' 				'PharoLauncher-Tests-Functional' 				'PharoLauncher-GToolkit' 				'PharoLauncher-Squeak') ]! !!BaselineOfPharoLauncher methodsFor: 'external projects'!osSubprocess: spec	spec 		baseline: #OSSubprocess		with: [ spec repository: 'github://pharo-contributions/OSSubprocess:master/repository' ]! !!BaselineOfPharoLauncher methodsFor: 'external projects'!osWinSubprocess: spec	spec 		baseline: #OSWinSubprocess		with: [ spec repository: 'github://pharo-contributions/OSWinSubprocess:v1' ]! !!BaselineOfPharoLauncher methodsFor: 'external projects'!ston: spec	spec 		baseline: #Ston		with: [ spec repository: 'github://svenvc/ston:master/repository' ]! !!BaselineOfPharoLauncher methodsFor: 'external projects'!xmlParser: spec	spec 		baseline: #XMLParser		with: [ spec 					repository: 'github://pharo-contributions/XML-XMLParser:3.5.x';					loads: #('Core') ]! !"BaselineOfPharoLauncher"!!BaselineOfXMLParser commentStamp: '' prior: 0!Baseline for XML Parser (https://github.com/pharo-contributions/XML-XMLParser)!!BaselineOfXMLParser methodsFor: 'baselines'!baselineOf: spec	<baseline>	spec		for: #common		do: [						self 				bitmapCharacterSetOn: spec;				orderPreservingDictionaryOn: spec;				xmlWriterOn: spec.								"Packages"			spec 				package: 'XML-Parser' with: [ spec requires: #('OrderPreservingDictionary' 'BitmapCharacterSet') ];				package: 'XML-Parser-Tests' with: [ spec requires: #('XML-Parser' 'OrderPreservingDictionary Tests' 'BitmapCharacterSet Tests') ];				package: 'XML-Parser-Tests-Conformance' with: [ spec requires: #('XML-Parser' 'XMLWriter Tests' 'XML-Parser-Tests') ];				package: 'XML-Parser-GTExtensions' with: [ spec requires: #('XML-Parser') ].						"Groups"			spec				group: 'Core' with: #('XML-Parser');				group: 'Tools' with: #(OrderPreservingDictionary Tools 'XMLWriter Tools' 'XML-Parser-GTExtensions'); 				group: 'Tests' with: #('XML-Parser-Tests' 'XML-Parser-Tests-Conformance');					group: 'all' with: #('Core' 'Tools' 'Tests');				group: 'default' with: #('all')		]! !!BaselineOfXMLParser methodsFor: 'prerequisites '!bitmapCharacterSetOn: spec				spec		baseline: 'BitmapCharacterSet'      with: [ 			spec				loads: #('Core');				repository: 'github://pharo-contributions/BitmapCharacterSet:1.2.x/src' ]. 					spec project: 'BitmapCharacterSet Tests' copyFrom: 'BitmapCharacterSet' with: [ spec loads: #('Tests') ] 										! !!BaselineOfXMLParser methodsFor: 'prerequisites '!orderPreservingDictionaryOn: spec	spec		baseline: 'OrderPreservingDictionary'      with: [ 			spec				loads: #('Core');				repository: 'github://pharo-contributions/OrderPreservingDictionary:1.5.x/src' ]. 					spec 		project: 'OrderPreservingDictionary Tests' copyFrom: 'OrderPreservingDictionary' with: [ spec loads: #('Tests') ];					project: 'OrderPreservingDictionary Tools' copyFrom: 'OrderPreservingDictionary' with: [ spec loads: #('Tools') ]! !!BaselineOfXMLParser methodsFor: 'prerequisites '!xmlWriterOn: spec	spec		baseline: 'XMLWriter'      with: [ 			spec				loads: #('Core');				repository: 'github://pharo-contributions/XML-XMLWriter:2.9.x/src' ]. 					spec 		project: 'XMLWriter Tests' copyFrom: 'XMLWriter' with: [ spec loads: #('Tests') ]; 			project: 'XMLWriter Tools' copyFrom: 'XMLWriter' with: [ spec loads: #('Tools') ] ! !"BaselineOfXMLParser"!!BaselineOfOSWinSubprocess methodsFor: 'baselines'!baseline: spec	<baseline>	spec		for: #common		do: [ 	spec				package: #OSWinSubprocess;				package: #'OSWinSubprocess-Tests' with: [ spec requires: #OSWinSubprocess ] ].! !"BaselineOfOSWinSubprocess"!!BaselineOfSton commentStamp: 'SvenVanCaekenberghe 10/8/2018 15:45' prior: 0!I am BaselineOfSton, I load STON (Smalltalk Object Notation).I am a BaselineOf.!!BaselineOfSton methodsFor: 'baselines' stamp: 'CompatibleUserName 4/12/2022 17:28:10'!baseline: spec	<baseline>	spec		for: #common		do: [ spec blessing: #baseline.			spec				package: 'STON-Core';				package: 'STON-Extensions';				package: 'STON-Tests';				package: 'STON-Text support';				group: 'Core' with: #('STON-Core');				group: 'default' with: #('STON-Core' 'STON-Extensions' 'STON-Text support' 'STON-Tests') ]! !"BaselineOfSton"!!BaselineOfOSSubprocess commentStamp: '' prior: 0!I am a baseline of OSSubprocess. OSSubprocess is a software project that allows the user to spawn Operatying System processes from within Pharo language. The main usage of forking external OS processes is to be able to execute OS commands (.e.g cat, ls, ps, cp, etc) as well as arbitrary shell scripts (.e.g /etc/myShellScript.sh) from Pharo.An important part of OSSubprocess is how to manage standard streams (stdin, stdout and stderr) and how to provide an API for reading and writing from them at the language level.For more details see: https://github.com/marianopeck/OSSubprocess!!BaselineOfOSSubprocess methodsFor: 'baseline'!baseline: spec	<baseline>	spec		for: #pharo		do: [							spec				package: 'OldFileStream';				package: 'OSSubprocess' with: [ spec requires: #('FFICHeaderExtractor' 'OldFileStream') ];				package: 'OSSubprocess-Tests-Unit' with: [ spec requires: #('OSSubprocess' 'Unicode') ];				package: 'OSSubprocess-Tests-Stress' with: [ spec requires: 'OSSubprocess-Tests-Unit' ].			spec baseline: 'FFICHeaderExtractor' with: [    			spec repository: 'github://pharo-contributions/FFICHeaderExtractor:v1.0.2/repository' ].			spec baseline: 'Unicode' with: [				spec repository: 'github://pharo-contributions/pharo-unicode:v1.1.0/src' ].			spec				group: 'Core' with: #( 'OSSubprocess' );				group: 'Tests' with: #( 'OSSubprocess-Tests-Unit' 'OSSubprocess-Tests-Stress' ).		]! !"BaselineOfOSSubprocess"!!BaselineOfUnicode methodsFor: 'baselines'!baseline: spec 	<baseline>	spec for: #common do: [		spec 			package: 'Unicode-Character-Data';			package: 'Unicode-Stream-Support';			package: 'Unicode-Casing' with: [ 				spec requires: #('Unicode-Character-Data' 'Unicode-Stream-Support') ];			package: 'Unicode-Normalization' with: [ 				spec requires: #('Unicode-Character-Data' 'Unicode-Stream-Support') ];			package: 'Unicode-Collate' with: [ 				spec requires: #('Unicode-Normalization') ];			package: 'Unicode-Tests-Character-Data' with: [ 				spec requires: 'Unicode-Character-Data' ];			package: 'Unicode-Tests-Casing' with: [ 				spec requires: 'Unicode-Casing' ];			package: 'Unicode-Tests-Normalization' with: [ 				spec requires: 'Unicode-Normalization' ];			package: 'Unicode-Tests-Collate' with: [ 				spec requires: 'Unicode-Collate' ];			group: 'default' with: #('Core' 'Tests');						group: 'Core' with: #(				'Unicode-Character-Data' 'Unicode-Casing' 'Unicode-Stream-Support' 'Unicode-Normalization');			group: 'Tests' with: #(				'Unicode-Tests-Character-Data' 'Unicode-Tests-Casing' 'Unicode-Tests-Normalization');			group: 'Collate' with: #(				'Unicode-Collate' 'Unicode-Tests-Collate') ]! !"BaselineOfUnicode"!!BaselineOfFFICHeaderExtractor commentStamp: '' prior: 0!For more details see https://github.com/marianopeck/FFICHeaderExtractorIn short, FFICHeaderExtractor is a program to extract information (e.g. constants) from C headers and integrate that into Smalltalk SharedPools.When we use FFI to call a certain library, it's quite common that we need to pass specific constants (for example, SIGKILL to kill()). These constants are defined in C header files and can even change their values in different paltforms. Sometimes, these constants also are defined by the C preprocessor and so there is not way to get those values from FFI. If you don't have the value of those constants, you cannot make the FFI call. In other words, if I cannot know that the value of SIGKILL is 9, how do I call kill() from FFI?This tool allows the developers of a FFI tool (any project which uses FFI to call a certain library), to automatically create a C program that writes all the user-defined constants values, compile it, run it, and create a Smalltalk init method which initializes the shared pool constants based on C program output. This autogenerated init method can then be distributed with the rest of the FFI tool. FFICHeaderExtractor will also automatically initialize (searching and executing the previously autogenerated init method for the current platform) a SharedPool upon system startup.!!BaselineOfFFICHeaderExtractor methodsFor: 'baseline'!baseline: spec	<baseline>	spec		for: #common		do: [ 			spec				package: 'FFICHeaderExtractor';				package: 'FFICHeaderExtractor-Tests' with: [ spec requires: 'FFICHeaderExtractor' ];				package: 'FFICHeaderExtractor-LibC' with: [ spec requires: 'FFICHeaderExtractor' ].				]! !"BaselineOfFFICHeaderExtractor"!!BaselineOfBitmapCharacterSet commentStamp: '' prior: 0!A baseline for https://github.com/pharo-contributions/BitmapCharacterSet!!BaselineOfBitmapCharacterSet methodsFor: 'baselines'!baseline: spec	<baseline>		spec for: #common do: [ 		"Packages and Dependencies"		spec 			package: 'Collections-BitmapCharacterSet';			package: 'Collections-BitmapCharacterSet-Tests' with: [ spec requires: 'Collections-BitmapCharacterSet' ].					"Groups"			spec								group: 'Core' with: #('Collections-BitmapCharacterSet');				group: 'Tests' with: #('Collections-BitmapCharacterSet-Tests');				group: 'all' with: #('Core' 'Tests');				group: 'default' with: #('all')		]! !"BaselineOfBitmapCharacterSet"!!BaselineOfOrderPreservingDictionary commentStamp: '' prior: 0!A baseline for an order preserving dictionary (https://github.com/pharo-contributions/OrderPreservingDictionary)!!BaselineOfOrderPreservingDictionary methodsFor: 'baselines'!baseline: spec	<baseline>	spec		for: #common		do: [ 			"Packages"			spec package: 'Collections-OrderPreservingDictionary';				  package: 'Collections-OrderPreservingDictionary-Tests' with: [ spec requires: #('Collections-OrderPreservingDictionary') ];				  package: 'Collections-OrderPreservingDictionary-GTExtensions' with: [ spec requires: #('Collections-OrderPreservingDictionary') ].							"Groups"				spec				group: 'Core' with: #('Collections-OrderPreservingDictionary');				group: 'Tests' with: #('Collections-OrderPreservingDictionary-Tests');				group: 'Tools' with: #('Collections-OrderPreservingDictionary-GTExtensions');				group: 'all' with: #('Core' 'Tools' 'Tests');				group: 'default' with: #('all') ].	spec		for: #gemstone		do: [ 			spec package: 'Collections-OrderPreservingDictionary' with: [ spec includes: 'Collections-OrderPreservingDictionary-GemstoneCompatibility' ].			spec package: 'Collections-OrderPreservingDictionary-GemstoneCompatibility' with: [ spec requires: 'Collections-OrderPreservingDictionary' ]].! !!BaselineOfOrderPreservingDictionary methodsFor: 'accessing'!customProjectAttributes	"Edit to return a collection of any custom attributes e.g. for conditional loading: Array with: #'Condition1' with: #'Condition2.	For more information see: http://code.google.com/p/metacello/wiki/CustomProjectAttributes "	(Smalltalk globals includesKey: #GTInspector)		ifTrue: [ ^ #(gt) ]		ifFalse: [ ^ #() ]! !"BaselineOfOrderPreservingDictionary"!!STONWriter methodsFor: 'initialize-release' stamp: 'CompatibleUserName 4/12/2022 17:28:10' prior: 60662382!initialize	super initialize.	stonCharacters := STONCharacters.	prettyPrint := false.	newLine := OSPlatform current lineEnding.	level := 0.	referencePolicy := #normal.	jsonMode := keepNewLines := asciiOnly := false.	objects := IdentityDictionary new! !"STON-Core"!!ManifestDeprecatedFileStream commentStamp: '' prior: 0!Deprecated package including the old file stream implementations!!OldFileStream commentStamp: '' prior: 0!I'm a deprecated class. Since the version 5, Pharo provides a new file streams API that makes the old one based on classes like FileStream or MultiByteBinaryOrTextStream deprecated. Pharo 7 makes the next important steps and removes usages of the old API from the kernel.What you should remember:- use file references as entry points to file streams - DO NOT USE FileStream class- 'file.txt' asFileReference readStream and similar methods now return an instance of ZnCharacterReadStream instead of MultiByteFileStream- 'file.txt' asFileReference writeStream and similar methods now return an instance of ZnCharacterWriteStream instead of MultiByteFileStream- the new API has a clearer separation between binary and text files1. Basic FilesBy default files are binary. Not buffered.Read UTF-8 text from an existing fileObsolete code:FileStream readOnlyFileNamed: '1.txt' do: [ :stream |     stream upToEnd ].New code:(File named: 'name') readStream.(File named: 'name') readStreamDo: [ :stream | ‚Ä¶ ].'1.txt' asFileReference readStreamDo: [ :stream |     stream upToEnd ].2. EncodingTo add encoding, wrap a stream with a corresponding ZnCharacterRead/WriteStream.‚ÄúReading‚Äùutf8Encoded := ZnCharacterReadStream on: aBinaryStream encoding: ‚Äòutf8‚Äô.utf16Encoded := ZnCharacterReadStream on: aBinaryStream encoding: ‚Äòutf16‚Äô.‚ÄúWriting‚Äùutf8Encoded := ZnCharacterWriteStream on: aBinaryStream encoding: ‚Äòutf8‚Äô.utf16Encoded := ZnCharacterWriteStream on: aBinaryStream encoding: ‚Äòutf16‚Äô.Force creation of a new file and write a UTF-8 textObsolete code:FileStream forceNewFileNamed: '1.txt' do: [ :stream | stream nextPutAll: 'a ‚â† b' ].New code:(File named: ‚Äòname‚Äô) writeStream.(File named: ‚Äòname‚Äô) writeStreamDo: [ :stream | ‚Ä¶ ].'1.txt' asFileReference ensureDelete;     writeStreamDo: [ :stream | stream nextPutAll: 'a ‚â† b' ].Get all content of existing UTF-8 fileObsolete code:(FileStream readOnlyFileNamed: '1.txt') contentsOfEntireFile.New code:'1.txt' asFileReference readStream upToEnd.3. BufferingTo add buffering, wrap a stream with a corresponding ZnBufferedRead/WriteStream.bufferedReadStream := ZnBufferedReadStream on: aStream.bufferedWriteStream := ZnBufferedWriteStream on: aStream.It is in general better to buffer the reading on the binary file and apply the encoding on the buffer in memory than the other way around. See[file := Smalltalk sourcesFile fullName.(File named: file) readStreamDo: [ :binaryFile |(ZnCharacterReadStream on: (ZnBufferedReadStream on: binaryFile) encoding: ‚Äòutf8‚Äô) upToEnd]] timeToRun. ‚Äú0:00:00:09.288‚Äù[file := Smalltalk sourcesFile fullName.(File named: file) readStreamDo: [ :binaryFile |(ZnBufferedReadStream on: (ZnCharacterReadStream on: binaryFile encoding: ‚Äòutf8‚Äô)) upToEnd]] timeToRun. ‚Äú0:00:00:14.189‚ÄùThe MultiByteFileStream was buffered. If you create a stream using the expression'file.txt' asFileReference readStream.then the ZnCharacterReadStream is not created directly on top of the stream but on top of a buffered stream that uses the file stream internally.If you create a ZnCharacterReadStream directly on the file stream, then the characters from the file are read one by one which may be about ten times slower!!ZnCharacterReadStream on: (File openForReadFileNamed: 'file.txt').4. File SystemBy default, file system files are buffered and utf8 encoded to keep backwards compatibility.‚Äòname‚Äô asFileReference readStreamDo: [ :bufferedUtf8Stream | ‚Ä¶ ].‚Äòname‚Äô asFileReference writeStreamDo: [ :bufferedUtf8Stream | ‚Ä¶ ].FileStream also provides access to plain binary files using the #binaryRead/WriteStream messages. Binary streams are buffered by default too.‚Äòname‚Äô asFileReference binaryReadStreamDo: [ :bufferedBinaryStream | ‚Ä¶ ].‚Äòname‚Äô asFileReference binaryWriteStreamDo: [ :bufferedBinaryStream | ‚Ä¶ ].If you want a file with another encoding (to come in the PR https://github.com/pharo-project/pharo/pull/1134), you can specify it while obtaining the stream:‚Äòname‚Äô asFileReference    readStreamEncoded: ‚Äòutf16‚Äô    do: [ :bufferedUtf16Stream | ‚Ä¶ ].‚Äòname‚Äô asFileReference    writeStreamEncoded: ‚Äòutf8‚Äô    do: [ :bufferedUtf16Stream | ‚Ä¶ ].Force creation of a new file and write binary data into itObsolete code:(FileStream forceNewFileNamed: '1.bin')     binary;    nextPutAll: #[1 2 3].New code:'1.bin' asFileReference ensureDelete;     binaryWriteStreamDo: [ :stream | stream nextPutAll: #[1 2 3] ].Read binary data from an existing fileObsolete code:(FileStream readOnlyFileNamed: '1.bin') binary; contentsOfEntireFile.New code:'1.bin' asFileReference binaryReadStream upToEnd.Force creation of a new file with a different encodingObsolete code:FileStream forceNewFileNamed: '2.txt' do: [ :stream |     stream converter: (TextConverter newForEncoding: 'cp-1250').    stream nextPutAll: 'P≈ô√≠li≈° ≈ælu≈•ouƒçk√Ω k≈Ø≈à √∫pƒõl ƒè√°belsk√© √≥dy.' ].New code:('2.txt' asFileReference) ensureDelete;    writeStreamEncoded: 'cp-1250' do: [ :stream |        stream nextPutAll: 'P≈ô√≠li≈° ≈ælu≈•ouƒçk√Ω k≈Ø≈à √∫pƒõl ƒè√°belsk√© √≥dy.' ].Read encoded text from an existing fileObsolete code:FileStream readOnlyFileNamed: '2.txt' do: [ :stream |     stream converter: (TextConverter newForEncoding: 'cp-1250').    stream upToEnd ].New code:('2.txt' asFileReference)    readStreamEncoded: 'cp-1250' do: [ :stream |        stream upToEnd ].Write a UTF-8 text to STDOUTObsolete code:FileStream stdout nextPutAll: 'a ‚â† b'; lf.New code:(ZnCharacterWriteStream on: Stdio stdout)    nextPutAll: 'a ‚â† b'; lf;    flush.Write CP-1250 encoded text to STDOUTObsolete code:FileStream stdout     converter: (TextConverter newForEncoding: 'cp-1250');    nextPutAll: 'P≈ô√≠li≈° ≈ælu≈•ouƒçk√Ω k≈Ø≈à √∫pƒõl ƒè√°belsk√© √≥dy.'; lf.New code:(ZnCharacterWriteStream on: Stdio stdout encoding: 'cp1250')    nextPutAll: 'P≈ô√≠li≈° ≈ælu≈•ouƒçk√Ω k≈Ø≈à √∫pƒõl ƒè√°belsk√© √≥dy.'; lf;    flush.Read a UTF-8 text from STDINCAUTION: Following code will stop your VM until an input on STDIN will be provided!!Obsolete code:FileStream stdin upTo: Character lf.New code:(ZnCharacterReadStream on: Stdio stdin) upTo: Character lf.Write binary data to STDOUTobsolete codeFileStream stdout     binary    nextPutAll: #[80 104 97 114 111 10 ].New code:Stdio stdout     nextPutAll: #[80 104 97 114 111 10 ].Read binary data from STDINCAUTION: Following code will stop your VM until an input on STDIN will be provided!!Obsolete code:FileStream stdin binary upTo: 10.New code:Stdio stdin upTo: 10.Positionable streamsThe message #position: always works on the binary level, not on the character level.'1.txt' asFileReference readStreamDo: [ :stream |     stream position: 4.    stream upToEnd ].This will lead to an error (ZnInvalidUTF8: Illegal leading byte for UTF-8 encoding) in case of the file created above because we set the position into the middle of a UTF-8 encoded character. To be safe, you need to read the file from the beginning.'1.txt' asFileReference readStreamDo: [ :stream |    3 timesRepeat: [ stream next ].    stream upToEnd.].5. Line Ending ConventionsIf you want to write files following a specific line ending convention, use the ZnNewLineWriterStream.This stream decorator will transform any line ending (cr, lf, crlf) into a defined line ending.By default, it chooses the platform line ending convention.lineWriter := ZnNewLineWriterStream on: aStream.If you want to choose another line ending convention you can do:lineWriter forCr.lineWriter forLf.lineWriter forCrLf.lineWriter forPlatformLineEnding.-------------------------------------------Old comment: I represent a Stream that accesses a FilePage from a File. One use for my instance is to access larger "virtual Strings" than can be stored contiguously in main memory. I restrict the objects stored and retrieved to be Integers or Characters. An end of file pointer terminates reading; it can be extended by writing past it, or the file can be explicitly truncated.	To use the file system for most applications, you typically create a FileStream. This is done by sending a message to a FileDirectory (file:, oldFile:, newFile:, rename:newName:) which creates an instance of me. Accesses to the file are then done via my instance.*** On DOS, files cannot be shortened!!  ***  To overwrite a file with a shorter one, first delete the old file (FileDirectory deleteFilePath: 'Hard Disk:aFolder:dataFolder:foo') or (aFileDirectory deleteFileNamed: 'foo').  Then write your new shorter version.!!OldStandardFileStream commentStamp: '' prior: 0!Provides a simple, platform-independent, interface to a file system. The instance variable rwmode, inherited from class PositionableStream, here is used to hold a Boolean -- true means opened for read-write, false means opened for read-only.  2/12/96 swI implement a simple read buffering scheme with the variables defined in PositionableStream (which are unused in me otherwise) in the following way:	collection	<ByteString> or <ByteArray>	This is the buffer.	position	<Integer>	The relative position in the buffer. Greater or equal to zero.	readLimit	<Integer>	The number of bytes buffered. Greater or equal to zero.Read buffering is enabled with #enableReadBuffering, disabled with #disableReadBuffering and it is enabled by default. The buffer is filled when a read attempt of an unbuffered absolute position is requested, or when a negative repositioning is made (with #position: with an argument < than the current absolute position) to an absolute position which is not buffered. In the first case, the buffer is positioned to the given absolute position. In the latter case the repositioning is made to the requested absolute position minus fourth of the buffer size. This means that further small negative repositionings won't result in buffer flushing. This is really useful when filing in code.The read buffer is flushed (#flushReadBuffer) whenever a write attempt is made.The buffer state is valid if and only if collection is not nil and position < readLimit.!!OldMultiByteFileStream commentStamp: '' prior: 0!The central class to access the external file.  The interface of this object is similar to good old StandardFileStream, but internally it asks the converter, which is a sub-instance of TextConverter, and do the text conversion.  It also combined the good old CrLfFileStream.  CrLfFileStream class>>new now returns an instance of MultiByteFileStream.  There are several pitfalls:  * You always have to be careful about the binary/text distinction.  In #text mode, it usually interpret the bytes.  * A few file pointer operations treat the file as uninterpreted byte no matter what.  This means that if you use 'fileStream skip: -1', 'fileStream position: x', etc. in #text mode, the file position can be in the middle of multi byte character.  If you want to implement some function similar to #peek for example, call the saveStateOf: and restoreStateOf: methods to be able to get back to the original state.  * #lineEndConvention: and #wantsLineEndConversion: (and #binary) can cause some puzzling situation because the inst var lineEndConvention and wantsLineEndConversion are mutated.  If you have any suggestions to clean up the protocol, please let me know.!!OldMultiByteBinaryOrTextStream commentStamp: '' prior: 0!It is similar to MultiByteFileStream, but works on in memory stream.!!OldRWBinaryOrTextStream commentStamp: '' prior: 0!This package is to support the migration of OSSubProcess to Pharo 9.0 where FileStream has been removed after been deprecated in Pharo 8.0.A simulation of a FileStream, but living totally in memory.  Hold the contents of a file or web page from the network.  Can then fileIn like a normal FileStream.Need to be able to switch between binary and text, as a FileStream does, without recopying the whole collection.  Convert to binary upon input and output.  Always keep as text internally.!!OldFileExistsException commentStamp: '' prior: 0!Notify when file exists!!OldLimitingLineStreamWrapper commentStamp: '' prior: 0!I'm a wrapper for a stream optimized for line-by-line access using #nextLine. My instances can be nested.I read one line ahead. Reading terminates when the stream ends, or if the limitingBlock evaluated with the line answers true. To skip the delimiting line for further reading use #skipThisLine.Character-based reading (#next) is permitted, too. Send #updatePosition when switching from line-based reading.See examples at the class side.--bf 2/19/1999 12:52!!PositionableStream methodsFor: '*OldFileStream'!asBinaryOrTextStream	"Convert to a stream that can switch between bytes and characters"	^ (OldRWBinaryOrTextStream with: self contentsOfEntireFile) reset! !!ManifestDeprecatedFileStream class methodsFor: 'deprecation'!isDeprecated	^true! !!OldFileStream class methodsFor: 'file reader services'!changesFileSuffixes	^#('changes')! !!OldFileStream class methodsFor: 'concrete classes'!concreteStream	"Who should we really direct class queries to?  "	^ OldMultiByteFileStream.! !!OldFileStream class methodsFor: 'utilities'!convertCRtoLF: fileName	"Convert the given file to LF line endings. Put the result in a file with the extention '.lf'"	| in out c justPutCR |	in := (self readOnlyFileNamed: fileName) binary.	out :=  (self newFileNamed: fileName, '.lf') binary.	justPutCR := false.	[in atEnd] whileFalse: [		c := in next.		c = 10			ifTrue: [				out nextPut: 13.				justPutCR := true]			ifFalse: [				(justPutCR and: [c = 10]) ifFalse: [out nextPut: c].				justPutCR := false]].	in close.	out close.! !!OldFileStream class methodsFor: 'instance creation'!detectFile: aBlock do: anotherBlock	^aBlock value		ifNil: [nil]      	ifNotNil: [:file| [anotherBlock value: file] ensure: [file close]]! !!OldFileStream class methodsFor: 'file reader services'!fileIn: fullName	"File in the entire contents of the file specified by the name provided"	| ff fn |	fullName ifNil: [^ self inform: 'Filename is nil.'].	fn := fullName asFileReference.	fn := (Smalltalk hasClassNamed: #GZipReadStream) 		ifTrue: [(Smalltalk classNamed:  #GZipReadStream) uncompressedFileName: fn fullName]		ifFalse: [fn fullName].	ff := self readOnlyFileNamed: fn.	ff fileIn.! !!OldFileStream class methodsFor: 'instance creation'!fileNamed: fileName 	^ self concreteStream fileNamed: (self fullName: fileName)! !!OldFileStream class methodsFor: 'instance creation'!fileNamed: fileName do: aBlock	"Returns the result of aBlock."		^ self detectFile: [ self fileNamed: fileName ] do: aBlock! !!OldFileStream class methodsFor: 'stdio'!flushAndVoidStdioFiles	StdioFiles ifNotNil: [		StdioFiles do: [ :file |			file ifNotNil: [ 				file isReadOnly ifFalse: [					[ file flush ]						on: Error						do: [ :ex | "care less" ] ] ] ].	].	self voidStdioFiles! !!OldFileStream class methodsFor: 'instance creation'!forceNewFileNamed: fileName 	"Create a new file with the given name, and answer a stream opened for writing on that file. If the file already exists, delete it without asking before creating the new file."	SessionManager default currentSession isReadOnlyAccessMode ifTrue: [ ((CannotDeleteFileException fileName: fileName)		messageText: 'Could not delete the old version of file ' , fileName) signal.		^ NullStream new ].	^self concreteStream forceNewFileNamed: fileName! !!OldFileStream class methodsFor: 'instance creation'!forceNewFileNamed: fileName do: aBlock	"Returns the result of aBlock."		^ self detectFile: [ self forceNewFileNamed: fileName ] do: aBlock! !!OldFileStream class methodsFor: 'instance creation'!fullName: fileName	^ fileName asFileReference fullName ! !!OldFileStream class methodsFor: 'initialize-release'!initialize	TheStdioHandles := Array new: 3.	SessionManager default registerSystemClassNamed: self name! !!OldFileStream class methodsFor: 'instance creation'!isAFileNamed: fName	"return whether a file exists with the given name"	^self concreteStream isAFileNamed: (self fullName: fName)! !!OldFileStream class methodsFor: 'file reader services'!isChangesFileSuffix: suffix	^ self changesFileSuffixes includes: suffix! !!OldFileStream class methodsFor: 'deprecation'!isDeprecated	^true! !!OldFileStream class methodsFor: 'file reader services'!isSourceFileSuffix: suffix	^ self sourceFileSuffixes includes: suffix! !!OldFileStream class methodsFor: 'instance creation'!new	^ self basicNew! !!OldFileStream class methodsFor: 'instance creation'!newFileNamed: fileName 	^ self concreteStream newFileNamed: (self fullName: fileName)! !!OldFileStream class methodsFor: 'instance creation'!newFileNamed: fileName do: aBlock	"Returns the result of aBlock."		^ self detectFile: [ self newFileNamed: fileName ] do: aBlock! !!OldFileStream class methodsFor: 'stdio'!newForStdio	"This is a hook for subclasses to initialize themselves properly."	^self new! !!OldFileStream class methodsFor: 'instance creation'!oldFileNamed: fileName 	^ self concreteStream oldFileNamed: (self fullName: fileName)! !!OldFileStream class methodsFor: 'instance creation'!oldFileNamed: fileName do: aBlock	"Returns the result of aBlock."		^ self detectFile: [ self oldFileNamed: fileName ] do: aBlock! !!OldFileStream class methodsFor: 'instance creation'!oldFileOrNoneNamed: fileName	"If the file exists, answer a read-only FileStream on it. If it doesn't, answer nil."	| fullName |	fullName := self fullName: fileName.	^ (self concreteStream isAFileNamed: fullName)		ifTrue: [ self concreteStream readOnlyFileNamed: fullName]		ifFalse: [ nil].! !!OldFileStream class methodsFor: 'instance creation'!onHandle: aFileSystemHandle	^ self concreteStream new		open: aFileSystemHandle fullName		forWrite: aFileSystemHandle isWritable! !!OldFileStream class methodsFor: 'instance creation'!readOnlyFileNamed: fileName 	^ self concreteStream readOnlyFileNamed: (self fullName: fileName)! !!OldFileStream class methodsFor: 'instance creation'!readOnlyFileNamed: fileName do: aBlock	"Open the existing file with the given name for read-only access and pass it as argument to aBlock.	Returns the result of aBlock."		^ self detectFile: [ self readOnlyFileNamed: fileName ] do: aBlock! !!OldFileStream class methodsFor: 'file reader services'!removeLineFeeds: fullName	| fileContents |	fileContents := ((OldFileStream readOnlyFileNamed: fullName) wantsLineEndConversion: true) contentsOfEntireFile.	(OldFileStream newFileNamed: fullName) 		nextPutAll: fileContents;		close.! !!OldFileStream class methodsFor: 'dnd requests'!requestDropStream: dropIndex	"Request a read-only stream for some file that was dropped onto the application"	^self concreteStream new requestDropStream: dropIndex.! !!OldFileStream class methodsFor: 'system startup'!shutDown: isImageQuitting	isImageQuitting ifTrue: [ self flushAndVoidStdioFiles ]! !!OldFileStream class methodsFor: 'file reader services'!sourceFileSuffixes	^#('st' 'cs')! !!OldFileStream class methodsFor: 'stdio'!standardIOStreamNamed: moniker forWrite: forWrite	"Create if necessary and store default stdin, stdout and other files based on the their names"		| index |		"This is an ugly hack, while waiting for a real fix for windows. There  several problems with this approach, but it allow us to run tests, etc."	Smalltalk os isWin32 		ifTrue: [ 			[ ^ OldMultiByteFileStream forceNewFileNamed: moniker asString ]			on: CannotDeleteFileException do: [				"HACK: if the image is opened a second time windows barks about the already opened locked file"				^ OldMultiByteFileStream forceNewFileNamed: moniker asString, '_', (Random new nextInt: SmallInteger maxVal) asString   ]]. 			index := #(stdin stdout stderr) identityIndexOf: moniker.	^((StdioFiles ifNil: [ StdioFiles := Array new: 3 ]) at: index)		ifNil: [			StdioFiles				at: index 				put: (					(TheStdioHandles at: index)						ifNil: [ ^self error: moniker, ' is unavailable' ]						ifNotNil: [ :handle |							OldMultiByteFileStream newForStdio								openOnHandle: handle								name: moniker								forWrite: forWrite ]) ]! !!OldFileStream class methodsFor: 'system startup'!startUp: isImageStarting	isImageStarting		ifFalse: [ ^ self ].	self voidStdioFiles.	[ TheStdioHandles := self stdioHandles ]		on: Error		do: [ :ex | 			TheStdioHandles isArray				ifFalse: [ TheStdioHandles := Array new: 3 ] ]! !!OldFileStream class methodsFor: 'stdio'!stderr	^Stderr ifNil: [ Stderr := self standardIOStreamNamed: #stderr forWrite: true ]! !!OldFileStream class methodsFor: 'stdio'!stdin	^Stdin ifNil: [		Stdin := self standardIOStreamNamed: #stdin forWrite: false.		Stdin			disableReadBuffering;			yourself ].! !!OldFileStream class methodsFor: 'stdio'!stdioHandles	<primitive: 'primitiveFileStdioHandles' module: 'FilePlugin' error: ec>	self primitiveFailed! !!OldFileStream class methodsFor: 'stdio'!stdout	^Stdout ifNil: [ Stdout := self standardIOStreamNamed: #stdout forWrite: true ]! !!OldFileStream class methodsFor: 'stdio'!voidStdioFiles			Smalltalk os isWin32 ifTrue: [ 		{Stdout . Stderr } do: [ :each | 			[ 	each ifNotNil: [ 					each size isZero ifTrue: [ 						each close.						each name asFileReference delete	 					] 				]			] ifError: [ ].		]	].		Stdin := Stdout := Stderr := StdioFiles := nil! !!OldFileStream class methodsFor: 'utilities'!writeSourceCodeFrom: aStream baseName: baseName isSt: stOrCsFlag	| extension converter fileName  |	[ 	extension :=  stOrCsFlag ifTrue: ['.st']  ifFalse: ['.cs'].		converter := aStream contents isAsciiString 			ifTrue: [MacRomanTextConverter new] 			ifFalse: [UTF8TextConverter new].		fileName := baseName, extension.		fileName := FileSystem disk checkName: fileName fixErrors: true.		[OldFileStream newFileNamed: fileName do: [:fileStream |			fileName := fileStream name. "in case it is changed when handling FileExistsException"			(converter isMemberOf: UTF8TextConverter)				ifTrue: [fileStream binary.						UTF8TextConverter writeBOMOn: fileStream].			fileStream				text;				converter: converter;				nextPutAll: aStream contents;				close]] on: Abort do: [:e | ^self ]	] on: Error do: 	[ 	:error | 		error isResumable 			ifTrue: [ error resumeUnchecked: error defaultAction]			ifFalse: [ error pass ]	].	self inform: 'Filed out to: ', String cr, fileName.! !!OldFileStream methodsFor: 'converting'!asBinaryOrTextStream	"I can switch between binary and text data"	^ self! !!OldFileStream methodsFor: 'modes'!ascii	"Set this file to ascii (text) mode."	self subclassResponsibility! !!OldFileStream methodsFor: 'testing'!atEnd	"Answer true if the current position is >= the end of file position."	self subclassResponsibility! !!OldFileStream methodsFor: 'modes'!binary	"Set this file to binary mode."	self subclassResponsibility! !!OldFileStream methodsFor: 'open/close'!close	"Close this file."	self subclassResponsibility! !!OldFileStream methodsFor: 'testing'!closed	"Answer true if this file is closed."	self subclassResponsibility! !!OldFileStream methodsFor: 'accessing'!contents	"Return the contents of the receiver. Do not close or otherwise touch the receiver. Return data in whatever mode the receiver is in (e.g., binary or text)."	| s savePos |	savePos := self position.	self position: 0.	s := self next: self size.	self position: savePos.	^s! !!OldFileStream methodsFor: 'accessing'!contentsOfEntireFile	"Read all of the contents of the receiver."	| s binary |	self readOnly.	binary := self isBinary.	self reset.	"erases knowledge of whether it is binary"	binary ifTrue: [self binary].	s := self next: self size.	self close.	^s! !!OldFileStream methodsFor: 'actions'!delete		(File named: self name) delete! !!OldFileStream methodsFor: 'actions'!exists		^ (File named: self name) exists! !!OldFileStream methodsFor: 'accessing'!file	"Answer the file for the page the receiver is streaming over."	self subclassResponsibility! !!OldFileStream methodsFor: 'ToDeprecate'!fileIn	"Guarantee that the receiver is readOnly before fileIn for efficiency and	to eliminate remote sharing conflicts."	self readOnly.	CodeImporter evaluateFileStream: self.! !!OldFileStream methodsFor: 'flushing'!flush	"When writing, this flushes the write buffer the stream uses to reduce	the number of write() system calls it makes. This should generally be	used before #sync, but on Windows they do the same thing."	self subclassResponsibility! !!OldFileStream methodsFor: 'accessing'!localName	^ self name asFileReference basename! !!OldFileStream methodsFor: 'printing'!longPrintOn: aStream	"Do nothing, so it will print short.  Called to print the error file.  If the error was in a file operation, we can't read the contents of that file.  Just print its name instead."! !!OldFileStream methodsFor: 'printing'!longPrintOn: aStream limitedTo: sizeLimit indent: indent	"Do nothing, so it will print short.  Called to print the error file.  If the error was in a file operation, we can't read the contents of that file.  Just print its name instead."	aStream cr! !!OldFileStream methodsFor: 'accessing'!mimeTypes	^ self name asFileReference mimeTypes.! !!OldFileStream methodsFor: 'accessing'!name	"Answer the name of the file for the page the receiver is streaming over."	self subclassResponsibility! !!OldFileStream methodsFor: 'accessing'!next	(position >= readLimit and: [self atEnd])		ifTrue: [^nil]		ifFalse: [^collection at: (position := position + 1)]! !!OldFileStream methodsFor: 'accessing'!next: anInteger	| newCollection howManyRead increment |	newCollection := self collectionSpecies new: anInteger.	howManyRead := 0.	[howManyRead < anInteger] whileTrue:		[self atEnd ifTrue:			[(howManyRead + 1) to: anInteger do: [:i | newCollection at: i put: (self next)].			^newCollection].		increment := (readLimit - position) min: (anInteger - howManyRead).		newCollection replaceFrom: (howManyRead + 1)			to: (howManyRead := howManyRead + increment)			with: collection			startingAt: (position + 1).		position := position + increment].	^newCollection! !!OldFileStream methodsFor: 'accessing'!nextPut: aByte	"1/31/96 sw: subclassResponsibility"	self subclassResponsibility! !!OldFileStream methodsFor: 'accessing'!nextPutAll: aCollection	"1/31/96 sw: made subclass responsibility"	self subclassResponsibility! !!OldFileStream methodsFor: 'positioning'!position	"Answer the current character position in the file."	self subclassResponsibility! !!OldFileStream methodsFor: 'positioning'!position: pos	"Set the current character position in the file to pos."	self subclassResponsibility! !!OldFileStream methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' on '.	self file printOn: aStream! !!OldFileStream methodsFor: 'modes'!readOnly	"Set this file's mode to read-only."	self subclassResponsibility! !!OldFileStream methodsFor: 'modes'!readOnlyStream	^self readOnly! !!OldFileStream methodsFor: 'modes'!readWrite	"Set this file's mode to read-write."	self subclassResponsibility! !!OldFileStream methodsFor: 'open/close'!reopen	"Ensure that the receiver is open, re-open it if necessary."	"Details: Files that were open when a snapshot occurs are no longer valid when the snapshot is resumed. This operation re-opens the file if that has happened."	self subclassResponsibility! !!OldFileStream methodsFor: 'initialization'!reset	"Set the current character position to the beginning of the file."	self subclassResponsibility! !!OldFileStream methodsFor: 'positioning'!setToEnd	"Set the current character position to the end of the File. The same as	self position: self size."	self subclassResponsibility! !!OldFileStream methodsFor: 'accessing'!size	"Answer the size of the file in characters."	self subclassResponsibility! !!OldFileStream methodsFor: 'positioning'!skip: n	"Set the character position to n characters from the current position.	Error if not enough characters left in the file." 	self subclassResponsibility! !!OldFileStream methodsFor: 'flushing'!sync	"When writing, this syncs any written/flushed data still in the kernel	file system buffers to disk. This should generally be used after #flush,	but on Windows they do the same thing."	self subclassResponsibility! !!OldFileStream methodsFor: 'modes'!text	"Set this file to text (ascii) mode."	self ascii.! !!OldFileStream methodsFor: 'positioning'!truncate: pos	"Truncate file to pos"	self subclassResponsibility! !!OldMultiByteFileStream class methodsFor: 'defaults'!defaultToCR	"MultiByteFileStream defaultToCR"	LineEndDefault := #cr.! !!OldMultiByteFileStream class methodsFor: 'defaults'!defaultToCRLF	"MultiByteFileStream defaultToCRLF"	LineEndDefault := #crlf.! !!OldMultiByteFileStream class methodsFor: 'defaults'!defaultToLF	"MultiByteFileStream defaultToLF"	LineEndDefault := #lf.! !!OldMultiByteFileStream class methodsFor: 'defaults'!guessDefaultLineEndConvention	"Lets try to guess the line end convention from what we know about the	path name delimiter from FileDirectory."		FileSystem disk delimiter = $:		ifTrue: [^ self defaultToCR].			FileSystem disk delimiter = $/		ifTrue: [^ (Smalltalk os isMacOSX or: [Smalltalk os isUnix])				ifTrue: [ self defaultToLF]				ifFalse: [ self defaultToCR]].				FileSystem disk delimiter = $\		ifTrue: [^ self defaultToCRLF].			"in case we don't know"	^ self defaultToCR! !!OldMultiByteFileStream class methodsFor: 'class initialization'!initialize	Cr := Character cr.	Lf := Character lf.	CrLf := String with: Cr with: Lf.	LineEndStrings := Dictionary new.	LineEndStrings at: #cr put: (String with: Character cr).	LineEndStrings at: #lf put: (String with: Character lf).	LineEndStrings at: #crlf put: (String with: Character cr with: Character lf).	LookAheadCount := 2048.		SessionManager default registerSystemClassNamed: self name.	self startUp.! !!OldMultiByteFileStream class methodsFor: 'accessing'!lineEndDefault	"Answer the default line-ending convention that will be used by default, which was determined at start-up by looking at platform attributes."	^ LineEndDefault! !!OldMultiByteFileStream class methodsFor: 'instance creation'!newFrom: aFileStream	| rw n |	n := aFileStream name.	rw := aFileStream isReadOnly not.	aFileStream close.	^self new open: n forWrite: rw.! !!OldMultiByteFileStream class methodsFor: 'system startup'!startUp	self guessDefaultLineEndConvention.! !!OldMultiByteFileStream class methodsFor: 'system startup'!startUp: resuming	self guessDefaultLineEndConvention.! !!OldMultiByteFileStream methodsFor: 'remnant'!accepts: aSymbol 	^ converter accepts: aSymbol.! !!OldMultiByteFileStream methodsFor: 'modes'!ascii	super ascii.	self detectLineEndConvention.! !!OldMultiByteFileStream methodsFor: 'private - crlf'!bareNext	 ^ self converter nextFromStream: self.! !!OldMultiByteFileStream methodsFor: 'file in/out'!basicChunk	"If our buffer in collection contains an chunk with no embedded !!'s, nor	any non-ascii characters, return that.	This presumes the source code encoding is unambiguously ascii-compatible"	| bufferIX goodString |	"Not possible if read buffering disabled"	collection ifNil: [^nil].	^ ((bufferIX := (collection indexOf: $!! startingAt: position + 1) min: readLimit +1) > 0			and: [bufferIX < collection size					and: [(collection at: bufferIX + 1)								~= $!!							and: [goodString := collection copyFrom: position + 1 to: bufferIX - 1.								goodString isAsciiString]]])		ifTrue: [ position := bufferIX.				goodString]! !!OldMultiByteFileStream methodsFor: 'private'!basicNext: anInteger	^ super next: anInteger.! !!OldMultiByteFileStream methodsFor: 'private'!basicNext: n into: aString	^ super next: n into: aString.! !!OldMultiByteFileStream methodsFor: 'private'!basicNext: anInteger putAll: aCollection startingAt: startIndex        ^super next: anInteger putAll: aCollection startingAt: startIndex! !!OldMultiByteFileStream methodsFor: 'private'!basicNextInto: aString	^ super nextInto: aString.! !!OldMultiByteFileStream methodsFor: 'private'!basicNextPut: char	^ super nextPut: char.! !!OldMultiByteFileStream methodsFor: 'private'!basicNextPutAll: aString	^ super nextPutAll: aString.! !!OldMultiByteFileStream methodsFor: 'private'!basicPeek	^ super peek! !!OldMultiByteFileStream methodsFor: 'private'!basicPosition	^ super position.! !!OldMultiByteFileStream methodsFor: 'private'!basicPosition: pos	^ super position: pos.! !!OldMultiByteFileStream methodsFor: 'private'!basicReadInto: byteArray startingAt: startIndex count: count	^ super readInto: byteArray startingAt: startIndex count: count.! !!OldMultiByteFileStream methodsFor: 'private'!basicSetToEnd	^ super setToEnd.! !!OldMultiByteFileStream methodsFor: 'private'!basicSkip: n	^ super skip: n.! !!OldMultiByteFileStream methodsFor: 'private'!basicUpTo: delim	^ super upTo: delim.! !!OldMultiByteFileStream methodsFor: 'private'!basicVerbatim: aString	^ super verbatim: aString.! !!OldMultiByteFileStream methodsFor: 'modes'!binary	super binary.	self lineEndConvention: nil! !!OldMultiByteFileStream methodsFor: 'private - crlf'!convertStringFromCr: aString 	| inStream outStream |	lineEndConvention ifNil: [^ aString].	lineEndConvention == #cr ifTrue: [^ aString].	lineEndConvention == #lf ifTrue: [^ aString copy replaceAll: Cr with: Lf].	"lineEndConvention == #crlf"	inStream := aString readStream.	outStream :=  (String new: aString size) writeStream.	[inStream atEnd]		whileFalse: 			[outStream nextPutAll: (inStream upTo: Cr).			(inStream atEnd not or: [aString last = Cr])				ifTrue: [outStream nextPutAll: CrLf]].	^ outStream contents! !!OldMultiByteFileStream methodsFor: 'private - crlf'!convertStringToCr: aString 	| inStream outStream |	lineEndConvention ifNil: [^ aString].	lineEndConvention == #cr ifTrue: [^ aString].	lineEndConvention == #lf ifTrue: [^ aString copy replaceAll: Lf with: Cr].	"lineEndConvention == #crlf"	inStream := aString readStream.	outStream := (String new: aString size) writeStream.	[inStream atEnd]		whileFalse: 			[outStream nextPutAll: (inStream upTo: Cr).			(inStream atEnd not or: [aString last = Cr])				ifTrue: 					[outStream nextPut: Cr.					inStream peek = Lf ifTrue: [inStream next]]].	^ outStream contents! !!OldMultiByteFileStream methodsFor: 'accessing'!converter	converter ifNil: [self converter: TextConverter defaultSystemConverter].	^ converter! !!OldMultiByteFileStream methodsFor: 'accessing'!converter: aConverter	converter := aConverter.	self installLineEndConventionInConverter! !!OldMultiByteFileStream methodsFor: 'private - crlf'!detectLineEndConvention	"Detect the line end convention used in this stream. The result may be either #cr, #lf or #crlf."	| char numRead state |	self isBinary ifTrue: [^ self error: 'Line end conventions are not used on binary streams'].	wantsLineEndConversion == true ifFalse: [self lineEndConvention: nil.					^lineEndConvention].	self closed ifTrue: [self lineEndConvention: LineEndDefault.					^lineEndConvention].	"Default if nothing else found"	numRead := 0.	state := self converter saveStateOf: self.	lineEndConvention := nil.	[super atEnd not and: [numRead < LookAheadCount]]		whileTrue: 			[char := self next.			char = Lf				ifTrue: 					[converter restoreStateOf: self with: state.					self lineEndConvention: #lf.					^lineEndConvention].			char = Cr				ifTrue: 					[self peek = Lf						ifTrue: [self lineEndConvention: #crlf]						ifFalse: [self lineEndConvention: #cr].					converter restoreStateOf: self with: state.					^ lineEndConvention].			numRead := numRead + 1].	converter restoreStateOf: self with: state.	self lineEndConvention: LineEndDefault.	^ lineEndConvention! !!OldMultiByteFileStream methodsFor: 'private - crlf'!doConversion	^wantsLineEndConversion == true and: [ lineEndConvention notNil ]! !!OldMultiByteFileStream methodsFor: 'accessing'!fileInEncodingName: aString	self converter: (TextConverter newForEncoding: aString).	super fileIn.! !!OldMultiByteFileStream methodsFor: 'private'!installLineEndConventionInConverter	converter ifNotNil: [		converter installLineEndConvention: (			(wantsLineEndConversion == true and: [ lineEndConvention notNil ]) "#doConversion is inlined here"				ifTrue: [ LineEndStrings at: lineEndConvention ]				ifFalse: [ nil ]) ]! !!OldMultiByteFileStream methodsFor: 'accessing'!lineEndConvention	^lineEndConvention! !!OldMultiByteFileStream methodsFor: 'accessing'!lineEndConvention: aSymbol	(lineEndConvention := aSymbol) ifNotNil: [wantsLineEndConversion := true].	self installLineEndConventionInConverter! !!OldMultiByteFileStream methodsFor: 'accessing'!next	| char secondChar state |	char := (converter ifNil: [ self converter ]) nextFromStream: self.	(wantsLineEndConversion == true and: [ lineEndConvention notNil ]) "#doConversion is inlined here"		 ifTrue: [			char == Cr ifTrue: [				state := converter saveStateOf: self.				secondChar := self bareNext.				secondChar ifNotNil: [					secondChar == Lf ifFalse: [ converter restoreStateOf: self with: state ] ].				^Cr ].			char == Lf ifTrue: [				^Cr ] ].	^char.! !!OldMultiByteFileStream methodsFor: 'accessing'!next: anInteger 	| multiString |	self isBinary ifTrue: [^ super next: anInteger].	multiString := String new: anInteger.	1 to: anInteger do: [:index |		| character |		(character := self next)			ifNotNil: [ multiString at: index put: character ]			ifNil: [				multiString := multiString copyFrom: 1 to: index - 1.				(wantsLineEndConversion == true and: [ lineEndConvention notNil ]) "#doConversion is inlined here"					ifFalse: [ ^multiString ].				^self next: anInteger innerFor: multiString ] ].	(wantsLineEndConversion == true and: [ lineEndConvention notNil ]) "#doConversion is inlined here"		 ifFalse: [ ^multiString ].	multiString := self next: anInteger innerFor: multiString.	(multiString size = anInteger or: [self atEnd]) ifTrue: [ ^ multiString].	^ multiString, (self next: anInteger - multiString size).! !!OldMultiByteFileStream methodsFor: 'private - crlf'!next: n innerFor: aString	| peekChar state |	"if we just read a CR, and the next character is an LF, then skip the LF"	aString size = 0 ifTrue: [^ aString].	(aString last = Character cr) ifTrue: [		state := converter saveStateOf: self.		peekChar := self bareNext.		"super peek doesn't work because it relies on #next"		(peekChar notNil and: [peekChar ~= Character lf]) ifTrue: [			converter restoreStateOf: self with: state.		].	]. 	^ aString withInternalLineEndings.! !!OldMultiByteFileStream methodsFor: 'accessing'!next: anInteger putAll: aCollection startingAt: startIndex        (self isBinary or: [ aCollection class == ByteArray ]) ifTrue: [                ^super next: anInteger putAll: aCollection startingAt: startIndex ].        ^self converter next: anInteger putAll: aCollection startingAt: startIndex toStream: self! !!OldMultiByteFileStream methodsFor: 'file in/out'!nextChunk	"Answer the contents of the receiver, up to the next terminator	character. Doubled terminators indicate an embedded terminator	character."	self skipSeparators.	^ self		parseLangTagFor: (self basicChunk				ifNil: [String						new: 1000						streamContents: [:stream | 							| character state |							[(character := self next) == nil								or: [character == $!!										and: [state := converter saveStateOf: self.											self next ~~ $!!]]]								whileFalse: [stream nextPut: character].							character								ifNotNil: [converter restoreStateOf: self with: state.]]])! !!OldMultiByteFileStream methodsFor: 'accessing'!nextDelimited: terminator	| out ch save |	out := (String new: 1000) writeStream.	self atEnd ifTrue: [^ ''].	save := converter saveStateOf: self.	self next = terminator ifFalse: [		"absorb initial terminator"		converter restoreStateOf: self with: save.	].	[(ch := self next) == nil] whileFalse: [		(ch = terminator) ifTrue: [			self peek = terminator ifTrue: [				self next.  "skip doubled terminator"			] ifFalse: [				^ out contents  "terminator is not doubled; we're done!!"			].		].		out nextPut: ch.	].	^ out contents.! !!OldMultiByteFileStream methodsFor: 'accessing'!nextMatchAll: aColl    | save |    save := converter saveStateOf: self.    aColl do: [:each |       (self next) = each ifFalse: [            converter restoreStateOf: self with: save.            ^ false.		].	].    ^ true.! !!OldMultiByteFileStream methodsFor: 'file in/out'!nextPreamble	"Assuming that preamble part does not contain ]lang[ tag"	self skipSeparators.	^ self basicChunk				ifNil: [String						new: 1000						streamContents: [:stream | 							| character state |							[(character := self next) == nil								or: [character == $!!										and: [state := converter saveStateOf: self.											self next ~~ $!!]]]								whileFalse: [stream nextPut: character].							character								ifNotNil: [converter restoreStateOf: self with: state.]]]! !!OldMultiByteFileStream methodsFor: 'accessing'!nextPut: aCharacter	aCharacter isInteger 		ifTrue: [ ^ super nextPut: aCharacter ].	(wantsLineEndConversion == true and: [ lineEndConvention notNil ]) "#doConversion is inlined here"		 ifTrue: [			aCharacter = Cr				ifTrue: [ converter nextPutAll: (LineEndStrings at: lineEndConvention) toStream: self ]				ifFalse: [ converter nextPut: aCharacter toStream: self ].			^aCharacter ].	^ self converter nextPut: aCharacter toStream: self! !!OldMultiByteFileStream methodsFor: 'accessing'!nextPutAll: aCollection	^ (self isBinary or: [ aCollection class == ByteArray ])		ifTrue: [ super nextPutAll: aCollection ]		ifFalse: [ self converter nextPutAll: aCollection toStream: self ]! !!OldMultiByteFileStream methodsFor: 'open/close'!open: fileName forWrite: writeMode 	| result |	(writeMode and: [SessionManager default currentSession isReadOnlyAccessMode]) 		ifTrue: [ ((CannotDeleteFileException fileName: fileName)			messageText: 'Attempt to open file ' , fileName, ' as writable on read-only filesystem') signal. ].	result := super open: fileName forWrite: writeMode.	result ifNotNil: [			converter ifNil: [self converter: UTF8TextConverter new].			lineEndConvention ifNil: [ self detectLineEndConvention ]	].	^result! !!OldMultiByteFileStream methodsFor: 'accessing'!peek	"Answer what would be returned if the message next were sent to the receiver. If the receiver is at the end, answer nil.  "	| next save |	self atEnd ifTrue: [^ nil].	save := converter saveStateOf: self.	next := self next.	converter restoreStateOf: self with: save.	^ next.! !!OldMultiByteFileStream methodsFor: 'accessing'!peekFor: item 	| next state |	state := converter saveStateOf: self.	(next := self next) == nil ifTrue: [^ false].	item = next ifTrue: [^ true].	converter restoreStateOf: self with: state.	^ false.! !!OldMultiByteFileStream methodsFor: 'accessing'!readInto: buffer startingAt: offset count: requestedCount	"Read up to requestedCount elements into the given buffer starting at offset.	Return the number of elements actually read.	If I am binary or if buffer is a ByteArray, I skip decoding. Yes this is weird.	This is a necessarily inefficient implementation, reading and decoding characters one by one."	(self isBinary or: [ buffer class == ByteArray ])		ifTrue: [ ^ super readInto: buffer startingAt: offset count: requestedCount ].	0 to: requestedCount - 1 do: [ :count | 		| element |		(element := self next) ifNil: [ ^ count ].		buffer at: offset + count put: element ].	^ requestedCount! !!OldMultiByteFileStream methodsFor: 'private'!requestDropStream: dropIndex	"Needs to install proper converter"		| result |	result := super requestDropStream: dropIndex.	result ifNotNil: [		converter ifNil: [self converter: UTF8TextConverter new].		lineEndConvention ifNil: [ self detectLineEndConvention] ].	^result! !!OldMultiByteFileStream methodsFor: 'initialization'!reset	super reset.	converter ifNil: [		self converter: UTF8TextConverter new.	].! !!OldMultiByteFileStream methodsFor: 'private'!setConverterForCode	| current |	SourceFiles changesFileStream ifNotNil: [ :aStream |		self fullName = aStream fullName ifTrue: [ ^ self ] ].	current := self converter saveStateOf: self.	self position: 0.	self binary.	((self next: 3) = #[ 16rEF 16rBB 16rBF ]) ifTrue: [		self converter: UTF8TextConverter new	] ifFalse: [		self converter: MacRomanTextConverter new.	].	converter restoreStateOf: self with: current.	self text.! !!OldMultiByteFileStream methodsFor: 'positioning'!skipSeparators	| state character |	[ 		state := converter saveStateOf: self.		(character := self next) 			ifNil: [ false ]			ifNotNil: [ character isSeparator ] ] whileTrue.	character ifNotNil: [ 		converter restoreStateOf: self with: state ]! !!OldMultiByteFileStream methodsFor: 'accessing'!skipSeparatorsAndPeekNext	"Same as #skipSeparators, but returns the next character after the separators if such exists."	| state character |	[ 		state := converter saveStateOf: self.		(character := self next) 			ifNil: [ false ]			ifNotNil: [ character isSeparator ] ] whileTrue.	character ifNotNil: [ 		converter restoreStateOf: self with: state.		^character ].	! !!OldMultiByteFileStream methodsFor: 'accessing'!upTo: delimiter	^self collectionSpecies new: 1000 streamContents: [ :stream |		| ch |		[ (ch := self next) == nil or: [ ch = delimiter ] ] 			whileFalse: [ stream nextPut: ch ] ]! !!OldMultiByteFileStream methodsFor: 'accessing'!upToAnyOf: delimiters do: aBlock	^self collectionSpecies new: 1000 streamContents: [ :stream |		| ch |		[ (ch := self next) == nil or: [ (delimiters includes: ch) and: [aBlock value: ch. true] ] ] 			whileFalse: [ stream nextPut: ch ] ]! !!OldMultiByteFileStream methodsFor: 'accessing'!upToEnd	^self collectionSpecies		new: self size - self position		streamContents: [ :stream |			| element |			[ (element := self next) == nil ] whileFalse: [				stream nextPut: element ] ]! !!OldMultiByteFileStream methodsFor: 'accessing'!upToPosition: anInteger	"Answer a subcollection containing items starting from the current position and ending including the given position. Usefully different to #next: in that positions measure *bytes* from the file, where #next: wants to measure *characters*."	^self collectionSpecies new: 1000 streamContents: [ :stream |		| ch |		[ (ch := self next) == nil or: [ position > anInteger ] ] 			whileFalse: [ stream nextPut: ch ] ]! !!OldMultiByteFileStream methodsFor: 'private - crlf'!wantsLineEndConversion	^wantsLineEndConversion == true! !!OldMultiByteFileStream methodsFor: 'remnant'!wantsLineEndConversion: aBoolean		wantsLineEndConversion :=  aBoolean.	lineEndConvention ifNil: [ self detectLineEndConvention ]. ! !!OldStandardFileStream class methodsFor: 'error handling'!fileDoesNotExistUserHandling: fullFileName	| selection newName |	selection := UIManager default		chooseFrom:			{('create a new file' translated).			('choose another name' translated).			('cancel' translated)}		title: fullFileName asFileReference basename , ' does not exist.'.	selection = 1		ifTrue: [ ^ self new open: fullFileName forWrite: true ].	selection = 2		ifFalse: [ ^ self ].	newName := UIManager default request: 'Enter a new file name' initialAnswer: fullFileName.	^ self oldFileNamed: (self fullName: newName)! !!OldStandardFileStream class methodsFor: 'error handling'!fileExistsUserHandling: fullFileName	| file localName choice newName newFullFileName |		file := fullFileName asFileReference.	localName := file basename.	choice := UIManager default chooseFrom:{		'overwrite that file'.		'choose another name'.		'cancel'	} title: localName, ' already exists.'. 	choice = 1 ifTrue: [		file delete.		file exists ifTrue:  [self error: 'Could not delete the old version of that file'].		^ self new open: fullFileName forWrite: true].	choice = 2 ifTrue: [		newName := UIManager default request: 'Enter a new file name' initialAnswer: fullFileName.		newName ifNil: [Abort signal].		newFullFileName := self fullName: newName.		^ self newFileNamed: newFullFileName].	Abort signal: 'Please close this to abort file opening'! !!OldStandardFileStream class methodsFor: 'file creation'!fileNamed: fileName	"Open a file with the given name for reading and writing. If the name has no directory part, then the file will be created in the default directory. If the file already exists, its prior contents may be modified or replaced, but the file will not be truncated on close."	^ self new open: (self fullName: fileName) forWrite: true! !!OldStandardFileStream class methodsFor: 'file creation'!forceNewFileNamed: fileName 	"Create a new file with the given name, and answer a stream opened 	for writing on that file. If the file already exists, delete it without 	asking before creating the new file."	| dir  fullName f |		SessionManager default currentSession isReadOnlyAccessMode ifTrue: [ ((CannotDeleteFileException fileName: fileName)		messageText: 'Could not delete the old version of file ' , fileName) signal.		^ NullStream new ].		fullName := self fullName: fileName.	(self isAFileNamed: fullName)		ifFalse: [f := self new open: fullName forWrite: true.			^ f ifNil: ["Failed to open the file"					(FileDoesNotExistException fileName: fullName) signal]].				dir := fullName asFileReference.	dir delete.	dir exists ifTrue: [(CannotDeleteFileException new			messageText: 'Could not delete the old version of file ' , fullName) signal].			f := self new open: fullName forWrite: true.	^ f ifNil: ["Failed to open the file"			(FileDoesNotExistException fileName: fullName) signal].! !!OldStandardFileStream class methodsFor: 'file creation'!isAFileNamed: fileName	"Answer true if a file of the given name exists."	| f |	f := self new open: fileName forWrite: false.	f ifNil: [^ false].	f close.	^ true! !!OldStandardFileStream class methodsFor: 'file creation'!newFileNamed: fileName 	"Create a new file with the given name, and answer a stream opened for writing on that file. If the file already exists, ask the user what to do."	| fullName |	fullName := self fullName: fileName.	^(self isAFileNamed: fullName)		ifTrue: ["file already exists:"			(OldFileExistsException fileName: fullName fileClass: self) signal]		ifFalse: [self new open: fullName forWrite: true]! !!OldStandardFileStream class methodsFor: 'file creation'!oldFileNamed: fileName	"Open an existing file with the given name for reading and writing. If the name has no directory part, then the  default directory will be assumed. If the file does not exist, an exception is signaled. If the file exists, its prior contents may be modified or replaced, but the file will not be truncated on close."	| fullName |	fullName := self fullName: fileName.	^(self isAFileNamed: fullName)		ifTrue: [self new open: fullName forWrite: true]		ifFalse: ["File does not exist..."			(FileDoesNotExistException fileName: fullName) signal]! !!OldStandardFileStream class methodsFor: 'error handling'!readOnlyFileDoesNotExistUserHandling: fullFileName	| dir files choices selection newName fileName |		dir := fullFileName asFileReference.	files := dir parent fileNames.	fileName := dir basename.		choices := fileName correctAgainst: files.	choices add: 'Choose another name'.	choices add: 'Cancel'.		selection := UIManager default chooseFrom: choices lines: (Array with: 5)		title: (fullFileName asFileReference basename), ' does not exist.'.			selection = choices size ifTrue:["cancel" ^ nil "should we raise another exception here?"].	selection < (choices size - 1) ifTrue: [		newName := dir parent / (choices at: selection)].	selection = (choices size - 1) ifTrue: [		newName := UIManager default 							request: 'Enter a new file name' 							initialAnswer: fileName].	newName = '' ifFalse: [^ self readOnlyFileNamed: (self fullName: newName)].	^ self error: 'Could not open a file'! !!OldStandardFileStream class methodsFor: 'file creation'!readOnlyFileNamed: fileName 	"Open an existing file with the given name for reading."	| fullName f |	fullName := self fullName: fileName.	f := self new open: fullName forWrite: false.	^ f ifNil: ["File does not exist..."			((FileDoesNotExistException fileName: fullName) readOnly: true) signal].	"StandardFileStream readOnlyFileNamed: 'kjsd.txt' "! !!OldStandardFileStream class methodsFor: 'registry'!register: anObject	^self registry add: anObject! !!OldStandardFileStream class methodsFor: 'registry'!registry	^Registry ifNil: [Registry := WeakRegistry new]! !!OldStandardFileStream class methodsFor: 'registry'!retryWithGC: execBlock until: testBlock forFileNamed: fullName	"Re-implemented to only force GC if a file with the given name exists"	| blockValue foundIt |	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	"See if we have a file with the given name"	foundIt := self registry keys "hold on strongly for now" 		anySatisfy:[:file| file name sameAs: fullName].	foundIt ifFalse:[^blockValue].	Smalltalk garbageCollectMost.	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	Smalltalk garbageCollect.	^execBlock value.! !!OldStandardFileStream class methodsFor: 'registry'!unregister: anObject	^self registry remove: anObject ifAbsent:[]! !!OldStandardFileStream methodsFor: 'finalization'!actAsExecutor	super actAsExecutor.	name := nil.! !!OldStandardFileStream methodsFor: 'modes'!ascii	"opposite of binary"	buffer1 := String new: 1.	collection ifNotNil: [ collection := collection asString ]! !!OldStandardFileStream methodsFor: 'testing'!atEnd	"Answer whether the receiver is at its end.  "		collection ifNotNil: [		position < readLimit ifTrue: [ ^false ] ].	^self primAtEnd: fileID! !!OldStandardFileStream methodsFor: 'private'!basicNext	"Answer the next byte from this file, or nil if at the end of the file."		| count |	collection ifNotNil: [		position < readLimit 			ifFalse: [ 				readLimit := self primRead: fileID into: collection startingAt: 1 count: collection size.				position := 0.				readLimit = 0 ifTrue: [ ^nil ] ].		^collection at: (position := position + 1) ].		count := self primRead: fileID into: buffer1 startingAt: 1 count: 1.	count = 1		ifTrue: [ ^buffer1 at: 1 ]		ifFalse: [ ^nil ]! !!OldStandardFileStream methodsFor: 'modes'!binary	buffer1 := ByteArray new: 1.	collection ifNotNil: [ collection := collection asByteArray ]! !!OldStandardFileStream methodsFor: 'open/close'!close	"Close this file."	fileID ifNotNil: [		collection ifNotNil: [			readLimit := position := 0 ].		self primClose: fileID.		self unregister.		fileID := nil].! !!OldStandardFileStream methodsFor: 'testing'!closed	"Answer true if this file is closed."	^ fileID == nil or: [ (self primSizeNoError: fileID) == nil ]! !!OldStandardFileStream methodsFor: 'private'!collectionSpecies	"Answer the species of collection into which the receiver can stream"		^buffer1 species! !!OldStandardFileStream methodsFor: 'accessing'!directory	"Return the directory containing this file."	^ self fullName asFileReference parent! !!OldStandardFileStream methodsFor: 'private'!disableReadBuffering	collection ifNotNil: [		position < readLimit			ifTrue: [				| currentPosition |				currentPosition := self position.				collection := readLimit := position := nil.				self position: currentPosition ]			ifFalse: [				collection := readLimit := position := nil ] ]		! !!OldStandardFileStream methodsFor: 'private'!enableReadBuffering	collection ifNil: [		buffer1 ifNotNil: [			collection := self collectionSpecies new: 2048 ] ].	readLimit := position := 0! !!OldStandardFileStream methodsFor: 'open/close'!ensureOpen	"Make sure that this file really is open."	self closed ifTrue: [^ self reopen].	(self primSizeNoError: fileID) ifNotNil: [^ self].	self reopen.! !!OldStandardFileStream methodsFor: 'accessing'!file	"Answer the object representing the receiver's file.  Need for compatibility with some calls -- check senders. "	^ self! !!OldStandardFileStream methodsFor: 'finalization'!finalize	self primCloseNoError: fileID.! !!OldStandardFileStream methodsFor: 'accessing'!findString: string	"Fast version of #upToAll: to find a String in a file starting from the beginning.	Returns the position and also sets the position there.	If string is not found 0 is returned and position is unchanged."	| pos buffer count oldPos sz |	oldPos := self position.	self reset.	sz := self size.	pos := 0.	buffer := String new: 2000.	[ buffer := self nextInto: buffer.	(count := buffer findString: string) > 0		ifTrue: ["Found the string part way into buffer"			self position: pos.			self next: count - 1.			^self position ].	pos := ((pos + 2000 - string size) min: sz).	self position: pos.	pos = sz] whileFalse.	"Never found it, and hit end of file"	self position: oldPos.	^0! !!OldStandardFileStream methodsFor: 'accessing'!findStringFromEnd: string	"Fast version to find a String in a file starting from the end.	Returns the position and also sets the position there.	If string is not found 0 is returned and position is unchanged."	| pos buffer count oldPos |	oldPos := self position.	self setToEnd.	pos := self position.	[ pos := ((pos - 2000 + string size) max: 0).  "the [+ string size] allows for the case where the end of the search string is at the beginning of the current buffer"	self position: pos.	buffer := self next: 2000.	(count := buffer findString: string) > 0		ifTrue: ["Found the string part way into buffer"			self position: pos.			self next: count-1.  "use next instead of position:, so that CrLfFileStream can do its magic if it is being used"			^self position].	pos = 0] whileFalse.	"Never found it, and hit beginning of file"	self position: oldPos.	^0! !!OldStandardFileStream methodsFor: 'flushing'!flush	"When writing, this flushes the write buffer the stream uses to reduce	the number of write() system calls it makes. This should generally be	used before #sync, but on Windows they do the same thing."	^ self primFlush: fileID! !!OldStandardFileStream methodsFor: 'private'!flushReadBuffer	collection ifNotNil: [		position < readLimit ifTrue: [			| currentPosition |			currentPosition := self position.			position := readLimit := 0.			self primSetPosition: fileID to: currentPosition ] ]! !!OldStandardFileStream methodsFor: 'accessing'!fullName	"Answer this file's full path name."	^ name! !!OldStandardFileStream methodsFor: 'utilities'!insertLineFeeds	"(FileStream oldFileNamed: 'BBfix2.st') insertLineFeeds"	| s crLf f |	crLf := String crlf.	s := self next: self size.	self close.	f := OldFileStream newFileNamed: self name.	s linesDo: [:line | f nextPutAll: line; nextPutAll: crLf].	f close! !!OldStandardFileStream methodsFor: 'testing'!isBinary	^ buffer1 class == ByteArray! !!OldStandardFileStream methodsFor: 'testing'!isDirectory	"Answer whether the receiver represents a directory.  For the post-transition case, uncertain what to do."	^ false! !!OldStandardFileStream methodsFor: 'testing'!isReadOnly	^ rwmode not! !!OldStandardFileStream methodsFor: 'accessing'!localName	^ name ifNotNil: [		(name findTokens: FileSystem disk delimiter asString) last]! !!OldStandardFileStream methodsFor: 'accessing'!name	"Answer this file's full path name."	^ name! !!OldStandardFileStream methodsFor: 'accessing'!next	"Answer the next byte from this file, or nil if at the end of the file."	^ self basicNext! !!OldStandardFileStream methodsFor: 'accessing'!next: n	"Return a string with the next n characters of the filestream in it."	^ self nextInto: (self collectionSpecies new: n)! !!OldStandardFileStream methodsFor: 'accessing'!next: n into: aString startingAt: startIndex	"Read n bytes into the given string.	Return aString or a partial copy if less than	n elements have been read."	|read|	read := (self readInto: aString startingAt: startIndex count: n).	^read = n 		ifTrue: [ aString ]		ifFalse: [ aString copyFrom: 1 to: startIndex + read - 1 ]		! !!OldStandardFileStream methodsFor: 'accessing'!next: anInteger putAll: aString startingAt: startIndex	"Store the next anInteger elements from the given collection."	rwmode ifFalse: [^ self error: 'Cannot write a read-only file'].	collection ifNotNil: [		position < readLimit ifTrue: [ self flushReadBuffer ] ].		self primWrite: fileID from: aString startingAt: startIndex count: anInteger.	^aString! !!OldStandardFileStream methodsFor: 'accessing'!nextPut: char	"Write the given character to this file."	rwmode ifFalse: [^ self error: 'Cannot write a read-only file'].	collection ifNotNil: [ 		position < readLimit ifTrue: [ self flushReadBuffer ] ].	buffer1 at: 1 put: char.	self primWrite: fileID from: buffer1 startingAt: 1 count: 1.	^ char! !!OldStandardFileStream methodsFor: 'accessing'!nextPutAll: stringOrByteArray	"Write all the characters of the given string to this file."	rwmode ifFalse: [^ self error: 'Cannot write a read-only file'].	collection ifNotNil: [ 		position < readLimit ifTrue: [ self flushReadBuffer ] ].	self primWrite: fileID from: stringOrByteArray startingAt: 1 count: stringOrByteArray basicSize.	^ stringOrByteArray! !!OldStandardFileStream methodsFor: 'open/close'!open	"For compatibility with a few existing things."	^ self reopen! !!OldStandardFileStream methodsFor: 'open/close'!open: fileName forWrite: writeMode 	"Open the file with the given name. If writeMode is true, allow writing, otherwise open the file in read-only mode."	| f |	f := fileName asVmPathName.		(writeMode and: [ FileSystem disk isWritable not ]) ifTrue: [ ^ nil ].	fileID := OldStandardFileStream retryWithGC:[self primOpen: f writable: writeMode] 					until:[:id| id notNil] 					forFileNamed: fileName.	fileID ifNil: [^ nil].  "allows sender to detect failure"	name := fileName.	self register.	rwmode := writeMode.	buffer1 := String new: 1.	self enableReadBuffering	! !!OldStandardFileStream methodsFor: 'open/close'!openOnHandle: aFileID name: streamName forWrite: writeMode	"Initialize the file with the given handle. If writeMode is true then	 allow writing, otherwise put the file in read-only mode.	 N.B. Do _not_ register the stream.  We do not want it to be	 closed implicitly (e.g. on GC).  There may be multiple instances	 accessing the same stream.  The stream is not a file."	fileID := aFileID.	name := streamName.	rwmode := writeMode.	buffer1 := String new: 1.	self enableReadBuffering! !!OldStandardFileStream methodsFor: 'open/close'!openReadOnly	"Open the receiver as a read-only file."	^ self open: name forWrite: false! !!OldStandardFileStream methodsFor: 'accessing'!padToEndWith: aChar	"On the Mac, files do not truncate.  One can delete the old file and write a new one, but sometime deletion fails (file still open? file stale?).  This is a sad compromise.  Just let the file be the same length but pad it with a harmless character."	| pad |	self atEnd ifTrue: [^ self].	pad := self isBinary 		ifTrue: [aChar asCharacter asciiValue]	"ok for char or number"		ifFalse: [aChar asCharacter].	self nextPutAll: (self collectionSpecies new: ((self size - self position) min: 20000) 							withAll: pad).! !!OldStandardFileStream methodsFor: 'accessing'!peek	"Answer what would be returned if the message next were sent to the receiver. If the receiver is at the end, answer nil.  "	| next |	self atEnd ifTrue: [^ nil].	next := self basicNext.	self position: self position - 1.	^ next! !!OldStandardFileStream methodsFor: 'accessing'!peekFor: item 	"Answer false and do not advance if the next element is not equal to item, or if this stream is at the end.  If the next element is equal to item, then advance over it and return true"	| next |	(next := self next) == nil ifTrue: [^ false].	item = next ifTrue: [^ true].	self skip: -1.	^ false! !!OldStandardFileStream methodsFor: 'accessing'!peekLast	"Return that item just put at the end of the stream"	^ buffer1 size > 0 		ifTrue: [buffer1 last]		ifFalse: [nil]! !!OldStandardFileStream methodsFor: 'positioning'!position	"Return the receiver's current file position."	collection ifNotNil: [		position < readLimit ifTrue: [			^(self primGetPosition: fileID) - readLimit + position ] ].	^self primGetPosition: fileID! !!OldStandardFileStream methodsFor: 'positioning'!position: pos	"Set the receiver's position as indicated."	collection ifNotNil: [		position < readLimit ifTrue: [			| newPosition |			newPosition := pos - (self primGetPosition: fileID) + readLimit.			newPosition < 0 ifTrue: [					| offsetPos |					self primSetPosition: fileID to: (offsetPos := pos - (collection size // 4) max: 0).					readLimit := self primRead: fileID into: collection startingAt: 1 count: collection size.					position := pos - offsetPos.					^self ].			newPosition < readLimit 				ifTrue: [					position := newPosition.					^self ]				ifFalse: [					readLimit := position := 0 ] ] ].	^self primSetPosition: fileID to: pos! !!OldStandardFileStream methodsFor: 'private - primitives'!primAtEnd: id	"Answer true if the file position is at the end of the file."	<primitive: 'primitiveFileAtEnd' module: 'FilePlugin'>	self primitiveFailed! !!OldStandardFileStream methodsFor: 'private - primitives'!primClose: id	"Close this file."	<primitive: 'primitiveFileClose' module: 'FilePlugin'>	self primitiveFailed! !!OldStandardFileStream methodsFor: 'private - primitives'!primCloseNoError: id	"Close this file. Don't raise an error if the primitive fails."	<primitive: 'primitiveFileClose' module: 'FilePlugin'>! !!OldStandardFileStream methodsFor: 'private'!primDropRequestFileHandle: dropIndex	"Primitive. Return the (read-only) file handle for some file that was just dropped onto the application.	Fail if dropIndex is out of range or the primitive is not supported."	<primitive: 'primitiveDropRequestFileHandle' module:'DropPlugin'>	^nil! !!OldStandardFileStream methodsFor: 'private'!primDropRequestFileName: dropIndex	"Primitive. Return the file name for some file that was just dropped onto the application.	Fail if dropIndex is out of range or the primitive is not supported."	<primitive: 'primitiveDropRequestFileName' module:'DropPlugin'>	^nil! !!OldStandardFileStream methodsFor: 'private - primitives'!primFlush: id	"On Unix, the FilePlugin uses stdio FILE* structs which maintain their	own internal buffer to minimize write() syscalls. This flushes that buffer.	On Windows this and primSync: do the same thing."	<primitive: 'primitiveFileFlush' module: 'FilePlugin'>		"We can't ignore fflush() failing, because it can fail for any of the	reasons write() can."	self primitiveFailed! !!OldStandardFileStream methodsFor: 'private - primitives'!primGetPosition: id	"Get this files current position."	<primitive: 'primitiveFileGetPosition' module: 'FilePlugin'>	self primitiveFailed! !!OldStandardFileStream methodsFor: 'private - primitives'!primOpen: fileName writable: writableFlag	"Open a file of the given name, and return the file ID obtained.	If writableFlag is true, then		if there is none with this name, then create one		else prepare to overwrite the existing from the beginning	otherwise		if the file exists, open it read-only		else return nil"	<primitive: 'primitiveFileOpen' module: 'FilePlugin'>	^ nil! !!OldStandardFileStream methodsFor: 'private - primitives'!primRead: id into: byteArray startingAt: startIndex count: count	"Read up to count bytes of data from this file into the given string or byte array starting at the given index. Answer the number of bytes actually read."	<primitive: 'primitiveFileRead' module: 'FilePlugin'>	self closed ifTrue: [^ self error: 'File is closed'].	self error: 'File read failed'.! !!OldStandardFileStream methodsFor: 'private - primitives'!primSetPosition: id to: anInteger	"Set this file to the given position."	<primitive: 'primitiveFileSetPosition' module: 'FilePlugin'>	self primitiveFailed! !!OldStandardFileStream methodsFor: 'private - primitives'!primSize: id	"Answer the size of this file."	<primitive: 'primitiveFileSize' module: 'FilePlugin'>	self primitiveFailed! !!OldStandardFileStream methodsFor: 'private - primitives'!primSizeNoError: id	"Answer the size of this file. Answer nil if the primitive fails; this indicates that the file handle has become stale."	<primitive: 'primitiveFileSize' module: 'FilePlugin'>	^ nil! !!OldStandardFileStream methodsFor: 'private - primitives'!primSync: id	"On Unix, this syncs any written or flushed data still in the kernel file	system buffers to disk. On Windows this and primFlush: do the same thing"	<primitive: 'primitiveFileSync' module: 'FilePlugin'>	"fsync() failing cannot be ignored"	self primitiveFailed! !!OldStandardFileStream methodsFor: 'private - primitives'!primTruncate: id to: anInteger	"Truncate this file to the given position."	<primitive: 'primitiveFileTruncate' module: 'FilePlugin'>	self primitiveFailed! !!OldStandardFileStream methodsFor: 'private - primitives'!primWrite: id from: stringOrByteArray startingAt: startIndex count: count	"Write count bytes onto this file from the given string or byte array starting at the given index. Answer the number of bytes written."	<primitive: 'primitiveFileWrite' module: 'FilePlugin'>	(FileWriteError fileName: name)		signal: (self closed			ifTrue: [ 'File ', name, ' is closed' ]			ifFalse: [ 'File ', name, ' write failed' ])! !!OldStandardFileStream methodsFor: 'printing'!printOn: aStream	"Put a printed version of the receiver onto aStream."	aStream nextPutAll: self class name; nextPutAll: ': '; print: name! !!OldStandardFileStream methodsFor: 'accessing'!readInto: byteArray startingAt: startIndex count: count	"Read up to n bytes into the given byteArray.	Return the number of bytes actually read."		| newN newStartIndex available|	available := 0.	collection 		ifNil: [ 			newN := count.			newStartIndex := startIndex ]		ifNotNil: [			byteArray class isBytes 				ifFalse: [ 					position < readLimit ifTrue: [ self flushReadBuffer ].					newN := count.					newStartIndex := startIndex ]				ifTrue: [					(available := readLimit - position) > 0 						ifTrue: [							| bufferedCount |							bufferedCount := count min: available.							byteArray								replaceFrom: startIndex								to: startIndex + bufferedCount - 1								with: collection								startingAt: position + 1.							position := position + bufferedCount.							bufferedCount = count ifTrue: [ ^count ] ].					newN := count - available.					newStartIndex := startIndex + available ] ].	^available + (self primRead: fileID into: byteArray				startingAt: newStartIndex count: newN).! !!OldStandardFileStream methodsFor: 'modes'!readOnly	"Make this file read-only."	rwmode := false.! !!OldStandardFileStream methodsFor: 'copying'!readOnlyCopy	^ self class readOnlyFileNamed: self name.! !!OldStandardFileStream methodsFor: 'modes'!readWrite	"Make this file writable."	rwmode := true.! !!OldStandardFileStream methodsFor: 'registry'!register	^self class register: self! !!OldStandardFileStream methodsFor: 'open/close'!reopen	"Close and reopen this file. The file position is reset to zero."	"Details: Files that were open when a snapshot occurs are no longer valid when the snapshot is resumed. This operation re-opens the file if that has happened."	fileID ifNotNil: [		collection ifNotNil: [			position < readLimit ifTrue: [				self flushReadBuffer ] ].		self primCloseNoError: fileID ].	self open: name forWrite: rwmode.! !!OldStandardFileStream methodsFor: 'dnd requests'!requestDropStream: dropIndex	"Return a read-only stream for some file the user has just dropped onto the application."	| rawName |	rawName := self primDropRequestFileName: dropIndex.	name := FilePathEncoder decode: rawName.	fileID := self primDropRequestFileHandle: dropIndex.	fileID == nil		ifTrue: [ ^ nil ].	self register.	rwmode := false.	buffer1 := String new: 1.	self enableReadBuffering! !!OldStandardFileStream methodsFor: 'initialization'!reset	self ensureOpen.	self position: 0.! !!OldStandardFileStream methodsFor: 'positioning'!setToEnd	"Set the position of the receiver to the end of file."	self position: self size! !!OldStandardFileStream methodsFor: 'accessing'!size	"Answer the size of the file in characters."	^ self primSize: fileID! !!OldStandardFileStream methodsFor: 'positioning'!skip: n	"Set the character position to n characters from the current position.	Error if not enough characters left in the file."	collection ifNotNil: [		position < readLimit ifTrue: [			| newPosition |			((newPosition := position + n) >= 0 and: [ newPosition < readLimit ])				ifTrue: [ 					position := newPosition.					^self ] ] ].	self position: self position + n! !!OldStandardFileStream methodsFor: 'flushing'!sync	"When writing, this syncs any written/flushed data still in the kernel	file system buffers to disk. This should generally be used after #flush,	but on Windows they do the same thing."	^ self primSync: fileID! !!OldStandardFileStream methodsFor: 'positioning'!truncate	"Truncate to zero"	^ self truncate: 0! !!OldStandardFileStream methodsFor: 'positioning'!truncate: pos	"Truncate to this position"	self position: pos.	^self primTruncate: fileID to: pos! !!OldStandardFileStream methodsFor: 'registry'!unregister	^self class unregister: self! !!OldStandardFileStream methodsFor: 'accessing'!upTo: delim 	"Fast version to speed up nextChunk"	| pos buffer count |	collection ifNotNil: [		(position < readLimit and: [			(pos := collection indexOf: delim startingAt: position + 1) <= readLimit and: [				pos > 0 ] ]) ifTrue: [					^collection copyFrom: position + 1 to: (position := pos) - 1 ] ].	pos := self position.	buffer := self next: 2000.	(count := buffer indexOf: delim) > 0 ifTrue: 		["Found the delimiter part way into buffer"		self position: pos + count.		^ buffer copyFrom: 1 to: count - 1].	self atEnd ifTrue:		["Never found it, and hit end of file"		^ buffer].	"Never found it, but there's more..."	^ buffer , (self upTo: delim)! !!OldStandardFileStream methodsFor: 'accessing'!upToAnyOf: delimiters do: aBlock	"Fast version to speed up nextChunk"	| pos buffer count result |	collection ifNotNil: [		(position < readLimit and: [			(count := collection indexOfAnyOf: delimiters startingAt: position + 1) <= readLimit and: [				count > 0 ] ]) ifTrue: [					result := collection copyFrom: position + 1 to: (position := count) - 1.					aBlock value: (collection at: count).					^result ] ].	pos := self position.	buffer := self next: 2000.	(count := buffer indexOfAnyOf: delimiters) > 0 ifTrue: 		["Found one of the delimiters part way into buffer"		self position: pos + count.		aBlock value: (buffer at: count).		^ buffer copyFrom: 1 to: count - 1].	self atEnd ifTrue:		["Never found it, and hit end of file"		^ buffer].	"Never found it, but there's more..."	^ buffer , (self upToAnyOf: delimiters do: aBlock)! !!OldStandardFileStream methodsFor: 'accessing'!upToEnd	"Answer a subcollection from the current access position through the last element of the receiver."	^self collectionSpecies streamContents: [ :newStream |		| next |		[ (next := self next) == nil ] whileFalse: [			newStream nextPut: next ] ]! !!OldMultiByteBinaryOrTextStream class methodsFor: 'defaults'!defaultConverter	^ Latin1TextConverter new.! !!OldMultiByteBinaryOrTextStream class methodsFor: 'deprecation'!isDeprecated	^true! !!OldMultiByteBinaryOrTextStream class methodsFor: 'instance creation'!on: aCollection encoding: encodingName 	| aTextConverter |	encodingName 		ifNil: [aTextConverter := TextConverter default]		ifNotNil: [aTextConverter := TextConverter newForEncoding: encodingName].	^ (self on: aCollection)		converter: aTextConverter! !!OldMultiByteBinaryOrTextStream class methodsFor: 'instance creation'!with: aCollection encoding: encodingName 	| aTextConverter |	encodingName 		ifNil: [aTextConverter := TextConverter default]		ifNotNil: [aTextConverter := TextConverter newForEncoding: encodingName].	^ (self with: aCollection)		converter: aTextConverter! !!OldMultiByteBinaryOrTextStream methodsFor: 'converting'!asBinaryOrTextStream	^ self! !!OldMultiByteBinaryOrTextStream methodsFor: 'modes'!ascii	isBinary := false! !!OldMultiByteBinaryOrTextStream methodsFor: 'private'!basicNext	| nextChar |	^ isBinary		ifTrue: [super next]		ifFalse: [			(nextChar := super next)				ifNotNil: [nextChar asCharacter]].! !!OldMultiByteBinaryOrTextStream methodsFor: 'private'!basicNext: anInteger	^ super next: anInteger.! !!OldMultiByteBinaryOrTextStream methodsFor: 'private'!basicNext: n into: aString	^ self next: n into: aString.! !!OldMultiByteBinaryOrTextStream methodsFor: 'private'!basicNext: anInteger putAll: aCollection startingAt: startIndex		^super next: anInteger putAll: aCollection startingAt: startIndex! !!OldMultiByteBinaryOrTextStream methodsFor: 'private'!basicNextInto: aString	^ self nextInto: aString.! !!OldMultiByteBinaryOrTextStream methodsFor: 'private'!basicNextPut: char	^ super nextPut: char.! !!OldMultiByteBinaryOrTextStream methodsFor: 'private'!basicNextPutAll: aString	^ super nextPutAll: aString.! !!OldMultiByteBinaryOrTextStream methodsFor: 'private'!basicPeek	^ super peek! !!OldMultiByteBinaryOrTextStream methodsFor: 'private'!basicPosition	^ self position.! !!OldMultiByteBinaryOrTextStream methodsFor: 'private'!basicPosition: pos	^ self position: pos.! !!OldMultiByteBinaryOrTextStream methodsFor: 'modes'!binary	isBinary := true! !!OldMultiByteBinaryOrTextStream methodsFor: 'accessing'!contents	| ret state |	state := converter saveStateOf: self.	ret := self upToEnd.	converter restoreStateOf: self with: state.	^ ret.! !!OldMultiByteBinaryOrTextStream methodsFor: 'accessing'!converter	converter ifNil: [converter := self class defaultConverter].	^ converter! !!OldMultiByteBinaryOrTextStream methodsFor: 'accessing'!converter: aConverter	converter := aConverter.! !!OldMultiByteBinaryOrTextStream methodsFor: 'testing'!isBinary	^ isBinary! !!OldMultiByteBinaryOrTextStream methodsFor: 'accessing'!next	| n |	n := self converter nextFromStream: self.	n ifNil: [^ nil].	isBinary and: [n isCharacter ifTrue: [^ n asciiValue]].	^ n.! !!OldMultiByteBinaryOrTextStream methodsFor: 'accessing'!next: anInteger 	| multiString |	self isBinary ifTrue: [^ (super next: anInteger) asByteArray].	multiString := WideString new: anInteger.	1 to: anInteger do: [:index |		| character |		(character := self next) ifNotNil: [			multiString at: index put: character		] ifNil: [			multiString := multiString copyFrom: 1 to: index - 1.			^ multiString		]	].	^ multiString.! !!OldMultiByteBinaryOrTextStream methodsFor: 'accessing'!next: anInteger putAll: aCollection startingAt: startIndex        (self isBinary or: [ aCollection class == ByteArray ]) ifTrue: [                ^super next: anInteger putAll: aCollection startingAt: startIndex ].        ^self converter next: anInteger putAll: aCollection startingAt: startIndex toStream: self! !!OldMultiByteBinaryOrTextStream methodsFor: 'accessing'!nextDelimited: terminator	| out ch pos |	out := (String new: 1000) writeStream.	self atEnd ifTrue: [^ ''].	pos := self position.	self next = terminator ifFalse: [		"absorb initial terminator"		self position: pos.	].	[(ch := self next) == nil] whileFalse: [		(ch = terminator) ifTrue: [			self peek = terminator ifTrue: [				self next.  "skip doubled terminator"			] ifFalse: [				^ out contents  "terminator is not doubled; we're done!!"			].		].		out nextPut: ch.	].	^ out contents.! !!OldMultiByteBinaryOrTextStream methodsFor: 'accessing'!nextMatchAll: aColl    | save |    save := converter saveStateOf: self.    aColl do: [:each |       (self next) = each ifFalse: [            converter restoreStateOf: self with: save.            ^ false.		].	].    ^ true.! !!OldMultiByteBinaryOrTextStream methodsFor: 'accessing'!nextPut: aCharacter	^ aCharacter isInteger 		ifTrue: [ super nextPut: aCharacter asCharacter ]		ifFalse: [ self converter nextPut: aCharacter toStream: self ]! !!OldMultiByteBinaryOrTextStream methodsFor: 'accessing'!nextPutAll: aCollection	^ self isBinary		ifTrue: [ super nextPutAll: aCollection ]		ifFalse: [ aCollection do: [ :each | self nextPut: each ] ]! !!OldMultiByteBinaryOrTextStream methodsFor: 'accessing'!padToEndWith: aChar	"We don't have pages, so we are at the end, and don't need to pad."! !!OldMultiByteBinaryOrTextStream methodsFor: 'accessing'!peek	"Answer what would be returned if the message next were sent to the receiver. If the receiver is at the end, answer nil.  "	| next pos |	self atEnd ifTrue: [^ nil].	pos := self position.	next := self next.	self position: pos.	^ next.! !!OldMultiByteBinaryOrTextStream methodsFor: 'accessing'!peekFor: item 	| next state |	"self atEnd ifTrue: [^ false]. -- SFStream will give nil"	state := converter saveStateOf: self.	(next := self next) == nil ifTrue: [^ false].	item = next ifTrue: [^ true].	converter restoreStateOf: self with: state.	^ false.! !!OldMultiByteBinaryOrTextStream methodsFor: 'initialization'!reset	super reset.	isBinary ifNil: [isBinary := false].	collection class == ByteArray ifTrue: ["Store as String and convert as needed."		collection := collection asString.		isBinary := true].	self converter. "ensure that we have a converter."! !!OldMultiByteBinaryOrTextStream methodsFor: 'file in/out'!setConverterForCode	| current |	current := converter saveStateOf: self.	self position: 0.	self binary.	((self next: 3) =  #[239 187 191]) ifTrue: [		self converter: UTF8TextConverter new	] ifFalse: [		self converter: MacRomanTextConverter new.	].	converter restoreStateOf: self with: current.	self text.! !!OldMultiByteBinaryOrTextStream methodsFor: 'file in/out'!setEncoderForSourceCodeNamed: streamName	| l |	l := streamName asLowercase.	((l endsWith: 'cs') or: [		(l endsWith: 'st') or: [			(l endsWith: ('st.gz')) or: [				(l endsWith: ('st.gz'))]]]) ifTrue: [					self converter: MacRomanTextConverter new.					^ self.	].	self converter: UTF8TextConverter new.! !!OldMultiByteBinaryOrTextStream methodsFor: 'positioning'!skipSeparators	[self atEnd] whileFalse: [		self basicNext isSeparator ifFalse: [			^ self position: self position - 1]]! !!OldMultiByteBinaryOrTextStream methodsFor: 'accessing'!skipSeparatorsAndPeekNext	"A special function to make nextChunk fast"	| peek pos |	[self atEnd] whileFalse: [		pos := self position.		(peek := self next) isSeparator ifFalse: [			self position: pos.			^ peek.		].	].! !!OldMultiByteBinaryOrTextStream methodsFor: 'modes'!text	isBinary := false! !!OldMultiByteBinaryOrTextStream methodsFor: 'accessing'!upTo: delim 	| out ch |	out := (String new: 1000) writeStream.	self atEnd ifTrue: [^ ''].	[(ch := self next) isNil] whileFalse: [		(ch = delim) ifTrue: [			^ out contents  "terminator is not doubled; we're done!!"		].		out nextPut: ch.	].	^ out contents.! !!OldMultiByteBinaryOrTextStream methodsFor: 'accessing'!upToEnd	| newStream element newCollection |	newCollection := self isBinary				ifTrue: [ByteArray new: 100]				ifFalse: [String new: 100].	newStream := newCollection writeStream.	[(element := self next) notNil]		whileTrue: [newStream nextPut: element].	^ newStream contents! !!OldRWBinaryOrTextStream class methodsFor: 'deprecation'!isDeprecated	^true! !!OldRWBinaryOrTextStream methodsFor: 'converting'!asBinaryOrTextStream	^ self! !!OldRWBinaryOrTextStream methodsFor: 'modes'!ascii	isBinary := false! !!OldRWBinaryOrTextStream methodsFor: 'modes'!binary	isBinary := true! !!OldRWBinaryOrTextStream methodsFor: 'accessing'!contents	"Answer with a copy of my collection from 1 to readLimit."	| newArray |	readLimit := readLimit max: position.	isBinary ifFalse: [ "String"		^ collection copyFrom: 1 to: readLimit].	newArray := ByteArray new: readLimit.	^ newArray replaceFrom: 1		to: readLimit		with: collection		startingAt: 1.! !!OldRWBinaryOrTextStream methodsFor: 'testing'!isBinary	^ isBinary! !!OldRWBinaryOrTextStream methodsFor: 'accessing'!next	| byte |	^ isBinary 			ifTrue: [byte := super next.				 byte ifNil: [nil] ifNotNil: [byte asciiValue]]			ifFalse: [super next].! !!OldRWBinaryOrTextStream methodsFor: 'accessing'!next: anInteger 	"Answer the next anInteger elements of my collection. Must override to get class right."	| newArray |	newArray := (isBinary ifTrue: [ByteArray] ifFalse: [ByteString]) new: anInteger.	^ self nextInto: newArray! !!OldRWBinaryOrTextStream methodsFor: 'accessing'!next: n into: aCollection startingAt: startIndex	"Read n objects into the given collection. 	Return aCollection or a partial copy if less than n elements have been read."	"Overriden for efficiency"	| max |	max := (readLimit - position) min: n.	aCollection 		replaceFrom: startIndex 		to: startIndex+max-1		with: collection		startingAt: position+1.	position := position + max.	max = n		ifTrue:[^aCollection]		ifFalse:[^aCollection copyFrom: 1 to: startIndex+max-1]! !!OldRWBinaryOrTextStream methodsFor: 'accessing'!next: anInteger putAll: aCollection startingAt: startIndex	"Optimized for ByteArrays"	aCollection class == ByteArray 		ifTrue:[^super next: anInteger putAll: aCollection asString startingAt: startIndex].	^super next: anInteger putAll: aCollection startingAt: startIndex! !!OldRWBinaryOrTextStream methodsFor: 'accessing'!nextPut: charOrByte	^ super nextPut: charOrByte asCharacter! !!OldRWBinaryOrTextStream methodsFor: 'accessing'!nextPutAll: aCollection	"Optimized for ByteArrays"	^ aCollection class == ByteArray 		ifTrue: [ super nextPutAll: aCollection asString ]		ifFalse: [ super nextPutAll: aCollection ]! !!OldRWBinaryOrTextStream methodsFor: 'converting'!on: aCollection	super on: aCollection.	readLimit := 0! !!OldRWBinaryOrTextStream methodsFor: 'accessing'!padToEndWith: aChar	"We don't have pages, so we are at the end, and don't need to pad."! !!OldRWBinaryOrTextStream methodsFor: 'accessing'!readInto: aCollection startingAt: startIndex count: n	"Read n objects into the given collection. 	Return number of elements that have been read."	"Overriden for efficiency"	| max |	max := (readLimit - position) min: n.	aCollection 		replaceFrom: startIndex 		to: startIndex + max - 1		with: collection		startingAt: position + 1.	position := position + max.	^ max! !!OldRWBinaryOrTextStream methodsFor: 'initialization'!reset	"Set the receiver's position to the beginning of the sequence of objects."	super reset.	isBinary ifNil: [isBinary := false].	collection class == ByteArray ifTrue: ["Store as String and convert as needed."		collection := collection asString.		isBinary := true].! !!OldRWBinaryOrTextStream methodsFor: 'modes'!text	isBinary := false! !!OldRWBinaryOrTextStream methodsFor: 'accessing'!upTo: anObject 	"Answer a subcollection from the current access position to the 	occurrence (if any, but not inclusive) of anObject in the receiver. If 	anObject is not in the collection, answer the entire rest of the receiver."	| newStream element species |	species := isBinary ifTrue:[ByteArray] ifFalse:[String].	newStream := WriteStream on: (species new: 100).	[self atEnd or: [(element := self next) = anObject]]		whileFalse: [newStream nextPut: element].	^newStream contents! !!OldRWBinaryOrTextStream methodsFor: 'accessing'!upToEnd	"Must override to get class right."	| newArray |	newArray := (isBinary ifTrue: [ByteArray] ifFalse: [ByteString]) new: self size - self position.	^ self nextInto: newArray! !!OldFileExistsException class methodsFor: 'exceptioninstantiator'!fileName: aFileName fileClass: aClass 	^ self new		fileName: aFileName;		fileClass: aClass! !!OldFileExistsException class methodsFor: 'deprecation'!isDeprecated	^true! !!OldFileExistsException methodsFor: 'exceptiondescription'!defaultAction	"The default action taken if the exception is signaled."	^ UIManager default fileExistsDefaultAction: self! !!OldFileExistsException methodsFor: 'accessing'!file		^ self fileClass fileNamed: fileName! !!OldFileExistsException methodsFor: 'accessing'!fileClass	^ fileClass ifNil: [OldStandardFileStream]! !!OldFileExistsException methodsFor: 'accessing'!fileClass: aClass	fileClass := aClass! !!OldLimitingLineStreamWrapper class methodsFor: 'examples'!example1	<sampleInstance>	"LimitingLineStreamWrapper example1"	"Separate chunks of text delimited by a special string"	| inStream msgStream messages |	inStream := self exampleStream.	msgStream := self on: inStream delimiter: 'From '.	messages := OrderedCollection new.	[inStream atEnd] whileFalse: [		msgStream skipThisLine.		messages add: msgStream upToEnd].	^messages			! !!OldLimitingLineStreamWrapper class methodsFor: 'examples'!example2	<sampleInstance>	"LimitingLineStreamWrapper example2"	"Demo nesting wrappers - get header lines from some messages"	| inStream msgStream headers headerStream |	inStream := self exampleStream.	msgStream := self on: inStream delimiter: 'From '.	headers := OrderedCollection new.	[inStream atEnd] whileFalse: [		msgStream skipThisLine. "Skip From"		headerStream := self on: msgStream delimiter: ''.		headers add: headerStream linesUpToEnd.		[msgStream nextLine isNil] whileFalse. "Skip Body"	].	^headers			! !!OldLimitingLineStreamWrapper class methodsFor: 'examples'!exampleStream	<sampleInstance>	^ 'From me@somewhereFrom: meTo: youSubject: TestTestFrom you@elsewhereFrom: youTo: meSubject: Re: testokay' readStream! !!OldLimitingLineStreamWrapper class methodsFor: 'deprecation'!isDeprecated	^true! !!OldLimitingLineStreamWrapper class methodsFor: 'instance creation'!on: aStream delimiter: aString	^self new setStream: aStream delimiter: aString! !!OldLimitingLineStreamWrapper methodsFor: 'testing'!atEnd	^line isNil or: [limitingBlock value: line]! !!OldLimitingLineStreamWrapper methodsFor: 'stream protocol'!close	^stream close! !!OldLimitingLineStreamWrapper methodsFor: 'accessing'!delimiter: aString	"Set limitBlock to check for a delimiting string. Be unlimiting if nil"	self limitingBlock: (aString caseOf: {		[nil] -> [[:aLine | false]].		[''] -> [[:aLine | aLine size = 0]]	} otherwise: [[:aLine | aLine beginsWith: aString]])! !!OldLimitingLineStreamWrapper methodsFor: 'accessing'!lastLineRead	"Return line last read. At stream end, this is the boundary line or nil"	^ line! !!OldLimitingLineStreamWrapper methodsFor: 'accessing'!limitingBlock: aBlock	"The limitingBlock is evaluated with a line to check if this line terminates the stream"	limitingBlock := aBlock.	self updatePosition! !!OldLimitingLineStreamWrapper methodsFor: 'accessing'!linesUpToEnd	| elements ln |	elements := OrderedCollection new.	[(ln := self nextLine) isNil] whileFalse: [ 		elements add: ln].	^elements! !!OldLimitingLineStreamWrapper methodsFor: 'accessing'!next	"Provide character-based access"	position ifNil: [^nil].	position < line size ifTrue: [^line at: (position := position + 1)].	line := stream nextLine.	self updatePosition.	^ Character cr! !!OldLimitingLineStreamWrapper methodsFor: 'accessing'!nextLine	| thisLine |	self atEnd ifTrue: [^nil].	thisLine := line.	line := stream nextLine.	^thisLine! !!OldLimitingLineStreamWrapper methodsFor: 'accessing'!peekLine	self atEnd ifTrue: [^nil].	^ line! !!OldLimitingLineStreamWrapper methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' on '.	stream printOn: aStream! !!OldLimitingLineStreamWrapper methodsFor: 'private'!setStream: aStream delimiter: aString	stream := aStream.	line := stream nextLine.	self delimiter: aString.	"sets position"! !!OldLimitingLineStreamWrapper methodsFor: 'accessing'!skipThisLine	line := stream nextLine.	self updatePosition.! !!OldLimitingLineStreamWrapper methodsFor: 'accessing'!upToEnd		^String streamContents: [:strm | | ln |		[(ln := self nextLine) isNil] whileFalse: [ 			strm nextPutAll: ln; cr]]! !!OldLimitingLineStreamWrapper methodsFor: 'accessing'!updatePosition	"Call this before doing character-based access"	position := self atEnd ifFalse: [0]! !"OldFileStream"!!OSPlatform methodsFor: '*FFICHeaderExtractor'!cHeaderExtractorFor: aSharedPool	"IMPORATNT: first read comment of FFISharedPool #cHeaderExtractorFor:	Subclass should likely check if platform is 32 or 64 bits and depending on that	send the correct method (from 'platform' protocol) to FFISharedPool.		Answers an instance of a FFICHeaderExtractor specially created for this platform.	"	^ self subclassResponsibility ! !!MacOSXPlatform methodsFor: '*FFICHeaderExtractor'!cHeaderExtractorFor: aSharedPool	"Read comment of superclass first.	So far there is none 64 bits VMs"	^ aSharedPool macOSX32Extractor! !!UnixPlatform methodsFor: '*FFICHeaderExtractor'!cHeaderExtractorFor: aSharedPool	"Read comment of superclass first.	So far there is none 64 bits VMs"	^ aSharedPool unix32Extractor! !!FFICHeaderExtractor class methodsFor: 'accessing'!autogeneratedMethodProtocol	^ 'autogenerated by FFICHeaderExtractor'! !!FFICHeaderExtractor methodsFor: 'filenames'!autogeneratedMethodName	"Answers the name/selector of the autogenerated init method. Examples of names are 'initVariablesMacOS32', 'initVariablesunix32', etc "	^ ('initVariables', (self platformName copyWithout: Character space) , (self wordSize * 8) asString)		! !!FFICHeaderExtractor methodsFor: 'filenames'!basicGeneralFilename	"For internal usage only. It answers the base filname from which we then base the C program filename, the binary, the log,  the output, etc"	^ self sharedPool name , '.', self platformName ! !!FFICHeaderExtractor methodsFor: 'filenames'!binaryFilename	"Answers the filename for the compiled C program, that is, the binary file. This is typically the argument to the '-o' in gcc and cc."	^ self basicGeneralFilename , '.o'! !!FFICHeaderExtractor methodsFor: 'method generation'!buildMethodSource	"This method creates the source of a Smalltalk method that would initialize the class vars of the shared pool with the values obtained from the output file of the C program"	| sourceStream ouput | 	sourceStream := String new writeStream.	ouput := self outputFilename asFileReference readStream contents.	"The output file of the C program is a literal array that looks like this:	#(SIGKILL 9 4)	#(UNDEFINED-SIGLOST 0 0)	#(SIGPIPE 13 4)	"	sourceStream nextPutAll: self autogeneratedMethodName; cr.	sourceStream nextPutAll: '"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"'; cr.	sourceStream tab; nextPutAll: '<platformName: '''; nextPutAll: FFISharedPool currentPlatformName; nextPutAll: ''' wordSize: '; nextPutAll: FFISharedPool currentWordSize asString; nextPutAll:'>'; cr.	ouput linesDo: [ :aLine | 		| array |		array := self class compilerClass new evaluate: aLine. 		((array first beginsWith: 'UNDEFINED') and: [ array third = 0 ])			ifTrue: [ 				"Undefined constants will be written in the method like this: 				WHATEVER := nil.""WHATEVER is UNDEFINED for this platform""				"				sourceStream tab.				sourceStream nextPutAll: (array first allButFirst: 'UNDEFINED' size); nextPutAll: ' := nil.'.				sourceStream nextPutAll: '"'.				sourceStream nextPutAll: (array first allButFirst: 'UNDEFINED' size).				sourceStream nextPutAll: ' is UNDEFINED for this platform'.				sourceStream nextPutAll: '"'.			]			ifFalse: [  				"Defined constants will be written like:				SIGKILL := 9.				"				sourceStream tab; nextPutAll: array first; nextPutAll: ' := '; nextPutAll: array second asString; nextPutAll: '.' ].		sourceStream cr.	].	^ sourceStream contents! !!FFICHeaderExtractor methodsFor: 'accessing'!cFlags	^ cFlags! !!FFICHeaderExtractor methodsFor: 'accessing'!cFlags: anObject	cFlags := anObject! !!FFICHeaderExtractor methodsFor: 'filenames'!cProgramFilename	"Answers the filename for the autogenerated C program."	^ self basicGeneralFilename , '.c'! !!FFICHeaderExtractor methodsFor: 'running C program'!compileCProgram	"This method takes care of compiling the autogenerated C program. The following is an example of a compilation command for the shared pool FFITestingSharedPool for MacOSX 32 bits:		cd /Users/mariano/pharo/imagenes; cc -m32 -o 'FFITestingSharedPool.Mac OS.o' 'FFITestingSharedPool.Mac OS.c' > 'FFITestingSharedPool.Mac OS.log' 2>&1 		As you can see, STDOUT and STDERR are redirected to #logFilename for analysis in case of errors.	"	| compileScriptStream | 	compileScriptStream := String new writeStream.	compileScriptStream nextPutAll: 'cd ', FileSystem workingDirectory fullName, '; '.	compileScriptStream nextPutAll: self compiler.	compileScriptStream nextPutAll: ' '.	compileScriptStream nextPutAll: self cFlags.	compileScriptStream nextPutAll: ' -o '.	compileScriptStream nextPutAll: '"', self binaryFilename, '"'.	compileScriptStream nextPutAll: ' '.	compileScriptStream nextPutAll: '"', self cProgramFilename, '"'.	compileScriptStream nextPutAll: ' > '.	compileScriptStream nextPutAll: '"', self logFilename, '"'.	compileScriptStream nextPutAll: ' 2>&1 '.	"Transcript show: 'Compile string: ', compileScriptStream contents; cr."	self executeOSShellCommand: compileScriptStream contents.	! !!FFICHeaderExtractor methodsFor: 'accessing'!compiler	^ compiler! !!FFICHeaderExtractor methodsFor: 'accessing'!compiler: anObject	compiler := anObject! !!FFICHeaderExtractor methodsFor: 'running C program'!executeOSShellCommand: aCommandString	"To perform the OS command, this method simply does a system() call via FFI. "	self flag: #fixIt.	"This won't work for Windows as it doesn't have system() function."	self system: aCommandString! !!FFICHeaderExtractor methodsFor: 'extracting'!extractAndStoreHeadersInformation	"Main API method used by FFISharedPool. It first extracts all the constants values (defined in C header files) and then creates a smalltalk init method which is then compiled/installed in the shared pool"	self extractHeadersInformation.		self storeFromExtracted.! !!FFICHeaderExtractor methodsFor: 'extracting'!extractHeadersInformation	"This method takes care of extracting all the constants values of a FFISharedPool from C header files. The way it does this is by first autogenerating a C program that will write down into an output text file, each constant and its value. Then such C program is compiled and run."	| log |	[	self 		generateCProgram;		compileCProgram;		runCProgram.	] on: Error do: [ :ex | 		self error: 'Error: ', ex printString. '. You may want to check ', self logFilename	].	log := self logFilename asFileReference readStream contents.	log ifNotEmpty: [ 		log inspect.		self inform: 'There was a problem in the autogeneration. You may want to check ', self logFilename		 ].		! !!FFICHeaderExtractor methodsFor: 'primitives'!ffiLibraryName 	^ LibC ! !!FFICHeaderExtractor methodsFor: 'generating C program'!generateCProgram	"This method is the one that finally autogenereates the C program"		self cProgramFilename asFileReference 		ensureDelete;		writeStreamDo: [ :stream |			self writeCMainCommentOn: stream.			self writeCIncludesOn: stream.			self writeRestOfCFileOn: stream.	]! !!FFICHeaderExtractor methodsFor: 'accessing'!headersToInclude	^ headersToInclude! !!FFICHeaderExtractor methodsFor: 'accessing'!headersToInclude: anObject	headersToInclude := anObject! !!FFICHeaderExtractor methodsFor: 'accessing'!includeFiles	^ includeFiles! !!FFICHeaderExtractor methodsFor: 'accessing'!includeFiles: anObject	includeFiles := anObject! !!FFICHeaderExtractor methodsFor: 'filenames'!logFilename	"Answers the log filename in which we redirect stdout and stderr in both, the compilation and execution of the C program"	^  self basicGeneralFilename, '.log'! !!FFICHeaderExtractor methodsFor: 'filenames'!outputFilename	"Answers the filename for the output file (that contains all the names and values of the constants) that the C program will write when executed"	^  self basicGeneralFilename, '.output'! !!FFICHeaderExtractor methodsFor: 'primitives'!perror: aMessage	"Prints the errno gloabl variable into the stderr together with aMessage string	and then signal an error"	self primitivePerror: aMessage.	self error: 'Error: ', aMessage,' You may want to check errors in stderr'! !!FFICHeaderExtractor methodsFor: 'accessing'!platformName	^ platformName! !!FFICHeaderExtractor methodsFor: 'accessing'!platformName: anObject	platformName := anObject! !!FFICHeaderExtractor methodsFor: 'primitives'!primitivePerror: anErrorString	^ self ffiCall: #( void perror(String anErrorString) )! !!FFICHeaderExtractor methodsFor: 'primitives'!primitiveSystem: commandString	 ^ self ffiCall: #(int system(char* commandString) ) 		! !!FFICHeaderExtractor methodsFor: 'running C program'!runCProgram	"This method takes care of executing the autogenerated and compiled C program. The following is an example of a execution command for the shared pool FFITestingSharedPool for MacOSX 32 bits:		cd /Users/mariano/pharo/imagenes; ./'FFITestingSharedPool.Mac OS.o' >> 'FFITestingSharedPool.Mac OS.log' 2>&1 		As you can see, STDOUT and STDERR are redirected to #logFilename for analysis in case of errors.	"		| runCStream | 	runCStream := String new writeStream.	runCStream nextPutAll: 'cd ', FileSystem workingDirectory fullName, '; '.	runCStream nextPutAll: './', '"', self binaryFilename, '"'.	runCStream nextPutAll: ' >> '.	runCStream nextPutAll: '"', self logFilename, '"'.	runCStream nextPutAll: ' 2>&1 '.	"Transcript show: 'Execute C program string: ', runCStream contents; cr."	self executeOSShellCommand: runCStream contents.	! !!FFICHeaderExtractor methodsFor: 'accessing'!sharedPool	^ sharedPool! !!FFICHeaderExtractor methodsFor: 'accessing'!sharedPool: anObject	sharedPool := anObject! !!FFICHeaderExtractor methodsFor: 'method generation'!storeFromExtracted	"This method first takes the output file generated by the C program and creates a Smalltalk init method that would set the constants values extracted into the shared pool class variables. Then, the created method is stored in the shared pool class."	| methodSource |	methodSource := self buildMethodSource.	self sharedPool class compile: methodSource classified: self class autogeneratedMethodProtocol! !!FFICHeaderExtractor methodsFor: 'primitives'!system: aCommandString	"Executes aCommandString in the OS via the system() call."	| returnValue |	returnValue := self primitiveSystem: aCommandString.	(returnValue = -1) ifTrue: [ 		self perror: 'system()'		].	^ returnValue ! !!FFICHeaderExtractor methodsFor: 'accessing'!wordSize	^ wordSize! !!FFICHeaderExtractor methodsFor: 'accessing'!wordSize: anObject	wordSize := anObject! !!FFICHeaderExtractor methodsFor: 'generating C program'!writeCInclude: aHeaderName on: aStream	"Internal method for the C program creation. Giving aHeaderName like 'signal.h' this method writes the C #include definition."	aStream 		nextPutAll: '#include <';		nextPutAll: aHeaderName;		nextPutAll: '>';		cr.	! !!FFICHeaderExtractor methodsFor: 'generating C program'!writeCIncludes: aListOfHeaderNames on: stream	"Internal method for the C program creation. It writes each of the user-defined header names (aListOfHeaderNames) as a C #include definition."	aListOfHeaderNames do: [ :each | self writeCInclude: each on: stream ]! !!FFICHeaderExtractor methodsFor: 'generating C program'!writeCIncludesOn: stream	"Internal method for the C program creation. It writes C #include definitions for all the header names. It includes the mandatry ones for our C program (such as stdio.h and stdlib.h) and then all the user-defined ones which should define the constants defined as class variables in the shared pool."	self writeCIncludes: #('stdio.h' 'stdlib.h') on: stream.	self writeCIncludes: self headersToInclude on: stream.	stream cr.		! !!FFICHeaderExtractor methodsFor: 'generating C program'!writeCMainCommentOn: stream	"Internal method for the C program creation. This one just writes a general comment at the beginning."	stream nextPutAll: ('//////  Program automatically generated on <1s> by FFICHeaderExtractor.// For more details, see https://github.com/marianopeck/FFICHeaderExtractor////'	expandMacrosWith: Date today yyyymmdd ).	stream cr.! !!FFICHeaderExtractor methodsFor: 'generating C program'!writeListOfConstantsOn: aStream	"Internal method for the C program creation. This one iterates each class variable of the shared pool and calls the correct function to write the values into the output file."	self sharedPool classVarNames withIndexDo: [ :each :index |		aStream nextPutAll: (('	#ifdef <1s>		printDefinedConstant(file, <1s>);	#else		printUndefinedConstant(file, <1s>);	#endif') expandMacrosWith: each); cr	].	! !!FFICHeaderExtractor methodsFor: 'generating C program'!writeRestOfCFileOn: stream	"Internal method for the C program creation. This one writes the end of the file, including the main(), the definition of our functions, and the opening of the FILE stream for the output. printDefinedConstant() and printUndefinedConstant() are called for each constant."	stream cr.	stream nextPutAll: '#define printDefinedConstant(file, const) fprintf(file, "#(%s %d %ld)\n", #const, const, sizeof(const))	#define printUndefinedConstant(file, const) fprintf(file, "#(UNDEFINED%s %d %d)\n", #const, 0, 0)	int main(int argc, const char * argv[]) {	    FILE *file = fopen("', self outputFilename, '", "w");	    if (file == NULL)	    {	        printf("Error opening file!!\n");	        exit(1);	    }	'.	self writeListOfConstantsOn: stream. 	stream nextPutAll: '	    fclose(file);    	    return 0;	}	'! !!FFISharedPool class methodsFor: 'methods generation'!allAutogeneratedMethodSelectors	"Answers the list of all the selectors of this class that are init methods autogenerated by FFICHeaderExtractor"	^ self class allSelectorsInProtocol: FFICHeaderExtractor autogeneratedMethodProtocol.! !!FFISharedPool class methodsFor: 'accessing'!cHeaderExtractor	"This is a double dispatch with the OSPlatform class. Each platform should be respoonsible of sending the correct message to the shared pool (methods under protocol 'platforms') based on the current platform information (like wether it is 32 or 64 bits), such as unix32Extractor, macOSX32Extractor, etc.	Answers an instance of a FFICHeaderExtractor specially created for current platform."	^ Smalltalk os cHeaderExtractorFor: self! !!FFISharedPool class methodsFor: 'accessing'!currentPlatformName	"Answers the platform name of the current platform"	^ Smalltalk os platformName! !!FFISharedPool class methodsFor: 'accessing'!currentWordSize	"Answers the word size of the current platform. This could be either 32 or 64. Right now the way we obtain this is via FFIExternalType"	^ FFIExternalType sizeOf: #int! !!FFISharedPool class methodsFor: 'testing'!didPlatformChange	"Answers whether this shared pool was initialized for the same platform as the current one. In other words, it answers whether the platform has changed."	^ ((self platformName = self currentPlatformName) and: [ self wordSize = self currentWordSize ]) not ! !!FFISharedPool class methodsFor: 'extracting'!extractAndStoreHeadersInformation	"Read the comment of FFICHeaderExtractor >> extractAndStoreHeadersInformation"	self cHeaderExtractor extractAndStoreHeadersInformation.! !!FFISharedPool class methodsFor: 'testing'!hasAlreadyBeenInitializedBefore	"Answers whether this shared pool was already initialized before or not"	^ self platformName notNil and: [ self wordSize notNil ] ! !!FFISharedPool class methodsFor: 'accessing'!headersContainingVariables	"Answers an array with the `C` header names that define all the defined constants of this SharedPool. Subclasses can override and define their own C headers."	^ self subclassResponsibility ! !!FFISharedPool class methodsFor: 'initialize - release'!initialize	self flag: #removeIt.	"This IF will be eliminated soon...only here temporary"	(SystemVersion current highestUpdate >= 50558)		ifTrue: [ 			SessionManager default registerToolClassNamed: self name			 ]		ifFalse: [ 			Smalltalk addToStartUpList: self. 		]	! !!FFISharedPool class methodsFor: 'variables initialization'!initializeVariables	"This method does the lookup for an autogenerated init method for this platform. If found, then initialize from it. If not found, then do nothing."	| selector |	selector := self lookupInitMethodForCurrentPlatform.	selector ifNotNil: [ 		self initializeVariablesFrom: selector.		self updatePlatformInfo.	] ! !!FFISharedPool class methodsFor: 'variables initialization'!initializeVariablesFrom: aSelector	"Initializes the class variables of this shared pool with the autogenerated init method aSelector"	aSelector ifNotNil: [ self perform: aSelector. ]	! !!FFISharedPool class methodsFor: 'DEPRECATED'!initializeVariablesFromStonExtracted	| stonStream parsedDict |	stonStream := (Smalltalk os cHeaderExtractorFor: self) outputFilename asFileReference readStream. 	parsedDict := STON fromStream: stonStream.	"The STON file looks like this:	{        'SIGHUP' : [                1,                4        ],        'SIGKILL' : [                9,                4        ],        'SIGTERM' : [                15,                4        ]}	"	parsedDict keysAndValuesDo: [ :key :value |		self classVarNamed: key put: value first.	 	]! !!FFISharedPool class methodsFor: 'variables initialization'!initializeVariablesIfNeeded	"If this shared pool shared pool should be initialized, then let's do it!!"	self shouldInitializeVariables ifTrue: [ 		self initializeVariables.	]	! !!FFISharedPool class methodsFor: 'methods generation'!lookupInitMethodForCurrentPlatform	"This method searches an autogenerated init method for the current platform. The lookup basically means checking the selectors in a specific protocol and search for the one (if exists) with the pragma matching the #platformName and #wordSize of the current platform. If found, it answers the selector. If not found, it answers nil. "	| selectors |	selectors := self allAutogeneratedMethodSelectors. 	^ selectors detect: [ :each | 		| method arguments |		method := self class compiledMethodAt: each. 		arguments := (method pragmaAt: #platformName:wordSize:) arguments.		(arguments first = self currentPlatformName) 			and: [ (arguments second = self currentWordSize) ]	] ifNone: [ 		"IMPORTANT: Here we cannot throw an error becasue this method is called from the startup code (from startUp: -> initializeVariablesIfNeeded) and if we throw an error during statup, the image shutsdown and doesn't start anymore."		Transcript show: 'There is no autogenerated init method for platform name ', self currentPlatformName, ' and word size ', self currentWordSize asString; cr.		nil ]! !!FFISharedPool class methodsFor: 'platforms'!macOSX32Extractor	"This is the default setup of a FFICHeaderExtractor for OSX 32 bits. Shared pool subclasses may need to override this if they want to add or change the default settings. For example, setting #includeFiles: to custom directories."	^ FFICHeaderExtractor new		sharedPool: self;		platformName: 'Mac OS'; "IMPORTANT: Should match with 'Smalltalk os platformName ' "		wordSize: 4;		cFlags: '-m32';		headersToInclude: self headersContainingVariables;		compiler: 'cc';		yourself! !!FFISharedPool class methodsFor: 'accessing'!platformName	^ platformName! !!FFISharedPool class methodsFor: 'accessing'!platformName: aString	platformName := aString! !!FFISharedPool class methodsFor: 'methods generation'!removeAllGeneratedMethods	"This is a facility method, likely only used for tests. It simply removes all the autogenerated init methods from this shared pool"	self allAutogeneratedMethodSelectors do: [ :each |		self class removeSelector: each.		]! !!FFISharedPool class methodsFor: 'resetting'!reset	"Simply resets the none-constants class vars of this shared pool. Only used for testing right now."	platformName := nil.	wordSize := nil.! !!FFISharedPool class methodsFor: 'testing'!shouldInitializeVariables	"We should initialize variables if: 1) the platform has changed (for example, if this image was now started in a different OS) or if 2) the class variables where never initialized before."	^ self hasAlreadyBeenInitializedBefore not or: [ self didPlatformChange ]! !!FFISharedPool class methodsFor: 'system startup'!startUp: resuming	"If 'resuming' is true, it means the image is being started. It's time then to iterate every subclass and initialize the class variables from the autogenerated init methods, for those subclasses that need such an initialization."	resuming ifTrue: [ 		self allSubclassesDo: [ :each | each initializeVariablesIfNeeded ]		]! !!FFISharedPool class methodsFor: 'platforms'!unix32Extractor	"This is the default setup of a FFICHeaderExtractor for Unix 32 bits. Shared pool subclasses may need to override this if they want to add or change the default settings. For example, setting #includeFiles: to custom directories."	^ FFICHeaderExtractor new		sharedPool: self;		platformName: 'unix'; "Should match with 'Smalltalk os platformName ' "		wordSize: 4;		cFlags: '-m32';		headersToInclude: self headersContainingVariables;		compiler: 'gcc';		yourself! !!FFISharedPool class methodsFor: 'variables initialization'!updatePlatformInfo	"Updates this shared pool with the info of the current platform."	platformName := self currentPlatformName.	wordSize := self currentWordSize.! !!FFISharedPool class methodsFor: 'accessing'!wordSize	^ wordSize! !!FFISharedPool class methodsFor: 'accessing'!wordSize: aNumber	wordSize := aNumber! !"FFICHeaderExtractor"!!FFICHeaderExtractorTest methodsFor: 'tests'!testBuildMethodSource	| extractor methodSource | 	extractor := self testingSharedPool cHeaderExtractor.	extractor 		generateCProgram;		compileCProgram;		runCProgram.	methodSource := extractor buildMethodSource.	self assert: (methodSource beginsWith: 'initVariables').	self assert: (methodSource includesSubstring: '<platformName:').	self assert: (methodSource includesSubstring: 'wordSize:').	self assert: (methodSource includesSubstring: '"WHATEVER is UNDEFINED for this platform"').	self assert: (methodSource includesSubstring: 'SIGKILL := 9.').	self assert: (methodSource includesSubstring: 'EINVAL := 22.').	self assert: methodSource lines size equals: 8. ! !!FFICHeaderExtractorTest methodsFor: 'tests'!testCProgramOutput	| extractor output | 	extractor := self testingSharedPool cHeaderExtractor.	extractor outputFilename asFileReference ensureDelete.	extractor 		generateCProgram;		compileCProgram;		runCProgram.	output := extractor outputFilename asFileReference readStream contents.	self assert: (output includesSubstring: '#(UNDEFINEDWHATEVER 0 0)').	self assert: (output includesSubstring: '#(SIGKILL 9').	self assert: (output includesSubstring: '#(EINVAL 22').	self assert: output lines size equals: 5. ! !!FFICHeaderExtractorTest methodsFor: 'tests'!testCompileCProgram	| extractor | 	extractor := self testingSharedPool cHeaderExtractor.	extractor binaryFilename asFileReference ensureDelete.	extractor 		generateCProgram;		compileCProgram.	self assert: extractor binaryFilename asFileReference exists.	self assert: extractor binaryFilename asFileReference size > 100.! !!FFICHeaderExtractorTest methodsFor: 'tests'!testGenerateCProgram	| extractor cProgram | 	extractor := self testingSharedPool cHeaderExtractor.	extractor generateCProgram.	cProgram := extractor cProgramFilename asFileReference readStream contents.	self assert: (cProgram includesSubstring: '#include <signal.h>').	self assert: (cProgram includesSubstring: '#include <errno.h>').	self assert: (cProgram includesSubstring: '#ifdef SIGKILL		printDefinedConstant(file, SIGKILL);	#else		printUndefinedConstant(file, SIGKILL);	#endif	#ifdef SIGTERM		printDefinedConstant(file, SIGTERM);	#else		printUndefinedConstant(file, SIGTERM);	#endif	#ifdef WHATEVER		printDefinedConstant(file, WHATEVER);	#else		printUndefinedConstant(file, WHATEVER);	#endif')	! !!FFICHeaderExtractorTest methodsFor: 'tests'!testRunCProgram	| extractor | 	extractor := self testingSharedPool cHeaderExtractor.	extractor outputFilename asFileReference ensureDelete.	extractor 		generateCProgram;		compileCProgram;		runCProgram.	self assert: extractor outputFilename asFileReference exists.	self assert: extractor outputFilename asFileReference size > 10.! !!FFICHeaderExtractorTest methodsFor: 'tests'!testStoreMethod	| extractor | 	extractor := self testingSharedPool cHeaderExtractor.	extractor 		generateCProgram;		compileCProgram;		runCProgram;		extractAndStoreHeadersInformation.		self assert: (self testingSharedPool class includesSelector: extractor autogeneratedMethodName asSymbol).! !!FFICHeaderExtractorTest methodsFor: 'accessing'!testingSharedPool	^ FFITestingSharedPool! !!FFISharedPoolTest methodsFor: 'tests'!testChangePlatformAndTestingMethods	self testingSharedPool reset; updatePlatformInfo.	self deny: self testingSharedPool platformName isNil.	self deny: self testingSharedPool wordSize isNil.	self assert: self testingSharedPool hasAlreadyBeenInitializedBefore.	self testingSharedPool platformName: 'whatever'. 	self assert: self testingSharedPool shouldInitializeVariables.	self assert: self testingSharedPool didPlatformChange.	! !!FFISharedPoolTest methodsFor: 'tests'!testInitializeVariables	self testingSharedPool 		reset;		extractAndStoreHeadersInformation.	self assert: self testingSharedPool shouldInitializeVariables.	self testingSharedPool initializeVariablesIfNeeded. 	self assert: self testingSharedPool platformName equals: FFISharedPool currentPlatformName.	self assert: self testingSharedPool wordSize equals: FFISharedPool currentWordSize.	self assert: (self testingSharedPool classVarNamed: 'SIGKILL') equals: 9.	self assert: (self testingSharedPool classVarNamed: 'EINVAL') equals: 22.	self assert: (self testingSharedPool classVarNamed: 'WHATEVER') isNil.		! !!FFISharedPoolTest methodsFor: 'tests'!testInitializeVariablesWithNoMethodFound	self testingSharedPool reset.	self testingSharedPool removeAllGeneratedMethods.	self testingSharedPool classVarNamed: 'SIGKILL' put: 42.	self assert: self testingSharedPool shouldInitializeVariables.	self testingSharedPool initializeVariablesIfNeeded.	self assert: self testingSharedPool platformName isNil.	self assert: self testingSharedPool wordSize isNil.	"Class variables are untouched if the initialize does not run"	self assert: (self testingSharedPool classVarNamed: 'SIGKILL') equals: 42.		! !!FFISharedPoolTest methodsFor: 'tests'!testLookupInitMethodForCurrentPlatform	self testingSharedPool 		reset;		extractAndStoreHeadersInformation.	self testingSharedPool class compile: 'initVariablesWhatever32		<platformName: ''Whatever'' wordSize: 4>	EACCES := 13.	EINVAL := 22.	SIGKILL := 9.	SIGTERM := 15.	"WHATEVER is UNDEFINED for this platform"	' classified: 'autogenerated by FFICHeaderExtractor'.	self assert: self testingSharedPool cHeaderExtractor autogeneratedMethodName asString equals: self testingSharedPool lookupInitMethodForCurrentPlatform asString. 	! !!FFISharedPoolTest methodsFor: 'tests'!testRemoveAllGeneratedMethods	self testingSharedPool 		reset; 		extractAndStoreHeadersInformation.	self assert: self testingSharedPool  allAutogeneratedMethodSelectors size >= 1.		self testingSharedPool removeAllGeneratedMethods.	self assert: self testingSharedPool  allAutogeneratedMethodSelectors isEmpty.		! !!FFISharedPoolTest methodsFor: 'tests'!testResetAndTestingMethods	self testingSharedPool classVarNamed: 'SIGKILL' put: 9.	self testingSharedPool reset. 	"Class variables values are not reset"	self assert: (self testingSharedPool classVarNamed: 'SIGKILL') isNil not.	self assert: self testingSharedPool platformName isNil.	self assert: self testingSharedPool wordSize isNil.	self deny: self testingSharedPool hasAlreadyBeenInitializedBefore.	self assert: self testingSharedPool shouldInitializeVariables.! !!FFISharedPoolTest methodsFor: 'accessing'!testingSharedPool	^ FFITestingSharedPool ! !!FFITestingSharedPool class methodsFor: 'accessing'!headersContainingVariables	^ #( 'signal.h' 'errno.h' )! !!FFITestingSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor'!initVariablesMacOS32"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"	<platformName: 'Mac OS' wordSize: 4>	EACCES := 13.	EINVAL := 22.	SIGKILL := 9.	SIGTERM := 15.	WHATEVER := nil."WHATEVER is UNDEFINED for this platform"! !!FFITestingSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor'!initVariablesunix32"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"	<platformName: 'unix' wordSize: 4>	EACCES := 13.	EINVAL := 22.	SIGKILL := 9.	SIGTERM := 15.	WHATEVER := nil."WHATEVER is UNDEFINED for this platform"! !"FFICHeaderExtractor-Tests"!!LibCErrnoSharedPool commentStamp: '' prior: 0!The class variables of this class was manually extracted from: http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/errno.h.html!!LibCFcntlSharedPool commentStamp: '' prior: 0!The class variables of this class was manually extracted from: http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/fcntl.h.html!!LibCWaitSharedPool commentStamp: '' prior: 0!The class variables of this class was manually extracted from: http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_wait.h.html!!LibCErrnoSharedPool class methodsFor: 'accessing'!headersContainingVariables	^ #( 'errno.h' )! !!LibCErrnoSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor'!initVariablesMacOS32"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"	<platformName: 'Mac OS' wordSize: 4>	E2BIG := 7.	EACCES := 13.	EADDRINUSE := 48.	EADDRNOTAVAIL := 49.	EAFNOSUPPORT := 47.	EAGAIN := 35.	EALREADY := 37.	EBADF := 9.	EBADMSG := 94.	EBUSY := 16.	ECANCELED := 89.	ECHILD := 10.	ECONNABORTED := 53.	ECONNREFUSED := 61.	ECONNRESET := 54.	EDEADLK := 11.	EDESTADDRREQ := 39.	EDOM := 33.	EDQUOT := 69.	EEXIST := 17.	EFAULT := 14.	EFBIG := 27.	EHOSTUNREACH := 65.	EIDRM := 90.	EILSEQ := 92.	EINPROGRESS := 36.	EINTR := 4.	EINVAL := 22.	EIO := 5.	EISCONN := 56.	EISDIR := 21.	ELOOP := 62.	EMFILE := 24.	EMLINK := 31.	EMSGSIZE := 40.	EMULTIHOP := 95.	ENAMETOOLONG := 63.	ENETDOWN := 50.	ENETRESET := 52.	ENETUNREACH := 51.	ENFILE := 23.	ENOBUFS := 55.	ENODATA := 96.	ENODEV := 19.	ENOENT := 2.	ENOEXEC := 8.	ENOLCK := 77.	ENOLINK := 97.	ENOMEM := 12.	ENOMSG := 91.	ENOPROTOOPT := 42.	ENOSPC := 28.	ENOSR := 98.	ENOSTR := 99.	ENOSYS := 78.	ENOTCONN := 57.	ENOTDIR := 20.	ENOTEMPTY := 66.	ENOTRECOVERABLE := 104.	ENOTSOCK := 38.	ENOTSUP := 45.	ENOTTY := 25.	ENXIO := 6.	EOPNOTSUPP := 102.	EOVERFLOW := 84.	EOWNERDEAD := 105.	EPERM := 1.	EPIPE := 32.	EPROTO := 100.	EPROTONOSUPPORT := 43.	EPROTOTYPE := 41.	ERANGE := 34.	EROFS := 30.	ESPIPE := 29.	ESRCH := 3.	ESTALE := 70.	ETIME := 101.	ETIMEDOUT := 60.	ETXTBSY := 26.	EWOULDBLOCK := 35.	EXDEV := 18.! !!LibCErrnoSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor'!initVariablesunix32"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"	<platformName: 'unix' wordSize: 4>	E2BIG := 7.	EACCES := 13.	EADDRINUSE := 98.	EADDRNOTAVAIL := 99.	EAFNOSUPPORT := 97.	EAGAIN := 11.	EALREADY := 114.	EBADF := 9.	EBADMSG := 74.	EBUSY := 16.	ECANCELED := 125.	ECHILD := 10.	ECONNABORTED := 103.	ECONNREFUSED := 111.	ECONNRESET := 104.	EDEADLK := 35.	EDESTADDRREQ := 89.	EDOM := 33.	EDQUOT := 122.	EEXIST := 17.	EFAULT := 14.	EFBIG := 27.	EHOSTUNREACH := 113.	EIDRM := 43.	EILSEQ := 84.	EINPROGRESS := 115.	EINTR := 4.	EINVAL := 22.	EIO := 5.	EISCONN := 106.	EISDIR := 21.	ELOOP := 40.	EMFILE := 24.	EMLINK := 31.	EMSGSIZE := 90.	EMULTIHOP := 72.	ENAMETOOLONG := 36.	ENETDOWN := 100.	ENETRESET := 102.	ENETUNREACH := 101.	ENFILE := 23.	ENOBUFS := 105.	ENODATA := 61.	ENODEV := 19.	ENOENT := 2.	ENOEXEC := 8.	ENOLCK := 37.	ENOLINK := 67.	ENOMEM := 12.	ENOMSG := 42.	ENOPROTOOPT := 92.	ENOSPC := 28.	ENOSR := 63.	ENOSTR := 60.	ENOSYS := 38.	ENOTCONN := 107.	ENOTDIR := 20.	ENOTEMPTY := 39.	ENOTRECOVERABLE := 131.	ENOTSOCK := 88.	ENOTSUP := 95.	ENOTTY := 25.	ENXIO := 6.	EOPNOTSUPP := 95.	EOVERFLOW := 75.	EOWNERDEAD := 130.	EPERM := 1.	EPIPE := 32.	EPROTO := 71.	EPROTONOSUPPORT := 93.	EPROTOTYPE := 91.	ERANGE := 34.	EROFS := 30.	ESPIPE := 29.	ESRCH := 3.	ESTALE := 116.	ETIME := 62.	ETIMEDOUT := 110.	ETXTBSY := 26.	EWOULDBLOCK := 11.	EXDEV := 18.! !!LibCErrnoSharedPool class methodsFor: 'initialize - release'!initialize	self initializeVariables	! !!LibCFcntlSharedPool class methodsFor: 'accessing'!headersContainingVariables	^ #( 'fcntl.h' )! !!LibCFcntlSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor'!initVariablesMacOS32"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"	<platformName: 'Mac OS' wordSize: 4>	AT_EACCESS := 16.	AT_FDCWD := -2.	AT_SYMLINK_FOLLOW := 64.	AT_SYMLINK_NOFOLLOW := 32.	FD_CLOEXEC := 1.	F_DUPFD := 0.	F_DUPFD_CLOEXEC := 67.	F_GETFD := 1.	F_GETFL := 3.	F_GETLK := 7.	F_GETOWN := 5.	F_RDLCK := 1.	F_SETFD := 2.	F_SETFL := 4.	F_SETLK := 8.	F_SETLKW := 9.	F_SETOWN := 6.	F_UNLCK := 2.	F_WRLCK := 3.	O_ACCMODE := 3.	O_APPEND := 8.	O_CLOEXEC := 16777216.	O_CREAT := 512.	O_DIRECTORY := 1048576.	O_DSYNC := 4194304.	O_EXCL := 2048.	O_EXEC := nil."O_EXEC is UNDEFINED for this platform"	O_NOCTTY := 131072.	O_NOFOLLOW := 256.	O_NONBLOCK := 4.	O_RDONLY := 0.	O_RDWR := 2.	O_RSYNC := nil."O_RSYNC is UNDEFINED for this platform"	O_SEARCH := nil."O_SEARCH is UNDEFINED for this platform"	O_SYNC := 128.	O_TRUNC := 1024.	O_TTY_INIT := nil."O_TTY_INIT is UNDEFINED for this platform"	O_WRONLY := 1.	POSIX_FADV_DONTNEED := nil."POSIX_FADV_DONTNEED is UNDEFINED for this platform"	POSIX_FADV_NOREUSE := nil."POSIX_FADV_NOREUSE is UNDEFINED for this platform"	POSIX_FADV_NORMAL := nil."POSIX_FADV_NORMAL is UNDEFINED for this platform"	POSIX_FADV_RANDOM := nil."POSIX_FADV_RANDOM is UNDEFINED for this platform"	POSIX_FADV_SEQUENTIAL := nil."POSIX_FADV_SEQUENTIAL is UNDEFINED for this platform"	POSIX_FADV_WILLNEED := nil."POSIX_FADV_WILLNEED is UNDEFINED for this platform"! !!LibCFcntlSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor'!initVariablesunix32"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"	<platformName: 'unix' wordSize: 4>	AT_EACCESS := 512.	AT_FDCWD := -100.	AT_SYMLINK_FOLLOW := 1024.	AT_SYMLINK_NOFOLLOW := 256.	FD_CLOEXEC := 1.	F_DUPFD := 0.	F_DUPFD_CLOEXEC := 1030.	F_GETFD := 1.	F_GETFL := 3.	F_GETLK := 5.	F_GETOWN := 9.	F_RDLCK := 0.	F_SETFD := 2.	F_SETFL := 4.	F_SETLK := 6.	F_SETLKW := 7.	F_SETOWN := 8.	F_UNLCK := 2.	F_WRLCK := 1.	O_ACCMODE := 3.	O_APPEND := 1024.	O_CLOEXEC := 524288.	O_CREAT := 64.	O_DIRECTORY := 65536.	O_DSYNC := 4096.	O_EXCL := 128.	O_EXEC := nil."O_EXEC is UNDEFINED for this platform"	O_NOCTTY := 256.	O_NOFOLLOW := 131072.	O_NONBLOCK := 2048.	O_RDONLY := 0.	O_RDWR := 2.	O_RSYNC := 1052672.	O_SEARCH := nil."O_SEARCH is UNDEFINED for this platform"	O_SYNC := 1052672.	O_TRUNC := 512.	O_TTY_INIT := nil."O_TTY_INIT is UNDEFINED for this platform"	O_WRONLY := 1.	POSIX_FADV_DONTNEED := 4.	POSIX_FADV_NOREUSE := 5.	POSIX_FADV_NORMAL := 0.	POSIX_FADV_RANDOM := 1.	POSIX_FADV_SEQUENTIAL := 2.	POSIX_FADV_WILLNEED := 3.! !!LibCFcntlSharedPool class methodsFor: 'initialize - release'!initialize	self initializeVariables	! !!LibCSignalSharedPool class methodsFor: 'accessing'!headersContainingVariables	^ #( 'signal.h' )! !!LibCSignalSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor'!initVariablesMacOS32"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"	<platformName: 'Mac OS' wordSize: 4>	SIGABRT := 6.	SIGALRM := 14.	SIGBUS := 10.	SIGCHLD := 20.	SIGCLD := nil."SIGCLD is UNDEFINED for this platform"	SIGCONT := 19.	SIGEMT := 7.	SIGFPE := 8.	SIGHUP := 1.	SIGINFO := 29.	SIGINT := 2.	SIGIO := 23.	SIGIOT := 6.	SIGKILL := 9.	SIGLOST := nil."SIGLOST is UNDEFINED for this platform"	SIGPIPE := 13.	SIGPOLL := nil."SIGPOLL is UNDEFINED for this platform"	SIGPROF := 27.	SIGQUIT := 3.	SIGSEGV := 11.	SIGSTOP := 17.	SIGSYS := 12.	SIGTERM := 15.	SIGTRAP := 5.	SIGTSTP := 18.	SIGTTIN := 21.	SIGTTOU := 22.	SIGURG := 16.	SIGUSR1 := 30.	SIGUSR2 := 31.	SIGVTALRM := 26.	SIGWINCH := 28.	SIGXCPU := 24.	SIGXFSZ := 25.! !!LibCSignalSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor'!initVariablesunix32"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"	<platformName: 'unix' wordSize: 4>	SIGABRT := 6.	SIGALRM := 14.	SIGBUS := 7.	SIGCHLD := 17.	SIGCLD := 17.	SIGCONT := 18.	SIGEMT := nil."SIGEMT is UNDEFINED for this platform"	SIGFPE := 8.	SIGHUP := 1.	SIGINFO := nil."SIGINFO is UNDEFINED for this platform"	SIGINT := 2.	SIGIO := 29.	SIGIOT := 6.	SIGKILL := 9.	SIGLOST := nil."SIGLOST is UNDEFINED for this platform"	SIGPIPE := 13.	SIGPOLL := 29.	SIGPROF := 27.	SIGQUIT := 3.	SIGSEGV := 11.	SIGSTOP := 19.	SIGSYS := 31.	SIGTERM := 15.	SIGTRAP := 5.	SIGTSTP := 20.	SIGTTIN := 21.	SIGTTOU := 22.	SIGURG := 23.	SIGUSR1 := 10.	SIGUSR2 := 12.	SIGVTALRM := 26.	SIGWINCH := 28.	SIGXCPU := 24.	SIGXFSZ := 25.! !!LibCSignalSharedPool class methodsFor: 'initialization-release'!initialize	self initializeVariables	! !!LibCWaitSharedPool class methodsFor: 'accessing'!headersContainingVariables	^ #( 'sys/wait.h' )! !!LibCWaitSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor'!initVariablesMacOS32"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"	<platformName: 'Mac OS' wordSize: 4>	WCONTINUED := 16.	WEXITED := 4.	WNOHANG := 1.	WNOWAIT := 32.	WSTOPPED := 8.	WUNTRACED := 2.! !!LibCWaitSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor'!initVariablesunix32"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"	<platformName: 'unix' wordSize: 4>	WCONTINUED := 8.	WEXITED := 4.	WNOHANG := 1.	WNOWAIT := 16777216.	WSTOPPED := 2.	WUNTRACED := 2.! !!LibCWaitSharedPool class methodsFor: 'initialize - release'!initialize	self initializeVariables	! !"FFICHeaderExtractor-LibC"!!OSSAttachableFileStream commentStamp: '' prior: 0!OSSAttachableFileStream represents a  stream on an input or output channel provided by the underlying operating system. It behaves like an ordinary file stream, except that it can be attached myself to an input or output stream which has already been opened by the underlying operating system.The most common use is to represent either the read or write end of a Pipe from the  Operatying System . This way, it provides a Stream API for both, reading and writing. An OSSPipe  contains a 'reader' and a 'writer' which will be two different instances of this class.!!OSSPipe commentStamp: '' prior: 0!OSSPipe represents a pipe provided by the underlying operating system, such as a Unix pipe. I have a reader stream and a writer stream which behave similarly to a read-only FileStream and a writeable FileStream. These streams are instances of OSSAttachableFileStream which are attached  to the underlying created  pipe (to either read and write end). The idea of OSSPipe is to provide an Stream-like API for pipes. The write-related methods will be delagated to the 'writer' (for example, #nextPutAll:) and the read-related methods (like #upToEnd) will be forwarded to the reader.Thanks to the Stream-API, it almos allows a code user, to either use Pipes or regular files polymorphically.  In fact, OSSUnixSubprocess can either work with regular files or with OSSPipe for dealing with stdin, stdout and stderr. OSSPipe uses a single-character buffer to implement #peek without losing data from the external OS pipe.!!OSSCFile commentStamp: '' prior: 0!OSSCFile is a external object which provides  a way for mapping C-level  FILE*  in our FFI calls. We have FFI calls that either answer or receive FILE*  and in these cases we use OSSCFile for the FFI signature. !!OSSUnixProcessExitStatus commentStamp: '' prior: 0!A OSSUnixProcessExitStatus represents the exit status of a unix process. This is an integer bit field answered by the wait() system call that contains information about exit status of the process. The meaning of the bit field varies according to the cause of process exit. When the OS process of a OSSUnixSubprocess exits and we collect the exit status via (#queryExitStatus which ends up doing the waitpid()), we get this bit integer bit fields. OSSUnixSubprocess #exitStatus answers this integer. To interpret it's result better, then we use this class OSSUnixProcessExitStatus (via #exitStatusInterpreter). Ideally, we should take the resulting integer and call the macros WIFSIGNALED, WIFEXITED etc.. but since they are macros, they are not accessible via FFI. Therefore, we do the internal bit shits ourselves.However, OSSUnixProcessExitStatus decodes the process exit status in a manner compatible with a typical GNU unix implementation. It is not guaranteed to be portable and may produce misleading results on other unix systems.Following a normal process exit, the status may be decoded to provide a small positive integer value in the range 0 - 255, which is the value that is presented by a unix shell as the exit status of a program. If terminated by a signal, the corresponding value is the signal number of the signal that caused process exit.!!OSSUnixSystemAccessor commentStamp: '' prior: 0!OSSUnixSystemAccessor provides access to the operating system in which the Pharo VM is currently running.  There is only one instance of this class, holded by 'OSSVMProcess vmProcess'  which depends on it  to provide access to the operating system process which they represent.This class provides GENERAL funcionallity for managing files, errors, environments variables, waiting calls, etc etc. Ideally, 100% of its functionallity should be implemented via FFI calls. However, we still use some OSProcess primitives which would be a bit complicaated to implement via FFI (mostly because they access macros, or constants, or things related to a the C pre-processor that we do not have at FFI level). The functionallity that is NOT GENERAL (like the call to posix_spawn() family of functions), should not be here but in the concrete place such as OSSUnixSubprocess. For the parts that are based on FFI calls, we split each call in two sides. The first side is the method that does the FFI call (under a 'XXX - primitives' protocol, for example, #primitiveFileno:). The other side, is wrapper method that calls the primitive internally but also takes care about managing possible errors of it, informing those, etc (for example, #fileno:). Therefore, is very much likely that the "code users" of this class, will be using the latter side (wrappers) of the methods and not the primitive ones.!!!! Management of dead processesNew processes are created as childs of the current process. The method #waitpidNoHang: is used to query the exit status of processes.However, since we use the waitpid() function using WNOHANG, it returns a finished process id that is not necessarily the one that is asked for.Becayse of this, the Accessor contains a map of process exit statuses.If the asked process is the one returned by waitpid, we return the corresponding exit status, otherwise we store that value in the map for later accesses.!!OSSVMProcess commentStamp: '' prior: 0!OSSVMProcess represents the operating system process in which this Pharo VM is currently running. OSSVMProcess has a unique instance accessed via #vmProcess and it also uses a unique instance of  OSSUnixSystemAccessor  which provides access to the external operating system.OSSVMProcess can answer some information about the OS process running the VM, such as running PID, children, etc etc. More can be added later. Another important task of this class is to keep track of all the launched children processes (instances of OSSUnixSubprocess). Whenever a process is started it's registered in OSSVMProcess and unregister in certain scenarios (see senders of #unregisterChildProcess:). We keep a  list of all our children, and ocasionally prune all those that have already been exited. This class takes care of running what we call the "child watcher" which is basically a way to monitor children status and collect exit code when they finish. This also  guarantees not to let zombies process (a child whose parent did not collected child exit status). Basically, we use a SIGCHLD handler to capture  a child death. For more details, see method #initializeChildWatcher. !!OSSUnixSubprocess commentStamp: '' prior: 0!OSSUnixSubprocess is the main interface for spwaning subprocesses in a Unix OS. A process consist at minimun of a program/command to be executed (a Unix binary..could be cat , ls, cp,  custom shell scripts, etc etc.  ) and an optional list of arguments that will be passed to that program.This class also allows you to define streams  (either StandardFileStream or OSSPipe) that will be mapped to the underlying standard streams stdout/stderr/stdin. This way it provides an API for reading and writing from those. In addition, it takes care of opening, closing, cleaning and all the rest of streams operations. It also provides code for checking the status or waiting the exit of the OS process. Different strategies are supported (SIGCHLD based or delay polling). See the different methods in the protocol 'running'.' In addition, once the subprocess was started, the subprocess instance is registered in OSSVMProcess which takes care of handling the child death via the childWatcher. Some additional features involved env variable settings (environmentAt:put:) for the child, defining a working directory (#workingDirectory: ), facilities for shell commands, etc.To achieve it's goals, this class relies on OSSUnixSystemAccessor for accessing Unix system calls. As for  implementation details to spwan processes this class relies on the posix_spwan() family of functions which we call via FFI. The following is ONE example of ONE possible usage. We define and set settings which are actually the default, so they wouldn't make sense..but just for showing the most of the API:OSSUnixSubprocess new		command: 'ls';	arguments: (Array with: Smalltalk image imagePath);	defaultWriteStreamCreationBlock: [ OSSVMProcess vmProcess systemAccessor makeNonBlockingPipe ];	redirectStdout; "automatic default stream creation...above closure."	redirectStderrTo: '/tmp/stderrFile.txt' asFileReference writeStream; "custom stream creation"	createMissingStandardStreams: false; "therefore won't create stdin stream"	workingDirectory: '/home'; "set working directory for child"	environmentAt: 'HOME' put: '/tmp/home';	addAllEnvVariablesFromParentWithoutOverride; "we will inherit then all but $HOME"	runAndWaitOnExitDo: [ :command :outString :errString |		self assert: (outString includesSubstring: Smalltalk image imagePath).			self assert: command isSuccess.		self assert: errString isEmpty. 	]	 !!OSSAttachableFileStream class methodsFor: 'file creation'!fileNamed: fileName	"Since this is an attacheable stream it means the underlying stream in the OS	has already been opened"	self shouldNotImplement! !!OSSAttachableFileStream class methodsFor: 'file creation'!isAFileNamed: fileName	"Since this is an attacheable stream it means the underlying stream in the OS	has already been opened"	self shouldNotImplement! !!OSSAttachableFileStream class methodsFor: 'instance creation'!name: aSymbolOrString attachTo: aFileID writable: readWriteFlag 	"Create a new instance attached to aFileID. For write streams, this represents two	Smalltalk streams which write to the same OS file or output stream,	presumably with interleaved output. The purpose of this method is to	permit a FileStream to be attached to an existing aFileID, such as	the handle for standard input, standard output, and standard error."	^ (super basicNew		name: aSymbolOrString		attachTo: aFileID		writable: readWriteFlag) initialize! !!OSSAttachableFileStream class methodsFor: 'TO USE LATER WITHOUT OSPROCESS'!name: aSymbolOrString attachToCFile: aCFile writable: readWriteFlag 	"Create a new instance attached to aCFile. For write streams, this represents two	Smalltalk streams which write to the same OS file or output stream,	presumably with interleaved output. The purpose of this method is to	permit a FileStream to be attached to an existing aCFile, such as	the handle for standard input, standard output, and standard error."	^ (super basicNew		name: aSymbolOrString		attachToCFile: aCFile		writable: readWriteFlag) initialize! !!OSSAttachableFileStream class methodsFor: 'file creation'!newFileNamed: fileName	"Since this is an attacheable stream it means the underlying stream in the OS	has already been opened"		self shouldNotImplement! !!OSSAttachableFileStream class methodsFor: 'file creation'!oldFileNamed: fileName	"Since this is an attacheable stream it means the underlying stream in the OS	has already been opened"		self shouldNotImplement! !!OSSAttachableFileStream class methodsFor: 'file creation'!readOnlyFileNamed: fileName	"Since this is an attacheable stream it means the underlying stream in the OS	has already been opened"		self shouldNotImplement! !!OSSAttachableFileStream class methodsFor: 'registry'!register: anObject	"An attachable file stream is generally either a second reference to an	existing file stream, or a reference to a transient object such as a pipe	endpoint. There is no need to register it for finalization."	^ anObject! !!OSSAttachableFileStream class methodsFor: 'registry'!unregister: anObject	"An attachable file stream is generally either a second reference to an	existing file stream, or a reference to a transient object such as a pipe	endpoint. There is no need to register it for finalization."	^ anObject! !!OSSAttachableFileStream methodsFor: 'converting'!asAttachableFileStream	^ self! !!OSSAttachableFileStream methodsFor: 'finalization'!autoClose	"Private. Answer true if the file should be automatically closed when 	this object is finalized."	^ autoClose		ifNil: [autoClose := true]! !!OSSAttachableFileStream methodsFor: 'open/close'!close	"Close this file."	| handle |	(handle := self basicFileID) ifNotNil: [		self primCloseNoError: handle.		self unregister.		fileID := nil	]! !!OSSAttachableFileStream methodsFor: 'open/close'!ensureOpen	"Since this is an attacheable stream it means the underlying stream in the OS	has already been opened"	self shouldNotImplement! !!OSSAttachableFileStream methodsFor: 'finalization'!finalize	"If #autoClose is true, then we try to close the stream upon finalization - GC "		self autoClose		ifTrue: [[self primCloseNoError: fileID] on: Error do: []]! !!OSSAttachableFileStream methodsFor: 'read, write, position'!flush	"Flush the external OS stream (the one in the C library)."		self systemAccessor fflush: self getFilePointerAsCFile! !!OSSAttachableFileStream methodsFor: 'finalization'!keepOpen	"Do not allow the file to be closed when this object is finalized."	autoClose := false! !!OSSAttachableFileStream methodsFor: 'attaching'!name: aSymbolOrString attachTo: aFileID writable: readWriteFlag	"Attach to an existing file handle, assumed to have been previously	 opened by the underlying operating system.	"		name := aSymbolOrString.	fileID := aFileID.	readWriteFlag ifTrue: [self readWrite] ifFalse: [self readOnly].	self ascii.	self register! !!OSSAttachableFileStream methodsFor: 'TO USE LATER WITHOUT OSPROCESS'!name: aSymbolOrString attachToCFile: externalFilePointer writable: readWriteFlag	"Attach to an existing file handle, assumed to have been previously opened by the underlying operating system.	We assume a 32 bits machine and here we document the SQFile used by the VM:	/* squeak file record; see sqFilePrims.c for details */typedef struct {  int			 sessionID;	/* ikp: must be first */  void			*file;  squeakFileOffsetType	 fileSize;	/* 64-bits we hope. */  char			 writable;  char			 lastOp; /* 0 = uncommitted, 1 = read, 2 = write */  char			 lastChar;  char			 isStdioStream;} SQFile;	"	| fileIDByteArray |	self flag: #fixIt.	"Hack...I calculated that the size of the SQFile struct in a 32 bits machine is 20 bytes only	if the fileSize was 64 bits. This is the case of Pharo OSX VM. However, Linux VM has not yet been build	with 64 buts but 32 bits for fileSize and so, instead of 20 it is 16.	For more details read thread with subject 'Why StandardFileStream fileID is 16 bytes in Linux while 20 bytes in OSX?'	"	fileIDByteArray := ByteArray new: 20. 	name := aSymbolOrString.	self setSessionIDTo: fileIDByteArray.	"Hack. I calculated that the File* of the SQFile is the second element of the struct and starts at the byte 5.	The first 4 byets is the session ID. "	self setOSFilePointerFromByteArray: externalFilePointer getHandle getHandle asByteArrayPointer to: fileIDByteArray offset: 4.	readWriteFlag 		ifTrue: [			self flag: #fixIt.			"Again, in 32 bytes machines, the byte17 is the variable 'writable' from the SQFile. 			In Linux, instead if 17 it should be 13.			 "			fileIDByteArray at: 17 put: 1.			self readWrite] 		ifFalse: [			self readOnly].	fileID := fileIDByteArray.	self ascii.	self register! !!OSSAttachableFileStream methodsFor: 'TO USE LATER WITHOUT OSPROCESS'!oldname: aSymbolOrString attachTo: externalFilePointer writable: readWriteFlag	"Attach to an existing file handle, assumed to have been previously opened by the underlying operating system.	We assume a 32 bits machine and here we document the SQFile used by the VM:	/* squeak file record; see sqFilePrims.c for details */typedef struct {  int			 sessionID;	/* ikp: must be first */  void			*file;  squeakFileOffsetType	 fileSize;	/* 64-bits we hope. */  char			 writable;  char			 lastOp; /* 0 = uncommitted, 1 = read, 2 = write */  char			 lastChar;  char			 isStdioStream;} SQFile;	"	| fileIDByteArray |	"Hack...I calculated that the size of the SQFile struct in a 32 bits machine is 20 bytes. "	fileIDByteArray := ByteArray new: 20. 	name := aSymbolOrString.	self setSessionIDTo: fileIDByteArray.	"Hack. I calculated that the File* of the SQFile is the second element of the struct and starts at the byte 5.	The first 4 byets is the session ID. "	self setOSFilePointerFromByteArray: externalFilePointer getHandle getHandle asByteArrayPointer to: fileIDByteArray offset: 4.	readWriteFlag 		ifTrue: [			"Again, in 32 bytes machines, the byte17 is the variable 'writable' from the SQFile.  "			fileIDByteArray at: 17 put: 1.			self readWrite] 		ifFalse: [			self readOnly].	fileID := fileIDByteArray.	self ascii.	self register! !!OSSAttachableFileStream methodsFor: 'open/close'!open	"Since this is an attacheable stream it means the underlying stream in the OS	has already been opened"		self shouldNotImplement! !!OSSAttachableFileStream methodsFor: 'open/close'!open: fileName forWrite: writeMode	"Since this is an attacheable stream it means the underlying stream in the OS	has already been opened"		self shouldNotImplement! !!OSSAttachableFileStream methodsFor: 'open/close'!openReadOnly	"Since this is an attacheable stream it means the underlying stream in the OS	has already been opened"		self shouldNotImplement! !!OSSAttachableFileStream methodsFor: 'read, write, position'!position	"Return the receiver's current file position. If the stream is not positionable,	as in the case of a Unix pipe stream, answer 0."	^ [super position]		on: Error		do: [0]! !!OSSAttachableFileStream methodsFor: 'open/close'!reopen	"Since this is an attacheable stream it means the underlying stream in the OS	has already been opened"		self shouldNotImplement! !!OSSAttachableFileStream methodsFor: 'non blocking'!setNonBlocking	"Make this stream to be none blocking. In Linux it means 	calling fcntl() to set the file non-blocking (O_NONBLOCK)." 	self systemAccessor makeFileNoneBocking: fileID! !!OSSAttachableFileStream methodsFor: 'TO USE LATER WITHOUT OSPROCESS'!setOSFilePointerFromByteArray: externalFilePointer to: aDestByteArray offset: anOffsetNumber	1 to: 4 do: [ :index | aDestByteArray at: (index + anOffsetNumber) put: (externalFilePointer at: index) ]	! !!OSSAttachableFileStream methodsFor: 'TO USE LATER WITHOUT OSPROCESS'!setSessionIDTo: fileIDByteArray	| currentSession |	currentSession := OSSVMProcess vmProcess sessionID.	1 to: currentSession size do: [ :index | fileIDByteArray at: index put: (currentSession at: index) ]! !!OSSAttachableFileStream methodsFor: 'read, write, position'!upToEnd	"Answer a subcollection from the current access position through the last element	of the receiver. This is slower than the method in StandardFileStream, but it	works with pipes which answer false to #atEnd when no further input is	currently available, but the pipe is not yet closed."	| newStream buffer nextBytes |	buffer := buffer1 species new: 1000.	newStream := WriteStream on: (buffer1 species new: 100).	[self atEnd or: [(nextBytes := self nextInto: buffer) isEmpty]]		whileFalse: [newStream nextPutAll: nextBytes].	^ newStream contents! !!OldStandardFileStream methodsFor: '*OSSubprocess'!atEndOfFile	"Answer whether the receiver is at its end based on the result of the last read operation. This uses feof() to test the underlying file stream status, and can be used as an alternative to #atEnd, which does not properly report end of file status for an OSPipe.		Answer whether the file represented by #getFilePointerAsCFile is at end of file, as determined by a call to feof(). This is different from StandardFileStream>>primAtEnd: which answers true if the file pointer is at the end of the file, but which does not call feof() to determine that an end of file condition has occurred. The difference is significant	if aSqFileStruct represents a pipe. Another case where the difference is significant is when using StandardFileStream to communicate with a child process since  the SQFile will not automatically be updated if some other process has changed the actual size of the file.	"	^ fileID isNil or: [ self systemAccessor feof: self getFilePointerAsCFile ]! !!OldStandardFileStream methodsFor: '*OSSubprocess'!basicFileID	^ fileID! !!OldStandardFileStream methodsFor: '*OSSubprocess'!getFilePointerAsCFile	| pointerSize secondFieldStart secondFieldEnd |	pointerSize := FFIExternalType pointerSize.	secondFieldStart := pointerSize + 1.	secondFieldEnd := secondFieldStart + pointerSize - 1.	^ OSSCFile new 		setHandle: (ExternalData 							fromHandle: ((fileID copyFrom: secondFieldStart to: secondFieldEnd) asExternalPointer  ) 							type: ExternalType void asPointerType);		yourself	! !!OldStandardFileStream methodsFor: '*OSSubprocess'!ossIsPipe	^ false! !!OldStandardFileStream methodsFor: '*OSSubprocess'!systemAccessor	^ OSSVMProcess vmProcess systemAccessor! !!OldStandardFileStream methodsFor: '*OSSubprocess'!upToEndOfFile	"Answer a subcollection from the current access position through the last element of the receiver.  Use #atEndOfFile to determine end of file status with feof(), required for reliable end of file test on OS pipes or in files that could have been written by another (child) process different than the VM process."		| newStream buffer |	self closed 		ifTrue: [ self error: 'File already closed' ]		ifFalse: [  			buffer := buffer1 species new: 1000.			newStream := WriteStream on: (buffer1 species new: 100).			[self atEndOfFile] whileFalse: [newStream nextPutAll: (self nextInto: buffer)].			^ newStream contents		]! !!OSSPipe class methodsFor: 'instance creation'!newWith: fileIDsArray readBlocking: readBlocking	"fileIDsArray is an array of two elements where the first represents a sqFile struct of the reader of the pipe and the second represents the sqFile of the writer of the pipe. 	If readBlocking is true, then the pipe will lock the reading waiting until there is data. If false, then the streams will not lock and answer immediatly instead.  	 "	^ self basicNew 			initializeWith: fileIDsArray readBlocking: readBlocking			yourself! !!OSSPipe methodsFor: 'testing'!atEnd	"Answer whether the receiver can access any more objects."	^ writer closed and: [self peek == nil]! !!OSSPipe methodsFor: 'testing'!atEndOfFile	"Answer whether the receiver is at its end based on the result of	the last read operation. This uses feof() to test the underlying file	stream status, and can be used as an alternative to #atEnd, which	does not properly report end of file status for an OSSPipe."	^ reader atEndOfFile! !!OSSPipe methodsFor: 'closing'!close	"Closes both streams"		self closeWriter.	self closeReader.! !!OSSPipe methodsFor: 'closing'!closeReader	reader ifNotNil: [reader close]! !!OSSPipe methodsFor: 'closing'!closeWriter	writer ifNotNil: [writer close]! !!OSSPipe methodsFor: 'testing'!closed	^ reader closed! !!OSSPipe methodsFor: 'accessing'!contents	"Answer contents of the pipe, and return the contents to the pipe so it can still be read."	| string |	self closed ifTrue:		[self notify: self printString, ' ', self reader printString, ' closed'.		^ nil].	string := self reader upToEnd.	string isEmpty ifFalse:		[self writer closed			ifTrue: [self notify: self printString, ' ', self writer printString,								' closed, cannot replace contents']			ifFalse: [self nextPutAll: string]].	^ string! !!OSSPipe methodsFor: 'character writing'!cr	"Append a return character to the receiver."	self writer cr! !!OSSPipe methodsFor: 'read, write, position'!flush	^writer flush! !!OSSPipe methodsFor: 'initialize - release'!initializeWith: fileIDsArray readBlocking: aBoolean	super initialize.	readBlocking := aBoolean.	self openReadStreamFor: fileIDsArray first withName: 'pipeReader'.	self openWriteStreamFor: fileIDsArray second withName: 'pipeWriter'.! !!OSSPipe methodsFor: 'read, write, position'!next	"Answer the next object accessible by the receiver."	| character |	nextChar isNil		ifTrue:			[^ [reader next]				on: Error				do: [nil]]		ifFalse:			[character := nextChar.			nextChar := nil.			^ character]! !!OSSPipe methodsFor: 'read, write, position'!next: anInteger 	"Answer the next anInteger elements of my collection."	| character stream |	stream := WriteStream on: String new.	(1 to: anInteger) do:		[:index |		character := self next.		character isNil			ifTrue: [^ stream contents]				ifFalse: [stream nextPut: character. false]].	^ stream contents! !!OSSPipe methodsFor: 'read, write, position'!nextPut: anObject 	"Insert the argument, anObject, as the next object accessible by the 	receiver. Answer anObject."	^ writer nextPut: anObject! !!OSSPipe methodsFor: 'read, write, position'!nextPutAll: aCollection 	"Append the elements of aCollection to the sequence of objects accessible 	by the receiver. Answer aCollection."	^ writer nextPutAll: aCollection! !!OSSPipe methodsFor: 'initialize - release'!openReadStreamFor: aFileID withName: aReadStreamName	"Creates a read OSSAttachableFileStream for the read end of the pipe. 	If the readBlock is false, then make the stream to be non blocking. "	reader := OSSAttachableFileStream name: aReadStreamName attachTo: aFileID writable: false.	readBlocking ifFalse: [ reader setNonBlocking ].	^ reader! !!OSSPipe methodsFor: 'initialize - release'!openWriteStreamFor: aFileID withName: aWriteStreamName	"Creates a write OSSAttachableFileStream for the write end of the pipe.  "	writer := OSSAttachableFileStream name: aWriteStreamName attachTo: aFileID writable: true.	^ writer! !!OSSPipe methodsFor: 'testing'!ossIsPipe	^ true! !!OSSPipe methodsFor: 'read, write, position'!peek	^ nextChar isNil		ifTrue: [reader closed				ifFalse: [nextChar := reader next]]		ifFalse: [nextChar]! !!OSSPipe methodsFor: 'printing'!printOn: aStream	"The implementation of Stream>>printOn: has bad side effects when used	for OSPipe. This implementation is copied from Object."	| title |	title := self class name.	aStream		nextPutAll: (title first isVowel ifTrue: ['an '] ifFalse: ['a ']);		nextPutAll: title! !!OSSPipe methodsFor: 'accessing'!reader	"Answer a stream on the read end of the pipe."	^ reader! !!OSSPipe methodsFor: 'accessing'!reader: aReadStream	reader := aReadStream! !!OSSPipe methodsFor: 'accessing'!systemAccessor	^ OSSVMProcess vmProcess systemAccessor! !!OSSPipe methodsFor: 'read, write, position'!upToEnd	"Answer the remaining elements in the string."	| strm s |	strm := WriteStream on: String new.	[(s := self next: 2000) isEmpty		ifTrue: [^ strm contents]		ifFalse: [strm nextPutAll: s]] repeat! !!OSSPipe methodsFor: 'read, write, position'!upToEndOfFile	"Answer the remaining elements in the pipe. Use #atEndOfFile to	determine end of file status with feof(), required for reliable end of	file test on OS pipes. Compare #upToEnd, which uses the generic end	of file test in FilePlugin."	| stream delay string |	stream := WriteStream on: String new.	delay := Delay forMilliseconds: 200.	[(string := self next: 2000) isEmpty		ifTrue: [self atEndOfFile						ifTrue: [^ stream contents]						ifFalse: [delay wait]]		ifFalse: [stream nextPutAll: string]] repeat! !!OSSPipe methodsFor: 'accessing'!writer	"Answer a stream on the write end of the pipe."	^ writer! !!OSSPipe methodsFor: 'accessing'!writer: aWriteStream	writer := aWriteStream! !!OSSUnixProcessExitStatus class methodsFor: 'instance creation'!for: integerValue	^self new for: integerValue! !!OSSUnixProcessExitStatus methodsFor: 'accessing'!exitStatus		self isExited ifTrue: [^self statusIfExited].	self isSignaled ifTrue: [^self statusIfSignaled].	self isStopped ifTrue: [^self statusIfStopped].	self notify: 'cannot decode exit status ', intValue asString.	^intValue! !!OSSUnixProcessExitStatus methodsFor: 'initialize-release'!for: anInteger	intValue := anInteger! !!OSSUnixProcessExitStatus methodsFor: 'testing'!isExited	"	/* Nonzero if STATUS indicates normal termination.  */	#define __WIFEXITED(status)     (__WTERMSIG(status) == 0)	"	^ self statusIfSignaled = 0! !!OSSUnixProcessExitStatus methodsFor: 'testing'!isSignaled	"	/* Nonzero if STATUS indicates termination by a signal.  */	#define __WIFSIGNALED(status) \	  (((signed char) (((status) & 0x7f) + 1) >> 1) > 0)	"	^(((intValue bitAnd: 16r7F) + 1) >> 1) > 0! !!OSSUnixProcessExitStatus methodsFor: 'testing'!isStopped	"	/* Nonzero if STATUS indicates the child is stopped.  */	#define __WIFSTOPPED(status)    (((status) & 0xff) == 0x7f)	"	^(intValue bitAnd: 16rFF) = 16r7F! !!OSSUnixProcessExitStatus methodsFor: 'testing'!isSuccess	^ self exitStatus = 0! !!OSSUnixProcessExitStatus methodsFor: 'testing'!notFinished		^ intValue isNil! !!OSSUnixProcessExitStatus methodsFor: 'printing'!printOn: aStream	self notFinished		ifTrue: [^ aStream nextPutAll: 'Not finished'].	self isExited		ifTrue: [aStream nextPutAll: 'normal termination with status ';				 nextPutAll: self statusIfExited asString].	self isSignaled		ifTrue: [aStream nextPutAll: 'exit due to signal ';				nextPutAll: self statusIfSignaled asString].	self isStopped		ifTrue: [aStream nextPutAll: 'stopped due to signal ';				nextPutAll: self statusIfStopped].! !!OSSUnixProcessExitStatus methodsFor: 'accessing'!statusIfExited	"	/* If WIFEXITED(STATUS), the low-order 8 bits of the status.  */	#define __WEXITSTATUS(status)   (((status) & 0xff00) >> 8)	"	^(intValue bitAnd: 16rFF00) >> 8! !!OSSUnixProcessExitStatus methodsFor: 'accessing'!statusIfSignaled	"	/* If WIFSIGNALED(STATUS), the terminating signal.  */	#define __WTERMSIG(status)      ((status) & 0x7f)	"	^intValue bitAnd: 16r7F! !!OSSUnixProcessExitStatus methodsFor: 'accessing'!statusIfStopped	"	/* If WIFSTOPPED(STATUS), the signal that stopped the child.  */	#define __WSTOPSIG(status)      __WEXITSTATUS(status)	"	^self statusIfExited! !!OSSUnixProcessExitStatus methodsFor: 'accessing'!statusNotFinished	^ 'Not finished'! !!OSSUnixProcessExitStatus methodsFor: 'accessing'!value	^intValue! !!OSSUnixSystemAccessor class methodsFor: 'instance creation'!forVMProcess	^ VMProcessSystemAcessor ifNil: [ VMProcessSystemAcessor := self basicNew initialize ]! !!OSSUnixSystemAccessor class methodsFor: 'instance creation'!new	self error: 'You cannot create instances of OSSUnixSystemAccessor. You can only access the correct instance via OSSVMProcess >> systemAccessor '.! !!OSSUnixSystemAccessor methodsFor: 'cwd'!chdir: aDirString encoding: encoding	"Changes the current working directory of the vmProcess to aDirString"	| returnValue | 	returnValue := self primitiveChdir: aDirString encoding: encoding.	(returnValue = -1) ifTrue: [ self perror: 'chdir()' ].	(returnValue = 0) ifFalse: [ self error: 'Unexpected return value from chdir() ', returnValue printString ].	! !!OSSUnixSystemAccessor methodsFor: 'files'!closeFileDescriptor: aFileDescription	"It closes the stream associated to aFileDescriptor"	| returnValue |	returnValue := self primitiveClose: aFileDescription.	(returnValue = -1) ifTrue:  [ self perror: 'close()' ].	^ returnValue! !!OSSUnixSystemAccessor methodsFor: 'files'!feof: aCFile	"Answers whether a FILE* is at the end of the file or not. This is trustful for pipes too"	| result |	result := self primitiveFeof: aCFile.	^ result ~= 0	! !!OSSUnixSystemAccessor methodsFor: 'private - support primitives'!ffiLibraryName 	^ LibC ! !!OSSUnixSystemAccessor methodsFor: 'files'!fflush: aCFile	"Flushes the file associated to the FILE* represented by aCFile"	| returnValue |	aCFile ifNil: [ self error: 'We disallow the fflush() of nil files since it will flush all open output streams' ].	returnValue := self primitiveFflush: aCFile.	(returnValue = 0) ifFalse: [ self perror: 'fflush()' ].	! !!OSSUnixSystemAccessor methodsFor: 'NOT CURRENTLY USED'!fileDescriptorOpen: aFileDescription mode: aMode	| cFile |	cFile := self primitiveFdopen: aFileDescription mode: aMode.	cFile isNull ifTrue: [ self perror: 'fdopen()' ].	^ cFile! !!OSSUnixSystemAccessor methodsFor: 'files'!fileno: aCFile	"Answers the file descriptor associated to the FILE* represented by aCFile"	| returnValue |	returnValue := self primitiveFileno: aCFile.	(returnValue = -1) ifTrue: [ self perror: 'fileno()' ].	^ returnValue "file descriptor"! !!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS'!forwardSigChld	"Set a signal handler for SIGCHLD. Answer a new Semaphore, or nil if unable	to set the handler (possibly because it has already been set)."	^ self forwardSignal: self primSigChldNumber! !!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS'!forwardSignal: signalNumber 	"Set a signal handler in the VM which will signal a Smalltalk semaphore 	at semaphoreIndex whenever an external signal signalNumber is received.	Answer a new Semaphore, or nil if unable to set the handler (possibly	because it has already been set). A Smalltalk process can wait on the	Semaphore, and take action when a signal is detected. See man(7) signal	for signal number definitions on your unix system."		| sema index |	sema := Semaphore new.	index := Smalltalk registerExternalObject: sema.	(self primForwardSignal: signalNumber toSemaphore: index)		ifNil:			[Smalltalk unregisterExternalObject: sema.			^ nil].	^ sema! !!OSSUnixSystemAccessor methodsFor: 'general'!getPid	"Answers the PID of the vmProcess"	^ self primitiveGetpid! !!OSSUnixSystemAccessor methodsFor: 'cwd'!getcwd 	"Returns the current working directory of the vmProcess"	| buffer bytesRead |	"Ideally, we should use a smaller buffer and then if the answer is NULL 	and errno is ERANGE then try again with a larget buffer. But...since we cannot	have access to errno.... we simply create a very large buffer that we trust that	any path fill fit in it..."	buffer := ExternalAddress allocate: 4096 + 1.	[	bytesRead := self primitiveGetcwd: buffer size: 4096 + 1.	bytesRead ifNil: [ self perror: 'getcwd()'].	] ensure: [ buffer free ].	^ bytesRead		! !!OSSUnixSystemAccessor methodsFor: 'initialization'!initialize	super initialize.	finishedChildProcesses := Dictionary new! !!OSSUnixSystemAccessor methodsFor: 'signals'!kill: aPid signal: aSignal	"Sends aSignal to aPid"	| answer | 	answer := self primitiveKill: aPid signal: aSignal.	(answer = -1) ifTrue: [ 		self perror: 'kill()'.	].	(answer = 0) 		ifTrue: [ ^ answer ]		ifFalse: [ self error: 'Unkown answer for kill()' ]! !!OSSUnixSystemAccessor methodsFor: 'pipes'!makeBlockingPipe	" Create a pipes with blocking reads"	^ self makePipeWithReadBlocking: true! !!OSSUnixSystemAccessor methodsFor: 'files'!makeFileNoneBocking: aFileId	"Make this stream to be none blocking. In Linux it means 	calling fcntl() to set the file non-blocking (O_NONBLOCK)."	self primSQFileSetNonBlocking: aFileId! !!OSSUnixSystemAccessor methodsFor: 'pipes'!makeNonBlockingPipe	"Creates a pipe with non blocking read"	^ self makePipeWithReadBlocking: false! !!OSSUnixSystemAccessor methodsFor: 'pipes'!makePipeWithReadBlocking: aBoolean	"Originally, we created the pipes ourselves and the answer was an array of file descriptors.	This was complicated because we have to then create our own sqFile structure and deal	with with offsets and their sizeof(). 		So now we use OSProcess primitive primCreatePipe which directly answers an array of sqFile structs	specifially created for them. This way we avoid all the sqFile creation and management at image side. 		"" ==================== OLD CODe =======================	| pipePointer returnValue fileDescriptors |	pipePointer := ExternalAddress allocate: 8.	[		returnValue := self primitivePipe: pipePointer.			(returnValue = -1) ifTrue: [ self perror: 'pipe()' ]. 		fileDescriptors := Array new: 2.		fileDescriptors at: 1 put: (pipePointer nbUInt32AtOffset: 0).		fileDescriptors at: 2 put: (pipePointer nbUInt32AtOffset: 4).		^ OSSPipe newWith: fileDescriptors readBlocking: aBoolean. 	] ensure:[		pipePointer free.	] ==================== OLD CODe ======================="	| fileIDsArray |	fileIDsArray := self primCreatePipe.	^ OSSPipe newWith: fileIDsArray readBlocking: aBoolean. ! !!OSSUnixSystemAccessor methodsFor: 'errors'!perror: aMessage	"Prints the errno gloabl variable into the stderr together with aMessage string	and then signal an error"	self primitivePerror: aMessage.	self error: 'Error: ', aMessage,' You may want to check errors in stderr'! !!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS'!primCreatePipe	"Create a pipe, and answer an array of two file handles (SQFile data structures in interp.c)	for the pipe reader and writer."	<primitive: 'primitiveCreatePipe' module: 'UnixOSProcessPlugin'>	^ nil! !!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS'!primForwardSignal: signalNumber toSemaphore: semaphoreIndex	"Set a signal handler in the VM which will signal a Smalltalk semaphore at	semaphoreIndex whenever an external signal sigNum is received. Answer the	prior value of the signal handler. If semaphoreIndex is zero, the handler is	unregistered, and the VM returns to its default behavior for handling that	signal.	The Smalltalk semaphore is expected to be kept at the same index location	indefinitely during the lifetime of a Squeak session. If that is not the case, the	handler must be unregistered prior to unregistering the Smalltalk semaphore."	<primitive: 'primitiveForwardSignalToSemaphore' module: 'UnixOSProcessPlugin'>	^ nil! !!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS'!primSQFileSetNonBlocking: aSQFileStruct	"Pass a struct SQFile on the stack, and call fcntl() to set the file non-blocking."	<primitive: 'primitiveSQFileSetNonBlocking' module: 'UnixOSProcessPlugin'>	^ nil! !!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS'!primSemaIndexFor: sigNum	"Answer the registration index of the semaphore currently associated with the	signal handler for sigNum."	<primitive: 'primitiveSemaIndexFor' module: 'UnixOSProcessPlugin'>	^ nil! !!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS'!primSigChldNumber	"Integer value corresponding to SIGCHLD"	<primitive: 'primitiveSigChldNumber' module: 'UnixOSProcessPlugin'>	^ nil! !!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS'!primUnixFileNumber: aFileID	"Pass a struct SQFile on the stack, and answer the corresponding Unix file number."	<primitive: 'primitiveUnixFileNumber' module: 'UnixOSProcessPlugin'>	^ nil! !!OSSUnixSystemAccessor methodsFor: 'cwd - primitives'!primitiveChdir: aDirString encoding: encoding	| encodingOption |	encodingOption := #optStringEncoding , encoding.	^ self 		ffiCall: #( int chdir(String aDirString) )		options: { #optStringEncodingMandatory . encodingOption }.! !!OSSUnixSystemAccessor methodsFor: 'files - primitives'!primitiveClose: aFileDescription 		^ self ffiCall: #( int close(int aFileDescription) )	! !!OSSUnixSystemAccessor methodsFor: 'NOT CURRENTLY USED'!primitiveFdopen: aFileDescription mode: aMode		^ self ffiCall: #( OSSCFile fdopen(int aFileDescription, String aMode) )	! !!OSSUnixSystemAccessor methodsFor: 'files - primitives'!primitiveFeof: filePointer	^ self ffiCall: #( int feof( OSSCFile filePointer) )! !!OSSUnixSystemAccessor methodsFor: 'files - primitives'!primitiveFflush: file	^ self ffiCall: #( int fflush( OSSCFile file) )! !!OSSUnixSystemAccessor methodsFor: 'NOT CURRENTLY USED'!primitiveFgetsInto: bufferPointer size: size file: file 	"Not directly used for the moment but could be useful to test the reading without the	SCAttachableFileStream using a code like this:		buffer := NativeBoost allocate: 1001.	(self primitiveFgetsInto: buffer  size: 1001 file: popenFile).	self primitivePerror: 'fgets()'.	buffer byteAt: 1001 put: 0.	string := buffer readString.	buffer free.	string inspect. 		"	^ self ffiCall: #( String fgets(void* bufferPointer, int size, OSSCFile file) )! !!OSSUnixSystemAccessor methodsFor: 'files - primitives'!primitiveFileno: file	^ self ffiCall: #( int fileno( OSSCFile file) )! !!OSSUnixSystemAccessor methodsFor: 'cwd - primitives'!primitiveGetcwd: buffer size: size		^ self ffiCall: #( String getcwd(char *buffer, int size) )	! !!OSSUnixSystemAccessor methodsFor: 'NOT CURRENTLY USED'!primitiveGetdtablesize		^ self ffiCall: #( int getdtablesize(void) )! !!OSSUnixSystemAccessor methodsFor: 'NOT CURRENTLY USED'!primitiveGetenv: variableName		^ self ffiCall: #( char * getenv(char* variableName) )! !!OSSUnixSystemAccessor methodsFor: 'general'!primitiveGetpid	^ self ffiCall: #( int getpid(void) )	! !!OSSUnixSystemAccessor methodsFor: 'signals - primitives'!primitiveKill: aPid signal: aSignal	^ self ffiCall: #( int kill(int aPid, int aSignal) )	! !!OSSUnixSystemAccessor methodsFor: 'errors - primitives'!primitivePerror: anErrorString	^ self ffiCall: #( void perror(String anErrorString) )! !!OSSUnixSystemAccessor methodsFor: 'NOT CURRENTLY USED'!primitivePipe: pipePointer		^ self ffiCall: #( int pipe(void* pipePointer) )! !!OSSUnixSystemAccessor methodsFor: 'errors - primitives'!primitiveStrerror: errorNumber		^ self ffiCall: #( String strerror( int errorNumber) )! !!OSSUnixSystemAccessor methodsFor: 'NOT CURRENTLY USED'!primitiveSysconf: aNumber		^ self ffiCall: #( long sysconf(int aNumber) )! !!OSSUnixSystemAccessor methodsFor: 'system - primitives'!primitiveSystem: commandString	 ^ self ffiCall: #(int system(char* commandString) ) 		! !!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS'!restoreSigChld	"Unset a SIGCHLD signal handler and unregister the Smalltalk semaphore.	Answer the unregistered Semaphore, or nil if unable to restore the signal	(possibly because no handler had been set)."	^ self restoreSignal: self primSigChldNumber! !!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS'!restoreSignal: signalNumber 	"Unset a signal handler and unregister the Smalltalk semaphore. Answer	the unregistered Semaphore, or nil if unable to restore the signal (possibly	because no handler had been set)."	| semaphoreIndex sema |	semaphoreIndex := self primSemaIndexFor: signalNumber.	semaphoreIndex ifNotNil:		[sema := Smalltalk externalObjects at: semaphoreIndex ifAbsent: [].		sema ifNotNil:			[self primForwardSignal: signalNumber toSemaphore: nil.			Smalltalk unregisterExternalObject: sema]].	^ sema! !!OSSUnixSystemAccessor methodsFor: 'sizeof'!sizeOfInt		^ FFIExternalType sizeOf: #long! !!OSSUnixSystemAccessor methodsFor: 'sizeof'!sizeOfPointer		^ FFIExternalType pointerSize	! !!OSSUnixSystemAccessor methodsFor: 'errors'!strerror: aReturnValue message: aMessage	"Get the string description of the error numnber aReturnValue and signal 	and error with such a description together with aMessage string"	| internalError | 	internalError := self primitiveStrerror: aReturnValue.	self error: 'Error: ', aMessage, ', code: ', aReturnValue asString, ', description: ', internalError! !!OSSUnixSystemAccessor methodsFor: 'system'!system: aCommandString	"Executes aCommandString in the OS via the system() call. Only used for testing."	| returnValue |	returnValue := self primitiveSystem: aCommandString.	(returnValue = -1) ifTrue: [ 		self perror: 'system()'		].	^ returnValue ! !!OSSVMProcess class methodsFor: 'initialize - release'!initialize	Smalltalk os isWindows ifTrue: [ ^ self ]. "Cannot be initialized nor used on Windows."		self initializeVMProcessInstance. 	self flag: #removeIt.	"This IF will be eliminated soon...only here temporary"	(SystemVersion current highestUpdate >= 50558)		ifTrue: [ 			SessionManager default registerToolClassNamed: self name			 ]		ifFalse: [ 			Smalltalk addToStartUpList: OSSVMProcess.			Smalltalk addToShutDownList: OSSVMProcess. 		]	! !!OSSVMProcess class methodsFor: 'initialize - release'!initializeVMProcessInstance	VMProcess isNil 		ifTrue: [ VMProcess := self basicNew. ]		ifFalse: [ VMProcess finalizePreviousSession ].	VMProcess initialize.! !!OSSVMProcess class methodsFor: 'instance creation'!new	self error: 'Only one instance of OSSVMProcess or any of its subclasses should exist in the image. Use #vmProcess to obtain the singleton instance.'.! !!OSSVMProcess class methodsFor: 'system startup'!shutDown: quitting	self vmProcess shutDown: quitting! !!OSSVMProcess class methodsFor: 'system startup'!startUp: resuming		resuming ifTrue: [ 		"To understand why the #stopWaiting, first read the comment of 		OSSVMProcess shutDown:		It could happen that when the shutDown happened, the child process		was in the wait of #waitForExitPollingEvery:doing:. Therefore, until the		next cycle of the loop it won't do the queryExitStatus. So we may still 		have this problem in image startup. So just in case we run it too in the startup code.		 "		self vmProcess activeChildren do: [ :each | each stopWaiting ].		self initializeVMProcessInstance.		]! !!OSSVMProcess class methodsFor: 'OS Process'!tryToDisableOSProcessSigchldHandler		self flag: #fixIt. "hack!!!!!!!!"	Smalltalk at: #OSProcess ifPresent: [ 		(Smalltalk at: #OSProcess) thisOSProcess processAccessor restoreSigChld. 		(Smalltalk at: #OSProcess) thisOSProcess processAccessor grimReaperProcess terminate.		(Smalltalk at: #ThisOSProcess) shutDown: true.		Smalltalk removeFromShutDownList: (Smalltalk at: #ThisOSProcess).		Smalltalk removeFromStartUpList: (Smalltalk at: #ThisOSProcess).	].! !!OSSVMProcess class methodsFor: 'accessing'!vmProcess	"Answer a single instance representing the OS process in 	which this Smalltalk VM and image is executing."	^ VMProcess! !!OSSVMProcess methodsFor: 'childs management'!activeChildren	"Answer child processes which are currently believed to be running."	^ accessProtect critical: [ childProcessList select: [ :process | process isRunning ] ].! !!OSSVMProcess methodsFor: 'childs management'!allMyChildren	^ childProcessList! !!OSSVMProcess methodsFor: 'child watching'!checkFinishedChildren	"Does a waitpid() with the flag WNOHANG which makes the system call to answer immediatly rather than waiting until child has exited. 	Answers nil if child has not yet exited or the exit status if it has.		http://man7.org/linux/man-pages/man2/waitpid.2.html	waitpid man's page is ambiguous with respect of the usage of the WNOHANG option.	It looks like waitpid ignores the first argument if WNOHANG is specified, and returns with ANY child process id.	This means that, in combination with the previous issue, it may happen that calling waitpid for process X will unregister process Y, what will make fail a subsequent call to waitpid from Y.	"	| waitedChildren childrenSize |	"Skip checking if we have no children"	waitedChildren := 0.	childrenSize := self activeChildren size.	[ waitedChildren < childrenSize ]		whileTrue: [ | statusPointer |			[ | status returnValue |			statusPointer := ExternalAddress allocate: systemAccessor sizeOfInt.			returnValue := self primitiveWaitpid: -1 statusPointer: statusPointer options: WNOHANG.			"If return value is 0 then there are no more changes, we can exit"			returnValue = 0				ifTrue: [ ^ self ].			"Only throw error in case it is an error other than no childs (represented as return -1 and errno=ECHILD)"			returnValue = -1				ifTrue: [ systemAccessor perror: 'waitpid()' ].			waitedChildren := waitedChildren + 1.			status := statusPointer platformLongAt: 1.			self updateChildProcessWithId: returnValue withStatus: status ]				ensure: [ statusPointer free ] ]! !!OSSVMProcess methodsFor: 'childs management'!childPids	^ childProcessList collect: [ :process | process pid ]! !!OSSVMProcess methodsFor: 'accessing'!earlyFinishedProcesses		^ earlyFinishedProcesses ifNil: [ earlyFinishedProcesses := Dictionary new ]! !!OSSVMProcess methodsFor: 'childs management'!exitedChildren	"Answer child processes which have exited and are no longer running."	^ accessProtect critical: [ childProcessList select: [ :process | process isComplete ]].! !!OSSVMProcess methodsFor: 'library path'!ffiLibraryName 	^ LibC! !!OSSVMProcess methodsFor: 'updating'!finalizePreviousSession	"This method is likely called at image startup and it's job is to finalize	stuff related to the previous run and let everything clean so that 	the unique instance vmProcess of OSSVMProcess can be initialized correctly at startup. "	childWatcher ifNotNil: [ 		childWatcher isTerminated ifFalse: [ childWatcher terminate ].		childWatcher := nil.	].	sigChldSemaphore ifNotNil: [		self systemAccessor restoreSigChld.		sigChldSemaphore := nil	]! !!OSSVMProcess methodsFor: 'initialize - release'!initialize	"Set my instance variables to reflect the state of the OS process in which 	this Smalltalk virtual machine is. executing."	Smalltalk os isWindows ifTrue: [ ^ self ]. "Cannot be initialized nor used on Windows."	accessProtect := Semaphore forMutualExclusion.	mutexForCwd := Semaphore forMutualExclusion.	self initializeAllMyChildren.	systemAccessor := OSSUnixSystemAccessor forVMProcess. 	pid := systemAccessor getPid.	childListTreshold := 20. "Once child list gets bigger than this number, we delete all exited processes"	self initializeSessionID.	self initializeSignalHandlers.	self initializeChildWatcher.! !!OSSVMProcess methodsFor: 'initialize - release'!initializeAllMyChildren	"Use a Dictionary if process identifiers are unique. On Windows, the	process ID is not unique, so use an OrderedCollection instead."	^ childProcessList := OrderedCollection new! !!OSSVMProcess methodsFor: 'child watching'!initializeChildWatcher	"This is a process which waits for the death of a child processes. Use SIGCHLD events rather than a Delay to poll."	| processSynchronizationDelay |	processSynchronizationDelay := Delay forMilliseconds: 30.	childWatcher	 ifNil: [		childWatcher := [[				"OSProcess authors suspected that there were various ways in which OS signals				could be missed under conditions of heavy load. For that reason, we use				#waitTimeoutMSecs: with the semaphore, so that if a signal is missed,				we time out and rescan occasionally anyway (#updateActiveChildrenAndNotifyDead				sends queryExitStatus which sends waitpid() )				"				self sigChldSemaphore waitTimeoutMSecs: 1000.				processSynchronizationDelay wait. "Avoids lost signals in heavy process switching"				self checkFinishedChildren.				] repeat] newProcess priority: Processor highIOPriority.		childWatcher resume.		"name selected to look reasonable in the process browser"		childWatcher name: ((ReadStream on: childWatcher hash asString) next: 5)				, ': the OSSubprocess child watcher'	]! !!OSSVMProcess methodsFor: 'initialize - release'!initializeSessionID	| oldFile | 	self flag: #fixMe. 	"grrr I need the sessionID (first int of the SQFile). .. there is no primitive to get it. Since it is the same for all files	lets try to grab it from a file we know there will be always there: the image file."	oldFile := OldStandardFileStream oldFileNamed: Smalltalk image imagePath.	sessionID := oldFile basicFileID copy first: (self systemAccessor sizeOfInt).	oldFile close.! !!OSSVMProcess methodsFor: 'initialize - release'!initializeSignalHandlers	"#sigChldSemaphore will lazily create and register the semaphore if needed"	self sigChldSemaphore.	! !!OSSVMProcess methodsFor: 'cwd'!lockCwdWithValue: cwdNewValue encoding: encoding during: aBlock	"This method is a complete hack in order to support a #cmd: option in OSSUnixSubprocess. 	OSSUnixSubprocess relies in posix_spawn() family of functions to spwan processes in the OS,	and these functions do not allow specifying a starting working directory for the child process. 	However, this is sometimes needed by subprocess.	Therefore, we propose this hack. Basically, we change the current directory of the parent process (vmProcess) 	BEFORE launching the subprocess. When the child is launched, it inherits the working directory of the parent.	As soon as the child was launched, we rollback and put back the original working directory in the parent. 	Because if this, it's very much likely that aBlock represents the launching of a child process.	mutexForCwd is needed because we may have multiple children at the same time trying to change working	directory (not thread safe..). So with mutexForCwd we sincronize this. 		Forking with userInterruptPriority is useful just in case there could be other Smalltalk process 	using another code, trying to ALSO change the working directory (very very unlikely). So at least with 	userInterruptPriority we make sure that we a higher priority than the rest of the normal user code	and so we minimize that problem.		"	| completed |	cwdNewValue asFileReference exists ifFalse: [ ^ self error: 'The directory: ', cwdNewValue, ' does not exist' ]. 	completed :=  Semaphore new. 	[ 		| oldCwd |		oldCwd := self systemAccessor getcwd.		[			self systemAccessor chdir: cwdNewValue encoding: encoding.			mutexForCwd critical: aBlock.		]		ensure: [ 			self systemAccessor chdir: oldCwd encoding: encoding.			completed signal.			]	] forkAt: Processor userInterruptPriority.	completed wait.	! !!OSSVMProcess methodsFor: 'accessing'!pid	^ pid! !!OSSVMProcess methodsFor: 'child watching'!primitiveWaitpid: aProcessId statusPointer: statusPointer options: optionBits		^ self ffiCall: #( int waitpid(int aProcessId, void* statusPointer, int optionBits) )! !!OSSVMProcess methodsFor: 'childs management'!pruneExitedChildrenAfter: size	"Limit the size of the child process registry. Select the last entries, and unregister	them if they are no longer active."	(accessProtect critical: [childProcessList allButFirst: size])		do: [ :aProcess |			aProcess isComplete ifTrue: [ self unregisterChildProcess: aProcess ]]! !!OSSVMProcess methodsFor: 'childs management'!registerChildProcess: anOSProcess	"Unregister anOSProcess, and trim the child process registry to prevent excessive	accumulation of exited children.		If the process finished before this registration, set it the exit status.	Otherwise, register it"	accessProtect critical: [ 		self earlyFinishedProcesses			at: anOSProcess pid			ifPresent: [ :exitStatus |				anOSProcess setExitStatus: exitStatus.				self earlyFinishedProcesses removeKey: anOSProcess pid ]			ifAbsent: [ childProcessList addFirst: anOSProcess ] ].	self pruneExitedChildrenAfter: childListTreshold.	^ anOSProcess	! !!OSSVMProcess methodsFor: 'accessing'!sessionID	"The sessionID is something internal to the VM and it's used	as part of the fileID structure (sqFile) of StandardFileStream. 	We use it for some file operations"	^ sessionID! !!OSSVMProcess methodsFor: 'system startup & shutdown'!shutDown: quitting	"If we have a process that do not stop automatically (like a tail -f) and it runs	with #fork  (at Smalltalk level)	then that process will be continue running 	after the image has stopped and started again. 	If this process continues running, it may be waiting via a delay polling	and that will throw an error since waitpid() will fail since the parent process 	(the VM process) is NOT the parent anymore of the child process.	And so.if the process fails, it makes the system startup to fail and we cannot	open the image anymore. See https://github.com/marianopeck/OSSubprocess/issues/12	So... to solve this we simply make all active childs to stop waiting so that the 	next startup of the image has no problem. 		"	quitting ifTrue: [ self activeChildren do: [ :each | each shutDown: quitting ] ].! !!OSSVMProcess methodsFor: 'child watching'!sigChldSemaphore	"Answer the value of sigChldSemaphore.	If nil, then register and create a semaphore to be signaled upon SIGCHLD.	See #forwardSigChld for more details. "	^ sigChldSemaphore ifNil: [sigChldSemaphore := self systemAccessor forwardSigChld].! !!OSSVMProcess methodsFor: 'accessing'!systemAccessor	^ systemAccessor ! !!OSSVMProcess methodsFor: 'childs management'!unregisterChildProcess: anOSProcess	"Unregister anOSProcess from the list of children"	accessProtect critical: [childProcessList remove: anOSProcess ifAbsent: [] ].	^ anOSProcess! !!OSSVMProcess methodsFor: 'child watching'!updateChildProcessWithId: aChildPid withStatus: status		| childProcess |	childProcess := self activeChildren		detect: [ :child | child pid = aChildPid ]		ifNone: [ ^ self earlyFinishedProcesses at: aChildPid put: status ].	childProcess setExitStatus: status.	childProcess processHasExitNotification.! !!OSSUnixSubprocess class methodsFor: 'temp files'!createTempFileToBeUsedAsReadStreamOn: aDirectoryPath	"Important: for some reason, if we use MultiByteFileStream instances, we have some test failures.	So for the moment, until we fix or understand this, always use StandardFileStream instances.		This is a simple facility method if the user wants to use regular files rather than pipes.	In the customization of defaultReadStreamCreationBlock: or defaultWriteStreamCreationBlock: 	the user may want to use this method to automatically create a temp file on a aDirectoryPath.	If you want another way of building temp files, then simply do not use this method and	set the closure you want in defaultReadStreamCreationBlock: or defaultWriteStreamCreationBlock: 		"		^ OldStandardFileStream forceNewFileNamed: (aDirectoryPath asFileReference / self createTempFilename) fullName! !!OSSUnixSubprocess class methodsFor: 'temp files'!createTempFileToBeUsedAsWriteStreamOn: aDirectoryPath	"See comment of #createTempFileToBeUsedAsReadStreamOn:."	^  OldStandardFileStream forceNewFileNamed: (aDirectoryPath asFileReference / self createTempFilename) fullName! !!OSSUnixSubprocess class methodsFor: 'temp files'!createTempFilename	"Read comment of createTempFileToBeUsedAsReadStreamOn:.		This answers just ONE WAY of defining a temp filename"		^ self name , '-p', OSSVMProcess vmProcess pid asString, '-', UUID new printString, '.deleteme'	! !!OSSUnixSubprocess methodsFor: 'env building'!addAllEnvVariablesFromParentWithoutOverride	"The user may have done an explicit set of a variable via #environmentAt:put: in which case	we do not want to override it with the inherit one.	This method allows to set all but overriden variables inherit from parent. "	self defaultEnvVariablesDictionary keysAndValuesDo: [ :key :value |		envVariables at: key ifAbsentPut: value.	]	! !!OSSUnixSubprocess methodsFor: 'close and dup2'!allocatePosixSpawnFilesActionStructure	"IMPORTANT:  It seems posix_spawn_file_actions_init() sometimes allocates AND initializes, and sometimes only initializes.	For OSX I found it it also allocates memory, so only allocating for the pointer is enough.	For Linux it seems we need to allocate the full structure of posix_spawn_file_actions_t.	Wathing at the implementation of GNU libc (glibc) here: http://osxr.org:8080/glibc/source/posix/spawn.h?v=glibc-2.17 	I found this struct definition:		typedef struct	 {	   int __allocated;	   int __used;	   struct __spawn_action *__actions;	   int __pad[16];	 } posix_spawn_file_actions_t;		We need a better solution to solve this kind of sizeof(). For the moment, see below how I estimate the size of this struct.  	For more details see thread 'Help with FFI crash in latest Spur (only in Linux)'	"	OSPlatform current isMacOSX ifTrue: [ posixSpawnFileActionsT := ExternalAddress allocate: self systemAccessor sizeOfPointer. ].	OSPlatform current isUnix ifTrue: [ posixSpawnFileActionsT := ExternalAddress allocate: (self systemAccessor sizeOfPointer + (self systemAccessor sizeOfInt * 2) + (16 * self systemAccessor sizeOfInt)). ].! !!OSSUnixSubprocess methodsFor: 'argv building'!argVArguments	"Answers the whole list of argV including the command as the first argument and a	null terminated."	^ OrderedCollection new		add: command;		addAll: (arguments ifNil: [#()]);		add: 0; "shell arguments are '\0' terminated"		yourself! !!OSSUnixSubprocess methodsFor: 'settings'!arguments: anObject	arguments := anObject collect: [ :each | (each encodeWith: encoding) asString ]! !!OSSUnixSubprocess methodsFor: 'argv building'!buildPrimitiveArgVArgument	"Takes care of allocating and building the array of arguments as expected	by the posix_spawn() function. 	Answers the array ready to be used."	| bufferPointer |	bufferPointer := ExternalAddress allocate: self argVArguments size * self systemAccessor sizeOfPointer.	self registerPointer: bufferPointer.	self collectArgumentPointersInto: bufferPointer.	 ^ bufferPointer! !!OSSUnixSubprocess methodsFor: 'env building'!buildPrimitiveEnvArgument	"Builds the whole env argument as expected by posix_spawn(), taking into account the variables	defined by the API #environmentAt:put:"	| envPointer |	"By default, if none variable was set, we add all the ones existing in parent"	envVariables isEmpty ifTrue: [ self addAllEnvVariablesFromParentWithoutOverride ].	"The +1 is because we will have a NULL at the end"	envPointer := ExternalAddress allocate: (envVariables keys size + 1) * self systemAccessor sizeOfPointer.	self registerPointer: envPointer.	self collectEnvVariablesPointersInto: envPointer.	^ envPointer! !!OSSUnixSubprocess methodsFor: 'cleaning'!cleanAndFixCopiedStreams	"If the stream is a pipe, we must close the end that we do not use at VM level (parent).	If we are using regular files, we must reopen them otherwise we won't be able to read what the	child has written "	stdinStream ifNotNil: [ stdinStream ossIsPipe ifTrue: [ stdinStream closeReader ] ifFalse: [ stdinStream reopen. ] ].	stdoutStream ifNotNil: [ stdoutStream ossIsPipe ifTrue: [ stdoutStream closeWriter ] ifFalse: [ stdoutStream reopen. ] ].	stderrStream ifNotNil: [ stderrStream ossIsPipe ifTrue: [ stderrStream closeWriter ] ifFalse: [ stderrStream reopen. ] ].	 ! !!OSSUnixSubprocess methodsFor: 'cleaning'!cleanResources	"Clear all resources. This step is mandatory and happens immeditaly after the process has 	started. And this must be called even if there is an error, since we must free pointers,	close streams, etc etc. "	self destroyPosixSpawnFileActionsT.	self cleanAndFixCopiedStreams.	self freePointers.! !!OSSUnixSubprocess methodsFor: 'close and dup2'!closeAllButStandardFileStreams	"Here I should loop and close all but fd 0 1 2"	"do a loop with #posixSpawnFileActionsAddClose:"		self flag: #toDo! !!OSSUnixSubprocess methodsFor: 'cleaning'!closeAndCleanStreams	"This method closes all the streams that have been opened and mapped to standard steams.	They could be either pipes or regular temp files. In the case of files, we also remove those temp files"	self closeStreams.	self deleteTempFilesFromStandardStreams.! !!OSSUnixSubprocess methodsFor: 'close and dup2'!closeAndDup2FilesActions	"First, it initializes the structure for managing the file actions allowed by posix_spwan(). 	Then defines and sets all actions we want. That is, closing or opening file descriptors,	or doing a dup2() "	self initPosixSpawnFileActionsT.	self closeAllButStandardFileStreams.	self defineActionsForStandardFileStreams.	! !!OSSUnixSubprocess methodsFor: 'streams'!closeStderrStream	" Close stderrStream if needed"	stderrStream ifNotNil: [ stderrStream close ]! !!OSSUnixSubprocess methodsFor: 'streams'!closeStdinStream	" Close stdinStream if needed"	stdinStream ifNotNil: [ stdinStream close ]! !!OSSUnixSubprocess methodsFor: 'streams'!closeStdoutStream	" Close stdoutStream if needed"	stdoutStream ifNotNil: [ stdoutStream close ]! !!OSSUnixSubprocess methodsFor: 'cleaning'!closeStreams	"Closes all the streams that have been opened and mapped to standard steams."	self closeStdinStream.	self closeStdoutStream.	self closeStderrStream.	! !!OSSUnixSubprocess methodsFor: 'argv building'!collectArgumentPointersInto: aPointer	"Allocates each string argument with a null terminated char and add them into aPointer"		"#allButLast is because the last is 0."	self argVArguments allButLast withIndexDo: [ :string :index |		| pointer | "0 terminated"		pointer := ExternalAddress allocate: string size + 1.		self registerPointer: pointer.		LibC memCopy: string to: pointer size: string size.		pointer nbUInt8AtOffset: string size put: 0. "string terminating null char"		aPointer platformUnsignedLongAt: ((index - 1) * self systemAccessor sizeOfPointer) + 1 put: pointer value ].	aPointer platformUnsignedLongAt: ((self argVArguments size - 1) * self systemAccessor sizeOfPointer) + 1 put: 0.! !!OSSUnixSubprocess methodsFor: 'env building'!collectEnvVariablesPointersInto: aPointer	"Creates the pair of KEY=VALUE string, allocating the memory and adding a null terminated char to each of the env.	Each processed pair of KEY=VALUE is added to aPointer. "	envVariables keys withIndexDo: [ :aKey :index |		| string pointer | 		string := aKey trimmed , '=', (envVariables at: aKey) trimmed. 		"The +1 is because string must be NULL terminated"		pointer := ExternalAddress allocate: string size + 1.		self registerPointer: pointer.		LibC memCopy: string to: pointer size: string size.		pointer nbUInt8AtOffset: string size put: 0. "string terminating null char"		aPointer platformUnsignedLongAt: ((index - 1) * self systemAccessor sizeOfPointer) + 1 put: pointer value	].	"The array of pointers also needs to finish with a NULL"	aPointer platformUnsignedLongAt: (envVariables keys size * self systemAccessor sizeOfPointer) + 1 put: 0! !!OSSUnixSubprocess methodsFor: 'settings'!command: aString	command := (aString encodeWith: encoding) asString! !!OSSUnixSubprocess methodsFor: 'streams'!createADefaultReadStream	"Creates a default read stream, most likely for stdin"	^ defaultReadStreamCreationBlock value! !!OSSUnixSubprocess methodsFor: 'streams'!createADefaultWriteStream	"Creates a default write stream, most likely for stdout or stderr"	^ defaultWriteStreamCreationBlock value! !!OSSUnixSubprocess methodsFor: 'settings'!createMissingStandardStreams: aBoolean	"If we don't create streams for the standard streams of the child process,	then the child will be used the inherit standard files from the parent. 		If aBoolean is true, then we will automatically create streams for mapping stdout/stderr/stdin.	Note that we will create streams ONLY for those standard streams that had not already been set by	another parts of the API (like #redirectStdoutTo:, or #createAndSetStdeoutStream, etc.).	In addition, the type of streams that we will automatically create is defined by defaultReadStreamCreationBlock	and defaultWriteStreamCreationBlock. So you can customize that to define the type of stream automatically created. 		"	createMissingStandardStreams := aBoolean	! !!OSSUnixSubprocess methodsFor: 'accessing'!defaultEncoding 	^ OSEnvironment current defaultEncoding ! !!OSSUnixSubprocess methodsFor: 'env building'!defaultEnvVariablesDictionary	"Get all the env vars inherit from the vmProcess as a dictionary"	^ Smalltalk os environment asDictionary! !!OSSUnixSubprocess methodsFor: 'settings'!defaultReadStreamCreationBlock: aClosure	"Read the comment of #createMissingStandardStreams:"	defaultReadStreamCreationBlock := aClosure! !!OSSUnixSubprocess methodsFor: 'settings'!defaultWriteStreamCreationBlock: aClosure	"Read the comment of createMissingStandardStreams:"	defaultWriteStreamCreationBlock := aClosure! !!OSSUnixSubprocess methodsFor: 'close and dup2'!defineActionsForReadStream: aReadStream dupTo: aFileDescriptor	"Sets all needed actions (close() and dup2()) for a aReadStream (stdin) FOR THE CHILD.	"	aReadStream ifNotNil: [ 		aReadStream ossIsPipe 			ifTrue: [  				"For pipes, in the child, we close write end (the child will read), 				then dup2 the reader to stdin, and then close the reader too. "				self posixSpawnFileActionsAddClose: (self systemAccessor primUnixFileNumber: aReadStream writer basicFileID).				self posixSpawnFileActionsAddDup2: (self systemAccessor primUnixFileNumber: aReadStream reader basicFileID) newFileDescritpion: aFileDescriptor.				self posixSpawnFileActionsAddClose: (self systemAccessor primUnixFileNumber: aReadStream reader basicFileID).				] 			ifFalse: [ 				| fileDesc |				fileDesc := self getFdFromStream: aReadStream. 				"For regular files, in the child, we dup2 the reader to stdin, and then close the reader too. "				self posixSpawnFileActionsAddDup2: fileDesc newFileDescritpion: aFileDescriptor.				self posixSpawnFileActionsAddClose: fileDesc.						]	]! !!OSSUnixSubprocess methodsFor: 'close and dup2'!defineActionsForStandardFileStreams	"Define close() and dup2() actions for standard file streams for the child process"	self defineActionsForStdin.	self defineActionsForStdout.	self defineActionsForStderr.		! !!OSSUnixSubprocess methodsFor: 'close and dup2'!defineActionsForStderr	"If needed, automatically create a stream (regular files or pipes) to be used for stderr, and then perform the needed close() and dup2()	for the mapping in the child"	self shouldCreateStreamFor: stderrStream ifTrue: [ self redirectStderr ].	self defineActionsForWriteStream: stderrStream dupTo: 2! !!OSSUnixSubprocess methodsFor: 'close and dup2'!defineActionsForStdin	"If needed, automatically create a stream (regular files or pipes) to be used for stdin, and then perform the needed close() and dup2()	for the mapping in the child"	self shouldCreateStreamFor: stdinStream ifTrue: [ self redirectStdin ].	self defineActionsForReadStream: stdinStream dupTo: 0! !!OSSUnixSubprocess methodsFor: 'close and dup2'!defineActionsForStdout	"If needed, automatically create a stream (regular files or pipes) to be used for stdout, and then perform the needed close() and dup2()	for the mapping in the child"	self shouldCreateStreamFor: stdoutStream ifTrue: [ self redirectStdout ].	self defineActionsForWriteStream: stdoutStream dupTo: 1! !!OSSUnixSubprocess methodsFor: 'close and dup2'!defineActionsForWriteStream: aWriteStream dupTo: aFileDescriptor	"Sets all needed actions (close() and dup2()) for a aWriteStream (stdout or stderr) FOR THE CHILD	"	aWriteStream ifNotNil: [ 		aWriteStream ossIsPipe 			ifTrue: [  				"For pipes, in the child, we close read end (the child will write), 				then dup2 the writer to stderr or stdout, and then close the writer too. "				self posixSpawnFileActionsAddClose: (self systemAccessor primUnixFileNumber: aWriteStream reader basicFileID).				self posixSpawnFileActionsAddDup2: (self systemAccessor primUnixFileNumber: aWriteStream writer basicFileID) newFileDescritpion: aFileDescriptor.				self posixSpawnFileActionsAddClose: (self systemAccessor primUnixFileNumber: aWriteStream writer basicFileID).				] 			ifFalse: [ 				| fileDesc |				fileDesc := self getFdFromStream: aWriteStream. 				"For regular files, in the child, we dup2 the writer to stdout or stderr, and then close the writer too. "				self posixSpawnFileActionsAddDup2: fileDesc newFileDescritpion: aFileDescriptor.				self posixSpawnFileActionsAddClose: fileDesc.						]	]! !!OSSUnixSubprocess methodsFor: 'cleaning'!deleteTempFileOf: aStream	"Deletes the temp file associated to aStream"	aStream ifNotNil: [ 		aStream ossIsPipe ifFalse: [ aStream fullName asFileReference ensureDelete ] 	]	! !!OSSUnixSubprocess methodsFor: 'cleaning'!deleteTempFilesFromStandardStreams	"Delete all temp files that were associated to standard streams."	self deleteTempFileOf: stdinStream.	self deleteTempFileOf: stdoutStream.	self deleteTempFileOf: stderrStream.		! !!OSSUnixSubprocess methodsFor: 'close and dup2'!destroyPosixSpawnFileActionsT	"This is part of the needed API of posix_spawn() family of functions and dismply destroys	the struct initialized by #initPosixSpawnFileActionsT"	posixSpawnFileActionsT ifNotNil: [ 		| returnValue |		returnValue := self primitivePosixSpawnFileActionsDestroy: posixSpawnFileActionsT. 		returnValue = 0 ifFalse: [ self systemAccessor strerror: returnValue message: 'posix_spawn_file_actions_distroy()'. ].		].! !!OSSUnixSubprocess methodsFor: 'settings'!encoding: anEncoder	"Specify the encoder to use to encode/decode Strings given to/retrieved from the process.	Default encoding for Unix-like systems is UTF-8".	" self encoding: #utf8 "	encoding := anEncoder! !!OSSUnixSubprocess methodsFor: 'env building'!envVariables	^ envVariables! !!OSSUnixSubprocess methodsFor: 'env building'!environmentAt: aVariableName put: aValue	"This is the expected API to allow users to define custom variables and values."	(aVariableName isString and: [ aValue isString ])		ifFalse: [ self error: 'Variable names and values must be strings' ].	envVariables at: aVariableName put: aValue! !!OSSUnixSubprocess methodsFor: 'status'!exitStatus	"Answers the bit field integer representing the exit status exactly as returned from #queryExitStatus (waitpid()). "	^ exitStatus! !!OSSUnixSubprocess methodsFor: 'status'!exitStatusInterpreter	"#exitStatus answers the bit field integer representing the exit status exactly as returned from #queryExitStatus (waitpid()).	However, sometimes you want to decode the internal meaning of the integer to get more information about the status. 	For those purposes, you can use this method and then query the result. 	For more details, read class comment of OSSUnixProcessExitStatus "	^ OSSUnixProcessExitStatus for: exitStatus! !!OSSUnixSubprocess methodsFor: 'private - support primitives'!ffiLibraryName 	^ LibC! !!OSSUnixSubprocess methodsFor: 'pointers management'!freePointers	"Frees all registered pointers. This must be called just after process is launched whether it	was successful or not to avoid memory leaks... Also, all users of FFI #allocate: kind of method	should either explicitly send #free (inside a ensure:) or register the allocated pointer so that 	it can be free here."	self pointers do: [ :pointer | pointer free ].	pointers := nil! !!OSSUnixSubprocess methodsFor: 'close and dup2'!getFdFromStream: aStream	^ self systemAccessor fileno: aStream getFilePointerAsCFile! !!OSSUnixSubprocess methodsFor: 'close and dup2'!initPosixSpawnFileActionsT	"This is part of the needed API of posix_spawn() family of functions and initializes	the struct posix_spawn_file_actions_t"	| returnValue |	self allocatePosixSpawnFilesActionStructure.	self registerPointer: posixSpawnFileActionsT.	returnValue := self primitivePosixSpawnFileActionsInit: posixSpawnFileActionsT. 	returnValue = 0 ifFalse: [ self systemAccessor strerror: returnValue message: 'posix_spawn_file_actions_init()' ].! !!OSSUnixSubprocess methodsFor: 'initialize - release'!initialize	super initialize.	envVariables := Dictionary new. 	createMissingStandardStreams := false.	"By default, we create a none blocking pipe for writers (stdout and stderr). For reader, we prefer blocking pipes (stdin), otherwise the child will exit quickly. We also allow regular StandardFileStreams instances."	defaultReadStreamCreationBlock := [self systemAccessor makeBlockingPipe].	defaultWriteStreamCreationBlock := [self systemAccessor makeNonBlockingPipe].	retrievedStdout := String new writeStream. 	retrievedStderr := String new writeStream. 	terminateOnShutdown := false.	waitPidCriticalSemaphore := Semaphore forMutualExclusion.	encoding := self defaultEncoding.! !!OSSUnixSubprocess methodsFor: 'running'!internalRun	"This is the real method that spwans the subprocess in the OS via the posix_spawn() function. 	It first must deal with all the file acctions for close() and dup() in the child.	Then spawns the process and sets the pid. 	Finally, it registers the process in the OSSVMProcess vmProcess (so that the childWatcher considers this child).	After this method is sent, we have to be sure to free resources (via #cleanResources)	"		| pidtPointer returnValue   |	pidtPointer := ExternalAddress allocate: self systemAccessor sizeOfPointer.	self registerPointer: pidtPointer.	self closeAndDup2FilesActions.	workingDirectory 		ifNil: [ returnValue := self primitivePosixSpawn: pidtPointer command: command fileActions: posixSpawnFileActionsT attributes: nil argPointer: self buildPrimitiveArgVArgument envPointer: self buildPrimitiveEnvArgument. ] 		ifNotNil: [ 			"This is a hack in order to support a #workingDirectory: kind of feature. 			Please read the comment of lockCwdWithValue:during: "			OSSVMProcess vmProcess				lockCwdWithValue: workingDirectory				encoding: encoding identifier				during: [ returnValue := self primitivePosixSpawn: pidtPointer command: command fileActions: posixSpawnFileActionsT attributes: nil argPointer: self buildPrimitiveArgVArgument envPointer: self buildPrimitiveEnvArgument. ]		].	(returnValue > 0) 		ifTrue: [ self systemAccessor strerror: returnValue message: 'posix_spawn()'. ].			"Pid is of type pid_t, which is mostly 32bits even in 64bit platforms"	pid := pidtPointer unsignedLongAt: 1.	OSSVMProcess vmProcess registerChildProcess: self.	! !!OSSUnixSubprocess methodsFor: 'status'!isComplete	"Answers whether the process has been completed or not (to our best knowledge)"	^ exitStatus notNil! !!OSSUnixSubprocess methodsFor: 'status'!isRunning	"Answers whether the process is still running or not (to our best knowledge)"	^ pid notNil and: [ self isComplete not ]! !!OSSUnixSubprocess methodsFor: 'status'!isSuccess	"Answers whether the process has been completed successfuly (to our best knowledge)"	^ self isComplete and: [ self exitStatusInterpreter exitStatus = 0 ]! !!OSSUnixSubprocess methodsFor: 'terminating'!kill	^ self sigkill! !!OSSUnixSubprocess methodsFor: 'shell'!loginShellCommand: aShellCommandString	"This is a simple facility method for the cases when the user wants to use a login shell as the program.	See comments of shellCommand: for more information."	self shellCommand: aShellCommandString.	arguments := Array with: '-l' withAll: arguments.! !!OSSUnixSubprocess methodsFor: 'accessing'!pid	^ pid! !!OSSUnixSubprocess methodsFor: 'pointers management'!pointers	^ pointers ifNil: [ pointers := Set new ]! !!OSSUnixSubprocess methodsFor: 'close and dup2'!posixSpawnFileActionsAddClose: aFileDescriptor	"Add a close() action for aFileDescriptor for the child process"	| returnValue |	returnValue := self primitivePosixSpawnFileActionsAddClose: posixSpawnFileActionsT fileDescription: aFileDescriptor.	returnValue = 0 ifFalse: [ self systemAccessor strerror: returnValue message: 'posix_spawn_file_actions_adddclose()' ].	^ returnValue! !!OSSUnixSubprocess methodsFor: 'close and dup2'!posixSpawnFileActionsAddDup2: oldFileDescription newFileDescritpion: newFileDescription	"Add a dup2() action for from oldFileDescription to newFileDescription, for the child process"	| returnValue |	returnValue := self primitivePosixSpawnFileActionsAddDup2: posixSpawnFileActionsT oldFileDescription: oldFileDescription newFileDescritpion: newFileDescription.	returnValue = 0 ifFalse: [ self systemAccessor strerror: returnValue message: 'posix_spawn_file_actions_adddup2()' ].	^ returnValue! !!OSSUnixSubprocess methodsFor: 'private - primitives'!primitivePosixSpawn: pidPointer command: commandString fileActions: fileActions attributes: attributes argPointer: argPointer envPointer: envPointer	 ^ self ffiCall: #( int posix_spawnp (void* pidPointer, String commandString, void* fileActions, void * attributes, void* argPointer, void* envPointer) ) 				! !!OSSUnixSubprocess methodsFor: 'private - primitives'!primitivePosixSpawnFileActionsAddClose: fileActions fileDescription: fileDescriptionNumber		^ self ffiCall: #( int posix_spawn_file_actions_addclose ( void* fileActions, int fileDescriptionNumber) )! !!OSSUnixSubprocess methodsFor: 'private - primitives'!primitivePosixSpawnFileActionsAddDup2: fileActions oldFileDescription: oldFileDescription newFileDescritpion: newFileDescription 	 ^ self ffiCall: #( int posix_spawn_file_actions_adddup2 ( void* fileActions, int oldFileDescription, int newFileDescription ) )! !!OSSUnixSubprocess methodsFor: 'private - primitives'!primitivePosixSpawnFileActionsDestroy: aPosixSpawnFileActionsT 		^ self ffiCall: #( int posix_spawn_file_actions_destroy(void*  aPosixSpawnFileActionsT) )	! !!OSSUnixSubprocess methodsFor: 'private - primitives'!primitivePosixSpawnFileActionsInit: aPosixSpawnFileActionsT 		^ self ffiCall: #( int posix_spawn_file_actions_init(void* aPosixSpawnFileActionsT) )	! !!OSSUnixSubprocess methodsFor: 'printing'!printOn: aStream	aStream		nextPutAll: self class name asString;		nextPut: $(;		nextPutAll: 'Command: ';		nextPutAll: command asString;		nextPutAll: '; Pid: ';		nextPutAll: pid asString;		nextPutAll: '; Status: ';		nextPutAll: self exitStatusInterpreter asString;		nextPut: $)! !!OSSUnixSubprocess methodsFor: 'status'!processHasExitNotification	"This method is called from the OSSVMProcess when its child watcher detects that this process has	exited (via the receive of SIGCHLD) and so it notifies to it (via #updateActiveChildrenAndNotifyDead).	We signal mutexForSigchld so that the #runAndWait can now finish.	Note that the mutexForSigchld could be nil if the waitForExit API was not used"	mutexForSigchld ifNotNil: [ mutexForSigchld signal ]! !!OSSUnixSubprocess methodsFor: 'status'!queryExitStatus	^ exitStatus! !!OSSUnixSubprocess methodsFor: 'streams'!redirectStderr	"Creates a default stream and set it as stderr. 	This method can be called directly by the user to note that he wants to map that standard stream,	or by our own if createMissingStandardStreams is true."	stderrStream := self createADefaultWriteStream ! !!OSSUnixSubprocess methodsFor: 'streams'!redirectStderrTo: aStream	stderrStream := aStream! !!OSSUnixSubprocess methodsFor: 'streams'!redirectStdin	"Creates a default stream and set it as stdin. 	This method can be called directly by the user to note that he wants to map that standard stream,	or by our own if createMissingStandardStreams is true."		stdinStream := self createADefaultReadStream ! !!OSSUnixSubprocess methodsFor: 'streams'!redirectStdinTo: aStream	stdinStream := aStream! !!OSSUnixSubprocess methodsFor: 'streams'!redirectStdout	"Creates a default stream and set it as stdout. 	This method can be called directly by the user to note that he wants to map that standard stream,	or by our own if createMissingStandardStreams is true."		stdoutStream := self createADefaultWriteStream ! !!OSSUnixSubprocess methodsFor: 'streams'!redirectStdoutTo: aStream	stdoutStream := aStream! !!OSSUnixSubprocess methodsFor: 'pointers management'!registerPointer: aPointer	"Register a pointer so that it is free automatically in #freePointers"	self pointers add: aPointer! !!OSSUnixSubprocess methodsFor: 'streams'!retrieveWhatIsAvailableOn: aStream andAddItTo: accumulatingStream	"This is an internal method which should only be used IF the user will NOT	retrieve contents himself from streams while the process is still running.	The usecase of this method is #runAndWaitOnExitDo: and #waitForExitPollingEvery:retrievingStreams:	in which we are sure the user will not be reading from the streams. 	What this method does is to simply get what is available in aStream and write it in  accumulatingStream, which is 	the one we are using for appending contents (so that it is available all togther when the process has exited)	This is important because for example, for pipes, you cannot read something twice as you consume what you read. 		 "	aStream 		ifNotNil: [ :str | 			accumulatingStream nextPutAll: str upToEnd 		].! !!OSSUnixSubprocess methodsFor: 'running'!run	"Main method for spwaning the process. It starts the subprocess, it cleans the needed resources for that, and answers,	it does not wait for child. There are others high end API for running the process,	but they will all end up sending this message for starting the subprocess."	[ self internalRun ] ensure: [ 		self cleanResources.	]! !!OSSUnixSubprocess methodsFor: 'running'!runAndWait	"IMPORTANT: read first the comment of #waitForExit.		This methods runs the subprocess AND waits until the child has exited. 	"	self run.	self waitForExit.	! !!OSSUnixSubprocess methodsFor: 'running'!runAndWaitOnExitDo: anExitClosure	"This is a high end API for #runAndWait. IMPORTANT: read the comment in #runAndWait to know when to use this API.	The facility this method adds over #runAndWait is that when the process has finished it:	1) Retrieves all contents from stdout and stderr (if they were defined)	2) It automatically closes the streams mapped to stdout/stderr (if defined)	3) It allows you to plug anExitClosure which will be evaluated with this subprocess and the contents of stdout and stderr. 		With this method, the user does not need to do anything else. 	"	self run.	self waitForExit.	self retrieveWhatIsAvailableOn: stdoutStream andAddItTo: retrievedStdout.	self retrieveWhatIsAvailableOn: stderrStream andAddItTo: retrievedStderr.	self closeAndCleanStreams.	anExitClosure cull: self cull: retrievedStdout contents cull: retrievedStderr contents.	! !!OSSUnixSubprocess methodsFor: 'running'!runAndWaitPollingEvery: aDelay doing: aClosure onExitDo: onExitClosure	"IMPORTANT: first read the comment of #waitForExitPollingEvery:doing:		This method runs the subprocess, then waits for it doing an image-based delay polling. 	It does not automatically retrieve from streams nor closes them on exit. 	The user must explicitly read from streams in aClosure otherwise it might 	have the problem mentioned in the comment of #waitForExit.	The user must also close streams at some point. Either inside the #onExitClosure	or later, but should be done. 		 	"	self run.	self waitForExitPollingEvery: aDelay doing: aClosure.	onExitClosure cull: self cull: stdoutStream cull: stderrStream.	! !!OSSUnixSubprocess methodsFor: 'running'!runAndWaitPollingEvery: aDelay retrievingStreams: retrieveStreams onExitDo: onExitClosure	"IMPORTANT: first read the comment of #waitForExitPollingEvery:retrievingStreams:		This method runs the subprocess, then waits for it doing an image-based delay polling. 	If retrieveStreams is true, then as part of the polling loop, it also reads from the streams and	appends the intemediate results in retrievedStdout / retrievedStderr. 	Once the process has finished we evaluate onExitClosure.	If retrieveStreams was true, before evaluating onExitClosure, we automatically close streams	so that there is nothing else to be done for the user, and we also pass as arguments the	retrievedStdout / retrievedStderr  to the closure.		With this method, the user does not need to do anything else. 	 	"	self run.	self waitForExitPollingEvery: aDelay retrievingStreams: retrieveStreams.	retrieveStreams 		ifTrue: [ 			self closeAndCleanStreams.			onExitClosure cull: self cull: retrievedStdout contents cull: retrievedStderr contents.		]		ifFalse: [ 			onExitClosure cull: self.		]		! !!OSSUnixSubprocess methodsFor: 'status'!setExitStatus: aStatus	"This method set's the current process exit status.	If exitStatus was already set it will fail.		This method is synchronized to avoid race conditions on the access to the exit status"	waitPidCriticalSemaphore critical: [		exitStatus ifNotNil: [ self error: 'Modification not allowed' ].		exitStatus := aStatus	]		! !!OSSUnixSubprocess methodsFor: 'shell'!shell: aShellPath command: aShellCommandString	"Please read comment of #shellCommand:.	This is the same as shellCommand: but with the addition that the use can define which shell to be used via 'aBasePath' "	command := aShellPath.	arguments := Array with: '-c' with: (aShellCommandString encodeWith: encoding) asString. ! !!OSSUnixSubprocess methodsFor: 'shell'!shellCommand	"We first try to use the SHELL defined in the OS by getting the env variable $SHELL. 	If not found, then we fallback to /bin/sh"	^ Smalltalk platform environment at: 'SHELL' ifAbsent: ['/bin/sh']! !!OSSUnixSubprocess methodsFor: 'shell'!shellCommand: aShellCommandString	"This is a simple facility method for the cases when the user wants to use shell as the program.	This way, the user can directly send shellCommand: 'ls -la | grep Pharo > /tmp/test.txt ' with the whole string 	rather than having to do set the command sh, send the '-c' argument, etc etc etc.	We first try to use the SHELL defined in the OS by getting the env variable $SHELL. 	If not found, then we fallback to /bin/sh"		self shell: self shellCommand command: aShellCommandString. ! !!OSSUnixSubprocess methodsFor: 'streams'!shouldCreateStreamFor: aStream ifTrue: aBlock	"Internal method. 	If aStream was not specified explicitly by the user, but createMissingStandardStreams is true,	then it evaluates aBlock"	(aStream isNil and: [ createMissingStandardStreams ]) 		ifTrue: [ aBlock value ]! !!OSSUnixSubprocess methodsFor: 'system startup & shutdown'!shutDown: quitting	" IMPORTANT: read first the comment of OSSVMProcess >> shutDown:	This method is called if this process is still running at the time a 'Quit image' is happening 	in Pharo. If terminateOnShutdown is true, then we simply terminate the process via sigterm	and collect it exit status.	If it false, then we simply stop waiting for it, and allow to finish at OS level	(althought it may become orphan process as the parent will be die).	"	quitting ifTrue: [ 		terminateOnShutdown 			ifTrue: [ 				self terminate.				"To avoid problems..let's wait until we have the	exit status"				self waitForExitPolling.			]			ifFalse: [ self stopWaiting ]	] ! !!OSSUnixSubprocess methodsFor: 'OS signal sending'!sigabrt	"Send a SIGABRT signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGABRT! !!OSSUnixSubprocess methodsFor: 'OS signal sending'!sigalrm	"Send a SIGALRM signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGALRM! !!OSSUnixSubprocess methodsFor: 'OS signal sending'!sigchld	"Send a SIGCHLD signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGCHLD! !!OSSUnixSubprocess methodsFor: 'OS signal sending'!sigcont	"Send a SIGCONT signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGCONT! !!OSSUnixSubprocess methodsFor: 'OS signal sending'!sighup	"Send a SIGHUP signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGHUP! !!OSSUnixSubprocess methodsFor: 'OS signal sending'!sigint	"Send a SIGINT signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGINT! !!OSSUnixSubprocess methodsFor: 'OS signal sending'!sigkill	"Send a SIGKILL signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGKILL! !!OSSUnixSubprocess methodsFor: 'OS signal sending'!sigpipe	"Send a SIGPIPE signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGPIPE! !!OSSUnixSubprocess methodsFor: 'OS signal sending'!sigquit	"Send a SIGQUIT signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGQUIT! !!OSSUnixSubprocess methodsFor: 'OS signal sending'!sigstop	"Send a SIGSTOP signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGSTOP! !!OSSUnixSubprocess methodsFor: 'OS signal sending'!sigterm	"Send a SIGTERM signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGTERM! !!OSSUnixSubprocess methodsFor: 'OS signal sending'!sigusr1	"Send a SIGUSR1 signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGUSR1! !!OSSUnixSubprocess methodsFor: 'OS signal sending'!sigusr2	"Send a SIGUSR2 signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGUSR2! !!OSSUnixSubprocess methodsFor: 'streams'!stderrStream	^ stderrStream! !!OSSUnixSubprocess methodsFor: 'streams'!stdinStream	^ stdinStream! !!OSSUnixSubprocess methodsFor: 'streams'!stdoutStream	^ stdoutStream! !!OSSUnixSubprocess methodsFor: 'waiting'!stopWaiting	"This will work only for the High Methods API that rely in the waiting provided by the framework. If the user	user custom waiting, this won't work.	The wait inside this framework could be done either from #waitForExit with mutexForSigchld or via  #waitForExitPollingEvery:doing:	with the delay polling"	mutexForSigchld ifNotNil: [ mutexForSigchld signal ].	(shouldContinueWaiting = true) ifTrue: [ shouldContinueWaiting := false. ] 	! !!OSSUnixSubprocess methodsFor: 'accessing'!systemAccessor 	^ OSSVMProcess vmProcess systemAccessor! !!OSSUnixSubprocess methodsFor: 'terminating'!terminate	^ self sigterm! !!OSSUnixSubprocess methodsFor: 'system startup & shutdown'!terminateOnShutdown	" IMPORTANT: read first the comment of OSSVMProcess >> shutDown:	If terminateOnShutdown is true, then the external process will be terminated if it was still	running at the time a system quit image is happening.	If false, then we will simply stop waiting for it and allow it to finish (thought it will likely become a orphan).	"	terminateOnShutdown := true! !!OSSUnixSubprocess methodsFor: 'waiting'!waitForExit	"The waiting in this case is efficient since it is NOT done with a delay polling but using the SIGCHLD handler of OSSVMProcess childWatcher. The childWatcher when received a SIGCHLD will detect the child 	that died and will send #processHasExitNotification to such a child. 	In #processHasExitNotification the child will signal this 'mutexForSigchld' and hence	make the #waitForExit to proceed.  		IMPORTANT: This kind of waiting could generate a deadlock when the user uses pipes 	for mapping standard streams and the child writes a lot of stuff into it. Basically, there is a problem in	general with waiting for an external process to exit before reading its output. If the external process 	creates a large amount of output, and if the output is a pipe, it will block on writing to the pipe until	 someone (our VM process) reads some data from the pipe to make room for the writing. That leads to cases where 	we never read the output (because the external process did not exit) and the external process never exits 	(because we have not read the data from the pipe).			Therefore, use this method (and all its senders) only when using FileStreams for the standard streams, 	when not defining standard streams at all, or when you know the command to be executed does not write much in stdout/stderr."	exitStatus ifNotNil: [ ^ exitStatus ].	mutexForSigchld := Semaphore new.	mutexForSigchld wait. 	^ exitStatus  ! !!OSSUnixSubprocess methodsFor: 'waiting'!waitForExitPolling	"Read the comment of waitForExitPollingEvery:retrievingStreams:"	^ self waitForExitPollingEvery: (Delay forMilliseconds: 50)! !!OSSUnixSubprocess methodsFor: 'waiting'!waitForExitPollingEvery: aDelay 	"Read the comment of waitForExitPollingEvery:retrievingStreams:"	^ self waitForExitPollingEvery: aDelay retrievingStreams: true! !!OSSUnixSubprocess methodsFor: 'waiting'!waitForExitPollingEvery: aDelay doing: aClosure	" IMPORTANT: read first the comment of #waitForExit. 		This method does NOT use #runAndWait nor #waitForExit. Instead, it does an image-based polling to check status of child process. 	Note that the loop does send #queryExitStatus which is the method that indeeds does the waitpid() to check it.	This is not strictly necessary because the childWatcher of the OSSVMProcess	takes care of capturing SIGCHDL and update exitStatus. 	However, as a more reliable solution, we can also check exit status here in case there are missed SIGCHLD or whatever.		As part of the loop, besides checking the exit status (#queryExitStatus) it also evaluates aClosure		"	shouldContinueWaiting := true.	[		"If the #shutDown: (shouldContinueWaiting was set to false) happened while this process was in the #wait 		 then we simply check 'shouldContinueWaiting' here before doing the #queryExitStatus"		shouldContinueWaiting 			ifTrue: [ self queryExitStatus ]			ifFalse: [ ^ nil ].		"nil answer means the child has not yet finished" 		(exitStatus isNil and: [ shouldContinueWaiting ])	]	whileTrue: [ 		aDelay wait.		aClosure cull: self cull: stdoutStream cull: stderrStream.	].	"We might have more contents in the streams that could have been written since the last 'aClosure value' and the moment #queryExitStatus answers non nil.	So just in case we execute aClosure one more time"	shouldContinueWaiting 		ifTrue: [ aClosure cull: self cull: stdoutStream cull: stderrStream. ].	^ exitStatus  ! !!OSSUnixSubprocess methodsFor: 'waiting'!waitForExitPollingEvery: aDelay retrievingStreams: retrieveStreams	" IMPORTANT: read first the comment of #waitForExit. 	Second, read the comment of #waitForExitPollingEvery:doing:		If retrieveStreams is true, we read from stdout/stderr as part of the loop and	append the answers in retrievedStdout / retrievedStderr.	And this solves the deadlock mentioned in #waitForExit.		This method (with retrieveStreams in true) should be used when mapping stdout / stderr with pipes	and the command to be executed may write a lot to it. Does not make much sense to be used with regular files. 		Answers the exit status of the child."	^ self 		waitForExitPollingEvery: aDelay		doing: [ 			retrieveStreams ifTrue: [ 				self retrieveWhatIsAvailableOn: stdoutStream andAddItTo: retrievedStdout.				self retrieveWhatIsAvailableOn: stderrStream andAddItTo: retrievedStderr.			]		] 	! !!OSSUnixSubprocess methodsFor: 'waiting'!waitForExitWithTimeout: aDuration	"The waiting in this case is efficient since it is NOT done with a delay polling but using the SIGCHLD handler of OSSVMProcess childWatcher. The childWatcher when received a SIGCHLD will detect the child 	that died and will send #processHasExitNotification to such a child. 	In #processHasExitNotification the child will signal this 'mutexForSigchld' and hence	make the #waitForExit to proceed.  		IMPORTANT: This kind of waiting could generate a deadlock when the user uses pipes 	for mapping standard streams and the child writes a lot of stuff into it. Basically, there is a problem in	general with waiting for an external process to exit before reading its output. If the external process 	creates a large amount of output, and if the output is a pipe, it will block on writing to the pipe until	 someone (our VM process) reads some data from the pipe to make room for the writing. That leads to cases where 	we never read the output (because the external process did not exit) and the external process never exits 	(because we have not read the data from the pipe).			Therefore, use this method (and all its senders) only when using FileStreams for the standard streams, 	when not defining standard streams at all, or when you know the command to be executed does not write much in stdout/stderr."	| expired |	exitStatus ifNotNil: [ ^ exitStatus ].	mutexForSigchld := Semaphore new.	expired := mutexForSigchld waitTimeoutMSecs: aDuration asMilliSeconds.	expired ifTrue: [ OSSTimeout signal: 'Process not finished after ', aDuration asString ].	^ exitStatus  ! !!OSSUnixSubprocess methodsFor: 'settings'!workingDirectory: aString	"This is a setting that allows defining a working directory for the OS process once started."	"Working directory is not encoded when set because it is used as FileReference at some places.	Instead, we encode it in #lockCwdWithValue:encoding:during:"	workingDirectory := aString! !"OSSubprocess"!!UnicodeCharacterData commentStamp: '' prior: 0!I am UnicodeCharacterData, I represent one record in the Unicode Character Database and describe properties of one character.I am uniquely identified by my code point (#codePoint), my Unicode scalar value.I have an official name (#name). Sometimes I also know my older name (#oldName).I have a general and a bidirectional category (#generalCategory  #bidirectionalCategory) and I know my canonicalCombiningClasses (#canonicalCombiningClasses).If applicable, I know my case mapping, what code point is like me, but upper, lower or title cased (#uppercase  #lowercase #titelcase)If applicable, I know my numerical mapping, the mathematical number that I represent (#decimalDigitValue #digitValue #numericValue).If I am a precomposed character, I know my decomposition (#decompositionMapping). This information is needed for normalization.I also known whether I am mirrored (#mirrored).My class side holds the full database of all official Unicode characters, indexed by codePoint (#database), which is loaded lazily from the official URL or from a local file system cache.Given a Unicode code point, my class method #forCodePoint: will answer an instance of me. A NotFound exception is raised if the code point is outside the allowed range.Given an integer, #unicodeCharacterData will answer an instance of me.	16r00C5 unicodeCharacterData.The character that I represent is available with #character.  Given a character instance, #unicodeCharacterData will answer an instance of me.	$a unicodeCharacterData.	$é unicodeCharacterData.	$7 unicodeCharacterData.More:For the interpretation of these concepts, please consult the Unicode documentation at http://unicode.orgIn particular, the UCD dataset is described in detail in http://www.unicode.org/reports/tr44/ and available directly at http://www.unicode.org/Public/UNIDATA/ and can be downloaded as http://www.unicode.org/Public/UNIDATA/UCD.zip.Implementation notesTo conserve space (the full database has about 30K entries), some of my fields (canonicalCombiningClass, generalCategory, bidirectionalCategory and mirrored) are combined in bitEncodedFields.Furthermore, since many entries (about 20K) have neither decomposition, case or numeric mappings, I have no instance variables for these properties, but my extended subclass does.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!UnicodeCharacterDataExtended commentStamp: '' prior: 0!I am UnicodeCharacterDataExtended, a subclass of UnicodeCharacterData.I am an implementation detail, from an external viewpoint I am identical to my superclass.Since many UCD entries (about 20K) have neither decomposition, case or numeric mappings, my superclass has no instance variables for these properties, but I do.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!Character methodsFor: '*unicode-character-data'!gtInspectorGlyphIn: composite	<gtInspectorPresentationOrder: 60>	^ composite morph		title: 'Glyph';		display: [ 			| morph largeFont |			"Add an extra space in front to prevent rendering glitches on combining marks"			morph := (String space , self asString) asMorph.			(largeFont := morph font copy)				clearRealFont;				pointSize: 256.			morph font: largeFont.			morph fitContents.			morph ]! !!Character methodsFor: '*unicode-character-data'!gtInspectorUnicodeCharacterDataIn: composite	<gtInspectorPresentationOrder: 40>	| unicodeCharacterData |	unicodeCharacterData := [ self unicodeCharacterData ] on: NotFound do: [ ^ self ].	^ (unicodeCharacterData gtInspectorCharacterIn: composite)			title: 'Unicode';			yourself ! !!Character methodsFor: '*unicode-character-data'!unicodeCharacterData	"Answer the official record from the Unicode Character Database for me"		^ UnicodeCharacterData forCodePoint: self codePoint ! !!SmallInteger methodsFor: '*unicode-character-data'!unicodeCharacterData	"Answer the official record from the Unicode Character Database for me"		^ UnicodeCharacterData forCodePoint: self ! !!UnicodeCharacterData class methodsFor: 'constants'!bidirectionalCategories	"Return the possible values for bidirectional category"		"Table 13. Bidi_Class Values in http://www.unicode.org/reports/tr44/#Bidi_Class_Values"		^ #(L R AL EN ES ET AN CS NSM BN B S WS ON LRE LRO RLE RLO PDF LRI RLI FSI PDI)! !!UnicodeCharacterData class methodsFor: 'initialization'!cleanUp: aggressive	"self cleanUp"	"self cleanUp: true"	self resetHangulDatabase.	"Not 100% sure this is a good idea"	aggressive		ifTrue: [ self resetDataSets ]! !!UnicodeCharacterData class methodsFor: 'accessing - datasets'!compositionExclusions	"D112"		^ CompositionExclusions ifNil: [ CompositionExclusions := self loadCompositionExclusions ]! !!UnicodeCharacterData class methodsFor: 'private - composition exclusion'!compositionExclusionsFile	^ 'CompositionExclusions.txt'! !!UnicodeCharacterData class methodsFor: 'accessing - datasets'!database	"Return the Unicode Character Database an a dictionary mapping each codepoint to an instance of me. 	Load the database if needed from the official URL over the internet or from a local filesystem cache."		UnicodeCharacterDatabase ifNil: [ self initializeDatabase ].	^ UnicodeCharacterDatabase! !!UnicodeCharacterData class methodsFor: 'constants'!decompositionCompatibilityTypes	"Return the possible values for type of compatibility decomposition"		"Table 14. Compatibility Formatting Tags in http://www.unicode.org/reports/tr44/#Character_Decomposition_Mappings"		^ #(font noBreak initial medial final isolated circle super sub vertical wide narrow small square fraction compat)! !!UnicodeCharacterData class methodsFor: 'private - derived normalization properties'!derivedNormalizationPropertiesFile	^ 'DerivedNormalizationProps.txt'! !!UnicodeCharacterData class methodsFor: 'private - database'!extractSpecialRanges: collectionOfCharacterData	|ranges|	ranges := (collectionOfCharacterData 			select: [ :each | (each name endsWith: 'First>') or: [ each name endsWith: 'Last>' ] ])				pairsCollect: [ :first :last | Array with: first with: last ].	"Happily, in Pharo, removeAllSuchThat does *not* return the collection of removed elements..."	collectionOfCharacterData 			removeAllSuchThat: [ :each | (each name endsWith: 'First>') or: [ each name endsWith: 'Last>' ] ].	^ranges! !!UnicodeCharacterData class methodsFor: 'accessing'!forCodePoint: integer	"Return an instance of me for codepoint integer. Fail if there is no such codepoint."	^ self		forCodePoint: integer		ifAbsent: [ KeyNotFound signalFor: integer in: self database ]! !!UnicodeCharacterData class methodsFor: 'accessing'!forCodePoint: integer ifAbsent: block	"Return an instance of me for codepoint integer. Execute block if there is no such codepoint."		^ self database 		at: integer 		ifAbsent: [ self hangulDataForCodePoint: integer ifAbsent: block ]! !!UnicodeCharacterData class methodsFor: 'constants'!generalCategories	"Return the possible values for general category"		"See Table 12. General_Category Values in http://www.unicode.org/reports/tr44/#General_Category_Values"		^ #(Lu Ll Lt Lm Lo Mn Mc Me Nd Nl No Pc Pd Ps Pe Pi Pf Po Sm Sc Sk So Zs Zl Zp Cc Cf Cs Co Sn)! !!UnicodeCharacterData class methodsFor: 'private - database common'!getUnicodeCharacterDatabaseRaw: file	"Return the contents of file from the Unicode Character Database specification as a String.	Optionally use a locally downloaded cache, to enable this,	decompress http://www.unicode.org/Public/UNIDATA/UCD.zip next to your image."		| fileReference url |	fileReference := self unicodeCharacterDatabaseCacheDirectory / file.	url := self unicodeCharacterDatabaseBaseUrl / file.	^ fileReference exists		ifTrue: [ 			fileReference binaryReadStreamDo: [ :bin |				(ZnCharacterReadStream on: bin) upToEnd ] ]		ifFalse: [ 			url retrieveContents ]! !!UnicodeCharacterData class methodsFor: 'private - hangul'!hangulDataForCodePoint: integer	^ self 		hangulDataForCodePoint: integer 		ifAbsent: [ KeyNotFound signalFor: integer in: self database ]! !!UnicodeCharacterData class methodsFor: 'private - hangul'!hangulDataForCodePoint: integer ifAbsent: aBlock	"Could use on: DomainError do: aBlock rather than check range here explicitly, not sure of the perf overhead though"	(integer notNil and: [ self isHangulSyllableCodePoint: integer ])		ifFalse: [ ^ aBlock value ].	^ self hangulDatabase 		at: integer 		ifAbsentPut: [ 			UnicodeCharacterDataExtended new 				initializeFromHangulSyllable: integer;				yourself ]! !!UnicodeCharacterData class methodsFor: 'private - hangul'!hangulDatabase	"Thumb-in-air figure; assume 1000 hangul characters will be a good working set."	^ HangulCache		ifNil: [ 			HangulCache := LRUCache new				maximumWeight: 1000;				yourself ]! !!UnicodeCharacterData class methodsFor: 'initialization'!initializeDatabase	| entries |	entries := self loadUnicodeCharacterDatabase.	SpecialRanges := self extractSpecialRanges: entries.	UnicodeCharacterDatabase := IdentityDictionary new: entries size.	entries do: [ :each | 		UnicodeCharacterDatabase at: each codePoint put: each ].	self sanityCheck: entries! !!UnicodeCharacterData class methodsFor: 'initialization'!initializeJamoShortNames	JamoShortNames := self loadJamoShortNames ! !!UnicodeCharacterData class methodsFor: 'private - hangul'!isHangulSyllableCodePoint: codePoint	^ codePoint between: 16rAC00 and: 16rD7A3! !!UnicodeCharacterData class methodsFor: 'accessing - normalization quick check'!isSupplementaryCodePoint: codePoint	^ codePoint between: 16r10000 and: 16r10FFFF! !!UnicodeCharacterData class methodsFor: 'accessing - datasets'!jamoShortNames	JamoShortNames ifNil: [ self initializeJamoShortNames  ].	^JamoShortNames! !!UnicodeCharacterData class methodsFor: 'private - jamo short names'!jamoShortNamesFile	^ 'Jamo.txt'! !!UnicodeCharacterData class methodsFor: 'private - composition exclusion'!loadCompositionExclusions	| compositionExclusions |	compositionExclusions := IdentitySet new.	(self getUnicodeCharacterDatabaseRaw: self compositionExclusionsFile) linesDo: [ :each | 		(each notEmpty and: [ each first ~= $# ])			ifTrue: [ compositionExclusions add: (Integer readFrom: each base: 16) ] ].	^ compositionExclusions! !!UnicodeCharacterData class methodsFor: 'private - derived normalization properties'!loadDerivedNormalizationProperties	^ OrderedCollection streamContents: [ :out |		(self getUnicodeCharacterDatabaseRaw: self derivedNormalizationPropertiesFile) linesDo: [ :line |			(line isEmpty or: [ line first = $# ])				ifFalse: [ 					out nextPut: (self parseDerivedNormalizationProperty: line) ] ] ]! !!UnicodeCharacterData class methodsFor: 'private - jamo short names'!loadJamoShortNames	| shortNames |	shortNames := IdentityDictionary new.	(self getUnicodeCharacterDatabaseRaw: self jamoShortNamesFile)		linesDo: [ :each | 			(self parseUnicodeJamoShortNames: each) 				ifNotNil: [ :shortName | shortNames add: shortName ] ].	^ shortNames! !!UnicodeCharacterData class methodsFor: 'private - derived normalization properties'!loadNormalizationQuickCheck	| normalizationQuickCheck derivedNormalizationProperties values |	normalizationQuickCheck := IdentityDictionary new.	derivedNormalizationProperties := self loadDerivedNormalizationProperties.	#(NFC_QC NFD_QC NFKC_QC NFKD_QC) do: [ :property |		values := IdentityDictionary new.		derivedNormalizationProperties 			select: [ :each | (each at: #property) = property ] 			thenDo: [ :each | 				(each at: #range) isInteger					ifTrue: [ 						values at: (each at: #range) put: (each at: #value) asSymbol ] 					ifFalse: [ 						(each at: #range) do: [ :codePoint | 							values at: codePoint put: (each at: #value) asSymbol ] ] ].		normalizationQuickCheck at: property put: values ].	^ normalizationQuickCheck! !!UnicodeCharacterData class methodsFor: 'private - database'!loadUnicodeCharacterDatabase	^ OrderedCollection streamContents: [ :out |		(self getUnicodeCharacterDatabaseRaw: self unicodeCharacterDatabaseFile) linesDo: [ :each |			out nextPut: (self parseUnicodeCharacterData: each) ] ]! !!UnicodeCharacterData class methodsFor: 'queries'!minimalCCC		| ccc |	ccc := IdentityDictionary new.	(self database values reject: #isStarter)		do: [ :each | ccc at: each codePoint put: each ccc ].	^ ccc! !!UnicodeCharacterData class methodsFor: 'queries'!minimalDecomposition	| decomposition |	decomposition := IdentityDictionary new.	(self database values select: #hasDecomposition)		do: [ :each | decomposition at: each codePoint put: each decompositionMapping ].	^ decomposition! !!UnicodeCharacterData class methodsFor: 'queries'!nameMatching: fragment	"Find and return the Unicode Character Data objects whose official name matches fragment."		"self nameMatching: 'CAPITAL LETTER A'"		| matches |	matches := Array streamContents: [ :out |		self database valuesDo: [ :each |			"Note that by using #names both #name and #oldName if any will be used"			(each names findString: fragment startingAt: 1 caseSensitive: false) ~= 0				ifTrue: [ out nextPut: each ] ] ].	^ matches! !!UnicodeCharacterData class methodsFor: 'queries'!named: fullName	"Find and return the Unicode Character Data object whose official name is fullName."		"self named: 'LATIN CAPITAL LETTER A'"		self database valuesDo: [ :each |		each name = fullName ifTrue: [ ^ each ] ].	NotFound signalFor: fullName in: self ! !!UnicodeCharacterData class methodsFor: 'queries'!nonStarterDecompositions	"D111"		^ self database values select: #isNonStarterDecomposition! !!UnicodeCharacterData class methodsFor: 'accessing - datasets'!normalizationQuickCheck	^ NormalizationQuickCheck ifNil: [ NormalizationQuickCheck := self loadNormalizationQuickCheck ]! !!UnicodeCharacterData class methodsFor: 'accessing - normalization quick check'!normalizationQuickCheck: property forCodePoint: codePoint	"Return #Y (yes), #N (no) or #M (maybe) for property, #NFC_QC, #NFD_QC, #NFKC_QC or #NFKD_QC"		^ (self normalizationQuickCheck at: property) at: codePoint ifAbsent: [ #Y ] ! !!UnicodeCharacterData class methodsFor: 'accessing - normalization quick check'!normalizationQuickCheck: property forCodePointStream: codePointStream	| result lastCCC codePoint ccc check |	result := #Y.	lastCCC := 0.	[ codePointStream atEnd ] whileFalse: [		codePoint := codePointStream next.		"(self isSupplementaryCodePoint: codePoint) ifTrue: [ codePointStream next ]."		ccc := [ codePoint unicodeCharacterData ccc ] on: NotFound do: [ 0 ].		(lastCCC > ccc and: [ ccc ~= 0 ]) ifTrue: [ ^ #N ].		check := self normalizationQuickCheck: property forCodePoint: codePoint.		check = #N ifTrue: [ ^ #N ].		check = #M ifTrue: [ result := #M ]. 		lastCCC := ccc ].	^ result! !!UnicodeCharacterData class methodsFor: 'accessing - normalization quick check'!normalizationQuickCheck: property forString: string	^ self 		normalizationQuickCheck: property 		forCodePointStream: string readStream unicodeCodePoints! !!UnicodeCharacterData class methodsFor: 'private - derived normalization properties'!parseDerivedNormalizationProperty: line	| fields range value comment |	fields := $; split: (line copyFrom: 1 to: (line indexOf: $#) - 1).	comment := line copyFrom: (line indexOf: $#) + 2 to: line size.	range := fields first trimBoth.	range := (range indexOfSubCollection: '..' startingAt: 1 ifAbsent: [ ])		ifNil: [ Integer readFrom: range base: 16 ]		ifNotNil: [ :ellipsis | 				(Integer readFrom: (range copyFrom: 1 to: ellipsis - 1) base: 16) 					to: (Integer readFrom: (range copyFrom: ellipsis + 2 to: range size) base: 16) ].	value := fields size = 2					ifTrue: [ true ]					ifFalse: [ fields third trimBoth asSymbol ].	^ { 		#range -> range.		#property -> fields second trimBoth asSymbol.		#value -> value.		#comment -> comment trimBoth } asDictionary! !!UnicodeCharacterData class methodsFor: 'private - database'!parseUnicodeCharacterData: line	| fields isCompact concreteClass |	fields := $; split: line.	"Test if the fields for decomposition, numerical and case mapping are all empty"	isCompact := #(6 7 8 9 13 14 15) allSatisfy: [ :each | (fields at: each) isEmpty ].	concreteClass := isCompact 		ifTrue: [ UnicodeCharacterData ] 		ifFalse: [ UnicodeCharacterDataExtended ].	^ concreteClass new		initializeFrom: fields;		yourself! !!UnicodeCharacterData class methodsFor: 'private - jamo short names'!parseUnicodeJamoShortNames: aLine	| codePoint start end shortName |	"Don't parse comments and empty lines"	(aLine isEmpty or: [aLine first = $#]) ifTrue: [ ^nil ].	"All lines are in format CODEPOINT; SHORTNAME #LONGNAME "	codePoint := Number readFrom: aLine base: 16.	start := (aLine indexOf: $;) + 2.	end := (aLine indexOf: Character space startingAt: start) -1.	shortName := aLine copyFrom: start to: end.	^codePoint -> shortName	 ! !!UnicodeCharacterData class methodsFor: 'initialization'!resetDataSets	"self resetDataSets"	UnicodeCharacterDatabase := nil.	SpecialRanges := nil.	JamoShortNames := nil.	NormalizationQuickCheck := nil.	CompositionExclusions := nil! !!UnicodeCharacterData class methodsFor: 'private - hangul'!resetHangulDatabase	^ HangulCache ifNotNil: [ HangulCache removeAll ]! !!UnicodeCharacterData class methodsFor: 'initialization'!sanityCheck: newlyImportedCharacterData	"Check that assumptions made of the structure in algoritmic implementations still hold."	 newlyImportedCharacterData do: [ :one | one decompositionWarning ifNotNil: [ :warning | warning logCr ] ].! !!UnicodeCharacterData class methodsFor: 'queries'!singletons	"D110"		^ self database values select: #isSingleton! !!UnicodeCharacterData class methodsFor: 'accessing - datasets'!specialRanges	SpecialRanges ifNil: [ self initializeDatabase ].	^ SpecialRanges! !!UnicodeCharacterData class methodsFor: 'private - database common'!unicodeCharacterDatabaseBaseUrl	"Return the base of URL where all files of the UCD dataset can be found"		^ 'http://www.unicode.org/Public/UNIDATA' asZnUrl! !!UnicodeCharacterData class methodsFor: 'private - database common'!unicodeCharacterDatabaseCacheDirectory	"Return the directory where a local filesystem copy of the UCD data is stored.	Decompress http://www.unicode.org/Public/UNIDATA/UCD.zip next to your image"		^ FileLocator imageDirectory / #UCD! !!UnicodeCharacterData class methodsFor: 'private - database'!unicodeCharacterDatabaseFile	"Return the name of the main Unicode Character Database specification file"		^ 'UnicodeData.txt'! !!UnicodeCharacterData class methodsFor: 'queries'!unmappedDecompositionCodePoints	^ (Array streamContents: [ :out | 			self database valuesDo: [ :ucd | 				ucd decompositionMappingDo: [ :each | 					self forCodePoint: each ifAbsent: [ out nextPut: each ] ] ] ]) asSet sorted! !!UnicodeCharacterData class methodsFor: 'queries'!unmappedDecompositions	^ (self database values select: [ :ucd | 			| missing |			missing := false.			ucd decompositionMappingDo: [ :each |				self forCodePoint: each ifAbsent: [ missing := true ] ]. 			missing ]) sorted! !!UnicodeCharacterData methodsFor: 'comparing'!<= otherUnicodeCharacterData	^ self codePoint <= otherUnicodeCharacterData codePoint! !!UnicodeCharacterData methodsFor: 'comparing'!= anObject	self == anObject ifTrue: [ ^ true ].	self class = anObject class ifFalse: [ ^ false ].	^ codePoint = anObject codePoint! !!UnicodeCharacterData methodsFor: 'accessing'!bidirectionalCategory	"Return the symbol indicating the Bidirection Category of my codepoint"	| index |	index := (bitEncodedFields >> 13) bitAnd: 2r11111.	^ self class bidirectionalCategories at: index + 1! !!UnicodeCharacterData methodsFor: 'accessing'!canonicalCombiningClass	"Return the integer indicating the Canonical Combining Class of my codepoint"	^ bitEncodedFields bitAnd: 16rFF! !!UnicodeCharacterData methodsFor: 'accessing'!caseMapping	"If not nil, a 3 element array: { upper. lower. title } each of which could be nil.	Use the accessors #uppercase, #lowercase or #titlecase instead"		^ nil! !!UnicodeCharacterData methodsFor: 'accessing'!ccc	"A shorter alias"		^ self canonicalCombiningClass ! !!UnicodeCharacterData methodsFor: 'accessing'!character	"Return a character instance corresponding to my codepoint"	^ Character codePoint: codePoint! !!UnicodeCharacterData methodsFor: 'accessing'!codePoint	"Return my codepoint, an integer"		^ codePoint! !!UnicodeCharacterData methodsFor: 'accessing'!decimalDigitValue	"Return the decimal digit value of my codepoint as an integer. Could be nil if not applicable."		^ self numericMapping ifNotNil: [ :numericMapping | numericMapping first ]! !!UnicodeCharacterData methodsFor: 'gt-inspector-extension'!decompositionAsUCDs	^ self decompositionMapping ifNotNil: [ :decomposition | 			decomposition collect: [ :each | 				each isInteger 					ifTrue: [ 						self class 							forCodePoint: each 							ifAbsent: [ 								self class new 									initializeDegenerate: each;									yourself ] ]					ifFalse: [ each ] ] ]! !!UnicodeCharacterData methodsFor: 'gt-inspector-extension'!decompositionDescription	^ String streamContents: [ :out |			self decompositionMapping ifNotNil: [ :mapping | 				| decomposition |				mapping first isInteger 					ifTrue: [ decomposition := mapping ]					ifFalse: [ 						out << $< << mapping first << $>; space. 						decomposition := mapping allButFirst ].			decomposition 				do: [ :each | out nextPut: (Character codePoint: each) ]				separatedBy: [ out << ' + ' ] ] ]! !!UnicodeCharacterData methodsFor: 'accessing'!decompositionMapping	"Return my decomposition mapping if applicable, an array of code points, with an optional symbol tag in the first position. The code points of my decomposition can be combined into my codepoint."		^ nil! !!UnicodeCharacterData methodsFor: 'accessing'!decompositionMappingDo: block	"Execute block for each code point in my decomposition mapping, if any"		self hasCanonicalDecomposition 		ifTrue: [ ^ self decompositionMapping do: block ].	self hasCompatibleDecomposition 		ifTrue: [ ^ self decompositionMapping allButFirstDo: block ]! !!UnicodeCharacterData methodsFor: 'accessing'!decompositionString	"Return my decomposition as a String, if I have none, return an empty string."		^ String streamContents: [ :out |			self decompositionMappingDo: [ :each | 				out nextPut: (Character codePoint: each) ] ]! !!UnicodeCharacterData methodsFor: 'private'!decompositionWarning	"Return a warning if our decomposition is on a form not handled by the decomposition implementations. 	We could hope the decomposition tests would be updated if this were the case, but then again, there's none exibiting correct reordering for nonStarters followed by starters with non-starter decomposition with lower combining class"	| first |	first := true.	self decompositionMappingDo: [ :cP | 		(first and: 		[[cP unicodeCharacterData isStarter] on: NotFound do: [true]]) ifTrue: [ ^nil].		first := false.		([cP unicodeCharacterData isStarter] on: NotFound do: [true]) ifTrue: [ ^self name, 'has decomposition not handled by implementation, #isNonStarter: must be changed to deal with #(NonStarter, Starter) decompositions to remain conformant with this version of Unicode'  ].		 ] .	^nil! !!UnicodeCharacterData methodsFor: 'accessing'!digitValue	"Return the digit value of my codepoint as an integer. Could be nil if not applicable."	^ self numericMapping ifNotNil: [ :numericMapping | numericMapping second ]! !!UnicodeCharacterData methodsFor: 'accessing'!generalCategory	"Return the symbol indicating the General Category of my codepoint"	| index |	index := (bitEncodedFields >> 8) bitAnd: 2r11111.	^ self class generalCategories at: index + 1! !!UnicodeCharacterData methodsFor: 'gt-inspector-extension'!gtInspectorCharacterIn: composite	<gtInspectorPresentationOrder: 30>	^ composite table		title: 'Character';		display: [			{				{ 'codepoint'. self codePoint }.				{ 'codepoint hex'. 					String streamContents: [ :stream | 						stream << 'U+'.						self codePoint printOn: stream base: 16 nDigits: 4 ].					self codePoint }.				{ 'character'. self character printString. self character }.				{ 'name'. self name }.				{ 'old name'. self oldName ifNil: [ '' ]. self oldName }.				{ 'general category'. self generalCategory }.				{ 'canonical combining class'. self canonicalCombiningClass }.				{ 'bidirectional category'. self bidirectionalCategory }.				{ 'mirrored'. self mirrored }.				{ 'uppercase'. 					self uppercase ifNotNil: [ :n | Character codePoint: n ] ifNil: [ '' ]. 					self class forCodePoint: self uppercase ifAbsent: [] }.				{ 'lowercase'. 					self lowercase ifNotNil: [ :n | Character codePoint: n ] ifNil: [ '' ]. 					self class forCodePoint: self lowercase ifAbsent: [] }.				{ 'titlecase'. 					self titlecase ifNotNil: [ :n | Character codePoint: n ] ifNil: [ '' ]. 					self class forCodePoint: self titlecase ifAbsent: [] }.				{ 'decimal digit value'. self decimalDigitValue ifNil: [ '' ]. self decimalDigitValue }.				{ 'digit value'. self digitValue ifNil: [ '' ]. self digitValue }.				{ 'numeric value'. self numericValue ifNil: [ '' ]. self numericValue }.				{ 'decomposition'. self decompositionDescription. self decompositionAsUCDs }			} ];		column: 'Key' evaluated: #first;		column: 'Value' evaluated: [ :entry | entry second asString ];		send: [ :entry | entry at: 3 ifAbsent: [ entry second ] ]! !!UnicodeCharacterData methodsFor: 'gt-inspector-extension'!gtInspectorGlyphIn: composite	<gtInspectorPresentationOrder: 40>	^ self character gtInspectorGlyphIn: composite! !!UnicodeCharacterData methodsFor: 'testing'!hasCanonicalDecomposition	^ self hasDecomposition and: [ self decompositionMapping first isInteger ]! !!UnicodeCharacterData methodsFor: 'testing'!hasCompatibleDecomposition	^ self hasDecomposition and: [ self decompositionMapping first isSymbol ]! !!UnicodeCharacterData methodsFor: 'testing'!hasDecomposition	^ false! !!UnicodeCharacterData methodsFor: 'testing'!hasStandardCanonicalDecomposition	^ self hasCanonicalDecomposition and: [ self decompositionMapping size = 2 ]! !!UnicodeCharacterData methodsFor: 'comparing'!hash	^ codePoint hash! !!UnicodeCharacterData methodsFor: 'private'!initializeBitEncodedFieldsFrom: fields	| generalCategory canonicalCombiningClass bidirectionalCategory mirrored generalIndex bidiIndex |	generalCategory := fields third asSymbol.	canonicalCombiningClass := fields fourth asNumber.	bidirectionalCategory := fields fifth asSymbol.	mirrored := (fields at: 10) first = $Y.	generalIndex := self class generalCategories 		indexOf: generalCategory ifAbsent: [ NotFound signalFor: generalCategory ].	bidiIndex := self class bidirectionalCategories 		indexOf: bidirectionalCategory ifAbsent: [ NotFound signalFor: bidirectionalCategory ].	bitEncodedFields := canonicalCombiningClass 		+ (generalIndex - 1 << 8) 		+ (bidiIndex - 1 << 13)		+ (mirrored asBit << 18)! !!UnicodeCharacterData methodsFor: 'initialize'!initializeDegenerate: integer	codePoint := integer.	name := '<UNKNOWN>'.	bitEncodedFields := 0! !!UnicodeCharacterData methodsFor: 'initialize'!initializeFrom: fields	codePoint := Integer readFrom: fields first base: 16.	name := fields second.	(fields at: 11) ifNotEmpty: [ :oldname | 		name := name, Character tab asString, oldname ].	self initializeBitEncodedFieldsFrom: fields.! !!UnicodeCharacterData methodsFor: 'testing'!isCompositionExclusion	^ self class compositionExclusions includes: codePoint ! !!UnicodeCharacterData methodsFor: 'testing'!isFullCompositionExclusion	^ self isSingleton or: [ self isNonStarterDecomposition or: [ self isCompositionExclusion ] ]! !!UnicodeCharacterData methodsFor: 'testing'!isLetter	^ self generalCategory first = $L! !!UnicodeCharacterData methodsFor: 'testing'!isLowercase	^ self generalCategory = #Ll! !!UnicodeCharacterData methodsFor: 'testing'!isMark	^ self generalCategory first = $M! !!UnicodeCharacterData methodsFor: 'testing'!isNonStarterDecomposition	^ self hasCanonicalDecomposition 			and: [ self isSingleton not				and: [ 					self isStarter not 						or: [ (self class forCodePoint: self decompositionMapping first) isStarter not ] ] ]! !!UnicodeCharacterData methodsFor: 'testing'!isNumber	^ self generalCategory first = $N! !!UnicodeCharacterData methodsFor: 'testing'!isNumberDecimal	^ self generalCategory = #Nd! !!UnicodeCharacterData methodsFor: 'testing'!isNumberLetter	^ self generalCategory = #Nl! !!UnicodeCharacterData methodsFor: 'testing'!isNumberOther	^ self generalCategory = #No! !!UnicodeCharacterData methodsFor: 'testing'!isOther	^ self generalCategory first = $C! !!UnicodeCharacterData methodsFor: 'testing'!isPrimaryComposite	^ self hasCanonicalDecomposition and: [ self isFullCompositionExclusion not ]! !!UnicodeCharacterData methodsFor: 'testing'!isPunctuation	^ self generalCategory first = $P! !!UnicodeCharacterData methodsFor: 'testing'!isSeparator	^ self generalCategory first = $Z! !!UnicodeCharacterData methodsFor: 'testing'!isSingleton	^ self hasCanonicalDecomposition and: [ self decompositionMapping size = 1 ]! !!UnicodeCharacterData methodsFor: 'testing'!isStarter	^ self canonicalCombiningClass = 0! !!UnicodeCharacterData methodsFor: 'testing'!isSymbol	^ self generalCategory first = $S! !!UnicodeCharacterData methodsFor: 'testing'!isTitlecase	^ self generalCategory = #Lt! !!UnicodeCharacterData methodsFor: 'testing'!isUppercase	^ self generalCategory = #Lu! !!UnicodeCharacterData methodsFor: 'accessing'!jamoShortName	"As the name only exists for the few hangul base characters, they are kept in a separate table, rather than as general properties"		^ self class jamoShortNames at: self codePoint ifAbsent: ''! !!UnicodeCharacterData methodsFor: 'accessing'!lowercase	"Return the codepoint of the lowercase version of my codepoint. Could be nil if not applicable"		^ self caseMapping ifNotNil: [ :caseMapping | caseMapping second ]! !!UnicodeCharacterData methodsFor: 'accessing'!mirrored	"Return if my codepoint is mirrored or not"		^ (bitEncodedFields bitAt: 19) = 1! !!UnicodeCharacterData methodsFor: 'accessing'!name	"Return my official name"		| tabIndex |	tabIndex := name indexOf: Character tab ifAbsent: [ ^ name ].	^ name copyFrom: 1 to: tabIndex - 1! !!UnicodeCharacterData methodsFor: 'accessing'!names	"Return our internal name(s) representation <NAME><TAB>[<OLD-NAME>]"		^ name! !!UnicodeCharacterData methodsFor: 'accessing'!numericMapping	"If not nil, a 3 element array: { decimalDigit. digit. numeric } each of which could be nil.	Use the accessors #decimalDigitValue, #digitValue or #numericValue instead"	^ nil! !!UnicodeCharacterData methodsFor: 'accessing'!numericValue	"Return the numeric value of my codepoint as an integer. Could be nil if not applicable."	^ self numericMapping ifNotNil: [ :numericMapping | numericMapping third ]! !!UnicodeCharacterData methodsFor: 'accessing'!oldName	"Return my old/legacy name, could be nil"		| tabIndex |	tabIndex := name indexOf: Character tab ifAbsent: [ ^ nil ].	^ name copyFrom: tabIndex + 1 to: name size! !!UnicodeCharacterData methodsFor: 'printing'!printOn: stream	stream << 'U+'.	self codePoint printOn: stream base: 16 nDigits: 4.	stream space; << self name.	self oldName ifNotNil: [ stream space; nextPut: $(; << self oldName; nextPut: $) ]! !!UnicodeCharacterData methodsFor: 'gt-spotter-extension'!spotterPreviewIn: aComposite	<spotterPreview: 10>	^ aComposite table		title: 'Unicode Character';		display: [			{				{ 'codepoint'. self codePoint }.				{ 'codepoint hex'. 					String streamContents: [ :stream | 						stream << 'U+'.						self codePoint printOn: stream base: 16 nDigits: 4 ].					self codePoint }.				{ 'character'. self character printString. self character }.				{ 'name'. self name }.				{ 'old name'. self oldName ifNil: [ '' ]. self oldName }.				{ 'general category'. self generalCategory }.				{ 'canonical combining class'. self canonicalCombiningClass }.				{ 'bidirectional category'. self bidirectionalCategory }.				{ 'mirrored'. self mirrored }.				{ 'uppercase'. 					self uppercase ifNotNil: [ :n | Character codePoint: n ] ifNil: [ '' ]. 					self class forCodePoint: self uppercase ifAbsent: [] }.				{ 'lowercase'. 					self lowercase ifNotNil: [ :n | Character codePoint: n ] ifNil: [ '' ]. 					self class forCodePoint: self lowercase ifAbsent: [] }.				{ 'titlecase'. 					self titlecase ifNotNil: [ :n | Character codePoint: n ] ifNil: [ '' ]. 					self class forCodePoint: self titlecase ifAbsent: [] }.				{ 'decimal digit value'. self decimalDigitValue ifNil: [ '' ]. self decimalDigitValue }.				{ 'digit value'. self digitValue ifNil: [ '' ]. self digitValue }.				{ 'numeric value'. self numericValue ifNil: [ '' ]. self numericValue }.				{ 'decomposition'. self decompositionDescription. self decompositionAsUCDs }			} ];		column: 'Key' evaluated: #first;		column: 'Value' evaluated: [ :entry | entry second asString ];		entity: self! !!UnicodeCharacterData methodsFor: 'accessing'!titlecase	"Return the codepoint of the titlecase version of my codepoint. Could be nil if not applicable"	^ self caseMapping ifNotNil: [ :caseMapping | caseMapping third ]! !!UnicodeCharacterData methodsFor: 'accessing'!uppercase	"Return the codepoint of the uppercase version of my codepoint. Could be nil if not applicable"	^ self caseMapping ifNotNil: [ :caseMapping | caseMapping first ]! !!UnicodeCharacterDataExtended methodsFor: 'accessing'!caseMapping	"If not nil, a 3 element array: { upper. lower. title } each of which could be nil.	Use the accessors #uppercase, #lowercase or #titlecase instead"		^ caseMapping! !!UnicodeCharacterDataExtended methodsFor: 'accessing'!decompositionMapping	"Return my decomposition mapping if applicable, an array of code points, with an optional symbol tag in the first position. The code points of my decomposition can be combined into my codepoint."		^ decompositionMapping! !!UnicodeCharacterDataExtended methodsFor: 'testing'!hasDecomposition	^ decompositionMapping notNil! !!UnicodeCharacterDataExtended methodsFor: 'private'!initializeCaseMappingFrom: fields	| uppercase lowercase titlecase |	uppercase := (fields at: 13) ifEmpty: [ ] ifNotEmpty: [ :each | Integer readFrom: each base: 16 ].	lowercase := (fields at: 14) ifEmpty: [ ] ifNotEmpty: [ :each | Integer readFrom: each base: 16 ].	titlecase := (fields at: 15) ifEmpty: [ ] ifNotEmpty: [ :each | Integer readFrom: each base: 16 ].	uppercase notNil | lowercase notNil | titlecase notNil		ifTrue: [ caseMapping := Array with: uppercase with: lowercase with: titlecase ]! !!UnicodeCharacterDataExtended methodsFor: 'private'!initializeDecompositionMappingFrom: fields	decompositionMapping := fields sixth ifEmpty: [  ] ifNotEmpty: [ :mapping | self parseDecompositionMapping: mapping ]! !!UnicodeCharacterDataExtended methodsFor: 'initialize'!initializeFrom: fields	super initializeFrom: fields.	self initializeDecompositionMappingFrom: fields.	self initializeNumericMappingFrom: fields.	self initializeCaseMappingFrom: fields! !!UnicodeCharacterDataExtended methodsFor: 'initialize'!initializeFromHangulSyllable: anInteger 	"Derived from hangul syllable code point. 	Ref. http://www.unicode.org/versions/Unicode8.0.0/ch03.pdf section 3.12 page 145, bottom part"	| sIndex vIndex tIndex lIndex lPart vPart tPart |	(self class isHangulSyllableCodePoint: anInteger)		ifFalse: [ DomainError signal: 'Hangul syllable outside range' from: 16rAC00 to: 16rD7A3 ].	"sBase := 16rAC00. lBase := 16r1100. vBase := 16r1161. tBase := 16r11A7.	 lCount := 19. vCount := 21. tCount := 28. nCount := 588."	codePoint := anInteger.	sIndex := codePoint - 16rAC00.	lIndex := sIndex // 588.	vIndex := sIndex \\ 588 // 28.	tIndex := sIndex \\ 28.	lPart := 16r1100 + lIndex.	vPart := 16r1161 + vIndex.	tPart := 16r11A7 + tIndex.	decompositionMapping := tIndex = 0 		ifTrue: [ Array with: lPart with: vPart ] 		ifFalse: [ Array with: lPart with: vPart with: tPart ] .	name := decompositionMapping 		inject: 'HANGUL SYLLABLE ' 		into: [ :sub :next | sub , (self class jamoShortNames at: next) ].	bitEncodedFields := 0 "CCC=0, General=#Lu, Bidi=#L, mirrored=false"! !!UnicodeCharacterDataExtended methodsFor: 'private'!initializeNumericMappingFrom: fields	| decimalDigitValue digitValue numericValue |	decimalDigitValue := (fields at: 7) ifEmpty: [ ] ifNotEmpty: [ :each | each asNumber ]. 	digitValue := (fields at: 8) ifEmpty: [ ] ifNotEmpty: [ :each | each asNumber ]. 	numericValue := (fields at: 9) ifEmpty: [ ] ifNotEmpty: [ :each | each asNumber ].	decimalDigitValue notNil | digitValue notNil | numericValue notNil		ifTrue: [ numericMapping := Array with: decimalDigitValue with: digitValue with: numericValue ]! !!UnicodeCharacterDataExtended methodsFor: 'accessing'!numericMapping	"If not nil, a 3 element array: { decimalDigit. digit. numeric } each of which could be nil.	Use the accessors #decimalDigitValue, #digitValue or #numericValue instead"	^ numericMapping! !!UnicodeCharacterDataExtended methodsFor: 'private'!parseDecompositionMapping: string	^ ((Character space split: string)			collect: [ :each |				each first = $<					ifTrue: [ (each copyFrom: 2 to: each size - 1) asSymbol ]					ifFalse: [ Integer readFrom: each base: 16 ] ]) asArray! !"Unicode-Character-Data"!!CharacterFromCodePointReadStream commentStamp: '' prior: 0!I am CharacterFromCodePointReadStream, I wrap a code point Integer ReadStream and translate code point Integers to Characters.For example	(97 to: 122) readStream is a ReadStream that returns Integers, while	(97 to: 122) readStream unicodeCharacters	is a ReadStream that returns the Character objects for each code point.	(97 to: 122) readStream unicodeCharacters upToEndIn effect I translate each Integer code point to a Character.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!CharacterToCodePointWriteStream commentStamp: '' prior: 0!I am CharacterToCodePointWriteStream. I wrap a code point Integer WriteStream and translate Characters to Integer code points.Here is an example	Array streamContents: [ :out |		out unicodeCharacters nextPut: $A; nextPutAll: 'bcde' ]	So client code writes Characters and Strings while the underlying stream receives Integer code points,In effect I translate each Character to an Integer code point.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!CodePointFromCharacterReadStream commentStamp: '' prior: 0!I am CodePointFromCharacterReadStream, I wrap a Character ReadStream and translate Characters into code point Integers.For example	'abc' readStream is a ReadStream that returns Character objects, while	'abc' readStream unicodeCodePoints	is a ReadStream that returns the Integer code points of each character.	Character alphabet  readStream unicodeCodePoints upToEndIn effect I translate each Character to an Integer code point.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!CodePointToCharacterWriteStream commentStamp: '' prior: 0!I am CodePointToCharacterWriteStream. I wrap a Character WriteStream and translate code point Integers into Characters.Here is an example	String streamContents: [ :out |		out unicodeCodePoints nextPutAll: (97 to: 122); nextPut: 33 ]	So client code writes Integer code points while the underlying stream receives Character objects.In effect I translate each Integer code point to a Character.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!WriteStream methodsFor: '*unicode-stream-support'!unicodeCharacters	"Assuming the receiver is a stream over Integer code points, return a CharacterToCodePointWriteStream over the receiver that streams over Characters"		^ CharacterToCodePointWriteStream on: self! !!WriteStream methodsFor: '*unicode-stream-support'!unicodeCodePoints	"Assuming the receiver is a stream over Characters, return a CodePointToCharacterWriteStream over the receiver that streams over Integer code points"		^ CodePointToCharacterWriteStream on: self! !!CharacterFromCodePointReadStream class methodsFor: 'initialization'!on: codePointReadStream	^ self new		on: codePointReadStream;		yourself! !!CharacterFromCodePointReadStream methodsFor: 'streaming'!atEnd	^ readStream atEnd! !!CharacterFromCodePointReadStream methodsFor: 'streaming'!next	^ readStream next ifNotNil: [ :codePoint | Character codePoint: codePoint ]! !!CharacterFromCodePointReadStream methodsFor: 'initialization'!on: codePointReadStream	readStream := codePointReadStream ! !!CharacterFromCodePointReadStream methodsFor: 'streaming'!peek	^ readStream peek ifNotNil: [ :codePoint | Character codePoint: codePoint ]! !!CharacterFromCodePointReadStream methodsFor: 'converting'!unicodeCodePoints	"Return a CodePointFromCharacterReadStream over the receiver that streams over Integer code points"		^ CodePointFromCharacterReadStream on: self! !!CharacterFromCodePointReadStream methodsFor: 'streaming'!upToEnd	| out character |	out := (String new: 10) writeStream.	[ self atEnd ] whileFalse: [ 		character := self next.		(character isOctetCharacter not and: [ out originalContents isWideString not ])			ifTrue: [ | position wideString |				position := out position.				wideString := WideString from: out originalContents.				out on: wideString; setFrom: position + 1 to: position ].		out nextPut: character ].	^ out contents! !!CharacterToCodePointWriteStream class methodsFor: 'initialization'!on: codePointWriteStream	^ self new		on: codePointWriteStream;		yourself! !!CharacterToCodePointWriteStream methodsFor: 'streaming'!nextPut: character	writeStream nextPut: character codePoint! !!CharacterToCodePointWriteStream methodsFor: 'streaming'!nextPutAll: collection	collection do: [ :each | self nextPut: each ]! !!CharacterToCodePointWriteStream methodsFor: 'initialization'!on: codePointWriteStream	writeStream := codePointWriteStream ! !!CodePointFromCharacterReadStream class methodsFor: 'initialization'!on: characterReadStream	^ self new		on: characterReadStream;		yourself! !!CodePointFromCharacterReadStream methodsFor: 'streaming'!atEnd	^ readStream atEnd! !!CodePointFromCharacterReadStream methodsFor: 'streaming'!next	^ readStream next ifNotNil: [ :character | character codePoint ]! !!CodePointFromCharacterReadStream methodsFor: 'initialization'!on: characterReadStream	readStream := characterReadStream ! !!CodePointFromCharacterReadStream methodsFor: 'streaming'!peek	^ readStream peek ifNotNil: [ :character | character codePoint ]! !!CodePointFromCharacterReadStream methodsFor: 'streaming'!reset	^ readStream reset! !!CodePointFromCharacterReadStream methodsFor: 'converting'!unicodeCharacters	"Return a CharacterFromCodePointReadStream over the receiver that streams over Characters"		^ CharacterFromCodePointReadStream on: self! !!CodePointFromCharacterReadStream methodsFor: 'streaming'!upToEnd	^ Array streamContents: [ :out |			[ self atEnd ] whileFalse: [ out nextPut: self next ] ]! !!CodePointToCharacterWriteStream class methodsFor: 'initialization'!on: characterWriteStream	^ self new		on: characterWriteStream;		yourself! !!CodePointToCharacterWriteStream methodsFor: 'streaming'!nextPut: codePoint	writeStream nextPut: (Character codePoint: codePoint)! !!CodePointToCharacterWriteStream methodsFor: 'streaming'!nextPutAll: collection	collection do: [ :each | self nextPut: each ]! !!CodePointToCharacterWriteStream methodsFor: 'initialization'!on: characterWriteStream	writeStream := characterWriteStream ! !!ReadStream methodsFor: '*unicode-stream-support'!unicodeCharacters	"Assuming the receiver is a stream over Integer code points, return a CharacterFromCodePointReadStream over the receiver that streams over Characters"		^ CharacterFromCodePointReadStream on: self! !!ReadStream methodsFor: '*unicode-stream-support'!unicodeCodePoints	"Assuming the receiver is a stream over Characters, return a CodePointFromCharacterReadStream over the receiver that streams over Integer code points"		^ CodePointFromCharacterReadStream on: self! !"Unicode-Stream-Support"!!UnicodeCaser commentStamp: '' prior: 0!I am UnicodeCaser, a tool to change the case of a string of Unicode characters to lower, upper or title case.Currently, this implementation is too simplistic.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!UnicodeCaser methodsFor: 'public'!case: case from: inputStream to: outputStream	self assert: (#(uppercase lowercase titelcase) includes: case).	inputStream do: [ :each |		| unicodeCharacterData |		unicodeCharacterData := each unicodeCharacterData.		(unicodeCharacterData perform: case)			ifNil: [ outputStream nextPut: each ] 			ifNotNil: [ :value | outputStream nextPut: value ] ]! !!UnicodeCaser methodsFor: 'public'!case: case fromCharacters: inputStream to: outputStream	self assert: (#(uppercase lowercase titelcase) includes: case).	inputStream do: [ :each |		(each unicodeCharacterData perform: case)			ifNil: [ outputStream nextPut: each ] 			ifNotNil: [ :value | outputStream nextPut: (Character codePoint: value) ] ]! !!UnicodeCaser methodsFor: 'convencience'!case: case string: string	^ String streamContents: [ :out |			self case: case fromCharacters: string readStream to: out ]! !"Unicode-Casing"!!UnicodeComposer commentStamp: '' prior: 0!I am UnicodeComposer. I compose streams of unicode code points to their composed form.I have two primary interfaces.The first is #composeFrom:to: that operates from an input stream of code points to an output stream of code points in one process.The second is #composeBuffer: the elementary operation of the above process that operates on a buffer of non-starters between a first and final starter. Note that this buffer can shrink.Streaming composition can be done by UnicodeComposingReadStream that uses me for buffer composition.I can only work 100% correct if my input is properly decomposed. If my input is NFD, my output will be NFC. If my input is NFKD, my output will be NFKC.I know how to do algorithmic composition of Hangul.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!UnicodeComposingReadStream commentStamp: '' prior: 0!I am UnicodeComposingReadStream. I wrap an input read stream of (normally decomposed) code points and produce a composed normalized stream of code points.I use UnicodeComposer to compose intermediate buffers.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!UnicodeConcatenator commentStamp: '' prior: 0!I am UnicodeConcatenator, for a given normalization form I can concatenate two strings.This implements the algorithm described in the last paragraph of section 9.1 Stable Code Points of http://www.unicode.org/reports/tr15/ Unicode Normalization.Try:  UnicodeConcatenator forNFC concatenateString: 'abce' with: '́def'.  UnicodeConcatenator forNFC concatenateCodePoints: #(97 98 99 101) with: #(769 100 101 102).The last character of the first string $e (U+0065 LATIN SMALL LETTER E) and the first character of the second string $́ (U+0301 COMBINING ACUTE ACCENT aka NON-SPACING ACUTE) combine to $é (U+00E9 LATIN SMALL LETTER E WITH ACUTE) in the resulting concatenation. Also note that both the first and second string had 4 characters, while their concatenation has 7. This is why concatenation of Unicode strings is non-trivial.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!UnicodeDecomposedNormalizationForm commentStamp: '' prior: 0!I am a Decomposed Normalization Form.I know how to perform the two main steps of the Unicode decomposition algorithm: - Recursively decompose a code point into a buffer- Recursively decompose a stream of non-starter codepoints into a buffer.These operations rely on no state, and as such are implemented on the class side.For pure string operations, decomposehttp://unicode.org/reports/tr15/#Description_NormPart of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!UnicodeNFD commentStamp: '' prior: 0!I am  Normalized Form D, Canonical Decomposition.The valid code point sequences  code points decompose to in this form, cannot be marked as a Compatible decomposition in the Unicode database.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!UnicodeNFKD commentStamp: '' prior: 0!I am  Normalized Form KD, Compatibility Decomposition.The valid code point sequences  code points decompose to in this form, cannot be marked as a Compatible decomposition in the Unicode database.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!UnicodeDecomposer commentStamp: '' prior: 0!I am UnicodeDecomposer. I decompose streams of Unicode code points using either Canonical or Compatible combinations, NFD and NFKD, using #decomposeFrom:to: and #decomposeCompatibleFrom:to:  respectively.I use the Unicode Character Database to recursively decompose combined characters.An alternative, streaming implementation of the process that I implement can be found in UnicodeDecomposingReadStream's two concrete subclasses.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!UnicodeDecomposingReadStream commentStamp: '' prior: 0!UnicodeDecomposingReadStream  is a streaming implementation of  the Unicode Normalization Algorithm for the Decomposed Forms.It wraps an input read stream of code points and produces a  stream of code points in the decomposed  form the stream was created as. An  alternate implementation of the same, operating on strings, rather than streams, can be found in UnicodeDecomposer.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!UnicodeNormalizer commentStamp: '' prior: 0!I am UnicodeNormalizer, I implement the normalize operation which transforms Unicode text into an equivalent composed or decomposed normal form, allowing for easier comparing, searching and sorting of text. I implement the forms NFC, NFD, NFKC and NFKD.I can handle String and code point collections.This is a high level interface that applies two fast path optimalizations: - don't do work on ASCII or Latin1 string when it is not needed - do a normalization quick check to see if normalization is really neededPart of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!UnicodeComposer class methodsFor: 'accessing'!default	^ Default ifNil: [ Default := self new ]! !!UnicodeComposer class methodsFor: 'accessing'!resetDefault	Default := nil! !!UnicodeComposer methodsFor: 'private - combinations'!combinationOf: first and: second	second ifNil: [ ^ nil ].	^ (self hangulCombinationOf: first and: second) 			ifNil: [ self primaryCombinationOf: first and: second ]! !!UnicodeComposer methodsFor: 'accessing'!combinations	combinations ifNil: [ self initializeForComposition ].	^ combinations! !!UnicodeComposer methodsFor: 'accessing'!combiningCharacters	combiningCharacters ifNil: [ self initializeForComposition ].	^ combiningCharacters! !!UnicodeComposer methodsFor: 'public'!composeBuffer: buffer		"Process decomposed CCC ordered buffer, trying to combine/compose pairs, unless blocked"	| lastCCC index ccc combination |	lastCCC := 0.	index := 2.	[ index <= buffer size ] whileTrue: [		ccc := [ (buffer at: index) unicodeCharacterData ccc ] on: NotFound do: [ 0 ].		combination := self combinationOf: buffer first and: (buffer at: index).		(combination notNil and: [ (lastCCC < ccc) | (lastCCC = 0) ])			ifTrue: [ 				buffer at: 1 put: combination.				buffer removeAt: index ]			ifFalse: [ 				index := index + 1. 				lastCCC := ccc ] ]! !!UnicodeComposer methodsFor: 'public'!composeFrom: input to: output	| buffer |	buffer := OrderedCollection new.	(self scanForStarterFrom: input to: output)		ifNotNil: [ :nonStarter | buffer addLast: nonStarter ].	[ input atEnd ] whileFalse: [		self scanUntilStarterFrom: input to: buffer.		"Compose the buffer <starter1> ... <starter2>" 		self composeBuffer: buffer.		"We're done, flush everything except <starter2> which we keep for the next iteration"		buffer allButLastDo: [ :each | output nextPut: each ].		buffer last in: [ :last | buffer reset; addLast: last ] ].	output nextPutAll: buffer! !!UnicodeComposer methodsFor: 'convencience'!composeString: string	"Return the NFC of string, the canonical composition normal form"		string isByteString ifTrue: [		"Latin1 strings are already in NFC" 		^ string ]. 	^ String streamContents: [ :out |			self 				composeFrom: string readStream unicodeCodePoints				to: out unicodeCodePoints ]! !!UnicodeComposer methodsFor: 'private - combinations'!hangulCombinationOf: first and: second	"Algorithmic Hangul Syllable Componsition.	Ref. http://www.unicode.org/versions/Unicode8.0.0/ch03.pdf section 3.12 page 146"		(self hangulLVCombinationOf: first and: second)		ifNotNil: [ :combination | ^ combination ].	(self hangulSTCombinationOf: first and: second)		ifNotNil: [ :combination | ^ combination ].	^ nil! !!UnicodeComposer methodsFor: 'private - combinations'!hangulCombinationOf: lPart and: vPart and: tPart	"Algorithmic Hangul Syllable Componsition.	Ref. http://www.unicode.org/versions/Unicode8.0.0/ch03.pdf section 3.12 page 146"		| lIndex vIndex tIndex |	"sBase := 16rAC00. lBase := 16r1100. vBase := 16r1161. tBase := 16r11A7.   nCount := 588. tCount := 28."	^ ((lPart between: 16r1100 and: 16r1112) 			and: [ (vPart between: 16r1161 and: 16r1175)				and: [ tPart between: 16r11A7 and: 16r11C2 ] ])				ifTrue: [ 					lIndex := lPart - 16r1100.					vIndex := vPart - 16r1161.					tIndex := tPart - 16r11A7.					16rAC00 + (lIndex * 588) + (vIndex * 28) + tIndex ]! !!UnicodeComposer methodsFor: 'private - combinations'!hangulLVCombinationOf: lPart and: vPart	"Algorithmic Hangul Syllable Componsition.	Ref. http://www.unicode.org/versions/Unicode8.0.0/ch03.pdf section 3.12 page 146"		| lIndex vIndex |	"sBase := 16rAC00. lBase := 16r1100. vBase := 16r1161.   nCount := 588. tCount := 28."	^ ((lPart between: 16r1100 and: 16r1112) 		and: [ vPart between: 16r1161 and: 16r1175 ])			ifTrue: [ 				lIndex := lPart - 16r1100.				vIndex := vPart - 16r1161.				^ 16rAC00 + (lIndex * 588) + (vIndex * 28) ]! !!UnicodeComposer methodsFor: 'private - combinations'!hangulSTCombinationOf: sPart and: tPart	"Algorithmic Hangul Syllable Componsition.	Ref. http://www.unicode.org/versions/Unicode8.0.0/ch03.pdf section 3.12 page 146"		| tIndex |	"sBase := 16rAC00. lBase := 16r1100. vBase := 16r1161.   nCount := 588. tCount := 28."	^ ((sPart between: 16rAC00 and: 16rD7A3)		and: [ (tPart between: 16r11A7 and: 16r11C2)			and: [ sPart - 16rAC00 \\ 28 = 0 ] ])			ifTrue: [ 				tIndex := tPart - 16r11A7.				sPart + tIndex ]! !!UnicodeComposer methodsFor: 'initialize'!initializeForComposition	combinations := IdentityDictionary new.	combiningCharacters := IdentitySet new.	UnicodeCharacterData database valuesDo: [ :each |		each isPrimaryComposite ifTrue: [ | combination |			combination := each decompositionMapping.			"combination first + combination second = each codePoint"			combinations 				at: combination first 				ifPresent: [ :value | 					value at: combination second put: each codePoint ]				ifAbsent: [ | value |					value := IdentityDictionary new at: combination second put: each codePoint; yourself.					combinations at: combination first put: value ].			combiningCharacters add: combination second ] ]! !!UnicodeComposer methodsFor: 'testing'!isCombiningCharacter: codePoint	^ self combiningCharacters includes: codePoint! !!UnicodeComposer methodsFor: 'private - combinations'!primaryCombinationOf: first and: second	"Resolve Primary Composition using inverse computed table"		^ (self isCombiningCharacter: second)			ifTrue: [ 				self combinations 					at: first 					ifPresent: [ :compositions | 						compositions at: second ifAbsent: [ ] ] 					ifAbsent: [ ] ]! !!UnicodeComposer methodsFor: 'private'!scanForStarterFrom: input to: output	| current |	"Find the first starter in input and return it, else copy to output"	[ input atEnd ] whileFalse: [ 		current := input next.		([ current unicodeCharacterData isStarter ] on: NotFound do: [ false ])			ifTrue: [ ^ current ]			ifFalse: [ output nextPut: current ] ].	^ nil! !!UnicodeComposer methodsFor: 'private'!scanUntilStarterFrom: input to: buffer	| current |	"Put non-starters and the next starter from input in the buffer, if any"	[ input atEnd ] whileFalse: [ 		current := input next.		buffer addLast: current.		([ current unicodeCharacterData isStarter ] on: NotFound do: [ false ])			ifTrue: [ ^ self ] ]! !!UnicodeComposingReadStream class methodsFor: 'initialization'!on: codePointReadStream	^ self new		on: codePointReadStream;		yourself! !!UnicodeComposingReadStream methodsFor: 'streaming'!atEnd	^ buffer isEmpty and: [ self isFirstEmpty and: [ input atEnd ] ]! !!UnicodeComposingReadStream methodsFor: 'private'!consumeFirst	| current |	current := first.	first := nil.	^ current! !!UnicodeComposingReadStream methodsFor: 'initialization'!initialize	super initialize.	buffer := OrderedCollection new.	composer := UnicodeComposer default! !!UnicodeComposingReadStream methodsFor: 'private'!isFirstEmpty	^ first isNil or: [ first = #initialized ]! !!UnicodeComposingReadStream methodsFor: 'streaming'!next	self isFirstEmpty		ifFalse: [ ^ self consumeFirst ].	self shouldGetNextChunk 		ifTrue: [ self nextChunk ].	self isFirstEmpty		ifFalse: [ ^ self consumeFirst ].	buffer ifEmpty: [ ^ nil ].	^ buffer removeFirst! !!UnicodeComposingReadStream methodsFor: 'private'!nextChunk	"Initialize when needed, try putting first starter in buffer"	first = #initialized 		ifFalse: [ 			self scanFirstStarter 				ifFalse: [ "Non-starter is in first" ^ self ] ].	"buffer = <starter1>"	[		self scanUntilStarter.		"buffer = <starter1> ... <starter2>"		composer composeBuffer: buffer ] 			doWhileFalse: [ buffer size > 1 or: [ input atEnd ] ]	"There has to be more than one element in the buffer unless we're eof.	Composition shrinks the buffer, sometimes recursively, but can need additional starters"! !!UnicodeComposingReadStream methodsFor: 'initialization'!on: codePointReadStream	input := codePointReadStream ! !!UnicodeComposingReadStream methodsFor: 'streaming'!peek	self isFirstEmpty		ifFalse: [ ^ first ].	self shouldGetNextChunk 		ifTrue: [ self nextChunk ].	self isFirstEmpty		ifFalse: [ ^ first ].	buffer ifEmpty: [ ^ nil ].	^ buffer first! !!UnicodeComposingReadStream methodsFor: 'streaming'!reset	input reset.	buffer removeAll! !!UnicodeComposingReadStream methodsFor: 'private'!scanFirstStarter	| current |	"Find the first starter in input to use, put it in buffer and return true.	Else put the non-starter in first and return false.	Switch to #initialized once we've seen the first starter or when empty."	input atEnd ifFalse: [ 		current := input next.		([ current unicodeCharacterData isStarter ] on: NotFound do: [ false ])			ifTrue: [ 				buffer addLast: current. 				first := #initialized. 				^ true ]			ifFalse: [ 				first := current. 				^ false ] ].	first := #inialized.	^ false! !!UnicodeComposingReadStream methodsFor: 'private'!scanUntilStarter	| current |	"Put non-starters and the next starter from input in the buffer, if any"	[ input atEnd ] whileFalse: [ 		current := input next.		buffer addLast: current.		([ current unicodeCharacterData isStarter ] on: NotFound do: [ false ])			ifTrue: [ ^ self ] ]! !!UnicodeComposingReadStream methodsFor: 'private'!shouldGetNextChunk	"One element should remain in the buffer for the next iteration unless we're eof"		^ buffer isEmpty or: [ buffer size = 1 and: [ input atEnd not] ]! !!UnicodeComposingReadStream methodsFor: 'converting'!unicodeCharacters	"Return a CharacterFromCodePointReadStream over the receiver that streams over Characters"		^ CharacterFromCodePointReadStream on: self! !!UnicodeComposingReadStream methodsFor: 'streaming'!upToEnd	^ Array streamContents: [ :out |			[ self atEnd ] whileFalse: [ out nextPut: self next ] ]! !!UnicodeConcatenator class methodsFor: 'instance creation'!forNFC	^ self new forNFC! !!UnicodeConcatenator class methodsFor: 'instance creation'!forNFD	^ self new forNFD! !!UnicodeConcatenator class methodsFor: 'instance creation'!forNFKC	^ self new forNFKC! !!UnicodeConcatenator class methodsFor: 'instance creation'!forNFKD	^ self new forNFKD! !!UnicodeConcatenator methodsFor: 'private'!codePointsToNFC: codePoints	^ codePoints readStream unicodeNFC upToEnd! !!UnicodeConcatenator methodsFor: 'private'!codePointsToNFD: codePoints	^ codePoints readStream unicodeNFD upToEnd! !!UnicodeConcatenator methodsFor: 'private'!codePointsToNFKC: codePoints	^ codePoints readStream unicodeNFKC upToEnd! !!UnicodeConcatenator methodsFor: 'private'!codePointsToNFKD: codePoints	^ codePoints readStream unicodeNFKD upToEnd! !!UnicodeConcatenator methodsFor: 'public'!concatenateCodePoints: first with: second	| lastStable firstStable middle result |	first ifEmpty: [ ^ second ].	second ifEmpty: [ ^ first ].	lastStable := first findLast: self isStableCodePointBlock.	lastStable = 0 ifTrue: [ lastStable := 1 ].	firstStable := second findFirst: self isStableCodePointBlock.	firstStable = 0 ifTrue: [ firstStable := second size ].	(lastStable = first size and: [ firstStable = 1 ]) ifTrue: [ ^ first , second ].	middle := (first copyFrom: lastStable to: first size) , (second copyFrom: 1 to: firstStable).	middle := self normalizeCodePoints: middle.	result := first class new: (lastStable - 1 + middle size + second size - firstStable).	result 		replaceFrom: 1 to: lastStable - 1 with: first startingAt: 1;		replaceFrom: lastStable to: lastStable + middle size - 1 with: middle startingAt: 1;		replaceFrom: lastStable + middle size to: result size with: second startingAt: firstStable + 1. 	^ result! !!UnicodeConcatenator methodsFor: 'public'!concatenateString: first with: second	| lastStable firstStable middle result |	first ifEmpty: [ ^ second ].	second ifEmpty: [ ^ first ].	lastStable := first findLast: self isStableCharacterBlock.	lastStable = 0 ifTrue: [ lastStable := 1 ].	firstStable := second findFirst: self isStableCodePointBlock.	firstStable = 0 ifTrue: [ firstStable := second size ].	(lastStable = first size and: [ firstStable = 1 ]) ifTrue: [ ^ first , second ].	middle := (first copyFrom: lastStable to: first size) , (second copyFrom: 1 to: firstStable).	middle := self normalizeString: middle.	result := first class new: (lastStable - 1 + middle size + second size - firstStable).	result 		replaceFrom: 1 to: lastStable - 1 with: first startingAt: 1;		replaceFrom: lastStable to: lastStable + middle size - 1 with: middle startingAt: 1;		replaceFrom: lastStable + middle size to: result size with: second startingAt: firstStable + 1. 	^ result! !!UnicodeConcatenator methodsFor: 'initalize'!forNFC	property := #NFC.! !!UnicodeConcatenator methodsFor: 'initalize'!forNFD	property := #NFD.! !!UnicodeConcatenator methodsFor: 'initalize'!forNFKC	property := #NFKC.! !!UnicodeConcatenator methodsFor: 'initalize'!forNFKD	property := #NFKD.! !!UnicodeConcatenator methodsFor: 'private'!isStableCharacterBlock	| quickCheckProperty |	quickCheckProperty := self quickCheckProperty.	^ [ :each | 		([ each unicodeCharacterData isStarter ] on: NotFound do: [ true ]) 			and: [ (UnicodeCharacterData normalizationQuickCheck: quickCheckProperty forCodePoint: each codePoint) = #Y ] ]! !!UnicodeConcatenator methodsFor: 'private'!isStableCodePointBlock	| quickCheckProperty |	quickCheckProperty := self quickCheckProperty.	^ [ :each | 		([ each unicodeCharacterData isStarter ] on: NotFound do: [ true ]) 			and: [ (UnicodeCharacterData normalizationQuickCheck: quickCheckProperty forCodePoint: each) = #Y ] ]! !!UnicodeConcatenator methodsFor: 'private'!normalizeCodePoints: codePoints	| method |	method := (#codePointsTo, property) asSymbol asMutator.	^ self perform: method with: codePoints ! !!UnicodeConcatenator methodsFor: 'private'!normalizeString: string	| method |	method := (#stringTo, property) asSymbol asMutator.	^ self perform: method with: string ! !!UnicodeConcatenator methodsFor: 'acccessing'!quickCheckProperty	^ (property , #'_QC') asSymbol! !!UnicodeConcatenator methodsFor: 'private'!stringToNFC: string	^ UnicodeNormalizer new toNFC: string! !!UnicodeConcatenator methodsFor: 'private'!stringToNFD: string	^ UnicodeNormalizer new toNFD: string! !!UnicodeConcatenator methodsFor: 'private'!stringToNFKC: string	^ UnicodeNormalizer new toNFKC: string! !!UnicodeConcatenator methodsFor: 'private'!stringToNFKD: string	^ UnicodeNormalizer new toNFKD: string! !!UnicodeDecomposedNormalizationForm class methodsFor: 'private'!add: codePoint cccOrderedTo: buffer	| ccc index stop otherCCC |	ccc := [ codePoint unicodeCharacterData ccc ] on: NotFound do: [ 0 ].	index := buffer size.	ccc = 0 		ifFalse: [			stop := false.			[ index > 0 & stop not ] whileTrue: [ 				otherCCC := [ (buffer at: index) unicodeCharacterData ccc ] on: NotFound do: [ 0 ].				ccc < otherCCC					ifTrue: [ index := index - 1 ]					ifFalse: [ stop := true ] ] ].	buffer add: codePoint afterIndex: index! !!UnicodeDecomposedNormalizationForm class methodsFor: 'conversion'!addMapping: codePoint to: buffer	(self decompositionEntryOf: codePoint)		ifNotNil: [ :entry | entry decompositionMappingDo: [ :each | self addMapping: each to: buffer]]		ifNil: [ self add: codePoint cccOrderedTo: buffer ]! !!UnicodeDecomposedNormalizationForm class methodsFor: 'conversion'!addNonStartersFrom: input to: buffer	| stop |	stop := false.	[ input atEnd | stop ] whileFalse: [ 		([ self isNonStarter: input peek ] on: NotFound do: [ false ])			ifTrue: [ self addMapping: input next to: buffer ]			ifFalse: [ stop := true ] ]! !!UnicodeDecomposedNormalizationForm class methodsFor: 'private'!decompositionEntryOf: aCodePoint	"Return a UnicodeCharacterDate instance that holds the decomposition mapping I care about for aCodePoint"	^self subclassResponsibility ! !!UnicodeDecomposedNormalizationForm class methodsFor: 'private'!isNonStarter: codePoint	"If we have a decomposition, we need to see if decomposed, we will be a nonStarter.	Assume there is no decomposition on form NonStarter,*,Starter,* (which would make very little sense...)"	(self decompositionEntryOf: codePoint)		ifNotNil: [ :entry | entry decompositionMappingDo: [ :onlyFirst | ^ self isNonStarter: onlyFirst ] ]		ifNil:			[ | ucd |			ucd := [ codePoint unicodeCharacterData ] on: NotFound do: [nil].			^ucd notNil and: [ ucd isStarter not ] ].! !!UnicodeNFD class methodsFor: 'private'!decompositionEntryOf: aCodePoint	"Return a Unicode Data Entry if it has a decomposition of my form"	|ucd|	ucd := [ aCodePoint unicodeCharacterData ] on: NotFound do: [nil].	^(ucd notNil and: [ucd hasCanonicalDecomposition]) ifTrue: [ucd]! !!UnicodeNFKD class methodsFor: 'private'!decompositionEntryOf: aCodePoint	"Return a Unicode Data Entry if it has a decomposition of my form"	|ucd|	ucd := [ aCodePoint unicodeCharacterData ] on: NotFound do: [nil].	^(ucd notNil and: [ucd hasDecomposition]) ifTrue: [ucd]! !!UnicodeDecomposer methodsFor: 'private'!decompose: inputStream to: outputStream	| buffer |	form ifNil: 		[ ^self error: 'decompose:to: should not be called directly' ].	buffer := OrderedCollection new.	[ inputStream atEnd ]		whileFalse:			[ form addMapping: inputStream next to: buffer.			form addNonStartersFrom: inputStream to: buffer.			"The additions to the buffer above were done respecting the CCC order, so we're done"			outputStream nextPutAll: buffer.			buffer reset ]! !!UnicodeDecomposer methodsFor: 'public'!decomposeCompatibleFrom: input to: output	form := UnicodeNFKD.	self decompose: input to: output.	! !!UnicodeDecomposer methodsFor: 'public'!decomposeFrom: input to: output	form := UnicodeNFD.	self decompose: input to: output! !!UnicodeDecomposer methodsFor: 'convencience'!decomposeString: string	"Return the NFD of string, the canonical decomposition normal form"		(string isByteString and: [ string isAsciiString ])		ifTrue: ["ACII strings are already in NFD"			 ^ string ].		^ String		streamContents:			[ :out | 			form := UnicodeNFD.			self				decompose: string readStream unicodeCodePoints				to: out unicodeCodePoints ]! !!UnicodeDecomposer methodsFor: 'convencience'!decomposeStringCompatible: string	"Return the NFKD of string, the compatible decomposition normal form"		(string isByteString and: [ string isAsciiString ]) 		ifTrue: ["ACII strings are already in NFKD" 			^ string ]. 	^ String streamContents: [ :out |			form := UnicodeNFKD.			self 				decompose: string readStream unicodeCodePoints				to: out unicodeCodePoints ]! !!UnicodeDecomposingReadStream class methodsFor: 'initialization'!form: aDecomposedNormalizationForm on: codePointReadStream	^ self new		form: aDecomposedNormalizationForm on: codePointReadStream;		yourself! !!UnicodeDecomposingReadStream class methodsFor: 'initialization'!nfdFormOn: codePointReadStream	^ self 		form: UnicodeNFD		on: codePointReadStream! !!UnicodeDecomposingReadStream class methodsFor: 'initialization'!nfkdFormOn: codePointReadStream	^ self 		form: UnicodeNFKD		on: codePointReadStream! !!UnicodeDecomposingReadStream methodsFor: 'streaming'!atEnd	^ buffer isEmpty and: [ input atEnd ]! !!UnicodeDecomposingReadStream methodsFor: 'initialization'!form: aDecomposedNormalizationForm on: codePointReadStream	form := aDecomposedNormalizationForm.	input := codePointReadStream ! !!UnicodeDecomposingReadStream methodsFor: 'initialization'!initialize	super initialize.	buffer := OrderedCollection new! !!UnicodeDecomposingReadStream methodsFor: 'streaming'!next	buffer ifEmpty: [ self nextChunk ].	buffer ifEmpty: [ ^ nil ].	^ buffer removeFirst! !!UnicodeDecomposingReadStream methodsFor: 'private'!nextChunk	input atEnd		ifFalse: [  			form addMapping: input next to: buffer.			form addNonStartersFrom: input to: buffer.			"The additions to the buffer above were done respecting the CCC order, so we're done" ]! !!UnicodeDecomposingReadStream methodsFor: 'initialization'!on: codePointReadStream	input := codePointReadStream ! !!UnicodeDecomposingReadStream methodsFor: 'streaming'!peek	buffer ifEmpty: [ self nextChunk ].	buffer ifEmpty: [ ^ nil ].	^ buffer first! !!UnicodeDecomposingReadStream methodsFor: 'streaming'!reset	input reset.	buffer removeAll! !!UnicodeDecomposingReadStream methodsFor: 'converting'!unicodeCharacters	"Return a CharacterFromCodePointReadStream over the receiver that streams over Characters"		^ CharacterFromCodePointReadStream on: self! !!UnicodeDecomposingReadStream methodsFor: 'converting'!unicodeCompose	"Return a NeoUnicodeComposingReadStream over the receiver that streams over Integer code points after composing them"		^ UnicodeComposingReadStream on: self! !!UnicodeDecomposingReadStream methodsFor: 'streaming'!upToEnd	^ Array streamContents: [ :out |			[ self atEnd ] whileFalse: [ out nextPut: self next ] ]! !!UnicodeNormalizer methodsFor: 'public'!composeString: string	"Return the NFC of string, the canonical composition normal form"		(self isAlreadyNFC: string) ifTrue: [ ^ string ]. 	^ string readStream unicodeCodePoints unicodeNFC unicodeCharacters upToEnd! !!UnicodeNormalizer methodsFor: 'public'!composeStringCompatible: string	"Return the NFKC of string, the compatible composition normal form"		(self isAlreadyNFKC: string) ifTrue: [ ^ string ]. 	^ string readStream unicodeCodePoints unicodeNFKC unicodeCharacters upToEnd! !!UnicodeNormalizer methodsFor: 'public'!decomposeString: string	"Return the NFD of string, the canonical decomposition normal form"		(self isAlreadyNFD: string) ifTrue: [ ^ string ]. 	^ string readStream unicodeCodePoints unicodeNFD unicodeCharacters upToEnd! !!UnicodeNormalizer methodsFor: 'public'!decomposeStringCompatible: string	"Return the NFKD of string, the compatible decomposition normal form"		(self isAlreadyNFKD: string) ifTrue: [ ^ string ]. 	^ string readStream unicodeCodePoints unicodeNFKD unicodeCharacters upToEnd! !!UnicodeNormalizer methodsFor: 'testing'!isAlreadyNFC: string	"Return true when we know string is already in NFC form, false otherwise.	This uses a quick check algorithm.	False means we don't know, but it is still possible. 	The only way to know for sure is to do the actual conversion."		"Latin1 strings are always in NFC"	^ string isByteString or: [ 		(UnicodeCharacterData normalizationQuickCheck: #NFC_QC forString: string) = #Y ]! !!UnicodeNormalizer methodsFor: 'testing'!isAlreadyNFD: string	"Return true when we know string is already in NFD form, false otherwise.	This uses a quick check algorithm.	False means we don't know, but it is still possible. 	The only way to know for sure is to do the actual conversion."	"ASCII strings are always in NFD"	^ (string isByteString and: [ string isAsciiString ])		or: [ (UnicodeCharacterData normalizationQuickCheck: #NFD_QC forString: string) = #Y ]! !!UnicodeNormalizer methodsFor: 'testing'!isAlreadyNFKC: string	"Return true when we know string is already in NFKC form, false otherwise.	This uses a quick check algorithm.	False means we don't know, but it is still possible. 	The only way to know for sure is to do the actual conversion."	"ASCII strings are always in NFKC"	^ (string isByteString and: [ string isAsciiString ])		or: [ (UnicodeCharacterData normalizationQuickCheck: #NFKC_QC forString: string) = #Y ]! !!UnicodeNormalizer methodsFor: 'testing'!isAlreadyNFKD: string	"Return true when we know string is already in NFKD form, false otherwise.	This uses a quick check algorithm.	False means we don't know, but it is still possible. 	The only way to know for sure is to do the actual conversion."	"ASCII strings are always in NFKD"	^ (string isByteString and: [ string isAsciiString ])		or: [ (UnicodeCharacterData normalizationQuickCheck: #NFKD_QC forString: string) = #Y ]! !!UnicodeNormalizer methodsFor: 'testing'!isNFC: string	"Return true when string is in NFC form, false otherwise"		^ string = (self toNFC: string)! !!UnicodeNormalizer methodsFor: 'testing'!isNFD: string	"Return true when string is in NFD form, false otherwise"		^ string = (self toNFD: string)! !!UnicodeNormalizer methodsFor: 'testing'!isNFKC: string	"Return true when string is in NFC form, false otherwise"		^ string = (self toNFKC: string)! !!UnicodeNormalizer methodsFor: 'testing'!isNFKD: string	"Return true when string is in NFKD form, false otherwise"		^ string = (self toNFKD: string)! !!UnicodeNormalizer methodsFor: 'public'!toNFC: string	^ self composeString: string! !!UnicodeNormalizer methodsFor: 'public'!toNFD: string	^ self decomposeString: string! !!UnicodeNormalizer methodsFor: 'public'!toNFKC: string	^ self composeStringCompatible: string! !!UnicodeNormalizer methodsFor: 'public'!toNFKD: string	^ self decomposeStringCompatible: string! !!CodePointFromCharacterReadStream methodsFor: '*unicode-normalization'!unicodeCompose	"Return a UnicodeComposingReadStream over the receiver that streams over Integer code points after composing them"		^ UnicodeComposingReadStream on: self! !!CodePointFromCharacterReadStream methodsFor: '*unicode-normalization'!unicodeNFC	"Return a UnicodeComposingReadStream over the receiver that streams over Integer code points composing them after decomposing them canonically"		^ self unicodeNFD unicodeCompose! !!CodePointFromCharacterReadStream methodsFor: '*unicode-normalization'!unicodeNFD	"Return a UnicodeNFDReadStream over the receiver that streams over Integer code points after decomposing them canonically"		^ UnicodeDecomposingReadStream nfdFormOn: self! !!CodePointFromCharacterReadStream methodsFor: '*unicode-normalization'!unicodeNFKC	"Return a UnicodeComposingReadStream over the receiver that streams over Integer code points composing them after decomposing them compatibly"		^ self unicodeNFKD unicodeCompose! !!CodePointFromCharacterReadStream methodsFor: '*unicode-normalization'!unicodeNFKD	"Return a UnicodeNFKDReadStream over the receiver that streams over Integer code points after decomposing them compatibly"		^ UnicodeDecomposingReadStream nfkdFormOn: self! !!ReadStream methodsFor: '*unicode-normalization'!unicodeCompose	"Assuming the receiver is a stream over Integer code points, return a UnicodeComposingReadStream over the receiver that streams over Integer code points after composing them"		^ UnicodeComposingReadStream on: self! !!ReadStream methodsFor: '*unicode-normalization'!unicodeNFC	"Assuming the receiver is a stream over Integer code points, return a UnicodeComposingReadStream over the receiver that streams over Integer code points composing them after decomposing them canonically"		^ self unicodeNFD unicodeCompose! !!ReadStream methodsFor: '*unicode-normalization'!unicodeNFD	"Assuming the receiver is a stream over Integer code points, return a UnicodeNFDReadStream over the receiver that streams over Integer code points after decomposing them canonically"		^ UnicodeDecomposingReadStream nfdFormOn: self! !!ReadStream methodsFor: '*unicode-normalization'!unicodeNFKC	"Assuming the receiver is a stream over Integer code points, return a UnicodeComposingReadStream over the receiver that streams over Integer code points composing them after decomposing them compatibly"		^ self unicodeNFKD unicodeCompose! !!ReadStream methodsFor: '*unicode-normalization'!unicodeNFKD	"Assuming the receiver is a stream over Integer code points, return a UnicodeNFKDReadStream over the receiver that streams over Integer code points after decomposing them compatibly"		^ UnicodeDecomposingReadStream nfkdFormOn: self! !"Unicode-Normalization"!!UnicodeCharacterDataTests methodsFor: 'testing'!testDigitOne	| unicodeCharacterData |	unicodeCharacterData := $1 unicodeCharacterData.	self assert: unicodeCharacterData codePoint equals: 49.	self assert: unicodeCharacterData character equals: $1.	self assert: unicodeCharacterData name equals: 'DIGIT ONE'.	self assert: unicodeCharacterData isNumber.	self deny: unicodeCharacterData isLetter.	self assert: unicodeCharacterData isNumberDecimal.	self assert: unicodeCharacterData decimalDigitValue equals: 1! !!UnicodeCharacterDataTests methodsFor: 'testing'!testLatinCapitalLetterA	| unicodeCharacterData |	unicodeCharacterData := $A unicodeCharacterData.	self assert: unicodeCharacterData codePoint equals: 65.	self assert: unicodeCharacterData character equals: $A.	self assert: unicodeCharacterData name equals: 'LATIN CAPITAL LETTER A'.	self assert: unicodeCharacterData isLetter.	self deny: unicodeCharacterData isNumber.	self assert: unicodeCharacterData isUppercase.	self assert: unicodeCharacterData lowercase equals: $a codePoint! !!UnicodeCharacterDataTests methodsFor: 'testing'!testLatinSmallLetterA	| unicodeCharacterData |	unicodeCharacterData := $a unicodeCharacterData.	self assert: unicodeCharacterData codePoint equals: 97.	self assert: unicodeCharacterData character equals: $a.	self assert: unicodeCharacterData name equals: 'LATIN SMALL LETTER A'.	self assert: unicodeCharacterData isLetter.	self deny: unicodeCharacterData isNumber.	self assert: unicodeCharacterData isLowercase.	self assert: unicodeCharacterData uppercase equals: $A codePoint! !!UnicodeCharacterDataTests methodsFor: 'testing'!testLatinSmallLetterEWithAcute	| unicodeCharacterData |	unicodeCharacterData := $é unicodeCharacterData.	"LATIN SMALL LETTER E WITH ACUTE [U+00E9]"	self assert: unicodeCharacterData codePoint equals: 233.	self assert: unicodeCharacterData character equals: $é.	self assert: unicodeCharacterData name equals: 'LATIN SMALL LETTER E WITH ACUTE'.	self assert: unicodeCharacterData isLetter.	self deny: unicodeCharacterData isNumber.	self assert: unicodeCharacterData isLowercase.	self assert: unicodeCharacterData uppercase equals: $É codePoint.	self assert: unicodeCharacterData hasStandardCanonicalDecomposition.	"LATIN SMALL LETTER E [U+0065] followed by COMBINING ACUTE ACCENT [U+0301]"	self assert: unicodeCharacterData decompositionMapping equals: #(101 769)! !"Unicode-Tests-Character-Data"!!UnicodeCaserTests methodsFor: 'running'!setUp	caser := UnicodeCaser new! !!UnicodeCaserTests methodsFor: 'testing'!testLowercase	self assert: (caser case: #lowercase string: 'ABC') equals: 'abc'.	self assert: (caser case: #lowercase string: '123 !!= abc') equals: '123 !!= abc'.! !!UnicodeCaserTests methodsFor: 'testing'!testUppercase	self assert: (caser case: #uppercase string: 'abc') equals: 'ABC'.	self assert: (caser case: #uppercase string: '123 !!= ABC') equals: '123 !!= ABC'.! !"Unicode-Tests-Casing"!!UnicodeNormalizerConformanceTests commentStamp: '' prior: 0!This test uses http://www.unicode.org/Public/UNIDATA/NormalizationTest.txt to run about 75.000 individual test cases to test conformance to the official Unicode Normalization specification.!!UnicodeNormalizationTestResource commentStamp: '' prior: 0!I hold the contents of NormalizationTest.txt loaded from a URL.  UnicodeNormalizationTestResource new setUphttp://www.unicode.org/Public/UNIDATA/NormalizationTest.txt# Normalization Test Suite# Format:##   Columns (c1, c2,...) are separated by semicolons#   They have the following meaning:#      source; NFC; NFD; NFKC; NFKD#   Comments are indicated with hash marks#   Each of the columns may have one or more code points.## CONFORMANCE:# 1. The following invariants must be true for all conformant implementations##    NFC#      c2 ==  toNFC(c1) ==  toNFC(c2) ==  toNFC(c3)#      c4 ==  toNFC(c4) ==  toNFC(c5)##    NFD#      c3 ==  toNFD(c1) ==  toNFD(c2) ==  toNFD(c3)#      c5 ==  toNFD(c4) ==  toNFD(c5)##    NFKC#      c4 == toNFKC(c1) == toNFKC(c2) == toNFKC(c3) == toNFKC(c4) == toNFKC(c5)##    NFKD#      c5 == toNFKD(c1) == toNFKD(c2) == toNFKD(c3) == toNFKD(c4) == toNFKD(c5)## 2. For every code point X assigned in this version of Unicode that is not specifically#    listed in Part 1, the following invariants must be true for all conformant#    implementations:##      X == toNFC(X) == toNFD(X) == toNFKC(X) == toNFKD(X)!!UnicodeConcatenatorTests methodsFor: 'testing'!testASCII	self 		assert: (UnicodeConcatenator forNFC concatenateString: 'abc' with: 'def')		equals: 'abcdef'	! !!UnicodeConcatenatorTests methodsFor: 'testing'!testDiacritics	self 		assert: (UnicodeConcatenator forNFC concatenateString: 'éle' with: '̀ves')		equals: 'élèves'.	self 		assert: (UnicodeConcatenator forNFC concatenateString: 'Ko' with: '̈nigsallee')		equals: 'Königsallee'.	! !!UnicodeConcatenatorTests methodsFor: 'testing'!testSimple	self 		assert: (UnicodeConcatenator forNFC concatenateCodePoints: #(97 98 99 101) with: #(769 100 101 102))		equals: #(97 98 99 233 100 101 102)	! !!UnicodeNormalizerConformanceTests class methodsFor: 'accessing'!resources	^ Array with: UnicodeNormalizationTestResource ! !!UnicodeNormalizerConformanceTests methodsFor: 'running'!setUp	normalizer := UnicodeNormalizer new.	composer := UnicodeComposer default.	decomposer := UnicodeDecomposer new! !!UnicodeNormalizerConformanceTests methodsFor: 'accessing'!specification	^ UnicodeNormalizationTestResource current data! !!UnicodeNormalizerConformanceTests methodsFor: 'testing'!testNFC	| failed succeeded |	failed := OrderedCollection new.	succeeded := 0.	self specification do: [ :spec | | nfd result |		nfd := Array streamContents: [ :out |			decomposer decomposeFrom: (spec at: #source) readStream to: out ].		result := Array streamContents: [ :out |			composer composeFrom: nfd readStream to: out ].		result = (spec at: #NFC)			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed add: spec -> result ] ].	self crTrace: ('#testNFC {1}/{2} ({3}%)' format: { 		succeeded. self specification size. 		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).	self assert: failed isEmpty! !!UnicodeNormalizerConformanceTests methodsFor: 'testing'!testNFCStreaming	| failed succeeded |	failed := OrderedCollection new.	succeeded := 0.	self specification do: [ :spec | | result |		result := (spec at: #source) readStream unicodeNFC upToEnd.		result = (spec at: #NFC)			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed add: spec -> result ] ].	self crTrace: ('#testNFCStreaming {1}/{2} ({3}%)' format: { 		succeeded. self specification size. 		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).	self assert: failed isEmpty! !!UnicodeNormalizerConformanceTests methodsFor: 'testing'!testNFCString	| failed succeeded |	failed := OrderedCollection new.	succeeded := 0.	self specification do: [ :spec | | in out result |		in := (spec at: #source) collect: #asCharacter as: WideString.		out := normalizer toNFC: in.		result := out collect: #codePoint as: Array.		result = (spec at: #NFC)			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed add: spec -> result ] ].	self crTrace: ('#testNFCString {1}/{2} ({3}%)' format: { 		succeeded. self specification size. 		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).	self assert: failed isEmpty! !!UnicodeNormalizerConformanceTests methodsFor: 'testing'!testNFD	| failed succeeded |	failed := OrderedCollection new.	succeeded := 0.	self specification do: [ :spec | | result |		result := Array streamContents: [ :out |			decomposer decomposeFrom: (spec at: #source) readStream to: out ].		result = (spec at: #NFD)			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed add: spec -> result ] ].	self crTrace: ('#testNFD {1}/{2} ({3}%)' format: { 		succeeded. self specification size. 		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).	self assert: failed isEmpty! !!UnicodeNormalizerConformanceTests methodsFor: 'testing'!testNFDStreaming	| failed succeeded |	failed := OrderedCollection new.	succeeded := 0.	self specification do: [ :spec | | result |		result := (spec at: #source) readStream unicodeNFD upToEnd.		result = (spec at: #NFD)			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed add: spec -> result ] ].	self crTrace: ('#testNFDStreaming {1}/{2} ({3}%)' format: { 		succeeded. self specification size. 		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).	self assert: failed isEmpty! !!UnicodeNormalizerConformanceTests methodsFor: 'testing'!testNFDString	| failed succeeded |	failed := OrderedCollection new.	succeeded := 0.	self specification do: [ :spec | | in out result |		in := (spec at: #source) collect: #asCharacter as: WideString.		out := normalizer toNFD: in.		result := out collect: #codePoint as: Array.		result = (spec at: #NFD)			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed add: spec -> result ] ].	self crTrace: ('#testNFDString {1}/{2} ({3}%)' format: { 		succeeded. self specification size. 		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).	self assert: failed isEmpty! !!UnicodeNormalizerConformanceTests methodsFor: 'testing'!testNFKC	| failed succeeded |	failed := OrderedCollection new.	succeeded := 0.	self specification do: [ :spec | | nfkd result |		nfkd := Array streamContents: [ :out |			decomposer decomposeCompatibleFrom: (spec at: #source) readStream to: out ].		result := Array streamContents: [ :out |			composer composeFrom: nfkd readStream to: out ].		result = (spec at: #NFKC)			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed add: spec -> result ] ].	self crTrace: ('#testNFKC {1}/{2} ({3}%)' format: { 		succeeded. self specification size. 		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).	self assert: failed isEmpty! !!UnicodeNormalizerConformanceTests methodsFor: 'testing'!testNFKCStreaming	| failed succeeded |	failed := OrderedCollection new.	succeeded := 0.	self specification do: [ :spec | | result |		result := (spec at: #source) readStream unicodeNFKC upToEnd.		result = (spec at: #NFKC)			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed add: spec -> result ] ].	self crTrace: ('#testNFKCStreaming {1}/{2} ({3}%)' format: { 		succeeded. self specification size. 		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).	self assert: failed isEmpty! !!UnicodeNormalizerConformanceTests methodsFor: 'testing'!testNFKCString	| failed succeeded |	failed := OrderedCollection new.	succeeded := 0.	self specification do: [ :spec | | in out result |		in := (spec at: #source) collect: #asCharacter as: WideString.		out := normalizer toNFKC: in.		result := out collect: #codePoint as: Array.		result = (spec at: #NFKC)			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed add: spec -> result ] ].	self crTrace: ('#testNFKCString {1}/{2} ({3}%)' format: { 		succeeded. self specification size. 		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).	self assert: failed isEmpty! !!UnicodeNormalizerConformanceTests methodsFor: 'testing'!testNFKD	| failed succeeded |	failed := OrderedCollection new.	succeeded := 0.	self specification do: [ :spec | | result |		result := Array streamContents: [ :out |			decomposer decomposeCompatibleFrom: (spec at: #source) readStream to: out ].		result = (spec at: #NFKD)			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed add: spec -> result ] ].	self crTrace: ('#testNFKD {1}/{2} ({3}%)' format: { 		succeeded. self specification size. 		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).	self assert: failed isEmpty! !!UnicodeNormalizerConformanceTests methodsFor: 'testing'!testNFKDStreaming	| failed succeeded |	failed := OrderedCollection new.	succeeded := 0.	self specification do: [ :spec | | result |		result := (spec at: #source) readStream unicodeNFKD upToEnd.		result = (spec at: #NFKD)			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed add: spec -> result ] ].	self crTrace: ('#testNFKDStreaming {1}/{2} ({3}%)' format: { 		succeeded. self specification size. 		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).	self assert: failed isEmpty! !!UnicodeNormalizerConformanceTests methodsFor: 'testing'!testNFKDString	| failed succeeded |	failed := OrderedCollection new.	succeeded := 0.	self specification do: [ :spec | | in out result |		in := (spec at: #source) collect: #asCharacter as: WideString.		out := normalizer toNFKD: in.		result := out collect: #codePoint as: Array.		result = (spec at: #NFKD)			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed add: spec -> result ] ].	self crTrace: ('#testNFKDString {1}/{2} ({3}%)' format: { 		succeeded. self specification size. 		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).	self assert: failed isEmpty! !!UnicodeNormalizerTests methodsFor: 'running'!setUp	normalizer := UnicodeNormalizer new.	composer := UnicodeComposer default.	decomposer := UnicodeDecomposer new! !!UnicodeNormalizerTests methodsFor: 'tests'!testAsciiIsAlwaysNormalized	| ascii nfc nfd nfkc nfkd |	"ASCII strings are identical to all 4 normalization forms"	ascii := String withAll: ((0 to: 127) collect: #asCharacter).	"we have to circumvent the optimizations done in the convenience methods"	nfc := ascii readStream unicodeCodePoints unicodeNFC unicodeCharacters upToEnd.	self assert: nfc equals: ascii. 	nfd := ascii readStream unicodeCodePoints unicodeNFD unicodeCharacters upToEnd.	self assert: nfd equals: ascii. 	nfkc := ascii readStream unicodeCodePoints unicodeNFKC unicodeCharacters upToEnd.	self assert: nfkc equals: ascii. 	nfkd := ascii readStream unicodeCodePoints unicodeNFKD unicodeCharacters upToEnd.	self assert: nfkd equals: ascii! !!UnicodeNormalizerTests methodsFor: 'tests'!testFundamentalComposition	| in out |	"LATIN SMALL LETTER E [U+0065] followed by COMBINING ACUTE ACCENT [U+0301]"	in := #(101 769).	out := Array streamContents: [ :writeStream |		composer composeFrom: in readStream to: writeStream ].	"LATIN SMALL LETTER E WITH ACUTE [U+00E9]"	self assert: out equals: #(233)! !!UnicodeNormalizerTests methodsFor: 'tests'!testFundamentalDecomposition	| in out |	"LATIN SMALL LETTER E WITH ACUTE [U+00E9]"	in := #(233).	out := Array streamContents: [ :writeStream |		decomposer decomposeFrom: in readStream to: writeStream ].	"LATIN SMALL LETTER E [U+0065] followed by COMBINING ACUTE ACCENT [U+0301]"	self assert: out equals: #(101 769).! !!UnicodeNormalizerTests methodsFor: 'tests'!testHangul	"an lpart - vpart pair"	self 		assert: 16rAC1C unicodeCharacterData decompositionMapping 		equals: #(16r1100 16r1162).	self		assert: (composer hangulCombinationOf: 16r1100 and: 16r1162)		equals: 16rAC1C.		"an lpart - vpart - tpart triplet"	self 		assert: 16rD4DB unicodeCharacterData decompositionMapping 		equals: #(16r1111 16r1171 16r11B6).	self		assert: (composer hangulCombinationOf: 16r1111 and: 16r1171 and: 16r11B6) 		equals: 16rD4DB.	"converting an lpart - vpart - tpart triplet in two steps"	self		assert: (composer hangulCombinationOf: 16r1111 and: 16r1171)		equals: 16rD4CC.		self		assert: (composer hangulCombinationOf: 16rD4CC and: 16r11B6)		equals: 16rD4DB	! !!UnicodeNormalizerTests methodsFor: 'tests'!testLatin1IsAlwaysInNFC	| latin1 nfc |	"Latin1 strings are identical to their NFC normalization form"	latin1 := String withAll: ((0 to: 255) collect: #asCharacter).	"we have to circumvent the optimizations done in the convenience methods"	nfc := latin1 readStream unicodeCodePoints unicodeNFC unicodeCharacters upToEnd.	self assert: nfc equals: latin1! !!UnicodeNormalizerTests methodsFor: 'tests'!testSimple	| original composed decomposed |	original := 'les élèves Français'.	decomposed := normalizer decomposeString: original.	self assert: decomposed equals: 'les élèves Français'.	composed := normalizer composeString: decomposed.	self assert: composed equals: original.	original := 'Düsseldorf Königsallee'.	decomposed := normalizer decomposeString: original.	self assert: decomposed equals: 'Düsseldorf Königsallee'.	composed := normalizer composeString: decomposed.	self assert: composed equals: original.	! !!UnicodeNormalizationTestResource methodsFor: 'running'!ccc0CharWithCCCDecompositionPrecededByHigherCCC	"Oh, tibetan...	The only language with codepoints that have a combining class of 0, but a canonical decomposition of code points with ccc > 0. That these sort correctly when decomposed next to other CC > 0 is not tested by the official decomposition test file, so add a case for doing so here. These are also excluded for composition, see http://www.unicode.org/Public/8.0.0/ucd/CompositionExclusions.txt section 4""# 0F73 TIBETAN VOWEL SIGN II # 0F75 TIBETAN VOWEL SIGN UU # 0F81 TIBETAN VOWEL SIGN REVERSED II"	^ SmallDictionary new		at: #source put: #(16r0591 16r0F81);		at: #NFC put: #(16r0F71 16r0F80 16r0591);		at: #NFD put: #(16r0F71 16r0F80 16r0591);		at: #NFKC put: #(16r0F71 16r0F80 16r0591);		at: #NFKD put: #(16r0F71 16r0F80 16r0591);		yourself! !!UnicodeNormalizationTestResource methodsFor: 'accessing'!data	"A collection of dictionaries with keys: #source #NFC #NFD #NFKC #NFKD and #comment"		^ data! !!UnicodeNormalizationTestResource methodsFor: 'accessing'!normalizationTestFile	^ 'NormalizationTest.txt'! !!UnicodeNormalizationTestResource methodsFor: 'parsing'!parseLine: line	| columns test comment |	columns := $; split: line.	test := SmallDictionary new.	#(#source #NFC #NFD #NFKC #NFKD) doWithIndex: [ :key :number | 		| value |		value := columns at: number.		value := $  split: value.		value := value collect: [ :each | Integer readFrom: each base: 16 ] as: Array.		test at: key put: value ].	comment := line copyFrom: (line indexOf: $#) + 2 to: line size.	test at: #comment put: comment.	^ test! !!UnicodeNormalizationTestResource methodsFor: 'running'!setUp	data := Array streamContents: [ :out | 		(UnicodeCharacterData getUnicodeCharacterDatabaseRaw: self normalizationTestFile) linesDo: [ :line | 			(line isEmpty or: [ line first = $# or: [ line first = $@ ] ])				ifFalse: [ 					| test |					test := self parseLine: line.					out nextPut: test ] ].			out nextPut: self ccc0CharWithCCCDecompositionPrecededByHigherCCC ].! !"Unicode-Tests-Normalization"!!OSSAbstractUnixSubprocessTest methodsFor: 'helpers'!commandClass	^ OSSUnixSubprocess ! !!OSSAbstractUnixSubprocessTest methodsFor: 'instance creation'!newCommand		^ self commandClass new! !!OSSAbstractUnixSubprocessTest methodsFor: 'private'!systemAccessor	^ OSSVMProcess vmProcess systemAccessor! !!OSSPipeTest methodsFor: 'private'!blockingPipe	^ self systemAccessor makeBlockingPipe	! !!OSSPipeTest methodsFor: 'private'!nonBlockingPipe	^ self systemAccessor makeNonBlockingPipe	! !!OSSPipeTest methodsFor: 'private'!readFromAndClose: aPipe writingTo: aStream	| s |	[aPipe atEndOfFile] whileFalse:		[s := aPipe next: 10000.		aStream nextPutAll: s asString.		(Delay forMilliseconds: 100) wait].	(aPipe respondsTo: #reader) ifTrue: [aPipe reader close].	^ aStream! !!OSSPipeTest methodsFor: 'testing'!testBasicWriteAndRead	| pipe string readString |	string := 'this is a testing string'. 	pipe := self blockingPipe.	pipe writer nextPutAll: string; flush.	readString := pipe reader next: string size.	self assert: string equals: readString! !!OSSPipeTest methodsFor: 'testing'!testBlocking	| pipe |	pipe := self blockingPipe.	(1 to: 10) do: [:i | pipe nextPutAll: 'this is line ', i printString; cr].	pipe flush. "protect against buggy clib that may never flush output"	self should: ['this is line 1*' match: (pipe next: 15)].	self should: ['this is line 2*' match: (pipe next: 15)].	self should: ['this is line 3*' match: (pipe next: 15)].	self should: ['this is line 4*' match: (pipe next: 15)].	self should: ['this is line 5*' match: (pipe next: 15)].	self should: ['this is line 6*' match: (pipe next: 15)].	self should: ['this is line 7*' match: (pipe next: 15)].	self should: ['this is line 8*' match: (pipe next: 15)].	self should: ['this is line 9*' match: (pipe next: 15)].	pipe writer close.	self shouldnt: pipe atEnd.	self should: ['this is line 10*' match: (pipe next: 16)].	self should: pipe atEnd.	pipe close! !!OSSPipeTest methodsFor: 'testing'!testBlockingPeek		| pipe |	pipe := self blockingPipe.	pipe nextPutAll: 'abc'.	pipe flush. "protect against buggy clib that may never flush output"	self assert: (pipe peek == $a).	self assert: (pipe next == $a).	self assert: (pipe peek == $b).	self assert: (pipe next == $b).	self assert: (pipe peek == $c).	self deny: pipe atEnd.	self assert: (pipe next == $c).	self deny: pipe atEnd.	pipe closeWriter.	self assert: pipe atEnd.	pipe close! !!OSSPipeTest methodsFor: 'testing'!testIsAtEndOfFile	| pipe |	pipe := self nonBlockingPipe.	self deny: (pipe reader atEndOfFile).	self deny: pipe reader atEnd.	self deny: pipe atEnd.	self assert: (pipe reader basicNext == nil).	self deny: (pipe reader atEndOfFile).	self deny: pipe reader atEnd.	self deny: pipe atEnd.	pipe writer nextPut: $X; flush.	self assert: (pipe reader basicNext == $X).	self deny: (pipe reader atEndOfFile).	self deny: pipe reader atEnd.	self deny: pipe atEnd.	self assert: (pipe reader basicNext == nil).	self deny: (pipe reader atEndOfFile).	self deny: pipe reader atEnd.	self deny: pipe atEnd.	pipe writer close.	self deny: (pipe reader atEndOfFile).	self deny: pipe atEndOfFile. "no read yet, so flag has not been set"		"From Pharo 7 on, #atEnd does detect EOF on a pipe"	SystemVersion current major >= 7		ifTrue: [ self assert: pipe reader atEnd ].	self assert: pipe atEnd. "writer closed and read gives nil"	self assert: (pipe reader basicNext == nil). "read operation should set flag"	self assert: (pipe reader atEndOfFile).	"From Pharo 7 on, #atEnd does detect EOF on a pipe"	SystemVersion current major >= 7		ifTrue: [ self assert: pipe reader atEnd ].		self assert: pipe reader atEndOfFile.	self assert: pipe atEnd.	pipe close! !!OSSPipeTest methodsFor: 'testing'!testIsAtEndOfFile2	| pipe string |	pipe := self nonBlockingPipe.	[pipe nextPutAll: 'hello'; flush.	string := pipe next: 100.	self assert: string = 'hello'.	self deny: pipe atEndOfFile.	pipe closeWriter.	self deny: pipe atEndOfFile.	string := pipe next: 100.	self assert: string = ''.	self assert: pipe atEndOfFile]		ensure: [pipe close]! !!OSSPipeTest methodsFor: 'testing'!testNonBlocking	| pipe writeStream string |	pipe := self nonBlockingPipe.	self writeStuffOnThenClose: pipe.	writeStream := self readFromAndClose: pipe writingTo: (WriteStream on: String new).	string := (writeStream contents last: 16).	self should: ['this is line 10*' match: string].	pipe close! !!OSSPipeTest methodsFor: 'testing'!testNonBlockingPeek	| pipe |	pipe := self nonBlockingPipe.	pipe nextPutAll: 'abc'; flush.	self assert: (pipe peek == $a).	self assert: (pipe next == $a).	self assert: (pipe peek == $b).	self assert: (pipe next == $b).	self assert: (pipe peek == $c).	self deny: pipe atEnd.	self assert: (pipe next == $c).	self deny: pipe atEnd.	pipe closeWriter.	self assert: pipe atEnd.	pipe close! !!OSSPipeTest methodsFor: 'testing'!testReadAfterClosedReadEnd	| pipe writeStream readStream string |	string := 'this is a testing string'. 	pipe := self blockingPipe.	pipe writer nextPutAll: string; flush.	readStream := pipe reader.	pipe closeReader.	self assert: readStream closed.	self should: [ readStream upToEndOfFile ] raise: Error.	self should: [ readStream upToEnd ] raise: Error.	! !!OSSPipeTest methodsFor: 'testing'!testWriteAfterClosedWriteEnd	| pipe writeStream string |	string := 'this is a testing string'. 	pipe := self blockingPipe.	pipe closeWriter.	self should: [ pipe writer nextPutAll: string; flush ] raise: Error.	! !!OSSPipeTest methodsFor: 'private'!writeStuffOnThenClose: aPipe	^ [(1 to: 10) do:		[:i |		[aPipe nextPutAll: 'this is line ', i printString; cr]			on: Error			do: ["Ignore error. Test case will still fail, and throwing an error in this				process would cause a debugger to be scheduled inconveniently."].		(Delay forMilliseconds: 50) wait].	(aPipe respondsTo: #writer)		ifTrue: [[aPipe writer close]					on: Error					do: ["Ignore error to avoid a debugger"]]		ifFalse: [[aPipe close]					on: Error					do: ["Ignore error to avoid a debugger"]]]		forkAt: Processor userBackgroundPriority! !!OSSFileBasedUnixSubprocessTest methodsFor: 'helpers'!assertStreamsInfoWithPrevious: beforeArray	| afterArray |	afterArray := self getStreamsInfoForRunningTest.	self assert: beforeArray first equals: afterArray first.	self assert: beforeArray second equals: afterArray second.! !!OSSFileBasedUnixSubprocessTest methodsFor: 'helpers'!getStreamsInfoForRunningTest	"We obtain the open tmp files before the open files because in Pharo 7 and ealier getting the entries of /tmp using	    '/tmp' asFileReference entries	leaves the /tmp file descriptor open. Thus #numberOfOpenFiles, using lsof, detects /tmp as an open file and makes the test fail.	Fixed in Pharo 8."	| openTmpFiles |	openTmpFiles := self numberOfExistingTempStreamFiles.	^ Array with: self numberOfOpenFiles with: openTmpFiles! !!OSSFileBasedUnixSubprocessTest methodsFor: 'helpers'!newCommand	| command |	command := self commandClass new.	command defaultReadStreamCreationBlock: [ OSSUnixSubprocess createTempFileToBeUsedAsReadStreamOn: '/tmp' ].	command defaultWriteStreamCreationBlock: [ OSSUnixSubprocess createTempFileToBeUsedAsWriteStreamOn: '/tmp' ].	^ command 	! !!OSSFileBasedUnixSubprocessTest methodsFor: 'helpers'!numberOfExistingTempStreamFiles	"This answers the number of files that were created for mapping standard files.	Note that in OSSUnixSubprocessTest >> newCommand we define that temp files must be created in /tmp	and in OSSUnixSubprocess >> createTempFilename we can see the format of the name 	"		^ ('/tmp' asFileReference entries select: [ :each | 		(each name beginsWith: 'OSSUnixSubprocess-p')  and: [ each name endsWith: '.deleteme' ]  ]) size	! !!OSSFileBasedUnixSubprocessTest methodsFor: 'tests'!testBasicCommandWriteToStdin"testBasicCommandWriteToStdin  fails because of what the documentation says:	> **Important** We have found some problems when using regular files for the `stdin`. While we do not strictly forbid that, we recommend you do so only if you know very well what you are doing. Otherwise, use blocking pipes for `stdin` (default behavior)."		! !!OSSFileBasedUnixSubprocessTest methodsFor: 'tests'!testReadingFromStdoutAfterCommandFinishesDoesNotBlocksVM		"testReadingFromStdoutAfterCommandFinishesDoesNotBlocksVM fails on Travis on OSX. It looks like if another test would have run while this one was sleeping and hence in #assertStreamsInfoWithPrevious: it fails because there are 2 new not-closed files...which I suspect that those are from another running test..."	Smalltalk platform isMacOS 		ifFalse: [ super testReadingFromStdoutAfterCommandFinishesDoesNotBlocksVM ]! !!OSSFileBasedUnixSubprocessTest methodsFor: 'tests'!testReadingFromStdoutDoesNotBlocksVM	| command | 	"With files, the reading from stdout does not lock the VM"	command := self newCommand					command: '/bin/sleep';					arguments: (Array with: '4');					redirectStdout.		command run. 	self assert:[ command stdoutStream upToEnd ] timeToRun seconds <= 1. 	command waitForExit.	command closeAndCleanStreams.! !!OSSFileBasedUnixSubprocessTest methodsFor: 'tests - signals'!testSigTerm	"Same as super impl but special handling for #assertStreamsInfoWithPrevious:. Read comment at the bottom"	| process exited streamsInfo |		"We set the sunit test timeout to 2 times the sleep duration.	Otherwise default sunit test timeout is 1 minute.	This is for Pharo version >= 6.0"	(self respondsTo: #timeLimit:) ifTrue: [ 		self timeLimit: 30 seconds.	].		exited := false.	streamsInfo := self getStreamsInfoForRunningTest.	process := self newCommand.	[	process 		command: 'tail';		arguments: (Array with: '-f' with: Smalltalk image changesName);		redirectStdout;		redirectStderr;		runAndWaitPollingEvery: (Delay forMilliseconds: 500) 		doing: [ :aProcess :outStream :errStream |  		 	outStream upToEnd.			errStream upToEnd.		]		onExitDo: [ :aProcess :outStream :errStream  |			process closeAndCleanStreams.			exited := true.			self assert: aProcess exitStatusInterpreter printString equals: 'exit due to signal 15'		].	"The problem here is that we simply do a #fork this closure will continue to be executed while other test run. And so, all the test checking for zombies or opened files will fail because we can have this forked process that did not yet finish. A workaround is to simply run this closures with a higher priority so that there are less chances of other tests to be running. Another possibility would be to reject those 'tail' processes from #numberOfZombiesProcesses and #numberOfOpenFiles as all the tests that use #fork use the 'tail' OS command."		] forkAt: Processor userInterruptPriority.	(Delay forSeconds: 2) wait. 	process sigterm. 	(Delay forSeconds: 10) wait. 	self assert: exited.		[ 			"I could never understood why but only with OSSFileBasedUnixSubprocessTest and only on OSX, randomly (when running many tests together) below assertion fails. I cannod add this test as #expectedFailure because sometimes it works and then when it does it is marked as failure becasue it didn't fail. So I simply skip the test if it failed"		self assertStreamsInfoWithPrevious: streamsInfo.	] on: TestFailure do: [ self skip ]! !!OSSPipeBasedUnixSubprocessTest methodsFor: 'helper'!newCommand		^ self commandClass new			"For pipes, we can use a pipe for both reading or writing"			defaultReadStreamCreationBlock: [self systemAccessor makeBlockingPipe];			defaultWriteStreamCreationBlock: [self systemAccessor makeNonBlockingPipe];			yourself 		! !!OSSPipeBasedUnixSubprocessTest methodsFor: 'tests - streams'!testCommandTryToWriteToStdoutButHasNoReader	| command errString  | 	command := self newCommand					shellCommand: 'sleep 2; echo 42';					redirectStdout;					redirectStderr.		command run.	command stdoutStream closeReader.					command waitForExit.	"This should be a SIGPIPE because there is no reader opened for the pipe and someone is trying to write to it. " 	errString := command stderrStream upToEndOfFile.	self assert: command exitStatusInterpreter exitStatus > 0. "It ended with error".	"Ideally I would also add this assert, but it seems not all OS write this on stderr. For example,	OSX does write it, while Linux does not."	"self assert:( errString includesSubstring: 'Broken pipe')."	command closeAndCleanStreams.! !!OSSPipeBasedUnixSubprocessTest methodsFor: 'tests - streams'!testReadingFromStdoutBlocksVM	| command customStream | 	customStream := self systemAccessor makeBlockingPipe.	command := self newCommand					command: '/bin/sleep';					arguments: (Array with: '4');					redirectStdoutTo: customStream.		command run. 	self assert:[ command stdoutStream upToEnd ] timeToRun seconds > 2. 	command waitForExit.	command closeAndCleanStreams.! !!OSSPipeBasedUnixSubprocessTest methodsFor: 'tests - streams'!testReadingFromStdoutDoesNotBlocksVM	| command customStream | 	customStream := self systemAccessor makeNonBlockingPipe.	command := self newCommand					command: '/bin/sleep';					arguments: (Array with: '4');					redirectStdoutTo: customStream.		command run. 	self assert:[ command stdoutStream upToEnd ] timeToRun seconds <= 2. 	command waitForExit. 	command closeAndCleanStreams.! !!OSSUnixSubprocessTest class methodsFor: 'testing'!isAbstract	"Override to true if a TestCase subclass is Abstract and should not have	TestCase instances built from it"	^self name = #OSSUnixSubprocessTest			! !!OSSUnixSubprocessTest methodsFor: 'helpers'!assertStreamsInfoWithPrevious: anObject 	self assert: self getStreamsInfoForRunningTest equals: anObject! !!OSSUnixSubprocessTest methodsFor: 'helpers'!getStreamsInfoForRunningTest	^ self numberOfOpenFiles ! !!OSSUnixSubprocessTest methodsFor: 'helpers'!numberOfOpenFiles	"This is estimation number. Not to be used for real code. It's basically to check the number of opened FIFO files at the beginning of a test and at the end, to validate we are not leaving behind opened files.	This should work in most Unix-like and Linux systems.	Only FIFO files are checked as we can't control other threads, and it is redirecting stdio that is happening in the tests."	| tmpFileName openFiles |	tmpFileName := (FileSystem workingDirectory / 'openFilesByPharoVM-' , UUID new printString) fullName.	tmpFileName asFileReference ensureDelete.	self systemAccessor system: ('lsof -p ', OSSVMProcess vmProcess pid printString, ' > "', tmpFileName, '" 2>&1').	openFiles := tmpFileName asFileReference readStreamDo: [ :str | | lines |		lines := str contents lines.		"Count only pipes"		lines select: [ :each | each includesSubstring: 'FIFO' ]	].	tmpFileName asFileReference ensureDelete.	^ openFiles size! !!OSSUnixSubprocessTest methodsFor: 'helpers'!numberOfZombiesProcesses	"This is estimation number. Not to be used for real code. IT's basically 	to check the number of zombies at the beginning of a  test and at the end, to validate we are not leaving behind new zombies. 	This should work in most Unix-like and Linux	"	| tmpFileName zombiesCount |	tmpFileName := (FileSystem workingDirectory / 'zombiesByPharoVM-' , UUID new printString) fullName.	tmpFileName asFileReference ensureDelete.	self systemAccessor system: ('ps axo ppid=,stat= | grep ', OSSVMProcess vmProcess pid printString, ' | awk ''$2~/^Z/ { print $2 }'' | wc -l  > "', tmpFileName, '" 2>&1').	zombiesCount := tmpFileName asFileReference readStreamDo: [ :str |		str contents trimmed asNumber	].	tmpFileName asFileReference ensureDelete.	^ zombiesCount	! !!OSSUnixSubprocessTest methodsFor: 'helpers'!ppidOf: childPid	"Answers the parent pid (ppid) of the childPid	"	| tmpFileName openFilesNumber |	tmpFileName := (FileSystem workingDirectory / ' ppidof-' , UUID new printString) fullName.	tmpFileName asFileReference ensureDelete.	Transcript show: tmpFileName; cr.	self systemAccessor system: ('ps -p ', childPid , ' -o ppid=').	openFilesNumber := tmpFileName asFileReference readStreamDo: [ :str |		"The -1 is because the above command brings one line which is a header." 		str contents trimmed asNumber	].	tmpFileName asFileReference ensureDelete.	^ openFilesNumber	! !!OSSUnixSubprocessTest methodsFor: 'tests - env'!testAddAllEnvVariablesFromParent	| command | 	command := self newCommand					command: '/bin/ls';					environmentAt: 'WHATEVER' put: 'vi';					addAllEnvVariablesFromParentWithoutOverride. 	self assert: command envVariables size equals: (OSSUnixSubprocess new defaultEnvVariablesDictionary keys size) + 1.		! !!OSSUnixSubprocessTest methodsFor: 'tests - env'!testAddAllEnvVariablesFromParentWithoutOverride	| command | 	"Here we assume that the parent process will have the $PATH defined."	command := self newCommand					command: '/bin/ls';					environmentAt: 'PATH' put: 'whatever';					addAllEnvVariablesFromParentWithoutOverride. 	self assert: command envVariables size equals: (OSSUnixSubprocess new defaultEnvVariablesDictionary keys size).	self assert: (command envVariables at: 'PATH') equals: 'whatever'		! !!OSSUnixSubprocessTest methodsFor: 'tests - env'!testAddOnlyOneVariable	| command | 	command := self newCommand					command: '/bin/ls';					environmentAt: 'EDITOR' put: 'vi'.	self assert: command envVariables size equals: 1.		! !!OSSUnixSubprocessTest methodsFor: 'tests - basic'!testBasicCommand	| command |	command := self newCommand 					command: '/bin/ls'.	command runAndWait.	! !!OSSUnixSubprocessTest methodsFor: 'tests - streams'!testBasicCommandReadFromStderr	| streamsInfo |	streamsInfo := self getStreamsInfoForRunningTest.	self newCommand		command: '/bin/ls';		arguments: (Array with: '-' with: 'foo');		redirectStderr;		runAndWaitOnExitDo: [ :command :outString :errString |			self assert: (errString includesSubstring: ': No such file or directory').			self assert: command stdoutStream isNil.			self assert: command stderrStream closed.			self assertStreamsInfoWithPrevious: streamsInfo.		].		! !!OSSUnixSubprocessTest methodsFor: 'tests - streams'!testBasicCommandReadFromStdout	| streamsInfo |	streamsInfo := self getStreamsInfoForRunningTest.	self newCommand		command: '/bin/ls';		arguments: (Array with: Smalltalk image imagePath);		redirectStdout;		runAndWaitOnExitDo: [ :command :outString |			self assert: (outString includesSubstring: Smalltalk image imagePath).			self assertStreamsInfoWithPrevious: streamsInfo.		].		! !!OSSUnixSubprocessTest methodsFor: 'tests - basic'!testBasicCommandWithArgument	| command | 		command := self newCommand					command: '/bin/ls';					arguments: { Smalltalk image imagePath. }.		command runAndWait! !!OSSUnixSubprocessTest methodsFor: 'tests - basic'!testBasicCommandWithNonAsciiArgument	| command | 		self withNonAsciiDirectoryDo: [ :dir |		command := self newCommand					command: '/bin/ls';					arguments: { dir fullName }.		command runAndWait	]! !!OSSUnixSubprocessTest methodsFor: 'tests - basic'!testBasicCommandWithoutFullPath	self newCommand		command: 'ls';		arguments: (Array with: Smalltalk image imagePath);		redirectStdout;		runAndWaitOnExitDo: [ :command :outString |			self assert: (outString includesSubstring: Smalltalk image imagePath).							]		 ! !!OSSUnixSubprocessTest methodsFor: 'tests - streams'!testBasicCommandWriteToStdin	| command stdOutString string streamsInfo | 	streamsInfo := self getStreamsInfoForRunningTest.	string := 'this is a test shat should have been printed in the stdout'.	command := self newCommand					command: '/bin/cat';					redirectStdin;					redirectStdout.						command run.	command stdinStream 		nextPutAll: string;		close.	command waitForExit.	stdOutString := command stdoutStream upToEndOfFile.	command closeAndCleanStreams.	self assert: command isSuccess.	self assert: stdOutString equals: string.	self assertStreamsInfoWithPrevious: streamsInfo.		! !!OSSUnixSubprocessTest methodsFor: 'tests - streams'!testBasicCommandWriteToStdin2	| command streamsInfo outString | 	streamsInfo := self getStreamsInfoForRunningTest.	command := self newCommand					command: 'wc';					redirectStdin;					redirectStdout;					run. 	command stdinStream 			nextPutAll: Smalltalk image imagePath;			close.	command waitForExit.	outString := command stdoutStream upToEndOfFile. 	command closeAndCleanStreams.					self assert: command isSuccess.	"It's hard to test the output of wc crossplatform..."	self assert: outString size > 5.	self assertStreamsInfoWithPrevious: streamsInfo.		! !!OSSUnixSubprocessTest methodsFor: 'tests - shell'!testBasicShellCommand	| command | 		command := self newCommand					shellCommand: 'ls'.		command runAndWait.	! !!OSSUnixSubprocessTest methodsFor: 'tests - shell'!testBasicShellCommandWithNonAsciiCharacters		self withNonAsciiDirectoryDo: [ :dir |		(dir / 'ok.txt') ensureCreateFile.		self newCommand			shellCommand: 'ls ', dir fullName;			redirectStdout;			runAndWaitOnExitDo: [ :command :outString |				self assert: (outString includesSubstring: 'ok.txt').								]	]! !!OSSUnixSubprocessTest methodsFor: 'tests - shell'!testBasicShellCommandWithStdout	self newCommand		shellCommand: 'ls "', Smalltalk image imagePath, '"';		redirectStdout;		runAndWaitOnExitDo: [ :command :outString |			self assert: (outString includesSubstring: Smalltalk image imagePath).								]		 ! !!OSSUnixSubprocessTest methodsFor: 'tests - child status'!testCheckZombieStateAndTestChildWatcherWorking	| command oldZombies | 	oldZombies := self numberOfZombiesProcesses.	command := self newCommand 				command: '/bin/sleep';				arguments: {'1'}.		command run. 	self assert: command pid > 0.	(Duration seconds: 2) wait.	"In this case we are NOT going to do the queryExitStatus since we want to know 	if the child watcher is doing it's job."	"self assert: command queryExitStatus isNil not."	"Now it should not be a zombie anymore"	self assert: self numberOfZombiesProcesses equals: oldZombies.		! !!OSSUnixSubprocessTest methodsFor: 'tests - child status'!testCheckZombieStateWithNonExistingCommang	| command oldZombies | 	oldZombies := self numberOfZombiesProcesses.	command := self newCommand 				command: 'whatever'.						"Ideally, I would like to use a should:raise: but not all OS do fail. OSX does send errorl, while Linux does not.	So...if error, then it;s ok. But if not, also."	[ command runAndWait ] on: Error do: [  :ex | 		self assert: (ex printString includesSubstring: 'No such file or directory') .		self assert: command pid isNil.		^ nil	].		self assert: command exitStatusInterpreter exitStatus > 0.	self assert: self numberOfZombiesProcesses equals: oldZombies.		! !!OSSUnixSubprocessTest methodsFor: 'tests - child status'!testCheckZombieStateWithOnExitApi	| command oldZombies | 	oldZombies := self numberOfZombiesProcesses.	command := self newCommand 				command: '/bin/sleep';				arguments: {'1'};				runAndWaitOnExitDo: [  ].		self assert: self numberOfZombiesProcesses equals: oldZombies.		! !!OSSUnixSubprocessTest methodsFor: 'tests - child status'!testCheckZombieStateWithWaitChild	| command oldZombies | 	oldZombies := self numberOfZombiesProcesses.	command := self newCommand 				command: '/bin/sleep';				arguments: {'1'}.		command run.	command waitForExit. 	self assert: self numberOfZombiesProcesses equals: oldZombies.		! !!OSSUnixSubprocessTest methodsFor: 'tests - wait'!testCommandReturningDifferentThanZero	| command | 		"When the file does not exists ls returns 1"	command := self newCommand 					command: '/bin/ls';					arguments: {'asdasdasdasdsad'}.		command runAndWait. 		"Do not use #deny:equals: for Pharo 6 compatibility"	self deny: (command exitStatusInterpreter exitStatus = 0)! !!OSSUnixSubprocessTest methodsFor: 'tests - streams'!testCreateMissingStandardStreamsDisabled	| command | 		command := self newCommand					command: '/bin/ls'.						command runAndWait. 	self assert: command stdinStream isNil.	self assert: command stdoutStream isNil.	self assert: command stderrStream isNil.	! !!OSSUnixSubprocessTest methodsFor: 'tests - streams'!testCreateMissingStandardStreamsEnabled	| command streamsInfo | 	streamsInfo := self getStreamsInfoForRunningTest.	"The output of the ls command should be displayed in the stdout of the Pharo image. See comment of #createPipesForMissingStreams: for more details"	command := self newCommand					command: '/bin/ls';					createMissingStandardStreams: true.						command runAndWait. 	self assert: command stdinStream isNil not.	self assert: command stdoutStream isNil not.	self assert: command stderrStream isNil not.	command closeAndCleanStreams.	self assertStreamsInfoWithPrevious: streamsInfo.	! !!OSSUnixSubprocessTest methodsFor: 'tests - shell'!testCustomShellWithStdout	self newCommand		shell: '/bin/bash' command: 'ls "', Smalltalk image imagePath, '"';		redirectStdout;		runAndWaitOnExitDo: [ :command :outString |			self assert: (outString includesSubstring: Smalltalk image imagePath).							]		 ! !!OSSUnixSubprocessTest methodsFor: 'tests - streams'!testCustomStdoutStream	| customStream streamsInfo | 	streamsInfo := self getStreamsInfoForRunningTest.	customStream := self newCommand createADefaultWriteStream.	self newCommand		command: '/bin/ls';		arguments: (Array with: Smalltalk image imagePath);		redirectStdoutTo: customStream;		runAndWaitOnExitDo: [ :command :outString |			self assert: (outString includesSubstring: Smalltalk image imagePath).			self assert: command stdoutStream == customStream	.							self assertStreamsInfoWithPrevious: streamsInfo.		].		! !!OSSUnixSubprocessTest methodsFor: 'tests - child status'!testGetChildPid	| command | 		command := self newCommand 					command: '/bin/ls'.		command run.	self assert: command pid > 0.	command waitForExit. ! !!OSSUnixSubprocessTest methodsFor: 'tests - child status'!testGetChildStatusAfterFailingCommand	| command oldZombies | 	oldZombies := self numberOfZombiesProcesses.	command := self newCommand					command: '/bin/ls';					arguments: {'whatever'}.	command run.	self assert: command pid > 0.	command waitForExit.	command queryExitStatus.	self assert: command exitStatusInterpreter exitStatus >  0. 	self deny: command isSuccess.	self assert: command isComplete.	self deny: command isRunning.	self assert: self numberOfZombiesProcesses equals: oldZombies.! !!OSSUnixSubprocessTest methodsFor: 'tests - child status'!testGetChildStatusAfterFinishesMultipleTimes	| command oldZombies | 	oldZombies := self numberOfZombiesProcesses.	command := self newCommand					command: '/bin/ls'.		command run. 	self assert: command pid > 0.	command waitForExit.	"Just wanted to be sure there is no problem calling waitpid() multiple times"	command queryExitStatus.	command queryExitStatus.	command queryExitStatus.	command queryExitStatus.		self assert: command exitStatusInterpreter exitStatus equals: 0. 	self assert: command isSuccess.	self assert: command isComplete.	self deny: command isRunning.	self assert: self numberOfZombiesProcesses equals: oldZombies.! !!OSSUnixSubprocessTest methodsFor: 'tests - child status'!testGetChildStatusAfterFinishesSuccess	| command oldZombies | 	oldZombies := self numberOfZombiesProcesses.	command := self newCommand					command: '/bin/ls'.		command run. 	self assert: command pid > 0.	command waitForExit.	command queryExitStatus.	self assert: command exitStatusInterpreter exitStatus equals: 0. 	self assert: command isSuccess.	self assert: command isComplete.	self deny: command isRunning.	self assert: self numberOfZombiesProcesses equals: oldZombies.! !!OSSUnixSubprocessTest methodsFor: 'tests - child status'!testGetChildStatusBeforeAndAfterFinishing	| command oldZombies | 	oldZombies := self numberOfZombiesProcesses.	command := self newCommand 				command: '/bin/sleep';				arguments: {'3'}.		command run. 	self assert: command pid > 0.	(Duration seconds: 1) wait.	self assert: command queryExitStatus isNil.	self deny: command isComplete.	self assert: command isRunning.	command waitForExit.	self assert: command queryExitStatus isNil not.	self assert: command exitStatusInterpreter exitStatus equals: 0.	self assert: command isComplete.	self assert: self numberOfZombiesProcesses equals: oldZombies.	! !!OSSUnixSubprocessTest methodsFor: 'tests - env'!testInheritVarFromEnv	| command | 	command := self newCommand					shellCommand: 'echo ${HOME} 2>&1 > /tmp/testReadUserDefinedEnvVar ';					runAndWait.		self assert: ('/tmp/testReadUserDefinedEnvVar' asFileReference readStreamDo: [ :str | str contents ]) trimmed equals: (Smalltalk os environment at: 'HOME') trimmed.	'/tmp/testReadUserDefinedEnvVar' asFileReference ensureDelete. ! !!OSSUnixSubprocessTest methodsFor: 'tests - basic'!testNoneExistingCommand	| command stdout stderr | 		command := self newCommand					command: 'whatever';					redirectStdout;					redirectStderr.		"Ideally, I would like to use a should:raise: but not all OS do fail. OSX does send errorl, while Linux does not.	So...if error, then it;s ok. But if not, also."	[ command runAndWait ] on: Error do: [  :ex | 		self assert: (ex printString includesSubstring: 'No such file or directory') .		self assert: command pid isNil.		command closeAndCleanStreams.		^ nil	].		self assert: command exitStatusInterpreter exitStatus > 0.	command closeAndCleanStreams.! !!OSSUnixSubprocessTest methodsFor: 'tests - streams'!testReadingFromStdoutAfterCommandFinishesDoesNotBlocksVM	| command streamsInfo | 		"We set the sunit test timeout to 30 seconds.	Otherwise default sunit test timeout is 10 seconds.	This is for Pharo version >= 6.0"	(self respondsTo: #timeLimit:) ifTrue: [ 		self timeLimit: 30 seconds.	].		streamsInfo := self getStreamsInfoForRunningTest.	command := self newCommand					command: '/bin/sleep';					arguments: (Array with: '1');					redirectStdout;					runAndWait.						"Even with a blocking stream, if the command has finished, we have	all data ready to read and hence it's not blocking"	self assert:[ command stdoutStream upToEndOfFile ] timeToRun seconds <= 5. 	command closeAndCleanStreams.	self assertStreamsInfoWithPrevious: streamsInfo.		! !!OSSUnixSubprocessTest methodsFor: 'tests - wait'!testRunAndWaitPollingEveryRetrievingStreamsOnExitDo	self newCommand 		command: '/bin/ls';		arguments: (Array with: Smalltalk image imagePath);		redirectStdout;		runAndWaitPollingEvery: (Delay forMilliseconds: 50)  retrievingStreams: true onExitDo: [ :command :outString :errString |			self assert: command pid > 0.			self assert: command exitStatusInterpreter exitStatus equals: 0. 			self assert: (outString includesSubstring: Smalltalk image imagePath).			self assert: command stdoutStream closed.		]				! !!OSSUnixSubprocessTest methodsFor: 'tests - env'!testSetAndReadCustomVariable	self newCommand 		shellCommand: 'echo ${WHATEVER}';		environmentAt: 'WHATEVER' put: 'hello';		redirectStdout;		runAndWaitOnExitDo: [ :command :outString |			self assert: outString trimmed equals: 'hello'		]! !!OSSUnixSubprocessTest methodsFor: 'tests - env'!testSetAndReadCustomVariableOutsideShell	self newCommand 		command: 'printenv';		arguments: (Array with: 'WHATEVER');		environmentAt: 'WHATEVER' put: 'hello';		redirectStdout;		runAndWaitOnExitDo: [ :command :outString |			self assert: outString trimmed equals: 'hello'. 							]! !!OSSUnixSubprocessTest methodsFor: 'tests - env'!testSetCustomVariableOutsideShellAndPassedToCommand	" This test demonstrates that we do not expand variables automatically. So if you don't use the shell, or any other special command that	will search for special variables (like git searching $GIT_EDITOR), these will not be resolved. 	If you want that, then you must execute the command with the arguments already expandaded. That is, for example,	in this case, you should pass the argument 'hello' rather than ${WHATEVER} "		self newCommand 		command: '/bin/echo';		arguments: (Array with: '${WHATEVER}');		environmentAt: 'WHATEVER' put: 'hello';		redirectStdout;		runAndWaitOnExitDo: [ :command :outString |			self assert: outString trimmed equals: '${WHATEVER}'. 					]! !!OSSUnixSubprocessTest methodsFor: 'tests - wait'!testShellCommandReturningDifferentThanZero	| command | 		command := self newCommand shellCommand: 'exit 2'.	command runAndWait. 		self assert: command exitStatusInterpreter exitStatus equals: 2. ! !!OSSUnixSubprocessTest methodsFor: 'tests - shell'!testShellCommandWithPipingStdout	self newCommand		shellCommand: 'ps -fea | grep Pharo';		redirectStdout;		runAndWaitOnExitDo: [ :command :outString |			self assert: (outString includesSubstring: 'Pharo').								]		 ! !!OSSUnixSubprocessTest methodsFor: 'tests - shell'!testShellCommandWithStreamRedirects	| stdOutContents | 	self newCommand		shellCommand: 'ps -fea | grep Pharo > /tmp/testShellCommandWithStreamRedirects.deleteme';		redirectStdout;		runAndWaitOnExitDo: [ :command :outString |			self assert: outString isEmpty. 			stdOutContents := '/tmp/testShellCommandWithStreamRedirects.deleteme' asFileReference readStreamDo: [ :str | str contents ] .			self assert: (stdOutContents includesSubstring: 'Pharo').								].	'/tmp/testShellCommandWithStreamRedirects.deleteme' asFileReference ensureDelete. 		 			! !!OSSUnixSubprocessTest methodsFor: 'tests - signals'!testSigTerm	| process exited streamsInfo |		"We set the sunit test timeout to 30 seconds.	Otherwise default sunit test timeout is 10 seconds.	This is for Pharo version >= 6.0"	(self respondsTo: #timeLimit:) ifTrue: [ 		self timeLimit: 30 seconds.	].		exited := false.	streamsInfo := self getStreamsInfoForRunningTest.	process := self newCommand.	[	process 		command: 'tail';		arguments: (Array with: '-f' with: Smalltalk image changesName);		redirectStdout;		redirectStderr;		runAndWaitPollingEvery: (Delay forMilliseconds: 500) 		doing: [ :aProcess :outStream :errStream |  		 	outStream upToEnd.			errStream upToEnd.		]		onExitDo: [ :aProcess :outStream :errStream  |			process closeAndCleanStreams.			exited := true.			self assert: aProcess exitStatusInterpreter printString equals: 'exit due to signal 15'		].	"The problem here is that we simply do a #fork this closure will continue to be executed while other test run. And so, all the test checking for zombies or opened files will fail because we can have this forked process that did not yet finish. A workaround is to simply run this closures with a higher priority so that there are less chances of other tests to be running. Another possibility would be to reject those 'tail' processes from #numberOfZombiesProcesses and #numberOfOpenFiles as all the tests that use #fork use the 'tail' OS command."		] forkAt: Processor userInterruptPriority.	(Delay forSeconds: 2) wait. 	process sigterm. 	(Delay forSeconds: 10) wait. 	self assert: exited.		self assertStreamsInfoWithPrevious: streamsInfo.! !!OSSUnixSubprocessTest methodsFor: 'tests - signals'!testSigTermInsideLoop	| process exited streamsInfo |		exited := false.	streamsInfo := self getStreamsInfoForRunningTest.	process := self newCommand.		process 		command: 'tail';		arguments: (Array with: '-f' with: Smalltalk image changesName);		redirectStdout;		redirectStderr;		runAndWaitPollingEvery: (Delay forMilliseconds: 500) 		doing: [ :aProcess :outStream :errStream |  		 	"Imagine here that you have some condition...say.. elapsedTime > 1 h .. 			or ... stdOutStream size > 1MB  or whatever..  "						"#sigterm will throw an error (no such process) if the process with the given pid doesn't exist. Because of the looping of this method it COULD happen that we send #sigterm again even if the process was already killed in the previous loop. So we simply make sure the process is running before doing the #sigterm"			aProcess isRunning ifTrue: [ aProcess sigterm. ] 	]		onExitDo: [ :aProcess :outStream :errStream  |			process closeAndCleanStreams.			exited := true.			self assert: aProcess exitStatusInterpreter printString equals: 'exit due to signal 15'		].	self assert: exited.		self assertStreamsInfoWithPrevious: streamsInfo.! !!OSSUnixSubprocessTest methodsFor: 'tests - wait'!testStopWaitingWithPolling	| process counter oldZombies |	process := self newCommand.	oldZombies := self numberOfZombiesProcesses.	counter := 0.	[		process			command: 'tail';			arguments:  (Array with: '-f' with: Smalltalk image imagePath);			redirectStdout;			runAndWaitPollingEvery: (Delay forMilliseconds: 50)  retrievingStreams: true onExitDo: [ :command :outString :errString |				"The counter is to demonstrate that the exit happens only once we did the #stopWaiting				and not before"				self assert: counter equals: 0. 				self assert: process exitStatus isNil.				"Since we did not wait for the child to finish we must do a sigterm to avoid zombies				when running the tests"				command sigterm.				"Not sure about while this delay but it seems it's needed so that the next queryExitStatus				does collect exit status and hence avoid zombies"				(Delay forSeconds: 4) wait.				command queryExitStatus.				self assert: self numberOfZombiesProcesses equals: oldZombies.							]				"The problem here is that we simply do a #fork this closure will continue to be executed while other test run. And so, all the test checking for zombies or opened files will fail because we can have this forked process that did not yet finish. A workaround is to simply run this closures with a higher priority so that there are less chances of other tests to be running. Another possibility would be to reject those 'tail' processes from #numberOfZombiesProcesses and #numberOfOpenFiles as all the tests that use #fork use the 'tail' OS command."		] forkAt: Processor userInterruptPriority.	(Delay forSeconds: 3) wait.	"Just to demonstrate that tail will run forever until explicitly closed".	self assert: process isRunning. 	process stopWaiting.	! !!OSSUnixSubprocessTest methodsFor: 'tests - wait'!testStopWaitingWithSigchld	| process counter oldZombies |	process := self newCommand.	oldZombies := self numberOfZombiesProcesses.	counter := 0.	[	process		command: 'tail';		arguments:  (Array with: '-f' with: Smalltalk image imagePath);		redirectStdout;		runAndWaitPollingEvery: (Delay forMilliseconds: 50)  retrievingStreams: true onExitDo: [ :command :outString :errString |			"The counter is to demonstrate that the exit happens only once we did the #stopWaiting			and not before"			self assert: counter equals: 0. 			self assert: command exitStatus isNil.			"Since we did not wait for the child to finish we must do a sigterm to avoid zombies			when running the tests"			command sigterm.			"Not sure about while this delay but it seems it's needed so that the next queryExitStatus			does collect exit status and hence avoid zombies"			(Delay forSeconds: 4) wait.			command queryExitStatus.			self assert: self numberOfZombiesProcesses equals: oldZombies.		]	"The problem here is that we simply do a #fork this closure will continue to be executed while other test run. And so, all the test checking for zombies or opened files will fail because we can have this forked process that did not yet finish. A workaround is to simply run this closures with a higher priority so that there are less chances of other tests to be running. Another possibility would be to reject those 'tail' processes from #numberOfZombiesProcesses and #numberOfOpenFiles as all the tests that use #fork use the 'tail' OS command."		] forkAt: Processor userInterruptPriority.					(Delay forSeconds: 3) wait.	"Just to demonstrate that tail will run forever until explicitly closed".	self assert: process isRunning. 	process stopWaiting.	! !!OSSUnixSubprocessTest methodsFor: 'tests - wait'!testWaitForExit	| command | 		command := self newCommand 					command: '/bin/sleep';					arguments: {'3'}.		command run. 	self assert: command pid > 0.	self assert: [ command waitForExit ] timeToRun asSeconds >= 2.	self assert: command exitStatusInterpreter exitStatus equals: 0. ! !!OSSUnixSubprocessTest methodsFor: 'tests - wait'!testWaitForExitPolling	| command | 		command := self newCommand 					command: '/bin/sleep';					arguments: {'3'}.		command run. 	self assert: command pid > 0.	self assert: [ command waitForExitPolling ] timeToRun asSeconds >= 2.	self assert: command exitStatusInterpreter exitStatus equals: 0. ! !!OSSUnixSubprocessTest methodsFor: 'tests - wait'!testWaitForExitPollingEvery	| command | 		command := self newCommand 					command: '/bin/sleep';					arguments: {'3'}.		command run. 	self assert: command pid > 0.	self assert: [ command waitForExitPollingEvery: (Delay forSeconds: 1) ] timeToRun asSeconds >= 2.	self assert: command exitStatusInterpreter exitStatus equals: 0. ! !!OSSUnixSubprocessTest methodsFor: 'tests - high API'!testWaitForExitPollingEveryDoing	| streamsInfo totalRead |	totalRead := String new writeStream.	streamsInfo := self getStreamsInfoForRunningTest.	self newCommand		command: '/bin/ls';		arguments: (Array with: Smalltalk image imagePath);		redirectStdout;		redirectStderr;		runAndWaitPollingEvery: (Delay forMilliseconds: 50) 		doing: [ :process :outStream :errStream |  			| read | 			read := outStream upToEnd.			totalRead nextPutAll: read.		]		onExitDo: [ :process :outStream :errStream  |			self assert: (totalRead contents includesSubstring: Smalltalk image imagePath).			process closeAndCleanStreams.			self assertStreamsInfoWithPrevious: streamsInfo.		].	! !!OSSUnixSubprocessTest methodsFor: 'tests - wait'!testWaitForExitWithTimeoutWillFailIfProcessDoesNotFinish	| command | 		command := self newCommand 					command: '/bin/sleep';					arguments: {'2'}.		command run.		self		should: [ command waitForExitWithTimeout: 10 milliSeconds ]		raise: OSSTimeout.	self assert: command isRunning.! !!OSSUnixSubprocessTest methodsFor: 'tests - wait'!testWaitForExitWithTimeoutWillNotTimeoutIfProcessFinishes	| command | 		command := self newCommand 					command: '/bin/sleep';					arguments: {'1'}.		command run.	command waitForExitWithTimeout: 2 seconds.		self assert: command pid > 0.	self assert: command exitStatusInterpreter exitStatus equals: 0. ! !!OSSUnixSubprocessTest methodsFor: 'tests - wait'!testWaitpidIsNoneBocking	| command childStatus | 		command := self newCommand					command: '/bin/sleep';					arguments: {'5'}.		command run. 	self assert: command pid > 0.	(Duration seconds: 1) wait.	self assert: [ childStatus := command exitStatusInterpreter ] timeToRun asSeconds < 1.	self assert: childStatus value isNil.	command waitForExit.! !!OSSUnixSubprocessTest methodsFor: 'tests - pwd'!testWorkingDirectory	| oldWorkingDirectory | 	oldWorkingDirectory := self systemAccessor getcwd.	(FileSystem workingDirectory / 'testing') ensureCreateDirectory.		self newCommand		shellCommand: 'pwd';		workingDirectory: (FileSystem workingDirectory / 'testing') fullName;		redirectStdout;		runAndWaitOnExitDo: [ :command :outString |			self assert: outString trimmed equals: (FileSystem workingDirectory / 'testing') fullName.			]. 	self assert: self systemAccessor getcwd trimmed equals: oldWorkingDirectory trimmed.		 	(FileSystem workingDirectory / 'testing') ensureDelete.	! !!OSSUnixSubprocessTest methodsFor: 'helpers'!withNonAsciiDirectoryDo: aBlock 	| directory |	directory := FileLocator temp / (self class name , '-éoï-' , UUIDGenerator next asString).	directory ensureCreateDirectory.	[ aBlock cull: directory asFileReference ]	ensure: [ directory ensureDeleteAll ]! !!OSSVMProcessTest methodsFor: 'accessing'!runCaseManaged	"testChangeDirWithNonAsciiCharacters test has to download the unicode table that can take some time.	Disable test timeout."	^ self runCase! !!OSSVMProcessTest methodsFor: 'tests'!testChangeDir	| oldDir | 	oldDir := self systemAccessor getcwd.	OSSVMProcess vmProcess		lockCwdWithValue: '/tmp'		encoding: #utf8 		during: [			"Grrr in latest OSX /tmp is mapped to /private/tmp..."			self assert: ((self systemAccessor getcwd = '/tmp') or: [ self systemAccessor getcwd = '/private/tmp' ]).		].	self assert: self systemAccessor getcwd equals: oldDir				! !!OSSVMProcessTest methodsFor: 'tests'!testChangeDirWithNonAsciiCharacters	| oldDir newDir duringSystemCwd | 	oldDir := self systemAccessor getcwd.	newDir := FileLocator temp / 'strangË foldér namê'.	newDir ensureCreateDirectory.	OSSVMProcess vmProcess		lockCwdWithValue: newDir fullName		encoding: #utf8		during: [ duringSystemCwd := self systemAccessor getcwd ].	duringSystemCwd := UnicodeNormalizer new toNFC: duringSystemCwd.	"Grrr in latest OSX /tmp is mapped to /private/tmp..."	self assert: ((duringSystemCwd = newDir fullName) or: [ duringSystemCwd = ('/private' , newDir fullName) ]).	self assert: self systemAccessor getcwd equals: oldDir.	newDir ensureDelete.! !!OSSVMProcessTest methodsFor: 'tests'!testChangeDirWithNonExistingDir	| oldDir |	oldDir := self systemAccessor getcwd.	[ OSSVMProcess vmProcess		lockCwdWithValue: '/tmpWhatever'		encoding: #utf8		during: [  ] ]	on: Error	do: [ :ex | self assert: (ex printString includesSubstring: 'does not exist') ].	self assert: self systemAccessor getcwd equals: oldDir! !!OSSVMProcessTest methodsFor: 'tests'!testChildrenCollectionsWithOneProcessBeforeAndAfter	| command | 	OSSVMProcess vmProcess initializeAllMyChildren. 	command := self newCommand 		command: '/bin/sleep';		arguments: {'2'}.		command run. 		self assert: OSSVMProcess vmProcess allMyChildren size equals: 1.	self assert: OSSVMProcess vmProcess allMyChildren first == command.	self assert: OSSVMProcess vmProcess activeChildren size equals: 1.	self assert: OSSVMProcess vmProcess activeChildren first == command.	self assert: OSSVMProcess vmProcess exitedChildren isEmpty.	self assert: OSSVMProcess vmProcess childPids size equals: 1.	self assert: OSSVMProcess vmProcess childPids first equals: command pid.		command waitForExit. 		self assert: OSSVMProcess vmProcess allMyChildren size equals: 1.	self assert: OSSVMProcess vmProcess allMyChildren first == command.	self assert: OSSVMProcess vmProcess activeChildren size equals: 0.	self assert: OSSVMProcess vmProcess exitedChildren size equals: 1.	self assert: OSSVMProcess vmProcess exitedChildren first == command.	self assert: OSSVMProcess vmProcess childPids size equals: 1.	self assert: OSSVMProcess vmProcess childPids first equals: command pid.			! !!OSSVMProcessTest methodsFor: 'tests'!testInitializeChildren	OSSVMProcess vmProcess initializeAllMyChildren.		self assert: OSSVMProcess vmProcess allMyChildren isEmpty.	self assert: OSSVMProcess vmProcess activeChildren isEmpty.	self assert: OSSVMProcess vmProcess exitedChildren isEmpty.	self assert: OSSVMProcess vmProcess childPids isEmpty.					! !!OSSVMProcessTest methodsFor: 'tests'!testPruneExitedChildrenAfter	| command | 	OSSVMProcess vmProcess initializeAllMyChildren. 	command := self newCommand 		command: '/bin/ls'.	command runAndWait. 		self assert: OSSVMProcess vmProcess exitedChildren size equals: 1.	OSSVMProcess vmProcess pruneExitedChildrenAfter: 0. 		self assert: OSSVMProcess vmProcess allMyChildren isEmpty.	self assert: OSSVMProcess vmProcess activeChildren isEmpty.	self assert: OSSVMProcess vmProcess exitedChildren isEmpty.	self assert: OSSVMProcess vmProcess childPids isEmpty.		! !"OSSubprocess-Tests-Unit"!!OSSConcurrentProcessesTest methodsFor: 'tests'!launchAndWaitForProcessesToFinish: numberOfProcesses	"We set the sunit test timeout to 2 times the sleep duration.	Otherwise default sunit test timeout is 1 minute."		| processes |	"We set the sunit test timeout to 1 second per process.	Except for short running processes, where we keep the default timeout.	This is for Pharo version >= 6.0"	(self respondsTo: #timeLimit:) ifTrue: [ 		self timeLimit: (numberOfProcesses seconds max: self defaultTimeLimit).	].		processes := (1 to: numberOfProcesses) collect: [ :index |		self newCommand			command: '/bin/sleep';			arguments: { '1s' };			yourself ].		processes do: #run.		processes do: [ :command | command waitForExitWithTimeout: 5 seconds ]! !!OSSConcurrentProcessesTest methodsFor: 'tests'!test100ProcessEventuallyFinishes	self launchAndWaitForProcessesToFinish: 100! !!OSSConcurrentProcessesTest methodsFor: 'tests'!test10ProcessEventuallyFinishes	self launchAndWaitForProcessesToFinish: 10! !!OSSConcurrentProcessesTest methodsFor: 'tests'!test1ProcessEventuallyFinishes	self launchAndWaitForProcessesToFinish: 1! !!OSSLongRunningProcessTest methodsFor: 'tests'!doTestProcessEventuallyFinishesForSeconds: aDuration	| command |	"We set the sunit test timeout to 2 times the sleep duration.	Otherwise default sunit test timeout is 1 minute.	This is for Pharo version >= 6.0"	(self respondsTo: #timeLimit:) ifTrue: [ 		self timeLimit: aDuration * 2.	].	command := self newCommand		command: '/bin/sleep';		arguments: { aDuration asSeconds asString };		yourself.	command run.		"We should wait and finish without a timeout exception"	command waitForExitWithTimeout: aDuration * 2.! !!OSSLongRunningProcessTest methodsFor: 'tests'!test100SecondProcessEventuallyFinishes	self doTestProcessEventuallyFinishesForSeconds: 100 second! !!OSSLongRunningProcessTest methodsFor: 'tests'!test10SecondProcessEventuallyFinishes	self doTestProcessEventuallyFinishesForSeconds: 10 second! !!OSSLongRunningProcessTest methodsFor: 'tests'!test1SecondProcessEventuallyFinishes	self doTestProcessEventuallyFinishesForSeconds: 1 second! !!OSSLongRunningProcessTest methodsFor: 'tests'!test300SecondProcessEventuallyFinishes	"Wait for five minutes.	Times > 10 minutes make travis timeout."	self doTestProcessEventuallyFinishesForSeconds: 300 second! !"OSSubprocess-Tests-Stress"!!OSWSProcessCreationFailed commentStamp: '' prior: 0!Error thrown when the creation of a sub process fails.!!OSWSWinTypes commentStamp: '' prior: 0!Definition of Windows types used in prototypes of the functions needed to manage processes.!!OSWSProcessInformation commentStamp: '' prior: 0!Structure needed to make FFI calls to createProcess.It contains information about a newly created process and its primary thread.See PhLProcess class for more information.documentation: https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/ns-processthreadsapi-process_information!!OSWSStartupInfoW commentStamp: '' prior: 0!Structure needed to make FFI calls to createProcess.Specifies the window station, desktop, standard handles, and appearance of the main window for a process at creation time.See PhLWinProcess class for more information.Documentation: https://docs.microsoft.com/fr-fr/windows/desktop/api/processthreadsapi/ns-processthreadsapi-_startupinfow!!OSWSWinProcess commentStamp: '' prior: 0!I reprensent a Windows process.You can instantiate me and configure me to run a child process of Pharo. You can wait for my completion or run me in an asynchronuous way (default).I use a FFI library PhLWinProcessLibrary to make system calls to the Windows API.I do not manage standard and error outputs.WARNING: waiting a process will freeze your image while the process is running.You can use me as following:	PhLWinProcess new 		shellCommand: 'echo ok';		runAndWait.			PhLWinProcess new		shellCommand: 'timeout 1';		run.!!OSWSWinProcessLibrary commentStamp: '' prior: 0!PhLProcess can be used to run new processes on Windows.It uses Windows MSVCRT dll.https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa!!OSWSWinProcessWatcher commentStamp: '' prior: 0!This class is in charge of watching the execution of the process given as input to check regularly if it is still running or not.When the process is completed, I do a callback on the process so that it cleans the process fields.!!String methodsFor: '*OSWinSubprocess'!surroundedByDoubleQuotes	"Answer the receiver with leading and trailing double quotes.  "	^ self surroundedBy: ($" asString)! !!OSWSProcessCreationFailed methodsFor: 'accessing'!description	^ 'Failed to create a new process'! !!OSWSProcessInformation class methodsFor: 'field definition'!fieldsDesc	"self rebuildFieldAccessors"		^ #(	HANDLE hProcess;	HANDLE hThread;	DWORD  dwProcessId;	DWORD  dwThreadId;		)! !!OSWSProcessInformation methodsFor: 'accessing structure variables'!dwProcessId	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_DWPROCESSID! !!OSWSProcessInformation methodsFor: 'accessing structure variables'!dwProcessId: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_DWPROCESSID put: anObject! !!OSWSProcessInformation methodsFor: 'accessing structure variables'!dwThreadId	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_DWTHREADID! !!OSWSProcessInformation methodsFor: 'accessing structure variables'!dwThreadId: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_DWTHREADID put: anObject! !!OSWSProcessInformation methodsFor: 'accessing structure variables'!hProcess	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_HPROCESS) type: ExternalType void asPointerType! !!OSWSProcessInformation methodsFor: 'accessing structure variables'!hProcess: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_HPROCESS put: anObject getHandle.! !!OSWSProcessInformation methodsFor: 'accessing structure variables'!hThread	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_HTHREAD) type: ExternalType void asPointerType! !!OSWSProcessInformation methodsFor: 'accessing structure variables'!hThread: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_HTHREAD put: anObject getHandle.! !!OSWSProcessInformation methodsFor: 'initialization'!initialize	super initialize.	OSWSWinProcessLibrary clear: self! !!OSWSStartupInfoW class methodsFor: 'field definition'!fieldsDesc	"self rebuildFieldAccessors"	^ #(	DWORD	cb;	LPWSTR	lpReserved;	LPWSTR	lpDesktop;	LPWSTR	lpTitle;	DWORD	dwX;	DWORD	dwY;	DWORD	dwXSize;	DWORD	dwYSize;	DWORD	dwXCountChars;	DWORD	dwYCountChars;	DWORD	dwFillAttribute;	DWORD	dwFlags;	WORD	 wShowWindow;	WORD	 cbReserved2;	LPBYTE lpReserved2;	HANDLE hStdInput;	HANDLE hStdOutput;	HANDLE hStdError;)! !!OSWSStartupInfoW methodsFor: 'accessing structure variables'!cb	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_CB! !!OSWSStartupInfoW methodsFor: 'accessing structure variables'!cb: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_CB put: anObject! !!OSWSStartupInfoW methodsFor: 'accessing structure variables'!cbReserved2	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_CBRESERVED2! !!OSWSStartupInfoW methodsFor: 'accessing structure variables'!cbReserved2: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_CBRESERVED2 put: anObject! !!OSWSStartupInfoW methodsFor: 'accessing structure variables'!dwFillAttribute	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_DWFILLATTRIBUTE! !!OSWSStartupInfoW methodsFor: 'accessing structure variables'!dwFillAttribute: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_DWFILLATTRIBUTE put: anObject! !!OSWSStartupInfoW methodsFor: 'accessing structure variables'!dwFlags	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_DWFLAGS! !!OSWSStartupInfoW methodsFor: 'accessing structure variables'!dwFlags: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_DWFLAGS put: anObject! !!OSWSStartupInfoW methodsFor: 'accessing structure variables'!dwX	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_DWX! !!OSWSStartupInfoW methodsFor: 'accessing structure variables'!dwX: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_DWX put: anObject! !!OSWSStartupInfoW methodsFor: 'accessing structure variables'!dwXCountChars	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_DWXCOUNTCHARS! !!OSWSStartupInfoW methodsFor: 'accessing structure variables'!dwXCountChars: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_DWXCOUNTCHARS put: anObject! !!OSWSStartupInfoW methodsFor: 'accessing structure variables'!dwXSize	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_DWXSIZE! !!OSWSStartupInfoW methodsFor: 'accessing structure variables'!dwXSize: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_DWXSIZE put: anObject! !!OSWSStartupInfoW methodsFor: 'accessing structure variables'!dwY	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_DWY! !!OSWSStartupInfoW methodsFor: 'accessing structure variables'!dwY: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_DWY put: anObject! !!OSWSStartupInfoW methodsFor: 'accessing structure variables'!dwYCountChars	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_DWYCOUNTCHARS! !!OSWSStartupInfoW methodsFor: 'accessing structure variables'!dwYCountChars: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_DWYCOUNTCHARS put: anObject! !!OSWSStartupInfoW methodsFor: 'accessing structure variables'!dwYSize	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_DWYSIZE! !!OSWSStartupInfoW methodsFor: 'accessing structure variables'!dwYSize: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_DWYSIZE put: anObject! !!OSWSStartupInfoW methodsFor: 'accessing structure variables'!hStdError	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_HSTDERROR) type: ExternalType void asPointerType! !!OSWSStartupInfoW methodsFor: 'accessing structure variables'!hStdError: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_HSTDERROR put: anObject getHandle.! !!OSWSStartupInfoW methodsFor: 'accessing structure variables'!hStdInput	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_HSTDINPUT) type: ExternalType void asPointerType! !!OSWSStartupInfoW methodsFor: 'accessing structure variables'!hStdInput: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_HSTDINPUT put: anObject getHandle.! !!OSWSStartupInfoW methodsFor: 'accessing structure variables'!hStdOutput	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_HSTDOUTPUT) type: ExternalType void asPointerType! !!OSWSStartupInfoW methodsFor: 'accessing structure variables'!hStdOutput: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_HSTDOUTPUT put: anObject getHandle.! !!OSWSStartupInfoW methodsFor: 'initialization'!initialize	super initialize.	OSWSWinProcessLibrary clear: self! !!OSWSStartupInfoW methodsFor: 'accessing structure variables'!lpDesktop	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_LPDESKTOP) type: ExternalType void asPointerType! !!OSWSStartupInfoW methodsFor: 'accessing structure variables'!lpDesktop: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_LPDESKTOP put: anObject getHandle.! !!OSWSStartupInfoW methodsFor: 'accessing structure variables'!lpReserved	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_LPRESERVED) type: ExternalType void asPointerType! !!OSWSStartupInfoW methodsFor: 'accessing structure variables'!lpReserved2	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_LPRESERVED2) type: ExternalType char asPointerType! !!OSWSStartupInfoW methodsFor: 'accessing structure variables'!lpReserved2: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_LPRESERVED2 put: anObject getHandle.! !!OSWSStartupInfoW methodsFor: 'accessing structure variables'!lpReserved: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_LPRESERVED put: anObject getHandle.! !!OSWSStartupInfoW methodsFor: 'accessing structure variables'!lpTitle	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_LPTITLE) type: ExternalType void asPointerType! !!OSWSStartupInfoW methodsFor: 'accessing structure variables'!lpTitle: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_LPTITLE put: anObject getHandle.! !!OSWSStartupInfoW methodsFor: 'accessing structure variables'!wShowWindow	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_WSHOWWINDOW! !!OSWSStartupInfoW methodsFor: 'accessing structure variables'!wShowWindow: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_WSHOWWINDOW put: anObject! !!OSWSWinProcess class methodsFor: 'private'!TIMEOUT_INFINITE	^ 16rffffffff! !!OSWSWinProcess class methodsFor: 'constants'!WAIT_FAILED	^ 16rFFFFFFFF! !!OSWSWinProcess class methodsFor: 'constants'!WAIT_OBJECT_0	^ 0! !!OSWSWinProcess class methodsFor: 'constants'!WAIT_TIMEOUT	^ 16r00000102! !!OSWSWinProcess methodsFor: 'configuring'!arguments: aListOfArguments	arguments := aListOfArguments asArray.! !!OSWSWinProcess methodsFor: 'accessing'!argumentsString	| args |	args := Character space join: 		(surroundArgumentsWithDoubleQuotes			ifTrue: [ arguments collect: #surroundedByDoubleQuotes ]			ifFalse: [ arguments ]).	"cmd.exe /C waits a unique argument. Wrap the whole command but /C to run with double quotes"	^ (command = self shellCommandPath)		ifTrue: [ '/C ', args surroundedByDoubleQuotes ]		ifFalse: [ args ]! !!OSWSWinProcess methodsFor: 'running'!basicRun	| kNoWindow creationSucceeded |	kNoWindow := 16r08000000.	startupInfo := OSWSStartupInfoW externalNew.	startupInfo cb: startupInfo class structureSize.	processInfo := OSWSProcessInformation externalNew.		creationSucceeded := self ffiLibrary		createProcess: (Win32WideString fromString: command) getHandle		command: (Win32WideString fromString: self argumentsString) getHandle		processAttributes: ExternalAddress null		threadAttributes: ExternalAddress null		inheritHandles: false		creationFlags: kNoWindow		environment: ExternalAddress null		directory: self workingDirectoryHandle		startup: startupInfo		processInformation: processInfo.			creationSucceeded		ifFalse: [ self setLastErrorCode. OSWSProcessCreationFailed signal: lastErrorCode ].	isRunning := true.! !!OSWSWinProcess methodsFor: 'private'!clean	processInfo getHandle		ifNotNil: 			[ self closeHandle: processInfo hProcess.			self closeHandle: processInfo hThread ].	processInfo free.	startupInfo free! !!OSWSWinProcess methodsFor: 'private'!closeHandle: handle	^ self ffiLibrary closeHandle: handle! !!OSWSWinProcess methodsFor: 'configuring'!command: appName	"The name of the module to be executed. This module can be a Windows-based application. It can be some other type of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer.The string can specify the full path and file name of the module to execute or it can specify a partial name. In the case of a partial name, the function uses the current drive and current directory to complete the specification. The function will not use the search path. This parameter must include the file name extension; no default extension is assumed."	command := appName! !!OSWSWinProcess methodsFor: 'private'!completionCallback	self setExitCode.	self clean! !!OSWSWinProcess methodsFor: 'accessing'!exitCode	^ exitCode ! !!OSWSWinProcess methodsFor: 'private'!ffiLibrary	^ OSWSWinProcessLibrary uniqueInstance! !!OSWSWinProcess methodsFor: 'testing'!hasTimedOut	^ self isRunning not 		and: [ lastErrorCode isNil 		and: [ exitCode isNil ] ]! !!OSWSWinProcess methodsFor: 'initialization'!initialize	isRunning := false.	surroundArgumentsWithDoubleQuotes := false.! !!OSWSWinProcess methodsFor: 'testing'!isComplete	^ isRunning not and: [exitCode notNil]! !!OSWSWinProcess methodsFor: 'testing'!isRunning	"see https://docs.microsoft.com/en-us/windows/desktop/api/synchapi/nf-synchapi-waitforsingleobject for more information"	| returnValue |		(processInfo isNil 	or: [ processInfo getHandle isNil 	or: [ processInfo hProcess getHandle isNil ] ])		ifTrue: [ ^ false ].		returnValue := self ffiLibrary		waitForSingleObject: processInfo hProcess		milliSeconds: 0.	^ returnValue = self class WAIT_TIMEOUT! !!OSWSWinProcess methodsFor: 'testing'!isSuccess	^ self isRunning not 		and: [ lastErrorCode isNil 		and: [ self exitCode = 0 ] ]! !!OSWSWinProcess methodsFor: 'public'!lastError	^ self ffiLibrary getLastError! !!OSWSWinProcess methodsFor: 'running'!run	self basicRun.	self watch.! !!OSWSWinProcess methodsFor: 'running'!runAndWait	" This methods runs the subprocess AND waits until the child has exited. "		self basicRun.	self waitForCompletion.! !!OSWSWinProcess methodsFor: 'running'!runAndWaitTimeOut: nbMilliSeconds	" This methods runs the subprocess AND waits until the child has exited. "		self basicRun.	self waitForCompletionTimeout: nbMilliSeconds.! !!OSWSWinProcess methodsFor: 'running'!runUnwatch 	"Used to run a process and forget about it"	[ self basicRun ]	ensure: [ self clean ]! !!OSWSWinProcess methodsFor: 'private'!setExitCode	| exitCodeValueHolder succeeded |		exitCode ifNotNil: [ ^ self ]. "already set"	processInfo getHandle ifNil: [ ^ self ]. "process already cleaned. No way to get the exit code"		exitCodeValueHolder := LPDWORD new.	succeeded := self ffiLibrary		getProcess: processInfo hProcess		exitCode: exitCodeValueHolder.	succeeded ifFalse: [ Warning new messageText: 'Cannot get exit code of the process'; signal ].	exitCode := exitCodeValueHolder value! !!OSWSWinProcess methodsFor: 'private'!setLastErrorCode	^ lastErrorCode := self lastError! !!OSWSWinProcess methodsFor: 'configuring'!shellCommand	command := self shellCommandPath! !!OSWSWinProcess methodsFor: 'configuring'!shellCommand: aShellCommandString	"This is a simple facility method for the cases when the user wants to use shell as the program.	This way, the user can directly send shellCommand: 'ECHO y| DEL *.txt' with the whole string 	rather than having to do set the command cmd.exe, send the '/C' argument, etc etc etc."	self shellCommand.	arguments := Array withAll: (Character space split: aShellCommandString).! !!OSWSWinProcess methodsFor: 'configuring'!shellCommand: aShellCommandName arguments: aListOfArguments	"This is a simple facility method for the cases when the user wants to use shell as the program.	This way, the user can directly send shellCommand: 'ECHO' arguments: #('1 + 1' '>' 'a filename with spaces.txt')' 	rather than having to do set the command cmd.exe, send the '/C' argument, etc etc etc."	self shellCommand.	arguments := OrderedCollection with: aShellCommandName.	arguments addAll: aListOfArguments.	arguments := arguments asArray.! !!OSWSWinProcess methodsFor: 'configuring'!shellCommandPath	^ 'C:\Windows\System32\cmd.exe'.! !!OSWSWinProcess methodsFor: 'configuring'!surroundArgumentsWithDoubleQuotes	surroundArgumentsWithDoubleQuotes := true.! !!OSWSWinProcess methodsFor: 'public'!terminate	| success |	self isRunning ifFalse: [ ^ true ].		success := self ffiLibrary 		terminate: processInfo hProcess 		exitCode: 3	"Kill the process, set a non-success exit code".	success ifTrue: [ self clean ].	^ success! !!OSWSWinProcess methodsFor: 'private'!waitForCompletion	self waitForCompletionTimeout: self class TIMEOUT_INFINITE.! !!OSWSWinProcess methodsFor: 'private'!waitForCompletionTimeout: nbMilliSeconds	| returnValue |	[ returnValue := self ffiLibrary		waitForSingleObject: processInfo hProcess		milliSeconds: nbMilliSeconds.	isRunning := false.	returnValue = self class WAIT_OBJECT_0		ifTrue: [ self setExitCode ].	"successful process termination"	returnValue = self class WAIT_FAILED		ifTrue: [ self setLastErrorCode ] ]	ensure: [ self terminate ]! !!OSWSWinProcess methodsFor: 'private'!watch	(OSWSWinProcessWatcher on: self) watch! !!OSWSWinProcess methodsFor: 'configuring'!workingDirectory: aPathString	workingDirectory := aPathString! !!OSWSWinProcess methodsFor: 'private'!workingDirectoryHandle	^ workingDirectory 		ifNil: [ ExternalAddress null ]		ifNotNil: [ (Win32WideString fromString: workingDirectory) getHandle ]! !!OSWSWinProcessLibrary class methodsFor: 'public'!clear: externalStructure	^ self memSet: externalStructure value: 0! !!OSWSWinProcessLibrary class methodsFor: 'private'!memSet: externalStructure value: value	^ self uniqueInstance		memSet: externalStructure getHandle		value: value		size: externalStructure class structureSize! !!OSWSWinProcessLibrary methodsFor: 'public'!closeHandle: handle	^ self ffiCall: #(int CloseHandle(void * handle)) module: #Kernel32! !!OSWSWinProcessLibrary methodsFor: 'public'!createProcess: appName command: commandLine processAttributes: processAttributes threadAttributes: threadAttributes inheritHandles: inheritHandles creationFlags: creationFlags environment: environment directory: currentDirectory startup: startupInfo processInformation: processInformation	^ self ffiCall: #(Boolean CreateProcessW(  LPCWSTR                appName,  LPCWSTR                 commandLine,  void* "LPSECURITY_ATTRIBUTES"  processAttributes,  void* "LPSECURITY_ATTRIBUTES"  threadAttributes,  Boolean                inheritHandles,  DWORD                  creationFlags,  LPVOID                 environment,  LPCWSTR                currentDirectory,  #OSWSStartupInfoW        *startupInfo,  #OSWSProcessInformation *processInformation)) module: #Kernel32	"	#(int CreateProcessA (const char * appName, char * command, 0, 0, 0, ulong flags, 0, 0, ExternalAddress * startup, ExternalAddress * processInfo)) module: #Kernel32"! !!OSWSWinProcessLibrary methodsFor: 'public'!getLastError	^ self ffiCall: #(DWORD GetLastError(void)) module: #Kernel32! !!OSWSWinProcessLibrary methodsFor: 'public'!getProcess: hProcess exitCode: lpExitCode	^ self ffiCall: #(Boolean GetExitCodeProcess(  HANDLE  hProcess,  LPDWORD *lpExitCode)) module: #Kernel32! !!OSWSWinProcessLibrary methodsFor: 'public'!memSet: ptr value: value size: size	^ self ffiCall: #(void* memset(void* ptr, int value, size_t size))! !!OSWSWinProcessLibrary methodsFor: 'public'!terminate:hProcess exitCode:uExitCode	^ self ffiCall: #(Boolean TerminateProcess(  HANDLE hProcess,  uint   uExitCode)) module: #Kernel32! !!OSWSWinProcessLibrary methodsFor: 'public'!waitForSingleObject: handle milliSeconds: ms	^ self ffiCall: #( uint WaitForSingleObject (void * handle, uint ms)) module: #Kernel32! !!OSWSWinProcessLibrary methodsFor: 'public'!win32ModuleName	^ 'msvcrt.dll'! !!OSWSWinProcessWatcher class methodsFor: 'instance creation'!on: aProcess	^ self new 		process: aProcess! !!OSWSWinProcessWatcher methodsFor: 'accessing'!process: aProcess	process := aProcess! !!OSWSWinProcessWatcher methodsFor: 'watching'!watch	"active loop to catch the end of the process"	watchProcess := [ [ process isRunning ]		whileTrue: [ 200 milliSeconds wait ].		process completionCallback ]		forkAt: 35		named: 'WinProcess watcher'! !!OSWSWinTypes class methodsFor: 'class initialization'!initialize 	DWORD := #uint32.	HANDLE := 'void*'.	LPSTR := String.	LPCSTR := String.	LPWSTR := 'void*'. "Cannot use Win32WideString directly because FFI will not accept null pointers"	LPCWSTR := 'void*'. "Cannot use Win32WideString directly because FFI will not accept null pointers"	LPVOID := 'void*'.	WORD := #uint16.	LPBYTE := 'char*'.	LPDWORD := FFIExternalValueHolder ofType: #uint32.! !"OSWinSubprocess"!!OSWSWinProcessTest methodsFor: 'tests'!testBasicCommand	| newprocess |	Smalltalk os isWindows ifFalse: [ self skip. ^ self  ].		newprocess := OSWSWinProcess new 		shellCommand: 'echo ok';		runAndWait.	self deny: newprocess isRunning.	self assert: newprocess exitCode equals: 0.	self assert: newprocess isSuccess! !!OSWSWinProcessTest methodsFor: 'tests'!testBasicCommandWithArguments	| newprocess |	Smalltalk os isWindows ifFalse: [ self skip. ^ self  ].		newprocess := OSWSWinProcess new 		shellCommand: 'echo'		arguments: #('ok');		runAndWait.	self deny: newprocess isRunning.	self assert: newprocess exitCode equals: 0.	self assert: newprocess isSuccess! !!OSWSWinProcessTest methodsFor: 'tests'!testCanDetectIfProcessIsRunning	| newprocess |	Smalltalk os isWindows ifFalse: [ self skip. ^ self  ].		newprocess := OSWSWinProcess new		shellCommand: 'timeout 1';		run.	self assert: newprocess isRunning.	1 seconds wait.	self deny: newprocess isRunning.		! !!OSWSWinProcessTest methodsFor: 'tests'!testCanTerminateProcess	| newprocess succeeded |	Smalltalk os isWindows ifFalse: [ self skip. ^ self  ].		newprocess := OSWSWinProcess new 		shellCommand: 'timeout 50';		run.	self assert: newprocess isRunning.	succeeded := newprocess terminate.	self assert: succeeded.	1 second wait. "let time to the cleanup being executed"	self deny: newprocess isRunning.	self deny: newprocess isSuccess.! !!OSWSWinProcessTest methodsFor: 'tests'!testGivenACommandIncludingNonAsciiCharsThenCommandSucceed	| newprocess tempDir |	Smalltalk os isWindows ifFalse: [ self skip. ^ self  ].		tempDir := (FileLocator temp / 'Yann-Gaël Bérès') asFileReference.	self deny: tempDir exists.		[ newprocess := OSWSWinProcess new 		shellCommand: 'mkdir'		arguments: {tempDir fullName surroundedByDoubleQuotes};		runAndWait.	self assert: newprocess isSuccess.	self assert: tempDir exists. ]		ensure: [ tempDir ensureDelete ]	! !!OSWSWinProcessTest methodsFor: 'tests'!testGivenBasicCommandWhenCommandDoesNotExistThenExitCodeIsNot0	| newprocess |	Smalltalk os isWindows ifFalse: [ self skip. ^ self  ].		newprocess := OSWSWinProcess new 		shellCommand: 'nonexistingcommand foo bar'.	self deny: newprocess exitCode equals: 0.	self deny: newprocess isSuccess! !!OSWSWinProcessTest methodsFor: 'tests'!testProcessTimeOut	| newprocess start delta |	Smalltalk os isWindows ifFalse: [ self skip. ^ self  ].		start := Time now asMilliSeconds.	newprocess := OSWSWinProcess new 		shellCommand: 'sleep 50';		run;		waitForCompletionTimeout: 3 seconds asMilliSeconds.	"wait is blocking"	delta := Time now asMilliSeconds - start.	self deny: newprocess isRunning.	self deny: newprocess isSuccess.	self assert: newprocess hasTimedOut.	self 		assert: (delta between: 3 seconds asMilliSeconds and: 4 seconds asMilliSeconds)		description: 'expected 3 seconds wait, got ', delta asString , ' milliseconds'.! !"OSWinSubprocess-Tests"!!BitmapCharacterSet commentStamp: '' prior: 0!This class implements a set of Character objects similar to CharacterSet and WideCharacterSet, but it uses a bitmap internally to test if wide (multibyte) characters belong to it rather than using a Dictionary like WideCharacterSet does. For byte characters, a simple 256-element Array is used, the same as with CharacterSet, which is faster but uses more memory.(Used by and heavily optimized for XMLParser; please refactor carefully)!!BitmapCharacterSet class methodsFor: 'inspecting'!inspectorClass	"does not use Set class>>inspectorClass because it is incompatible"	^ Smalltalk tools inspectorClass! !!BitmapCharacterSet class methodsFor: 'instance creation'!new	^ self new: 256! !!BitmapCharacterSet class methodsFor: 'instance creation'!new: aCapacity	^ self basicNew initialize: aCapacity! !!BitmapCharacterSet class methodsFor: 'instance creation'!newFrom: aCollection	"for GS portability"	^ self new		addAll: aCollection;		yourself	! !!BitmapCharacterSet methodsFor: 'copying'!, aCollection	"GS doesn't define #, for non-Sequenceable collections"	^ self copy		addAll: aCollection;		yourself! !!BitmapCharacterSet methodsFor: 'comparing'!= anObject	self == anObject		ifTrue: [^ true].	(self species == anObject species		and: [self size = anObject size])		ifFalse: [^ false].	self do: [:each |		(anObject includes: each)			ifFalse: [^ false]].	^ true.! !!BitmapCharacterSet methodsFor: 'adding'!add: aCharacter	| asciiValue |	"optimized for speed with inlining; do not refactor"	(asciiValue := aCharacter asciiValue) < 256		ifTrue: [			(byteCharacters at: asciiValue + 1)				ifFalse: [tally := tally + 1].			byteCharacters				at: asciiValue + 1				put: true]		ifFalse: [| byteIndex byte bitmask |			"256 // 8 - 31 = 1 (first index), (256 + 8) // 8 - 31 = 2 (second), etc			(with 'bitShift: -3' used over '// 8' for speed)"			byteIndex := (asciiValue bitShift: -3) - 31.			(wideCharacters == nil				or: [byteIndex > wideCharacters size])				ifTrue: [self growWideCharacterBitmapTo: (byteIndex * 1.5) asInteger].			"raises an error if asciiValue > 16r10FFFF"			byte := wideCharacters at: byteIndex.			"for the byte bitmask, left shift 1 by 7 - (asciiValue \\ 8)			(with 'bitAnd: 7' used over '\\ 8' for speed)"			bitmask := 1 bitShift: 7 - (asciiValue bitAnd: 7).						"increment the tally if the character is not already present"			(byte bitAnd: bitmask) == 0				ifTrue: [tally := tally + 1].			wideCharacters				at: byteIndex				put: (byte bitOr: bitmask)].	^ aCharacter.! !!BitmapCharacterSet methodsFor: 'adding'!addRangeFrom: aStartCharacter to: aStopCharacter	"Adds character range from aStartCharacter to aStopCharacter inclusive	or none if aStartCharacter > aStopCharacter. Returns self to avoid	creating a temp collection of the added characters."	"chars don't support to:do: (compiled inline) and using to: and do:	separately needlessly creates a (possibly large) temp array"	aStartCharacter asciiValue		to: aStopCharacter asciiValue		do: [:i | self add: (Character value: i)]! !!BitmapCharacterSet methodsFor: 'private'!byteCharacters	^ byteCharacters! !!BitmapCharacterSet methodsFor: 'enumerating'!byteCharactersDo: aBlock	1 to: byteCharacters size do: [:i |		(byteCharacters at: i)			ifTrue: [aBlock value: (Character value: i - 1)]]! !!BitmapCharacterSet methodsFor: 'accessing'!capacity	^ byteCharacters size +		(wideCharacters			ifNil: [0]			ifNotNil: [wideCharacters size * 8]).! !!BitmapCharacterSet methodsFor: 'converting'!complement	| copy |	copy := self copyEmpty.	0 to: 16r10FFFF do: [:i | | character |		character := (Character value: i).		(self includes: character)			ifFalse: [copy add: character]].	^ copy.! !!BitmapCharacterSet methodsFor: 'copying'!copyEmpty	"reimplemented for GS and Squeak compatibility"	^ self species new: self capacity! !!BitmapCharacterSet methodsFor: 'enumerating'!do: aBlock	self		byteCharactersDo: aBlock;		wideCharactersDo: aBlock! !!BitmapCharacterSet methodsFor: 'private'!growWideCharacterBitmapTo: aSizeInBytes	| newSize |	newSize := aSizeInBytes min: self maxWideCharactersSize.	wideCharacters		ifNil: [wideCharacters := ByteArray new: newSize]		ifNotNil: [			wideCharacters :=				(ByteArray new: newSize)					replaceFrom: 1					to: wideCharacters size					with: wideCharacters					startingAt: 1].! !!BitmapCharacterSet methodsFor: 'testing'!hasWideCharacters	self wideCharactersDo: [:each | ^ true].	^ false.! !!BitmapCharacterSet methodsFor: 'comparing'!hash	| hash |	hash := self species hash.	self byteCharactersDo: [:each |		hash := hash bitXor: each hash].	^ hash bitXor: self size hash.! !!BitmapCharacterSet methodsFor: 'testing'!includes: aCharacter	| asciiValue |	"optimized for speed with inlining; do not refactor"	(asciiValue := aCharacter asciiValue) < 256		ifTrue: [^ byteCharacters at: asciiValue + 1]		ifFalse: [| byteIndex |			wideCharacters				ifNil: [^ false].			"256 // 8 - 31 = 1 (first index), (256 + 8) // 8 - 31 = 2 (second), etc			(with 'bitShift: -3' used over '// 8' for speed)"			(byteIndex := (asciiValue bitShift: -3) - 31) > wideCharacters size				ifTrue: [^ false].			"for the byte bitmask, left shift 1 by 7 - (asciiValue \\ 8)			(with 'bitAnd: 7' used over '\\ 8' for speed)"			^ ((wideCharacters at: byteIndex) bitAnd:				(1 bitShift: 7 - (asciiValue bitAnd: 7))) > 0]! !!BitmapCharacterSet methodsFor: 'testing'!includesRangeFrom: aStartCharacter to: aStopCharacter	"Tests for character range from aStartCharacter to aStopCharacter	inclusive. Always returns true if aStartCharacter > aStopCharacter."	"chars don't support to:do: (compiled inline) and using to: and do:	separately needlessly creates a (possibly large) temp array"	aStartCharacter asciiValue		to: aStopCharacter asciiValue		do: [:i |			(self includes: (Character value: i))				ifFalse: [^ false]].	^ true.! !!BitmapCharacterSet methodsFor: 'initialization'!initialize: aCapacity	byteCharacters := Array new: 256 withAll: false.	aCapacity > 256		ifTrue: [			"(257 - 1) // 8 - 31 = 1 (first byte),			(257 + 8 - 1) // 8 - 31 = 2 (second byte), etc			(with 'bitShift: -3' used over '// 8' for speed)"			self growWideCharacterBitmapTo: ((aCapacity - 1) bitShift: -3) - 31].	tally := 0.! !!BitmapCharacterSet methodsFor: 'testing'!isEmpty	"Squeak's Collection>>#isEmpty is inefficient"	^ self size = 0! !!BitmapCharacterSet methodsFor: 'private'!maxWideCharactersSize	^ 139232 "(16r10FFFF bitShift: -3) - 31"! !!BitmapCharacterSet methodsFor: 'copying'!postCopy	byteCharacters := byteCharacters copy.	wideCharacters		ifNotNil: [wideCharacters := wideCharacters copy].! !!BitmapCharacterSet methodsFor: 'removing'!remove: aCharacter ifAbsent: aBlock	| asciiValue |	"optimized for speed with inlining; do not refactor"	(asciiValue := aCharacter asciiValue) < 256		ifTrue: [			(byteCharacters at: asciiValue + 1)				ifFalse: [^ aBlock value].			byteCharacters				at: asciiValue + 1				put: false]		ifFalse: [| byteIndex byte bitmask |			wideCharacters				ifNil: [^ aBlock value].				"256 // 8 - 31 = 1 (first index), (256 + 8) // 8 - 31 = 2 (second), etc			(with 'bitShift: -3' used over '// 8' for speed)"			(byteIndex := (asciiValue bitShift: -3) - 31) > wideCharacters size				ifTrue: [^ aBlock value].			"for the byte bitmask, left shift 1 by 7 - (asciiValue \\ 8)			(with 'bitAnd: 7' used over '\\ 8' for speed)"			bitmask := 1 bitShift: 7 - (asciiValue bitAnd: 7).			((byte := wideCharacters at: byteIndex) bitAnd: bitmask) == 0				ifTrue: [^ aBlock value].			wideCharacters				at: byteIndex				put: (byte bitAnd: bitmask bitInvert)].	tally := tally - 1.	^ aCharacter.! !!BitmapCharacterSet methodsFor: 'removing'!removeAll	"empties but preserves the capacity"	1 to: byteCharacters size do: [:i |		byteCharacters			at: i			put: false].	wideCharacters		ifNotNil: [			1 to: wideCharacters size do: [:i |				wideCharacters					at: i					put: 0]].	tally := 0.! !!BitmapCharacterSet methodsFor: 'removing'!removeRangeFrom: aStartCharacter to: aStopCharacter	"Removes character range from aStartCharacter to aStopCharacter inclusive	or none if aStartCharacter > aStopCharacter. Returns self to avoid	creating a temp collection of the removed characters."	"chars don't support to:do: (compiled inline) and using to: and do:	separately needlessly creates a (possibly large) temp array"	aStartCharacter asciiValue		to: aStopCharacter asciiValue		do: [:i | self remove: (Character value: i)]! !!BitmapCharacterSet methodsFor: 'accessing'!size	^ tally! !!BitmapCharacterSet methodsFor: 'private'!wideCharacters	^ wideCharacters! !!BitmapCharacterSet methodsFor: 'enumerating'!wideCharactersDo: aBlock	"optimized for speed with to:do: and inlining; do not refactor"	| baseValue |	wideCharacters		ifNil: [^ self].	baseValue := 256.	1 to: wideCharacters size do: [:byteIndex | | byte |		(byte := wideCharacters at: byteIndex) == 0			ifFalse: [				0 to: 7 do: [:shiftIndex |					(byte bitAnd: (1 bitShift: 7 - shiftIndex)) == 0						ifFalse: [							aBlock value:								(Character value: baseValue + shiftIndex)]]].		baseValue := baseValue + 8].! !"Collections-BitmapCharacterSet"!!StandardOrderedDictionary commentStamp: '' prior: 0!This class is a dictionary that uses key insertion order when enumerating, printing, or returing collections of keys/values/associations, but not when testing for equality.Insertion, updating, and inclusion testing have O(1) complexity while removing has O(n) worst-case.!!OrderPreservingDictionary commentStamp: '' prior: 0!An order-preserving dictionary that returns a configurable default value (nil by default) when an absent key or value is requested from it rather than raising an exception.!!OrderPreservingIdentityDictionary commentStamp: '' prior: 0!An IdentityDictionary version that uses == instead of = for key comparing.!!OrderPreservingStringDictionary commentStamp: '' prior: 0!An order-preserving dictionary for strings that returns empty strings instead of raising errors when absent keys/values are accessed.!!OrderPreservingIdentityStringDictionary commentStamp: '' prior: 0!An IdentityDictionary version that uses == instead of = for key comparing.!!StandardOrderedIdentityDictionary commentStamp: '' prior: 0!An IdentityDictionary version that uses == instead of = for key comparing.!!OrderPreservingDictionary class methodsFor: 'instance creation'!defaultValue: aDefaultValue	^ self new defaultValue: aDefaultValue! !!OrderPreservingDictionary class methodsFor: 'instance creation'!new: aCapacity withDefaultValue: aDefaultValue	^ self basicNew		initialize: aCapacity		withDefaultValue: aDefaultValue! !!OrderPreservingDictionary class methodsFor: 'instance creation'!newFrom: anAssociationCollection	| newDictionary |	newDictionary := super newFrom: anAssociationCollection.	(anAssociationCollection respondsTo: #defaultValue)		ifTrue: [newDictionary defaultValue: anAssociationCollection defaultValue].	^ newDictionary.! !!OrderPreservingDictionary methodsFor: 'accessing'!associationAt: aKey	^ self		associationAt: aKey		ifAbsent: [nil]! !!OrderPreservingDictionary methodsFor: 'accessing'!at: aKey	^ self		at: aKey		ifAbsent: [defaultValue]! !!OrderPreservingDictionary methodsFor: 'copying'!copyEmpty	^ self species defaultValue: defaultValue! !!OrderPreservingDictionary methodsFor: 'accessing'!defaultValue	^ defaultValue! !!OrderPreservingDictionary methodsFor: 'accessing'!defaultValue: aDefaultValue	defaultValue := aDefaultValue! !!OrderPreservingDictionary methodsFor: 'initialization'!initialize: aCapacity withDefaultValue: aDefaultValue	self initialize: aCapacity.	defaultValue := aDefaultValue.! !!OrderPreservingDictionary methodsFor: 'accessing'!keyAtIdentityValue: aValue	^ self		keyAtIdentityValue: aValue		ifAbsent: [defaultValue]! !!OrderPreservingDictionary methodsFor: 'accessing'!keyAtIndex: anIndex	^ self		keyAtIndex: anIndex		ifAbsent: [defaultValue]! !!OrderPreservingDictionary methodsFor: 'accessing'!keyAtValue: aValue	^ self		keyAtValue: aValue		ifAbsent: [defaultValue]! !!OrderPreservingDictionary methodsFor: 'removing'!removeKey: aKey	^ self		removeKey: aKey		ifAbsent: [defaultValue]! !!OrderPreservingDictionary methodsFor: 'private'!speciesNewFrom: anAssociationCollection	^ (self species newFrom: anAssociationCollection)		defaultValue: defaultValue! !!OrderPreservingIdentityDictionary methodsFor: 'accessing'!dictionaryClass	^ IdentityDictionary! !!OrderPreservingIdentityDictionary methodsFor: 'accessing'!indexOfKey: aKey ifAbsent: aBlock	^ self		identityIndexOfKey: aKey		ifAbsent: aBlock! !!OrderPreservingIdentityDictionary methodsFor: 'testing'!isIdentityDictionary	^ true! !!OrderPreservingIdentityDictionary methodsFor: 'private'!orderedKeysIndexOf: aKey	^ self orderedKeysIdentityIndexOf: aKey! !!OrderPreservingIdentityStringDictionary methodsFor: 'accessing'!dictionaryClass	^ IdentityDictionary! !!OrderPreservingIdentityStringDictionary methodsFor: 'accessing'!indexOfKey: aKey ifAbsent: aBlock	^ self		identityIndexOfKey: aKey		ifAbsent: aBlock! !!OrderPreservingIdentityStringDictionary methodsFor: 'testing'!isIdentityDictionary	^ true! !!OrderPreservingIdentityStringDictionary methodsFor: 'private'!orderedKeysIndexOf: aKey	^ self orderedKeysIdentityIndexOf: aKey! !!OrderPreservingStringDictionary methodsFor: 'accessing'!associationAt: aKey	^ self		associationAt: aKey		ifAbsent: [nil]! !!OrderPreservingStringDictionary methodsFor: 'accessing'!at: aKey	^ self		at: aKey		ifAbsent: ['']! !!OrderPreservingStringDictionary methodsFor: 'accessing'!keyAtIdentityValue: aValue	^ self		keyAtIdentityValue: aValue		ifAbsent: ['']! !!OrderPreservingStringDictionary methodsFor: 'accessing'!keyAtIndex: anIndex	^ self		keyAtIndex: anIndex		ifAbsent: ['']! !!OrderPreservingStringDictionary methodsFor: 'accessing'!keyAtValue: aValue	^ self		keyAtValue: aValue		ifAbsent: ['']! !!OrderPreservingStringDictionary methodsFor: 'removing'!removeKey: aKey	^ self		removeKey: aKey		ifAbsent: ['']! !!StandardOrderedDictionary class methodsFor: 'inspecting'!inspectorClass	^ Dictionary inspectorClass! !!StandardOrderedDictionary class methodsFor: 'instance creation'!new	^ self new: 10! !!StandardOrderedDictionary class methodsFor: 'instance creation'!new: aCapacity	^ self basicNew initialize: aCapacity! !!StandardOrderedDictionary class methodsFor: 'instance creation'!newFrom: anAssociationCollection	| newDictionary |	newDictionary := self new: anAssociationCollection size.	anAssociationCollection associationsDo: [:each |		newDictionary			at: each key			put: each value].	^ newDictionary.! !!StandardOrderedDictionary class methodsFor: 'instance creation'!newFromPairs: aSequenceableCollection	| newDictionary |	newDictionary := self new: (aSequenceableCollection size / 2) floor.	1 to: aSequenceableCollection size - 1 by: 2 do: [:i |		newDictionary			at: (aSequenceableCollection at: i)			put: (aSequenceableCollection at: i + 1)].	^ newDictionary.! !!StandardOrderedDictionary methodsFor: 'comparing'!= anObject	"Returns true if the receiver and argument are identical, or if they	are both some kind of order-preserving dictionary and if they have	the same associations regardless of order."	self == anObject		ifTrue: [^ true].	(anObject isOrderPreservingDictionary		and: [self isIdentityDictionary = anObject isIdentityDictionary			and: [self size = anObject size]])		ifFalse: [^ false].	dictionary associationsDo: [:each |		(anObject at: each key ifAbsent: [^ false]) = each value			ifFalse: [^ false]].	^ true.! !!StandardOrderedDictionary methodsFor: 'adding'!add: anAssociation	| oldSize |	oldSize := dictionary size.	dictionary add: anAssociation.	dictionary size > oldSize		ifTrue: [			orderedKeys size > oldSize				ifFalse: [self growOrderedKeys].			orderedKeys at: oldSize + 1 put: anAssociation key].	^ anAssociation.! !!StandardOrderedDictionary methodsFor: 'adding'!addAll: anAssociationCollection	"Since Collection implements #associationsDo:, this method can accept	any collection of associations including Arrays and OrderedCollections"	anAssociationCollection associationsDo: [:each | self add: each].	^ anAssociationCollection.! !!StandardOrderedDictionary methodsFor: 'accessing'!associationAt: aKey	^ dictionary associationAt: aKey! !!StandardOrderedDictionary methodsFor: 'accessing'!associationAt: aKey ifAbsent: aBlock	^ dictionary		associationAt: aKey		ifAbsent: aBlock! !!StandardOrderedDictionary methodsFor: 'accessing'!associationAt: aKey ifPresent: aBlock	"Squeak and GS do not have #associationAt:ifPresent: so it	is reimplemented for portability"	^ aBlock cull:		(dictionary			associationAt: aKey			ifAbsent: [^ nil])! !!StandardOrderedDictionary methodsFor: 'accessing'!associations	| associations i |	associations := Array new: self size.	i := 1.	self associationsDo: [:each |		associations at: i put: each.		i := i + 1].	^ associations.! !!StandardOrderedDictionary methodsFor: 'enumerating'!associationsDo: aBlock	self keysDo: [:each |		aBlock value: (self associationAt: each)]! !!StandardOrderedDictionary methodsFor: 'enumerating'!associationsSelect: aBlock	^ self speciesNewFrom: (self associations select: aBlock)! !!StandardOrderedDictionary methodsFor: 'accessing'!at: aKey	^ dictionary at: aKey! !!StandardOrderedDictionary methodsFor: 'accessing'!at: aKey ifAbsent: aBlock	^ dictionary		at: aKey		ifAbsent: aBlock! !!StandardOrderedDictionary methodsFor: 'accessing'!at: aKey ifAbsentPut: aBlock	^ self		at: aKey		ifAbsent: [			self				at: aKey				put: aBlock value]! !!StandardOrderedDictionary methodsFor: 'accessing'!at: aKey ifPresent: aBlock	"Squeak and GS don't use #cull: for the ifPresent:	block, so it is reimplemented for portability"	^ aBlock cull:		(self			at: aKey			ifAbsent: [^ nil])! !!StandardOrderedDictionary methodsFor: 'accessing'!at: aKey ifPresent: aPresentBlock ifAbsent: anAbsentBlock	"Squeak and GS don't use #cull: for the ifPresent:	block, so it is reimplemented for portability"	self		at: aKey		ifPresent: [:value | ^ aPresentBlock cull: value].	^ anAbsentBlock value.! !!StandardOrderedDictionary methodsFor: 'accessing'!at: aKey put: aValue	| oldSize |	oldSize := dictionary size.	dictionary		at: aKey		put: aValue.	dictionary size > oldSize		ifTrue: [			orderedKeys size > oldSize				ifFalse: [self growOrderedKeys].			orderedKeys at: oldSize + 1 put: aKey].	^ aValue.! !!StandardOrderedDictionary methodsFor: 'accessing'!capacity	^ dictionary capacity! !!StandardOrderedDictionary methodsFor: 'enumerating'!collect: aBlock	^ self speciesNewFrom:		(self associations collect: [:each |			each key -> (aBlock value: each value)])! !!StandardOrderedDictionary methodsFor: 'copying'!copyEmpty	"Squeak and GS don't have Collection>>#copyEmpty:, so it is	reimplemented for portability"	^ self species new! !!StandardOrderedDictionary methodsFor: 'private'!dictionary	^ dictionary! !!StandardOrderedDictionary methodsFor: 'accessing'!dictionaryClass	^ Dictionary! !!StandardOrderedDictionary methodsFor: 'enumerating'!do: aBlock	self valuesDo: aBlock! !!StandardOrderedDictionary methodsFor: 'private'!errorInvalidIndex: anIndex	"Squeak and GS do not have SubscriptOutOfBounds, so Error is used	for portability"	Error signal: 'Invalid index: ', anIndex printString! !!StandardOrderedDictionary methodsFor: 'private'!errorValueNotFound: aValue	"Squeak and GS do not have ValueNotFound, so Error is used	for portability"	Error signal: 'Value not found'! !!StandardOrderedDictionary methodsFor: 'private'!growOrderedKeys	orderedKeys :=		(Array new: ((orderedKeys size * 1.5) asInteger max: 10))			replaceFrom: 1			to: orderedKeys size			with: orderedKeys			startingAt: 1.! !!StandardOrderedDictionary methodsFor: 'comparing'!hash	^ dictionary hash! !!StandardOrderedDictionary methodsFor: 'accessing'!identityIndexOfKey: aKey	^ self		identityIndexOfKey: aKey		ifAbsent: [0]! !!StandardOrderedDictionary methodsFor: 'accessing'!identityIndexOfKey: aKey ifAbsent: aBlock	1 to: self size do: [:i |		(orderedKeys at: i) == aKey			ifTrue: [^ i]].	^ aBlock value.! !!StandardOrderedDictionary methodsFor: 'testing'!includes: anObject	^ dictionary includes: anObject! !!StandardOrderedDictionary methodsFor: 'testing'!includesAssociation: anAssociation	"IndentityDictionary>>includesAssociation: works differently on GS	testing both key and value identity, so it is reimplemented here	to behave like Pharo/Squeak"	^ (dictionary		at: anAssociation key		ifAbsent: [^ false]) = anAssociation value! !!StandardOrderedDictionary methodsFor: 'testing'!includesIdentity: anObject	"GS does not have includesIdentity:"	self valuesDo: [:each |		each == anObject			ifTrue: [^ true]].	^ false.! !!StandardOrderedDictionary methodsFor: 'testing'!includesKey: aKey	^ dictionary includesKey: aKey! !!StandardOrderedDictionary methodsFor: 'accessing'!indexOfKey: aKey	^ self		indexOfKey: aKey		ifAbsent: [0]! !!StandardOrderedDictionary methodsFor: 'accessing'!indexOfKey: aKey ifAbsent: aBlock	1 to: self size do: [:i |		(orderedKeys at: i) = aKey			ifTrue: [^ i]].	^ aBlock value.! !!StandardOrderedDictionary methodsFor: 'initialization'!initialize: aCapacity	dictionary := self dictionaryClass new: aCapacity.	orderedKeys := Array new: aCapacity.! !!StandardOrderedDictionary methodsFor: 'testing'!isDictionary	^ true! !!StandardOrderedDictionary methodsFor: 'testing'!isEmpty	"Squeak's Collection>>#isEmpty is inefficient"	^ self size = 0! !!StandardOrderedDictionary methodsFor: 'testing'!isIdentityDictionary	^ false! !!StandardOrderedDictionary methodsFor: 'testing'!isOrderPreservingDictionary	^ true! !!StandardOrderedDictionary methodsFor: 'accessing'!keyAtIdentityValue: aValue	^ self		keyAtIdentityValue: aValue		ifAbsent: [self errorValueNotFound: aValue]! !!StandardOrderedDictionary methodsFor: 'accessing'!keyAtIdentityValue: aValue ifAbsent: aBlock	"GS does not have keyAtIdentityValue:ifAbsent:"	self keysAndValuesDo: [:key :value |		value == aValue			ifTrue: [^ key]].	^ aBlock value.! !!StandardOrderedDictionary methodsFor: 'accessing'!keyAtIndex: anIndex	^ self		keyAtIndex: anIndex		ifAbsent: [self errorInvalidIndex: anIndex]! !!StandardOrderedDictionary methodsFor: 'accessing'!keyAtIndex: anIndex ifAbsent: aBlock	(anIndex > 0 and: [anIndex <= self size])		ifTrue: [^ orderedKeys at: anIndex]		ifFalse: [^ aBlock value]! !!StandardOrderedDictionary methodsFor: 'accessing'!keyAtValue: aValue	^ dictionary keyAtValue: aValue! !!StandardOrderedDictionary methodsFor: 'accessing'!keyAtValue: aValue ifAbsent: aBlock	^ dictionary		keyAtValue: aValue		ifAbsent: aBlock! !!StandardOrderedDictionary methodsFor: 'accessing'!keyForIdentity: anObject	"reimplemented for portability"	self keysAndValuesDo: [:key :value |		value == anObject			ifTrue: [^ key]].	^ nil.! !!StandardOrderedDictionary methodsFor: 'accessing'!keys	^ orderedKeys		copyFrom: 1		to: self size! !!StandardOrderedDictionary methodsFor: 'enumerating'!keysAndValuesDo: aBlock	self keysDo: [:each |		aBlock			value: each			value: (self at: each)]! !!StandardOrderedDictionary methodsFor: 'removing'!keysAndValuesRemove: aTwoArgumentBlock	| removedAssociations |	removedAssociations := OrderedCollection new.	self associationsDo: [:each |		(aTwoArgumentBlock			value: each key			value: each value)			ifTrue: [removedAssociations add: each]].	removedAssociations do: [:each | self removeKey: each key].! !!StandardOrderedDictionary methodsFor: 'enumerating'!keysDo: aBlock	"use to:do: for speed"	1 to: self size do: [:i |		aBlock value: (orderedKeys at: i)]! !!StandardOrderedDictionary methodsFor: 'accessing'!keysSortedSafely	"GS's #keysSortedSafely returns a SortedCollection instead of	an Array, so this is reimplemented directly for portability, and	'self keys' is used instead of 'dictionary keys', because GS's	#keys returns a Set which can't be sorted"	^ self keys sort! !!StandardOrderedDictionary methodsFor: 'private'!orderedKeys	^ orderedKeys! !!StandardOrderedDictionary methodsFor: 'private'!orderedKeysIdentityIndexOf: aKey	"GS does not have #identityIndexOf:"	1 to: orderedKeys size do: [:i |		(orderedKeys at: i) == aKey			ifTrue: [^ i]].	^ 0.! !!StandardOrderedDictionary methodsFor: 'private'!orderedKeysIndexOf: aKey	^ orderedKeys indexOf: aKey! !!StandardOrderedDictionary methodsFor: 'private'!orderedKeysRemove: aRemovedKey	| index |	index := self orderedKeysIndexOf: aRemovedKey.	"shift every remaining key after to the left by one"	orderedKeys		replaceFrom: index		to: self size		with: orderedKeys		startingAt: index + 1.	"one key was removed and the rest shifted, so nil what was the last	key slot before removing and shifting"	orderedKeys		at: self size + 1		put: nil.! !!StandardOrderedDictionary methodsFor: 'copying'!postCopy	orderedKeys := orderedKeys copy.	dictionary := dictionary copy.! !!StandardOrderedDictionary methodsFor: 'printing'!printElementsOn: aStream	aStream nextPut: $(.	self size > 100		ifTrue: [			aStream nextPutAll: 'size '.			self size printOn: aStream]		ifFalse: [			self associations withIndexDo: [:each :i |				aStream					print: each key;					nextPutAll: '->';					print: each value.				(i < self size)					ifTrue: [aStream space]]].	aStream nextPut: $).! !!StandardOrderedDictionary methodsFor: 'removing'!remove: anObject ifAbsent: aBlock	self shouldNotImplement! !!StandardOrderedDictionary methodsFor: 'removing'!removeAll	1 to: self size do: [:i |		orderedKeys			at: i			put: nil].	dictionary removeAll.! !!StandardOrderedDictionary methodsFor: 'removing'!removeKey: aKey	| value |	value := dictionary removeKey: aKey.	self orderedKeysRemove: aKey.	^ value.! !!StandardOrderedDictionary methodsFor: 'removing'!removeKey: aKey ifAbsent: aBlock	| oldSize value |	oldSize := dictionary size.	value :=		dictionary			removeKey: aKey			ifAbsent: aBlock.	dictionary size < oldSize		ifTrue: [self orderedKeysRemove: aKey].	^ value.! !!StandardOrderedDictionary methodsFor: 'removing'!removeKeys: aKeyCollection	"Fast removal of multiple keys; returns self to avoid	having to create a removed value collection and does not	raise errors."	aKeyCollection	size > 1		ifTrue: [| oldSize newOrderedKeys newOrderedKeysIndex |			oldSize := self size.			aKeyCollection do: [:each |				dictionary					removeKey: each					ifAbsent: [nil]].			newOrderedKeys := Array new: oldSize.			newOrderedKeysIndex := 0.			1 to: oldSize do: [:i | | key |				(dictionary includesKey: (key := orderedKeys at: i))					ifTrue: [						newOrderedKeys							at: (newOrderedKeysIndex := newOrderedKeysIndex + 1)							put: key]].			orderedKeys := newOrderedKeys]		ifFalse: [			aKeyCollection size = 1				ifTrue: [					"use #anyOne, because it can be a Set"					self						removeKey: aKeyCollection anyOne						ifAbsent: [nil]]]! !!StandardOrderedDictionary methodsFor: 'enumerating'!select: aBlock	^ self speciesNewFrom:		(self associations select: [:each | aBlock value: each value])! !!StandardOrderedDictionary methodsFor: 'accessing'!size	^ dictionary size! !!StandardOrderedDictionary methodsFor: 'private'!speciesNewFrom: anAssociationCollection	^ self species newFrom: anAssociationCollection! !!StandardOrderedDictionary methodsFor: 'accessing'!values	^ self associations collect: [:each | each value]! !!StandardOrderedDictionary methodsFor: 'enumerating'!valuesDo: aBlock	self keysDo: [:each |		aBlock value: (self at: each)]! !!StandardOrderedIdentityDictionary methodsFor: 'accessing'!dictionaryClass	^ IdentityDictionary! !!StandardOrderedIdentityDictionary methodsFor: 'accessing'!indexOfKey: aKey ifAbsent: aBlock	^ self		identityIndexOfKey: aKey		ifAbsent: aBlock! !!StandardOrderedIdentityDictionary methodsFor: 'testing'!isIdentityDictionary	^ true! !!StandardOrderedIdentityDictionary methodsFor: 'private'!orderedKeysIndexOf: aKey	^ self orderedKeysIdentityIndexOf: aKey! !!Object methodsFor: '*Collections-OrderPreservingDictionary'!isOrderPreservingDictionary	"Defined here because not all collections inherit from Collection,	so just defining it in Collection and StandardOrderedDictionary	and using #isCollection with #isOrderPreservingDictionary in	StandardOrderedDictionary>>#= would trigger a DNU."	^ false! !"Collections-OrderPreservingDictionary"!!DTDAttributeDefinitionParser commentStamp: '' prior: 0!This class parses an attribute definition in an ATTLIST declaration and returns a new XMLAttributeValidator for it. It assumes the type has already been checked for well-formedness by the tokenizer and that it contains a value like "ID", "ENTITY", or an enumeration list.!!DTDStandaloneExternalAttributeDefinitionParser commentStamp: '' prior: 0!This class parses standalone externally defined ATTLIST attribute definitions and returns XMLAttributeValidators for them that disallow attributes needing further value normalization or substitution with default or fixed default values.!!DTDContentModelParser commentStamp: '' prior: 0!This is a base class for DTD content model parsers that turn element declarations into XMLElementValidators.!!DTDElementContentModelParser commentStamp: '' prior: 0!This class parses element content models. It uses postfix conversion and an XMLNFABuilder to build an NFA before converting it to a lazy DFA (states are built when needed and cached) and returns it as an XMLElementValidator.It assumes all spaces have been removed from the input and that it's been checked for well-formedness, meaning no missing names or misplaced operators/parentheses.!!DTDStandaloneExternalElementContentModelParser commentStamp: '' prior: 0!This class parses standalone externally defined element content models and returns XMLElementValidators for them. Validators for content models that specify element content like "(one|two+)" won't treat whitespace as ignorable.!!DTDLiteralContentModelParser commentStamp: '' prior: 0!This class parses literal "ANY" and "EMPTY" element content models and returns XMLElementValidators accepting any content or no content (not even whitespace, comments, or PIs).!!DTDMixedContentModelParser commentStamp: '' prior: 0!This class parses mixed content declarations like "(#PCDATA|one|two)*" using a DTDEnumerationListParser and returns an XMLElementValidator accepting any sequence of PCDATA and the named elements in any order.!!DTDDoctypeDefinition commentStamp: '' prior: 0!This class represents the parsed internal and external subset of a DTD taken together.!!DTDEntity commentStamp: '' prior: 0!This is an abstract base class for internal and external parsed entities with replacements that can be inserted into an XML document.!!DTDParsedEntity commentStamp: '' prior: 0!This is an abstract base class for parsed entities with replacements that can be inserted into an XML document.!!DTDExternalParsedEntity commentStamp: '' prior: 0!This is an abstract base class for external parsed entities with external replacements that can be inserted into an XML document.The external replacements are resolved lazily the first time #replacement or #replacementStream is sent.!!DTDExternalGeneralParsedEntity commentStamp: '' prior: 0!This is a class for external general parsed entities with external replacements that can be inserted into an XML document.!!DTDStandaloneExternalExternalGeneralParsedEntity commentStamp: '' prior: 0!This is a class for standalone externally defined external general entities that cannot be referenced in documents.!!DTDExternalParameterParsedEntity commentStamp: '' prior: 0!This is a class for external parameter parsed entities with external replacements that can be inserted into an XML document.!!DTDInternalParsedEntity commentStamp: '' prior: 0!This is an abstract base class for internal parsed entities with replacements that can be inserted into an XML document.!!DTDInternalGeneralParsedEntity commentStamp: '' prior: 0!This is a class for internal general parsed entities with replacements that can be inserted into documents.!!DTDStandaloneExternalInternalGeneralParsedEntity commentStamp: '' prior: 0!This is a class for standalone externally defined external general entities that cannot be referenced in documents except in ATTLIST attribute declaration default values.!!DTDInternalParameterParsedEntity commentStamp: '' prior: 0!This is a class for internal parameter parsed entities with replacements that can be inserted into documents.!!DTDUnresolvableExternalParsedEntity commentStamp: '' prior: 0!This is an abstract base class for unresolvable external parsed entities that lazily raises an error when #replacement or #replacementStream is sent, which would normally trigger resolution.!!DTDUnresolvableExternalGeneralParsedEntity commentStamp: '' prior: 0!This is a class for unresolvable external general parsed entities that lazily raises an error when #replacement or #replacementStream is sent, which would normally trigger resolution.!!DTDUnresolvableExternalParameterParsedEntity commentStamp: '' prior: 0!This is a class for unresolvable external parameter parsed entities that lazily raises an error when #replacement or #replacementStream is sent, which would normally trigger resolution.!!DTDUnparsedEntity commentStamp: '' prior: 0!A class for unparsed entities. These should never be directly referenced in content with the &name; syntax, but can be named in values of ENTITY and ENTITIES attributes.!!DTDEntityConfiguration commentStamp: '' prior: 0!This class contains configurations for entity replacement/retrieval. It is separate from XMLConfiguration so it is only lazy initialized when needed and saves memory.!!DTDEnumerationListParser commentStamp: '' prior: 0!This is a parser of lists in the form of "(one|two|...)".  It assumes there is no whitespace around the "|" separated list values.!!DTDMixedContentEnumerationListParser commentStamp: '' prior: 0!This is a parser of mixed content lists in the form of "(#PCDATA|one|two|...)*".  It assumes there is no whitespace around the "|" separated list values.!!DTDNotationEnumerationListParser commentStamp: '' prior: 0!This class parses notation attribute value lists in the form of "NOTATION (one|two|...)". It assumes there is no whitespace around the "|" separated list values.!!DTDExternalEntityLimits commentStamp: '' prior: 0!This class places security limits on the number and size of external parsed entities. You can set these using the configuration messages in DTDExternalEntityResolver or remove them using removeLimits.!!DTDExternalEntityResolver commentStamp: '' prior: 0!This class resolves external entity references using XMLURI, XMLHTTPRequest, and XMLFileHandle.The #externalEntityURIFromPublicID:systemID: and #externalEntityURIFromPublicID:systemID:baseURI: convert public IDs and system IDs into resolvable XMLURI objects.The #resolveExternalEntityURI: and #streamResolveExternalEntityURI: messages can resolve external entity XMLURIs or URI strings as either a string or a stream on the undecoded entity content. If the entity is in a file, then #streamResolveExternalEntityURI: can be used to avoid storing it in-memory, but if it's fetched over HTTP, it will just return a stream on the entire in-memory HTTP response.!!DTDCachingExternalEntityResolver commentStamp: '' prior: 0!This class is a resolver that caches non-local entities in a global cache so they don't have to be retrieved again (like over HTTP). This is the default resolver.!!DTDStaticExternalEntityResolver commentStamp: '' prior: 0!This class is a resolver that maps entity URIs to string replacements so resolution can be done without HTTP or file access. Used during testing.!!DTDExternalEntityResolverLimitingDecorator commentStamp: '' prior: 0!This class is a decorator for DTDExternalEntityResolvers that limits the number of entities that can be resolved. This is not handled directly by resolvers to make them less stateful and more reusable.!!DTDNotation commentStamp: '' prior: 0!A class for notation declarations.!!DTDResolvedExternalParsedEntityReplacement commentStamp: '' prior: 0!This is an abstract class for resolved external entity replacements.!!DTDDecodedResolvedExternalParsedEntityReplacement commentStamp: '' prior: 0!This class stores the decoded resolved replacement of an external parsed entity.!!DTDUndecodedResolvedExternalParsedEntityReplacement commentStamp: '' prior: 0!This class stores the undecoded resolved replacement of an external parsed entity as well as its likely encoding.!!DTDUnresolvedExternalParsedEntityReplacement commentStamp: '' prior: 0!This class stores an entity resolver and the public ID, system ID, and base URI of an external entity so its replacement can be lazily resolved only if the entity is referenced.!!SAX2ContentHandler commentStamp: '' prior: 0!This is a base class for SAX2 content handler classes that can be injected into SAX2Parser instances with #contentHandler: before parsing:	(SAX2Parser on: xmlStringOrStream)		contentHandler: MyContentHandlerClass new;		parseDocument.See SAX2Parser and SAXHandler for more info.!!SAX2DeclarationHandler commentStamp: '' prior: 0!This is a base class for SAX2 declaration handler classes that can be injected into SAX2Parser instances with #declarationHandler: before parsing:	(SAX2Parser on: xmlStringOrStream)		declarationHandler: MyDeclarationHandlerClass new;		parseDocument.See SAX2Parser and SAXHandler for more info.!!SAX2ElementHandler commentStamp: '' prior: 0!This is a base class for SAX2 element handlers to be used with SAX2ElementParsers.SAX2ElementParsers use individual SAX2ElementHandlers to handle the #startElement*, #endElement*, and #characters: events of each element in the document.The parser can be accessed with #parser, and the parent element handler (if any) can be accessed with #parent.!!SAX2ElementCharacterHandler commentStamp: '' prior: 0!This class is a SAX2ElementHandler that handles #characters: events. Sending #characters returns the complete character data of the element as a string.!!SAX2ElementHandlerFactory commentStamp: '' prior: 0!This is a base class for element handler factories used by SAX2ElementParsers to create element handlers. Instances can be injected into a SAX2ElementParser with #elementHandlerFactory: before parsing.This factory just uses the default handler class SAX2ElementHandler for all elements.!!SAX2PluggableElementHandlerFactory commentStamp: '' prior: 0!This class is a pluggable element handler factory with an API like XMLPluggableElementFactory. Instances can be injected into a SAX2ElementParser with #elementHandlerFactory: before parsing.You can map combinations of element name, namespace URI, and attributes to specific element handler classes using the "handling" messages, and change the default element handler class used when there's no mapping with #elementHandlerClass:.Instances can be saved and reused for performance and safely modified after copying.!!SAX2ElementHandlerFactoryMapper commentStamp: '' prior: 0!This is a base class for mappers to map element handler objects to element handler factories.Requesting the factory for an element handler checks the handler's #elementHandlerFactory message first and then the mapper's own #elementHandlerFactory message which can be (and is) overridden in subclasses to return a default factory.When a SAX2ElementParser requests the factory for a new element handler, if none is found, it will reuse (inherit) the current factory.!!SAX2PluggableElementHandlerFactoryMapper commentStamp: '' prior: 0!This class is a pluggable mapper to map element handler objects to element handler factories.Requesting the factory for an element handler checks for a mapping set with  #mapElementHandlerClass: toFactory:, then the handler's  #elementHandlerFactory message, then the mapper's own #elementHandlerFactory message, which returns a default factory (unlike in the base class) which can be changed with #elementHandlerFactory:.When a SAX2ElementParser requests the factory for a new element handler, if none is found, it will reuse (inherit) the current factory, but this won't happen unless the default factory is cleared by setting #elementHandlerFactory: to nil.Instances can be saved and reused for performance and safely modified after copying.!!SAX2LexicalHandler commentStamp: '' prior: 0!This is a base class for SAX2 lexical handler classes that can be injected into SAX2Parser instances with #lexicalHandler: before parsing:	(SAX2Parser on: xmlStringOrStream)		lexicalHandler: MyLexicalHandlerClass new;		parseDocument.See SAX2Parser and SAXHandler for more info.!!SAXHandler commentStamp: '' prior: 0!This class is an event-handling XML parser. To use it, subclass it and override event handlers in the "handling" categories, such as #startDocument, #startElement:attributes:, #endElement:, and #endDocument.By default XML namespace support and validation are enabled but not external entity resolution.Once the subclass is ready, use the class "parsing" messages to parse XML:	result := SAXHandlerSubclass parse: xmlStringOrStream.	resultFromURL := SAXHandlerSubclass parseURL: xmlURLString.	resultFromFile := SAXHandlerSubclass parseFileNamed: xmlFileName.The class "instance creation" messages create and return new parsers on the input so they can be configured with messages in the  "configuring" category before parsing:	result :=		(SAXHandlerSubclass on: xmlStringOrStream)			isValidating: true;			resolvesExternalEntities: true;			parseDocument.#interruptParsing can be sent from within a handler to stop parsing, and there is also #parseDocumentWhile: and #parseDocumentUntil: 	result :=		(SAXHandlerSubclass on: xmlStringOrStream)			parseDocumentWhile: [self shouldKeepParsing].To parse incrementally, send #parser to an instance to get the underlying XMLParser object and send it #parseToken repeatedly:	(handler := SAXHandlerSubclass on: xmlStringOrStream)		isValidating: false; 		preservesUndeclaredEntityReferences: true.	parser := handler parser.	"Only parse the first 10 tokens:"	10 timesRepeat: [parser parseToken].There are security limits on input you can remove with #removeLimits or change with messages like #documentReadLimit:	result :=		(SAXHandlerSubclass on: xmlStringOrStream)			removeLimits;			documentReadLimit: newReadLimit;			maxEntityReplacementDepth: newMaxEntityDepth;			parseDocument.		#optimizeForLargeDocuments can be used when parsing large documents if you don't care for validating or namespaces.!!SAX2Parser commentStamp: '' prior: 0!This class is a parser with an API like SAX 2.0, with separate SAX2ContentHandler, SAX2LexicalHandler, and SAX2DeclarationHandler classes that are subclassed unlike SAX 1.0 where a single,  unified handler class is subclassed directly. Parsers can be created with #on: or other instance creation messages, and instances of the content, lexical, and declaration handlers can be injected before parsing with #contentHandler:, #lexicalHandler:, and #declarationHandler:, like this:	(SAX2Parser on: xmlStringOrStream)		contentHandler: MyContentHandlerClass new;		declarationHandler: MyDeclarationHandlerClass new;		lexicalHandler: MyLexicalHandlerClass new;		parseDocument.Each handler can access the SAX2Parser object with #parser and set the parsing result returned by #parseDocument with #parsingResult:.SAXHandler is not deprecated and can still be used if you prefer the SAX 1.0 style API.!!SAX2ElementParser commentStamp: '' prior: 0!This class is a SAX2Parser that uses individual SAX2ElementHandlers to handle the #startElement*, #endElement*, and #characters: events of each element in the document. All other content events are handled by a single SAX2ContentHandler as usual.Custom subclasses of SAX2ElementHandler can be mapped to element names, namespace URIs, and attributes using a SAX2PluggableElementHandlerFactory. Factories can be injected with #elementHandlerFactory: before parsing.See #testParsingSampleBooks for an example.You can have multiple factories by mapping specific SAX2ElementHandlers to specific factories using a SAX2PluggableElementHandlerFactoryMapper, which can be injected with #elementHandlerFactoryMapper: before parsing. This can be used to create a finite-state machine, with the element handler instances being the states and the mapped factories being their transitions.See #testParsingSamplePerson for an example.!!XMLDOMParser commentStamp: '' prior: 0!This class is an XML parser that parses XML into a tree of nodes with an XMLDocument node as the root:	document := XMLDOMParser parse: xmlStringOrStream.See the XML-Parser-DOM category for info on the node classes.By default, XML comments are ignored during parsing and "<!![CDATA[...]]>" sections are merged with adjacent character data as XMLString nodes. Use #preservesCommentNodes: or #preservesCDataNodes: before parsing to change this. You can also use #preservesIgnorableWhitespace: to preserve ignorable whitespace as XMLString nodes, but this requires a DTD with <!!ELEMENT> declarations to distinguish ignorable and unignorable whitespace.To control what node classes the parser uses to construct the tree, inject a custom node factory with #nodeFactory: prior to parsing. See XMLNodeFactory.See the superclass for more info.!!XMLAbstractFactory commentStamp: '' prior: 0!An abstract class for dynamically choosing a supported concrete implementation from a class hierarchy for this platform.Each root subclass needs to override #preferredImplementation to return the preferred subclass and #noSupportedImplementationFound to signal an error if none are supported, and then each subclass of the root needs to define #isSupportedImplementation to return true if it supports this platform.!!XMLFileHandle commentStamp: '' prior: 0!This is an abstract class for file handles to read/write/delete files. Subclasses need to implement the abstract methods, and then instances of the correct concrete class for this platform can be created by sending #asXMLFileHandle to a string.The #readStream/#writeStream messages return file streams that do decoding/encoding, while the #rawReadStream/#rawWriteStream streams don't.These classes implement the #get/#getUpToLimit:decoding: and #streamGet/#streamGetUpToLimit:decoding: interface of XMLURI.!!XMLFileDirectoryFileHandle commentStamp: '' prior: 0!This class uses FileDirectory/DirectoryEntry to implement file IO. This is used on Squeak and Gemstone, which don't support the Pharo FileSystem API.!!XMLFileSystemFileHandle commentStamp: '' prior: 0!This class uses the Pharo FileSystem API to implement file IO. The preferred implementation.!!XMLFileReadStreamFactory commentStamp: '' prior: 0!An abstract factory for file read streams used by XMLFileHandles.Subclasses should create read streams that return raw byte characters and not characters decoded from some encoding (like UTF-8), so that XMLParser can do its own decoding later looking at byte-order marks and the <?xml ...?> encoding attribute.!!XMLStandardFileStreamReadStreamFactory commentStamp: '' prior: 0!A StandardFileStream read stream factory. This stream is preferred for Squeak/Pharo because it does no decoding and returns byte characters so XMLParser can do its own decoding.!!XMLFileWriteStreamFactory commentStamp: '' prior: 0!An abstract factory for file write streams used by XMLFileHandles.Subclasses should create write streams that do no automatic encoding and accept raw byte characters, so XMLParser can do its own encoding.!!XMLStandardFileStreamWriteStreamFactory commentStamp: '' prior: 0!A StandardFileStream write stream factory. This stream is preferred for Pharo/Squeak because it does no encoding and accepts byte characters so XMLParser can do its own encoding.!!XMLHTTPMessage commentStamp: '' prior: 0!This is an abstract class for HTTP messages.!!XMLHTTPRequest commentStamp: '' prior: 0!This is an abstract base class for HTTP requests.These classes implement the #get/#getUpToLimit:decoding: and #streamGet/#streamGetUpToLimit:decoding: interface of XMLURI.!!XMLHTTPWebClientRequest commentStamp: '' prior: 0!This class uses the WebClient library to implement HTTP requests. This is used on Squeak when Zinc isn't installed.!!XMLHTTPZincRequest commentStamp: '' prior: 0!This class uses Zinc HTTP Components to implement HTTP requests and is the preferred implementation.!!XMLHTTPResponse commentStamp: '' prior: 0!This is an abstract base class for HTTP responses.!!XMLHTTPWebClientResponse commentStamp: '' prior: 0!This class uses the WebClient library to implement HTTP responses. This is used on Squeak when Zinc isn't installed.!!XMLHTTPZincResponse commentStamp: '' prior: 0!This class uses Zinc HTTP Components to implement HTTP responses and is the preferred implementation.!!XMLKeyValueCache commentStamp: '' prior: 0!A simple key-value cache that automatically empties when it reaches a maximum size. Uses a reentrant mutex to ensure thread-safety.!!XMLStandardKeyValueCache commentStamp: '' prior: 0!This class is the standard key-value cache implementation used on Pharo/Squeak.!!XMLReentrantMutex commentStamp: '' prior: 0!An abstract class for reentrant mutexes that support nested sends of #critical: by the same process without deadlocking.!!XMLStandardReentrantMutex commentStamp: '' prior: 0!This class is the standard implementation that uses Pharo and Squeak's Mutex class to implement a reentrant mutex.!!XMLAbstractReadStream commentStamp: '' prior: 0!An abstract class for read streams.!!XMLNullReadStream commentStamp: '' prior: 0!This class is a null read stream that is already #atEnd and also makes sending #atEnd after #close or sending #close more than once safe, which is needed for the XMLNestedStreamReader null stream.!!XMLSingleCharacterReadStream commentStamp: '' prior: 0!A read stream for single characters. This is faster and uses less memory than converting a char to a string and using a read stream on it.!!XMLAbstractReadStreamParser commentStamp: '' prior: 0!This class is a generic abstract parser class for read-stream based parsers. It wraps its input stream with an XMLReadStreamAdapter and can parse tokens using #nextDelimitedBy: and #nextDelimitedByAny: and a temp write stream buffer.!!XMLHTTPMIMETypeParser commentStamp: '' prior: 0!This is a class to parse MIME types with a main type and sub type separated by a "/", like "text/plain", and optional name=value parameters separated by ";" after. Adapted from ZnMimeType.!!XMLURIParser commentStamp: '' prior: 0!This class is a parser that can extract the scheme, user info, host, port, path segments, query (as an OrderedCollection of associations), and fragment of a URI. It does not handle percent decoding and raises no errors.!!XMLAttributeDefaultValidator commentStamp: '' prior: 0!This is a base class for attribute default validators that implement constraints from the default declaration part of an ATTLIST attribute definition.!!XMLAttributeImpliedDefaultValidator commentStamp: '' prior: 0!This class allows an attribute to be absent (the #IMPLIED constraint).!!XMLAttributeRequiredDefaultValidator commentStamp: '' prior: 0!This class makes sure an attribute is present (the #REQUIRED constrant).!!XMLAttributeValueDefaultValidator commentStamp: '' prior: 0!This class will put a default value for an attribute if the attribute is absent.!!XMLAttributeFixedValueDefaultValidator commentStamp: '' prior: 0!This class will put a default value for an attribute if the attribute is absent and also makes sure that any value matches the default (the #FIXED constraint).!!XMLStandaloneExternalAttributeFixedValueDefaultValidator commentStamp: '' prior: 0!This class will make sure the value of a standalone externally defined attribute is present and that it matches a fixed default value (the #FIXED constraint).!!XMLStandaloneExternalAttributeValueDefaultValidator commentStamp: '' prior: 0!This class will make sure the value of a standalone externally defined attribute is present (the default value is never used).!!XMLAttributeSpec commentStamp: '' prior: 0!This is a base class for attribute specifications. Subclasses need to implement matchesAttributes: to return true if the argument attribute dictionary matches the spec and false otherwise.!!XMLBasicAttributeSpec commentStamp: '' prior: 0!A simple attribute spec that checks for attributes being present and optionally having a specific value.!!XMLPluggableAttributeSpec commentStamp: '' prior: 0!A block-based pluggable attribute spec that evaluates blocks with the attribute dictionary to test matching.!!XMLAttributeValidator commentStamp: '' prior: 0!This is a base class for attribute validators.!!XMLCDataAttributeValidator commentStamp: '' prior: 0!This class validates CDATA attributes, which are not whitespace-normalized further.!!XMLStandaloneExternalCDataAttributeValidator commentStamp: '' prior: 0!This class validates standalone externally defined CDATA attributes. It disallows attributes that need substitution with default or fixed default values.!!XMLEntityAttributeValidator commentStamp: '' prior: 0!This class validates attributes that contain unparsed entity names (that must be declared).!!XMLEntitiesAttributeValidator commentStamp: '' prior: 0!This class validates attributes with lists of unparsed entity name values (that must be declared) separated by spaces.!!XMLStandaloneExternalEntitiesAttributeValidator commentStamp: '' prior: 0!This class validates standalone externally defined attributes with lists of unparsed entity name values (that must be declared) separated by spaces. It disallows attributes that require further value normalization or substitution with default or fixed default values.!!XMLStandaloneExternalEntityAttributeValidator commentStamp: '' prior: 0!This class validates standalone externally defined attributes that contain unparsed entity names (that must be declared). It disallows attributes that require further value normalization or substitution with default or fixed default values.!!XMLEnumerationAttributeValidator commentStamp: '' prior: 0!This class validates attributes that can have any value taken from a list like "(one|two|thee)".!!XMLNotationEnumerationAttributeValidator commentStamp: '' prior: 0!This class validates attributes that can have NOTATION names from a list as values.!!XMLStandaloneExternalNotationEnumerationAttributeValidator commentStamp: '' prior: 0!This class validates attributes that can have NOTATION names from a list as values. It disallows attributes that require further value normalization or substitution with default or fixed default values.!!XMLStandaloneExternalEnumerationAttributeValidator commentStamp: '' prior: 0!This class validates attributes that can have any value taken from a list like "(one|two|thee)". It disallows attributes that require further value normalization or substitution with default or fixed default values.!!XMLIDAttributeValidator commentStamp: '' prior: 0!This class validates ID attributes that must have unique (not repeated in the same document) values.!!XMLStandaloneExternalIDAttributeValidator commentStamp: '' prior: 0!This class validates standalone externally defined ID attributes that must have unique (not repeated in the same document) values. It disallows attributes that require further value normalization.!!XMLXMLIDAttributeValidator commentStamp: '' prior: 0!This class validates ID attributes for the xml:id spec.!!XMLStandaloneExternalXMLIDAttributeValidator commentStamp: '' prior: 0!This class validates standalone externally defined xml:id ID attributes. It disallows attributes that require further value normalization.!!XMLIDRefAttributeValidator commentStamp: '' prior: 0!This class validates attributes that refer to an ID of another element with a ID attribute.!!XMLIDRefsAttributeValidator commentStamp: '' prior: 0!This class validates attributes with lists of ID ref values separated by spaces.!!XMLStandaloneExternalIDRefsAttributeValidator commentStamp: '' prior: 0!This class validates standalone externally defined attributes with lists of ID ref values separated by spaces. It disallows attributes that require further value normalization or substitution with default or fixed default values.!!XMLStandaloneExternalIDRefAttributeValidator commentStamp: '' prior: 0!This class validates standalone externally defined attributes that refer to an ID of another element with an ID attribute. It disallows attributes that require further value normalization or substitution with default or fixed default values.!!XMLNmtokenAttributeValidator commentStamp: '' prior: 0!This class validates Nmtoken name attributes.!!XMLNmtokensAttributeValidator commentStamp: '' prior: 0!This class validates attributes with lists of Nmtoken name values separated by spaces.!!XMLStandaloneExternalNmtokensAttributeValidator commentStamp: '' prior: 0!This class validates standalone externally defined attributes with lists of Nmtoken name values separated by spaces. It disallows attributes that require further value normalization or substitution with default or fixed default values.!!XMLStandaloneExternalNmtokenAttributeValidator commentStamp: '' prior: 0!This class validates standalone externally defined Nmtoken name attributes. It disallows attributes that require further value normalization or substitution with default or fixed default values.!!XMLClassFinder commentStamp: '' prior: 0!A simple cross-platform interface for finding classes that may not be in the image.!!XMLConfiguration commentStamp: '' prior: 0!This class stores the settings and components of a parser. For performance it uses separate inst vars instead of a dictionary and lazy initializes some components.!!XMLDOMConfiguration commentStamp: '' prior: 0!This class stores additional settings and components relevant to the DOM parser and DOM nodes.!!XMLDFAState commentStamp: '' prior: 0!This class is a DFA state made by grouping one or more NFA states.!!XMLDFAStateCache commentStamp: '' prior: 0!This class uses a dictionary with NFAStateSet keys to cache DFA states. (Does not use the regular XML key/value  cache for performance)!!XMLDocumentValidator commentStamp: '' prior: 0!This is a base class for XML document validators.!!DTDDocumentValidator commentStamp: '' prior: 0!This class validates documents using a DTD.!!XMLElementClassMapper commentStamp: '' prior: 0!This is a base class for element class mappers. Subclasses need to implement the abstract methods to register and lookup classes mapped to element names, namespace URIs, and attributes.!!XMLBasicElementClassMapper commentStamp: '' prior: 0!This class can match elements to classes based on their names, namespace URIs, and attributes.The precedence of mapping goes:-Qualified name, namespace URI, and attributes-Qualified name and namespace URI-Qualified name and attributes-Qualified name-Non-qualified name, namespace URI, and attributes-Non-qualified name and namespace URI-Non-qualified name and attributes-Non-qualified name!!XMLElementIDValidator commentStamp: '' prior: 0!This class is shared by attribute validators to validate element IDs and ID references, including xml:id IDs.!!XMLElementNester commentStamp: '' prior: 0!This is a base class for element nesters that are used by parser tokenizers and drivers to keep track of which elements are open while parsing and ensure they are properly nested.!!XMLElementValidator commentStamp: '' prior: 0!This is a base class for element validators.!!XMLAnyElementValidator commentStamp: '' prior: 0!This class validates elements that can contain any content.!!XMLDFAElementValidator commentStamp: '' prior: 0!This class validates elements using a regular expression converted to a DFA. It ignores PCDATA, comments, and PIs.!!XMLDFAElementContentElementValidator commentStamp: '' prior: 0!This class validates elements that can only contain element content (no PCDATA) using a regular expression converted to a DFA. It ignores comments, PIs, and whitespace.!!XMLStandaloneExternalDFAElementContentElementValidator commentStamp: '' prior: 0!This class validates standalone externally defined elements with element content that cannot have whitespace between elements unlike the superclass.!!XMLEmptyElementValidator commentStamp: '' prior: 0!This class validates EMPTY elements, which can't contain elements, PCDATA, or even comments or PIs.!!XMLMixedContentElementValidator commentStamp: '' prior: 0!This class validates elements that can contain a mix of PCDATA and certain elements.!!XMLEncodingDetector commentStamp: '' prior: 0!This is a class for automatic encoding detection of streams that infers encodings from a leading byte order mark (BOM) sequence.!!XMLImplicitEncodingDetector commentStamp: '' prior: 0!This is a class for automatic encoding detection of streams that infers explicit encodings from a leading byte order mark (BOM) sequence and implicit encodings from a sequence of one or three null bytes before or after a leading ASCII character (implicit UTF 16/32).(It actually implements the YAML implicit encoding detection algorithm, looking for any leading ASCII char, not just '<', before or after a null byte sequence. This algorithm is more general than the XML one, supporting non-XML text, and since the XML one is in a "(Non-Normative)" section of the spec, we don't actually have to implement it.)!!XMLHTTPDecompressingReadStreamAdapterFactory commentStamp: '' prior: 0!This class is a read stream adapter factory for decoding content compressed with compression schemes like GZip and DEFLATE.!!XMLHTTPGZipDecompressingReadStreamAdapterFactory commentStamp: '' prior: 0!A read stram adapter factory for the GZip compression scheme. Uses GZipReadStream if available.!!XMLHTTPMIMEType commentStamp: '' prior: 0!This is an immutable class for HTTP MIME types. Adapted from ZnMimeType.!!XMLHTTPResponseContentReader commentStamp: '' prior: 0!This is an abstract base class for response content readers. The #readUpToLimit:decoding: message returns the entire  decoded (if enabled) response content, raising an XMLLimitException if it exceeds the specified limit.Subclasses need to implement #rawReadWithLength:upToLimit: to read and return the raw response content and signal an error if it exceeds the limit.!!XMLHTTPWebClientResponseContentReader commentStamp: '' prior: 0!A WebClient content reader.!!XMLHTTPZincResponseContentReader commentStamp: '' prior: 0!A Zinc content reader. Zinc handles decompression automatically, so this class doesn't.!!XMLIntegerReader commentStamp: '' prior: 0!This class reads positive hex or decimal integers from minimal streams supporting #next, #peek, and #atEnd. It returns nil instead of raising errors for invalid integers.!!XMLSmallIntegerReader commentStamp: '' prior: 0!This class reads positive hex or decimal integers up to the maximum a SmallInteger can hold from minimal streams supporting #next, #peek, and #atEnd, handling overflow with saturation. It returns nil instead of raising errors for invalid integers.!!XMLNFABuilder commentStamp: '' prior: 0!This class builds an NFA using a stack of NFAFragments.!!XMLNFAFragment commentStamp: '' prior: 0!This class implements NFA fragments for an XMLNFABuilder. It stores a first state and either a single terminal state or a collection of terminal states (using an OrderedCollection instead of an XMLNFAStateSet), and it can be connected to a state or another fragment.!!XMLNFAState commentStamp: '' prior: 0!This is a base class for NFA states.!!XMLNFAAcceptingState commentStamp: '' prior: 0!An NFA in this state is considered to accept the input.!!XMLNFABranchingState commentStamp: '' prior: 0!This state can branch off into two different states without matching against anything.!!XMLNFAMatchingState commentStamp: '' prior: 0!This state can pass to a next state if the input matches against an object.!!XMLNamespaceScope commentStamp: '' prior: 0!A namespace scope is a possibly empty set of mappings from namespace prefixes to URIs and an optional default namespace URI to be used for unprefixed elements. Scopes can be created from other scopes by copying. (Uses copy-on-write to reduce memory use.)!!XMLNamespaceScopeAllocator commentStamp: '' prior: 0!This class allocates namespace scopes with a stack. Sending #enterScope pushes a new scope onto the stack that inherits all mappings from the previous (enclosing) scope, and #exitScop pops it off.!!XMLNestedStreamReader commentStamp: '' prior: 0!This class represents a stream reader that implements pushBack: using nested streams. This enables subsitution/replacement to be performed without modifying the underlying collections streamed-over or having to copy them. It also performs line-ending normalization, transforming a CR or a CRLF sequence into a single LF character.(The code in this class is optimized; refactor with care.)!!XMLNode commentStamp: '' prior: 0!This is a base class for XML nodes. It has testing messages, messages to access the parent, sibling, and ancestor nodes, and messages to control printing.!!XMLAttribute commentStamp: '' prior: 0!The class represents an attribute node stored in an attribute node list. The name of an attribute node can be namespaced using prefixes, but the prefix must be mapped to a namespace URI in the containing element node. Unprefixed attributes have no namespace, not even a default if one is in scope, per the XML namespace standard.The element of an attribute can be accessed with #element, but also with #parent, because attributes are modeled so their element is their parent (to simplify the implementation of the XPath library).!!XMLComment commentStamp: '' prior: 0!This class represents a comment node. Comments are ignored during parsing by default. If you want them preserved as comment nodes, use #preservesCommentNodes: with the DOM parser before parsing.!!XMLDeclarationNode commentStamp: '' prior: 0!This is an abstract class for markup declaration nodes in the internal subset.!!XMLAttributeDeclaration commentStamp: '' prior: 0!This is a class for <!!ATTLIST> declarations with definitions for single attributes. (An ATTLIST with multiple attribute defs is the same as a series of separate ATTLISTs for each def)!!XMLElementDeclaration commentStamp: '' prior: 0!This is a class for <!!ELEMENT> declarations.!!XMLEntityDeclaration commentStamp: '' prior: 0!This is an abstract class for general and parameter <!!ENTITY> declarations.!!XMLGeneralEntityDeclaration commentStamp: '' prior: 0!This is a class for general <!!ENTITY> declarations.!!XMLParameterEntityDeclaration commentStamp: '' prior: 0!This is a class for parameter <!!ENTITY> declarations.!!XMLNotationDeclaration commentStamp: '' prior: 0!This is class for <!!NOTATION> declarations.!!XMLNodeWithChildren commentStamp: '' prior: 0!This is an abstract class for nodes that can contain child nodes.It has messages to access, add and remove child nodes. The nodes are stored in a kind of XMLObservableList returned by #nodes, which can be modified directly to add or remove nodes from the owner of #nodes (copy it first if that isn't what you want).There are three types of "enumerating" messages: the #nodes* messages enumerate child nodes of the receiver, the #allNode* forms enumerate (using depth-first traversal) the receiver and all descendant nodes, and the #descendantNode* forms  enumerate only descendant nodes.!!XMLDoctypeDeclaration commentStamp: '' prior: 0!This class represents a <!!DOCTYPE ...> declaration. It stores the root element name, public/system ID, and its nodes are the internal subset.!!XMLNodeWithElements commentStamp: '' prior: 0!This is an abstract class for nodes with elements.Instances provide "accessing" messages to retrieve child elements by their name and namespace information. The #elementAt: forms return the first matching element, while the #elementsAt: forms return all matching child elements.There are three different modes of enumeration: the #elements* enumerating messages enumerate child elements, the #allElements* forms enumerate the receiver (if it's an element) and all descendant elements, and the #descendantElement* forms enumerate descendant elements only.The #findElementNamed:* forms search the receicer (if it's an element) and descendants for a specific element.Element name matching is done the qualified and local name, so 'prefix:element-name' will only match 'prefix:element-name' while 'element-name' will match 'element-name', 'prefix:element-name' or 'different-prefix:element-name' and so on.The inner XML can be accessed as a string using #innerXML and set (reparsed) using #innerXML:.!!XMLDocument commentStamp: '' prior: 0!This class represents a document node, which is often the root of a DOM tree. Nodes can access their document ancestor with #document.!!XMLElement commentStamp: '' prior: 0!The class represents an element node, which has a qualified or unqualified name and optionally attributes, namespace declarations and child nodes.Element names can be tested using #isNamed: and #isNamedAny:, which test both the qualified and local name.If the name is qualified and namespace support is enabled (the default), then the prefix must be mapped to a namespace URI in the element or an ancestor. The class-side instance creation #name:namespaceURI:* and #name:namespaces:* messages and the instance-side #name:namespaceURI: message can set both simultaneously. If namespace support is disabled, prefixes are not checked.The #attribute* messages provide a Dictionary-like protocol for manipulating attribute nodes. Unlike the #elementAt:* messages, they match qualified names only, and attribute value accessors return empty strings if the attribute is absent. The underlying attribute node list can be accessed using #attributeNodes (copy before modifying if you don't want to change the element's attributes), and the names/values can be obtained as an (order-preserving) dictionary using #attributes.See the superclasses for more info.!!XMLPI commentStamp: '' prior: 0!This class represents a processing instruction node.!!XMLString commentStamp: '' prior: 0!This class represents a string (character data) node. Instances are mutable, but the string is treated as immutable. String nodes can be created using the class-side #string: message or by sending a String #asXMLStringNode. When printing, XML-escaping of special characters is done.!!XMLCData commentStamp: '' prior: 0!This class represents a preserved <!![CDATA[...]]> section. By default these are handled as XMLString nodes and merged with adjacent string nodes during parsing.  To preserve CDATA nodes, use #preservesCDataNodes: with the DOM parser before parsing.!!XMLNodeFactory commentStamp: '' prior: 0!This class is the default node factory. Its accessor messages return the classes used by the DOM parser to build a node tree. You can override these messages to return different classes and inject an instance with the DOM parser's #nodeFactory: message before parsing.!!XMLPluggableNodeFactory commentStamp: '' prior: 0!This is a pluggable node factory that can be used to change which classes the DOM parser uses to build the DOM tree. Here is an example:	(XMLDOMParser on: anXMLStringOrStream)		nodeFactory:			(XMLPluggableNodeFactory new				documentClass: MyDocumentClass;				elementClass: MyElementClass;				stringNodeClass: MyStringNodeClass);		parseDocument.Instances can be saved and reused for performance and safely modified after copying.!!XMLPluggableElementFactory commentStamp: '' prior: 0!This class is a pluggable node factory that can also map elements to different XMLElement subclasses based on the name, namespace information, and attributes of those elements. You have to create an instance, configure it to handle certain elements with certain classes, and then inject your instance into a DOM parser using #nodeFactory: before parsing. Here is an example:	(XMLDOMParser on: anXMLStringOrStream)		nodeFactory:			(XMLPluggableElementFactory new				elementClass: GenericElement;				handleElement: 'user' withClass: UserElement;				handleElement: 'report' withClass: ReportElement;				handleElement: 'report' namespaceURI: 'urn:specialreprot' withClass: SpecialReportElement);		parseDocument.Instances can be saved and reused for performance and safely modified after copying.!!XMLNodeVisitor commentStamp: '' prior: 0!This is a base class for DOM node tree visitors. Subclasses can implement any of the "visiting" messages, and instances can be used by sending a node #acceptNodeVisitor: with it as the argument.!!XMLMutatingNodeVisitor commentStamp: '' prior: 0!This is a mutating node visitor that can remove nodes during enumeration by returning nil from a #visit* method, or replace a node by returning a new node other than the argument.!!XMLValidatingNodeVisitor commentStamp: '' prior: 0!A validating node visitor that can validate DOM node trees using XMLDocumentValidators.!!XMLParser commentStamp: '' prior: 0!This class is a facade that parses XML using a driver and tokenizer. See SAXHandler and XMLDOMParser for ready-made front ends to it.!!XMLParserDriver commentStamp: '' prior: 0!This is a base class for parser drivers. Subclasses should override any of the "handling" or "handling - dtd" messages sent by tokenizers to parse tokens.!!DTDSubsetParserDriver commentStamp: '' prior: 0!An abstract class for handling internal and external DTD subset events.!!DTDExternalSubsetParserDriver commentStamp: '' prior: 0!This class is used by SAXParserDriver for parsing the external subset of a DTD.!!SAXParserDriver commentStamp: '' prior: 0!SAXParserDriver together with SAXHandler provides a SAX-like API for XML parsing. The driver processes XML tokens and signals SAX events to a SAXHandler. See SAXHandler for more info.!!XMLParserLimits commentStamp: '' prior: 0!This class places security limits on input. Setting a limit to nil disables it, and removeAll disables all.!!XMLParserTokenizer commentStamp: '' prior: 0!This is a base class for parser tokenizers that read tokens from a stream using an XMLNestedStreamReader and state objects. Sending #nextToken causes a token to be read and handler messages to be sent to a driver.Be careful changing the code in this class or subclasses because it's optimized.!!XMLWellFormedParserTokenizer commentStamp: '' prior: 0!This is a tokenizer for well-formed XML documents that supports DTD subsets and entity replacement.!!XMLPushedBackEntity commentStamp: '' prior: 0!An abstract base class for decorating pushed-back entities to keep track of the nesting of markup within entity replacements.!!XMLPushedBackGeneralEntity commentStamp: '' prior: 0!A class to decorate pushed-back general entities to keep track of the nesting of elements within entity replacements.Each time a start tag is parsed from the entity's replacement, the count is incremented, and each time an end tag is parsed, it's decremented. If it goes negative, then an end tag terminated an element not started by the entity. When the entity is popped, the count should be zero. (This is more efficient than having the element nester also keep track of which entity replacement an element began in.)!!XMLPushedBackParameterEntity commentStamp: '' prior: 0!A class to decorate pushed-back parameter entities to keep track of the nesting of include sections within entity replacements.!!XMLPushedBackStream commentStamp: '' prior: 0!A base class to store a nested stream for XMLNestedStreamReader, along with its callback and the current position, line number, and line start position of the current external stream.!!XMLPushedBackExternalStream commentStamp: '' prior: 0!A class to store a nested external stream for XMLNestedStreamReader.!!XMLPushedBackInternalStream commentStamp: '' prior: 0!A class to store a nested internal stream for XMLNestedStreamReader. It reports the current position, line number, and line start position of its enclosing external stream.!!XMLStreamAdapter commentStamp: '' prior: 0!An abstract class for read and write stream adapters.!!XMLReadStreamAdapter commentStamp: '' prior: 0!A base class for read stream adapters for basic streams that support #next, #peek, #atEnd, #position, #position:, and #reset. It adds support for skipping and reading upto a character or the end of the stream, and ensures #next and #peek return nil when the stream is #atEnd instead of raising an error.!!XMLDecodingReadStreamAdapter commentStamp: '' prior: 0!A read stream adapter that decodes stream contents using a stream converter. Used to handle encoded external streams.The class  #on: and #on:streamConverter: instance creation messages accept character and binary streams.!!XMLLimitedReadStreamAdapter commentStamp: '' prior: 0!This class is a limited read stream adapter that will not read beyond a limit. Position changes are limited so you can only move forward as many positions as the limit allows, and moving backwards increases the number of objects that can be read.!!XMLPercentDecodingReadStreamAdapter commentStamp: '' prior: 0!This class percent decodes octets for URIs.!!XMLStringReadStreamAdapter commentStamp: '' prior: 0!A read stream adapter for string read streams that accepts character input and converts it to binary output.!!XMLWriteStreamAdapter commentStamp: '' prior: 0!A base class for write stream adapters for basic streams that support #nextPut:, #nextPutAll:, #contents, #position, #position:, and #reset. It adds support for writing characters like tabs, spaces, and line endings.!!XMLEncodingWriteStreamAdapter commentStamp: '' prior: 0!A write stream adapter that encodes stream contents using a stream converter.!!XMLNodeContentWriteStreamAdapter commentStamp: '' prior: 0!A write stream adapter for writing node content with whitespace insertion if needed between writes.!!XMLPercentEncodingWriteStreamAdapter commentStamp: '' prior: 0!A write stream adapter for percent encoding octets for URIs.!!XMLStringWriteStreamAdapter commentStamp: '' prior: 0!A write stream adapter that accepts binary input and converts it to character output for string write streams.!!XMLStreamConverter commentStamp: '' prior: 0!An abstract class for stream converters.Subclasses need to implement #nextFromStream: to use #basicNext on the argument to read byte characters and decode them, and implement #nextPut:toStream: to use #basicNextPut:/#basicNextPutByte: on the second argument to encode the first.The class #basicEncodingNames method should return a basic list of names for the encoding handled by the class, and #byteOrderMarkBytes can return the bytes of a BOM if the encoding has one.!!XMLStatelessStreamConverter commentStamp: '' prior: 0!This is a base class for stateless, immutable stream converter classes. Each subclass has a single instance that is shared.!!XMLASCIIStreamConverter commentStamp: '' prior: 0!A stream converter for ASCII.!!XMLLatin1StreamConverter commentStamp: '' prior: 0!A stream converter for ISO Latin-1.!!XMLNullStreamConverter commentStamp: '' prior: 0!A stream converter that does no encoding or decoding.!!XMLUTFStreamConverter commentStamp: '' prior: 0!An abstract class for Unicode stream converters.!!XMLUTF16StreamConverter commentStamp: '' prior: 0!An abstract class for UTF-16 stream converters.!!XMLUTF16BigEndianStreamConverter commentStamp: '' prior: 0!A stream converter for big endian UTF-16 streams, and the default converter class used when a UTF-16 stream converter is created with newForEncoding: or asXMLStreamConverter and no endian is specified by the encoding name.!!XMLImplicitUTF16BigEndianStreamConverter commentStamp: '' prior: 0!A stream converter for implicit big endian UTF-16 streams.!!XMLUTF16LittleEndianStreamConverter commentStamp: '' prior: 0!A stream converter for little endian UTF-16 streams.!!XMLImplicitUTF16LittleEndianStreamConverter commentStamp: '' prior: 0!A stream converter for implicit little endian UTF-16 streams.!!XMLUTF32StreamConverter commentStamp: '' prior: 0!An abstract class for UTF-32 stream converters.!!XMLUTF32BigEndianStreamConverter commentStamp: '' prior: 0!A stream converter for big endian UTF-32 streams, and the default converter class used when a UTF-32 stream converter is created with newForEncoding: or asXMLStreamConverter and no endian is specified by the encoding name.!!XMLImplicitUTF32BigEndianStreamConverter commentStamp: '' prior: 0!A stream converter for implicit big endian UTF-32 streams.!!XMLUTF32LittleEndianStreamConverter commentStamp: '' prior: 0!A stream converter for little endian UTF-32 streams.!!XMLImplicitUTF32LittleEndianStreamConverter commentStamp: '' prior: 0!A stream converter for implicit little endian UTF-32 streams.!!XMLUTF8StreamConverter commentStamp: '' prior: 0!A stream converter for UTF-8 streams. (Rejects overlong encodings.)!!XMLImplicitUTF8StreamConverter commentStamp: '' prior: 0!A stream converter for implicit UTF-8 streams.!!XMLZincByteEncoderStreamConverter commentStamp: '' prior: 0!A stream converter that wraps the ZnByteEncoder legacy byte encoder class. (Requires Zinc.)!!XMLTokenizerState commentStamp: '' prior: 0!This is an abstract class for states to control tokenization. Subclasses must implement #nextTokenFrom: to send a tokenizing message to the argument tokenizer.!!XMLContentState commentStamp: '' prior: 0!A state for content tokens, everything from the first stat tag to the end of the document.!!XMLExternalSubsetState commentStamp: '' prior: 0!A state for external subset tokens.!!XMLExternalSubsetTextDeclarationState commentStamp: '' prior: 0!A state for <?xml ...?> text declaration tokens at the start of the external DTD subset.This state #canTerminateInput unlike XMLXMLDeclarationState because external subsets and parsed entities can be empty, but documents must have at least one element.!!XMLPrologState commentStamp: '' prior: 0!A state for prolog tokens.!!XMLDoctypeDeclarationState commentStamp: '' prior: 0!A state for <!!DOCTYPE ...> and internal subset tokens.!!XMLInternalSubsetState commentStamp: '' prior: 0!A state for internal subset tokens.!!XMLPostDoctypeDeclarationState commentStamp: '' prior: 0!A state for parsing prolog tokens after <!!DOCTYPE ...> declarations.!!XMLXMLDeclarationState commentStamp: '' prior: 0!A state for parsing the <?xml ...?> token.!!XMLTerminatedState commentStamp: '' prior: 0!A state for when tokenizing has stopped.!!XMLUninitializedState commentStamp: '' prior: 0!A state for before tokenizing has started.!!XMLURI commentStamp: '' prior: 0!A class for XML URIs. Instances are immutable and support combining with other XMLURIs or URI strings using / (to resolve relative URIs in the context of the receiver), accessing URI components, creating copies with replaced components, and retrieving the contents of http:// and file:// URLs using XMLHTTPRequest and XMLFileHandle.Uses XMLURIParser to parse URIs lazily (for example, when a URI compoenent is accessed with an "accessing" message) when created from a string and eagerly when created from a stream.URI components are stored internally in encoded form and decoded only when needed, because the XML standard requires delaying decoding for as long as possible.!!XMLUnparsedEntityValidator commentStamp: '' prior: 0!Used by attribute validators to validate attribute references to unparsed entities and notations.!!XMLAttributeDictionary commentStamp: '' prior: 0!This class is an OrderPreservingStringDictionary for XML attributes that returns empty strings instead of raising errors when absent keys are looked up. It has messages to lookup the namespace URI of an attribute key and to lookup an attribute value or association by local or qualified name and namespace URI.!!XMLNamespacedAttributeDictionary commentStamp: '' prior: 0!This subclass is used when namespaces are enabled. It has an extra inst var for namespace scopes.!!XMLException commentStamp: '' prior: 0!A generic exception class that supports message formatting. Used as a base class for exceptions in XMLParser and related packages like XPath.!!XMLParserException commentStamp: '' prior: 0!A base class for XMLParser exceptions that supports line number error info and can be used with on:do: to catch any XMLParser-related errors.!!XMLDOMException commentStamp: '' prior: 0!Invoked when a DOM tree is manipulated wrong.!!XMLEncodingException commentStamp: '' prior: 0!Invoked for encoding errors.!!XMLFileException commentStamp: '' prior: 0!Invoked for file IO errors.!!XMLHTTPException commentStamp: '' prior: 0!Invoked for HTTP errors.!!XMLLimitException commentStamp: '' prior: 0!Invoked when a security limit on input is exceeded. Use the messages in XMLParserLimits and DTDExternalEntityLimits to configure these limits or the removeLimits message to remove them completely.!!XMLNamespaceException commentStamp: '' prior: 0!Invoked when namespaces are used improperly and namespace checking is on.!!XMLParsingInterruptException commentStamp: '' prior: 0!Used to interrupt parsing from a SAXHandler. Will be silently caught.!!XMLValidationException commentStamp: '' prior: 0!Invoked when invalid XML is detected and validation is on.!!XMLWellFormednessException commentStamp: '' prior: 0!Invoked when XML markup is not well-formed.!!XMLLazyAttributeDictionary commentStamp: '' prior: 0!A lazy version of XMLAttributeDictionary that uses less memory until it's modified.!!XMLLazyNamespacedAttributeDictionary commentStamp: '' prior: 0!A lazy version of XMLNamespacedAttributeDictionary that uses less memory until it's modified.!!XMLNFAStateSet commentStamp: '' prior: 0!This class is a set of NFA states. It wraps an IdentitySet and keeps track of if any of its states is accepting.!!XMLOrderedList commentStamp: '' prior: 0!This class functions as an OrderedCollection that will not raise exceptions when attempts are made to access absent objects. This means messages like #at:, #after:, and #first will return nil when the requested object cannot be retrieved. Messages that modify the collection will still raise exceptions as usual.!!XMLObservableList commentStamp: '' prior: 0!This class is an ordered list that sends notifications to an observer when objects are added to it or removed from it. Subclasses should override the #beforeAdding:, #afterAdding:at:, #afterAddingLast: and #afterRemoving: messages to send custom notifications.!!XMLAttributeList commentStamp: '' prior: 0!This class represents an ordered list of attribute nodes. It is not the default attribute list class, but it can be used by injecting it into a DOM parser before parsing:	(parser := XMLDOMParser on: xmlSource)		nodeFactory:			(XMLPluggableNodeFactory new				attributeListClass: XMLAttributeList);		parseDocument.It should be used over the default class when you want to reduce memory use at the cost of slower attribute lookup.!!XMLCachingAttributeList commentStamp: '' prior: 0!This class represents an ordered list of attribute nodes that also keeps a dictionary mapping attribute names to nodes for faster lookup.This is the default attribute list class.!!XMLInternalSubsetList commentStamp: '' prior: 0!This class represents the list of nodes that comprise a document's internal DTD subset.!!XMLNodeList commentStamp: '' prior: 0!This class represents an ordered list of child nodes for an XML document or element. Non-modifying accessing messages like #first and #last return nil instead of raising exceptions.!!XMLCachingNodeList commentStamp: '' prior: 0!This is a node list that caches child elements by name, keeping both an ordered list of elements and a dictionary that allows for faster retrieval of elements by qualified or local name. To use it, inject it into a DOM parser before parsing:	(parser := XMLDOMParser on: xmlSource)		nodeFactory:			(XMLPluggableNodeFactory new				nodeListClass: XMLCachingNodeList);		parseDocument.It should only be used when you know the DOM tree will be queried much more often than parsed or modified and the extra memory use is OK.!!DTDAttributeDefinitionParser class methodsFor: 'private'!attributeDefaultValidatorClassForPragma: aDefaultPragma	"the default pragma should have been checked for well-formedness by the	tokenizer so it's either empty, 'FIXED', 'REQUIRED', or 'IMPLIED'"	aDefaultPragma size > 0		ifTrue: [			(aDefaultPragma at: 1) == $F				ifTrue: [^ XMLAttributeFixedValueDefaultValidator].			(aDefaultPragma at: 1) == $I				ifTrue: [^ XMLAttributeImpliedDefaultValidator].			^ XMLAttributeRequiredDefaultValidator].	^ XMLAttributeValueDefaultValidator.! !!DTDAttributeDefinitionParser class methodsFor: 'instance creation'!element: anElement attribute: anAttribute type: aType defaultPragma: aDefaultPragma defaultValue: aDefaultValue	^ self new		setElement: anElement		attribute: anAttribute		type: aType		defaultValidator:			((self attributeDefaultValidatorClassForPragma: aDefaultPragma)				attribute: anAttribute				value: aDefaultValue)! !!DTDAttributeDefinitionParser methodsFor: 'private'!attributeValidatorClassForType	"the tokenizer should have checked the type for well-formedness	so it's only one of CDATA, ID, IDREF, IDREFS, etc"		| nextChar |	(nextChar := type at: 1) == $C		ifTrue: [^ XMLCDataAttributeValidator].	nextChar == $I		ifTrue: [			type size = 2 "'ID' size"				ifTrue: [					attribute = 'xml:id'						ifTrue: [^ XMLXMLIDAttributeValidator].					^ XMLIDAttributeValidator].			type size = 5 "'IDREF' size"				ifTrue: [^ XMLIDRefAttributeValidator].			"'IDREF' size < 'IDREFS' size"			^ XMLIDRefsAttributeValidator].	nextChar == $E		ifTrue: [			type size = 6 "'ENTITY' size"				ifTrue: [^ XMLEntityAttributeValidator].			"'ENTITY' size < 'ENTITIES' size"			^ XMLEntitiesAttributeValidator].	nextChar == $N		ifTrue: [			type size = 7 "'NMTOKEN' size"				ifTrue: [^ XMLNmtokenAttributeValidator].			type size = 8 "'NMTOKENS' size"				ifTrue: [^ XMLNmtokensAttributeValidator].			"'NMTOKENS' size < 'NOTATION (' size"			enumerationListParserClass := DTDNotationEnumerationListParser.			^ XMLNotationEnumerationAttributeValidator].	"otherwise it's a (one|two|...) enumeration attribute"	enumerationListParserClass := DTDEnumerationListParser.	^ XMLEnumerationAttributeValidator.! !!DTDAttributeDefinitionParser methodsFor: 'parsing'!parse	| validator |		validator :=		self attributeValidatorClassForType			element: element			attribute: attribute			defaultValidator: defaultValidator.	enumerationListParserClass		ifNotNil: [			validator allowedValues:				(enumerationListParserClass on: type) parse].	^ validator.! !!DTDAttributeDefinitionParser methodsFor: 'initialization'!setElement: anElement attribute: anAttribute type: aType defaultValidator: aDefaultValidator	element := anElement.	attribute := anAttribute.	type := aType.	defaultValidator := aDefaultValidator.! !!DTDStandaloneExternalAttributeDefinitionParser class methodsFor: 'private'!attributeDefaultValidatorClassForPragma: aDefaultPragma	^ (super attributeDefaultValidatorClassForPragma: aDefaultPragma)		standaloneExternalClass! !!DTDStandaloneExternalAttributeDefinitionParser methodsFor: 'private'!attributeValidatorClassForType	^ super attributeValidatorClassForType standaloneExternalClass! !!DTDContentModelParser class methodsFor: 'instance creation'!element: anElement contentModel: aContentModel	^ self new		setElement: anElement		contentModel: aContentModel! !!DTDContentModelParser class methodsFor: 'accessing'!parserClassForContentModel: aContentModel	"the tokenizer removes all spaces from the content model	and checks it for well-formedness"	(aContentModel at: 1) == $(		ifTrue: [			(aContentModel at: 2) == $# "#PCDATA mixed content"				ifTrue: [^ DTDMixedContentModelParser]				ifFalse: [^ DTDElementContentModelParser]]		ifFalse: [^ DTDLiteralContentModelParser]! !!DTDContentModelParser class methodsFor: 'defaults'!standaloneExternalClass	^ self! !!DTDContentModelParser methodsFor: 'parsing'!parse	self subclassResponsibility! !!DTDContentModelParser methodsFor: 'initialization'!setElement: anElement contentModel: aContentModel	element := anElement.	contentModel := aContentModel.! !!DTDElementContentModelParser class methodsFor: 'class initialization'!initialize	"self initialize"	self		initializeSpecialCharacterParsers;		initializeOperatorApplicators! !!DTDElementContentModelParser class methodsFor: 'class initialization'!initializeOperatorApplicators	"use an array instead of a dictionary for speed, and	assign after with #yourself to avoid possible race	conditions when reinitializing the class"	OperatorApplicators :=		(Array new: 255)			at: $, asciiValue put: #applyConcatenation;			at: $| asciiValue put: #applyBranch;			at: $? asciiValue put: #applyOptional;			at: $* asciiValue put: #applyStar;			at: $+ asciiValue put: #applyPlus;			yourself! !!DTDElementContentModelParser class methodsFor: 'class initialization'!initializeSpecialCharacterParsers	"use an array instead of a dictionary for speed, and	assign after with #yourself to avoid possible race	conditions when reinitializing the class"	SpecialCharacterParsers :=		(Array new: 255)			at: $( asciiValue put: #parseOpeningParenthesis:;			at: $) asciiValue put: #parseClosingParenthesis:;			at: $, asciiValue put: #parseBinaryOperator:;			at: $| asciiValue put: #parseBinaryOperator:;			at: $? asciiValue put: #parseUnaryOperator:;			at: $* asciiValue put: #parseUnaryOperator:;			at: $+ asciiValue put: #parseUnaryOperator:;			yourself! !!DTDElementContentModelParser class methodsFor: 'defaults'!standaloneExternalClass	^ DTDStandaloneExternalElementContentModelParser! !!DTDElementContentModelParser methodsFor: 'private'!applyBinaryOperatorOnStack	self applyOperator: binaryOperatorStack removeLast! !!DTDElementContentModelParser methodsFor: 'private'!applyOperator: aCharacter	nfaBuilder perform:		(OperatorApplicators at: aCharacter asciiValue)! !!DTDElementContentModelParser methodsFor: 'defaults'!elementValidatorClass	^ XMLDFAElementContentElementValidator! !!DTDElementContentModelParser methodsFor: 'private'!hasBinaryOperatorOnStack	^ binaryOperatorStack size > 0		and: [binaryOperatorStack last ~~ $(]! !!DTDElementContentModelParser methodsFor: 'parsing'!parse	"the tokenizer removes all spaces from the content model and checks	it for well-formedness (meaning no missing names or misplaced	operators/parentheses), which simplifies parsing"	| nameStart |	binaryOperatorStack := OrderedCollection new.	nfaBuilder := XMLNFABuilder new.	1 to: contentModel size do: [:i |		(self parserForSpecialCharacter: (contentModel at: i))			ifNil: [				nameStart					ifNil: [nameStart := i]]			ifNotNil: [:selector |				nameStart					ifNotNil: [						nfaBuilder pushFragmentMatching:							(contentModel copyFrom: nameStart to: i - 1).						nameStart := nil].				self					perform: selector					with: (contentModel at: i)]].	self popRemainingBinaryOperators.	^ self elementValidatorClass		element: element		dfa: nfaBuilder asAcceptingNFA asDFAState.! !!DTDElementContentModelParser methodsFor: 'private'!parseBinaryOperator: aCharacter	binaryOperatorStack addLast: aCharacter! !!DTDElementContentModelParser methodsFor: 'private'!parseClosingParenthesis: aCharacter	self popRemainingBinaryOperators.	(binaryOperatorStack size > 0		and: [binaryOperatorStack last == $(])		ifTrue: [binaryOperatorStack removeLast].! !!DTDElementContentModelParser methodsFor: 'private'!parseOpeningParenthesis: aCharacter	binaryOperatorStack addLast: $(! !!DTDElementContentModelParser methodsFor: 'private'!parseUnaryOperator: aCharacter	self applyOperator: aCharacter! !!DTDElementContentModelParser methodsFor: 'private'!parserForSpecialCharacter: aCharacter	| asciiValue |	"avoid at:ifAbsent: for speed"	((asciiValue := aCharacter asciiValue) > 0		and: [asciiValue <= SpecialCharacterParsers size])			ifTrue: [^ SpecialCharacterParsers at: asciiValue]			ifFalse: [^ nil]! !!DTDElementContentModelParser methodsFor: 'private'!popRemainingBinaryOperators	[self hasBinaryOperatorOnStack]		whileTrue: [self applyBinaryOperatorOnStack]! !!DTDStandaloneExternalElementContentModelParser methodsFor: 'defaults'!elementValidatorClass	^ XMLStandaloneExternalDFAElementContentElementValidator! !!DTDLiteralContentModelParser methodsFor: 'parsing'!parse	"either ANY or EMPTY"	(contentModel at: 1) == $A		ifTrue: [^ XMLAnyElementValidator element: element]		ifFalse: [^ XMLEmptyElementValidator element: element]! !!DTDMixedContentModelParser methodsFor: 'parsing'!parse	^ XMLMixedContentElementValidator		element: element		allowedContent:			(DTDMixedContentEnumerationListParser on: contentModel)				parse! !!DTDDoctypeDefinition methodsFor: 'adding'!addExternalGeneralEntity: aName resolver: aResolver publicID: aPublicID systemID: aSystemID baseURI: aBaseURIString	(self generalEntities includesKey: aName)		ifTrue: [^ nil].	^ self generalEntities		at: aName		put:			(DTDExternalGeneralParsedEntity				name: aName				resolver: aResolver				publicID: aPublicID				systemID: aSystemID				baseURI: aBaseURIString).! !!DTDDoctypeDefinition methodsFor: 'adding'!addExternalParameterEntity: aName resolver: aResolver publicID: aPublicID systemID: aSystemID baseURI: aBaseURIString	(self parameterEntities includesKey: aName)		ifTrue: [^ nil].	^ self parameterEntities		at: aName		put:			(DTDExternalParameterParsedEntity				name: aName				resolver: aResolver				publicID: aPublicID				systemID: aSystemID				baseURI: aBaseURIString).! !!DTDDoctypeDefinition methodsFor: 'adding'!addGeneralEntitiesFrom: aDoctypeDefinition	aDoctypeDefinition generalEntities keysAndValuesDo: [:name :entity |		self generalEntities			at: name			ifAbsentPut: [entity]]! !!DTDDoctypeDefinition methodsFor: 'adding'!addInternalGeneralEntity: aName replacement: aReplacement baseURI: aBaseURIString	(self generalEntities includesKey: aName)		ifTrue: [^ nil].	^ self generalEntities		at: aName		put:			(DTDInternalGeneralParsedEntity 				name: aName				replacement: aReplacement				uri: aBaseURIString).! !!DTDDoctypeDefinition methodsFor: 'adding'!addInternalParameterEntity: aName replacement: aReplacement baseURI: aBaseURIString	(self parameterEntities includesKey: aName)		ifTrue: [^ nil].	^ self parameterEntities		at: aName		put:			(DTDInternalParameterParsedEntity				name: aName				replacement: aReplacement				uri: aBaseURIString).! !!DTDDoctypeDefinition methodsFor: 'adding'!addNotation: aName publicID: aPublicID systemID: aSystemID	(self notations includesKey: aName)		ifTrue: [^ nil].	^ self notations		at: aName		put:			(DTDNotation				name: aName				publicID: aPublicID				systemID: aSystemID).! !!DTDDoctypeDefinition methodsFor: 'adding'!addStandaloneExternalExternalGeneralEntity: aName resolver: aResolver publicID: aPublicID systemID: aSystemID baseURI: aBaseURIString	(self generalEntities includesKey: aName)		ifTrue: [^ nil].	^ self generalEntities		at: aName		put:			(DTDStandaloneExternalExternalGeneralParsedEntity				name: aName				resolver: aResolver				publicID: aPublicID				systemID: aSystemID				baseURI: aBaseURIString).! !!DTDDoctypeDefinition methodsFor: 'adding'!addStandaloneExternalInternalGeneralEntity: aName replacement: aReplacement baseURI: aBaseURIString	(self generalEntities includesKey: aName)		ifTrue: [^ nil].	^ self generalEntities		at: aName		put:			(DTDStandaloneExternalInternalGeneralParsedEntity 				name: aName				replacement: aReplacement				uri: aBaseURIString).! !!DTDDoctypeDefinition methodsFor: 'adding'!addStandaloneExternalValidatorForAttributeIn: anElement named: anAttribute type: aType defaultPragma: aDefaultPragma defaultValue: aDefaultValue	| attributes |	attributes :=		self attributeValidators			at: anElement			ifAbsentPut: [Dictionary new].	(attributes includesKey: anAttribute)		ifTrue: [^ nil].	^ attributes		at: anAttribute		put:			((DTDStandaloneExternalAttributeDefinitionParser				element: anElement				attribute: anAttribute				type: aType				defaultPragma: aDefaultPragma				defaultValue: aDefaultValue) parse					initializeWithValidatorsFrom: self).! !!DTDDoctypeDefinition methodsFor: 'adding'!addStandaloneExternalValidatorForElement: anElement contentModel: aContentModel	(self elementValidators includesKey: anElement)		ifTrue: [^ nil].	^ self elementValidators		at: anElement		put:			((DTDContentModelParser parserClassForContentModel: aContentModel)				standaloneExternalClass					element: anElement					contentModel: aContentModel) parse.! !!DTDDoctypeDefinition methodsFor: 'adding'!addUnparsedEntity: aName publicID: aPublicID systemID: aSystemID ndata: aNotation	(self generalEntities includesKey: aName)		ifTrue: [^ nil].	^ self generalEntities		at: aName		put:			(self unparsedEntities				at: aName				put:					(DTDUnparsedEntity						name: aName						publicID: aPublicID						systemID: aSystemID						ndata: aNotation)).! !!DTDDoctypeDefinition methodsFor: 'adding'!addUnresolvableExternalGeneralEntity: aName	(self generalEntities includesKey: aName)		ifTrue: [^ nil].	^ self generalEntities		at: aName		put: (DTDUnresolvableExternalGeneralParsedEntity named: aName).! !!DTDDoctypeDefinition methodsFor: 'adding'!addUnresolvableExternalParameterEntity: aName	(self parameterEntities includesKey: aName)		ifTrue: [^ nil].	^ self parameterEntities		at: aName		put: (DTDUnresolvableExternalParameterParsedEntity named: aName).! !!DTDDoctypeDefinition methodsFor: 'adding'!addValidatorForAttributeIn: anElement named: anAttribute type: aType defaultPragma: aDefaultPragma defaultValue: aDefaultValue	| attributes |	attributes :=		self attributeValidators			at: anElement			ifAbsentPut: [Dictionary new].	(attributes includesKey: anAttribute)		ifTrue: [^ nil].	^ attributes		at: anAttribute		put:			((DTDAttributeDefinitionParser				element: anElement				attribute: anAttribute				type: aType				defaultPragma: aDefaultPragma				defaultValue: aDefaultValue) parse					initializeWithValidatorsFrom: self).! !!DTDDoctypeDefinition methodsFor: 'adding'!addValidatorForElement: anElement contentModel: aContentModel	(self elementValidators includesKey: anElement)		ifTrue: [^ nil].	^ self elementValidators		at: anElement		put:			((DTDContentModelParser parserClassForContentModel: aContentModel)				element: anElement				contentModel: aContentModel) parse.! !!DTDDoctypeDefinition methodsFor: 'accessing'!attributeValidators	^ attributeValidators ifNil: [attributeValidators := Dictionary new]! !!DTDDoctypeDefinition methodsFor: 'accessing'!attributeValidatorsAt: aName	^ self		attributeValidatorsAt: aName		ifAbsent: [nil]! !!DTDDoctypeDefinition methodsFor: 'accessing'!attributeValidatorsAt: aName ifAbsent: aBlock	^ self attributeValidators		at: aName		ifAbsent: aBlock! !!DTDDoctypeDefinition methodsFor: 'accessing'!elementIDValidator	^ elementIDValidator ifNil: [elementIDValidator := XMLElementIDValidator new]! !!DTDDoctypeDefinition methodsFor: 'accessing'!elementValidators	^ elementValidators ifNil: [elementValidators := Dictionary new]! !!DTDDoctypeDefinition methodsFor: 'accessing'!elementValidatorsAt: aName	^ self		elementValidatorsAt: aName		ifAbsent: [nil]! !!DTDDoctypeDefinition methodsFor: 'accessing'!elementValidatorsAt: aName ifAbsent: aBlock	^ self elementValidators		at: aName		ifAbsent: aBlock! !!DTDDoctypeDefinition methodsFor: 'accessing'!generalEntities	^ generalEntities ifNil: [generalEntities := Dictionary new]! !!DTDDoctypeDefinition methodsFor: 'accessing'!generalEntityAt: aName	^ self		generalEntityAt: aName		ifAbsent: [nil]! !!DTDDoctypeDefinition methodsFor: 'accessing'!generalEntityAt: aName ifAbsent: aBlock	^ self generalEntities		at: aName		ifAbsent: aBlock! !!DTDDoctypeDefinition methodsFor: 'testing'!hasAttributeValidators	"optimized to avoid lazy initialization"	attributeValidators == nil		ifTrue: [^ false].	^ attributeValidators size > 0.! !!DTDDoctypeDefinition methodsFor: 'testing'!hasElementIDReferences	"direct access to avoid lazy initialization"	^ elementIDValidator notNil		and: [elementIDValidator hasIDReferences]! !!DTDDoctypeDefinition methodsFor: 'testing'!hasElementIDs	"direct access to avoid lazy initialization"	^ elementIDValidator notNil		and: [elementIDValidator hasIDs]! !!DTDDoctypeDefinition methodsFor: 'testing'!hasElementValidators	"optimized to avoid lazy initialization"	elementValidators == nil		ifTrue: [^ false].	^ elementValidators size > 0.! !!DTDDoctypeDefinition methodsFor: 'testing'!hasEntities	^ self hasGeneralEntities		or: [self hasParameterEntities			or: [self hasUnparsedEntities]]! !!DTDDoctypeDefinition methodsFor: 'testing'!hasGeneralEntities	"direct access to avoid lazy initialization"	^ generalEntities notNil		and: [generalEntities notEmpty]! !!DTDDoctypeDefinition methodsFor: 'testing'!hasNotationAttributeValidators	^ self hasAttributeValidators		and: [self unparsedEntityValidator hasNotationAttributeValidators]! !!DTDDoctypeDefinition methodsFor: 'testing'!hasNotations	"direct access to avoid lazy initialization"	^ notations notNil		and: [notations notEmpty]! !!DTDDoctypeDefinition methodsFor: 'testing'!hasParameterEntities	"direct access to avoid lazy initialization"	^ parameterEntities notNil		and: [parameterEntities notEmpty]! !!DTDDoctypeDefinition methodsFor: 'testing'!hasRoot	^ root notNil and: [root notEmpty]! !!DTDDoctypeDefinition methodsFor: 'testing'!hasUnparsedEntities	"direct access to avoid lazy initialization"	^ unparsedEntities notNil		and: [unparsedEntities notEmpty]! !!DTDDoctypeDefinition methodsFor: 'instance creation'!newValidator	^ DTDDocumentValidator doctypeDefinition: self! !!DTDDoctypeDefinition methodsFor: 'accessing'!notations	^ notations ifNil: [notations := Dictionary new]! !!DTDDoctypeDefinition methodsFor: 'accessing'!parameterEntities	^ parameterEntities ifNil: [parameterEntities := Dictionary new]! !!DTDDoctypeDefinition methodsFor: 'accessing'!parameterEntityAt: aName	^ self		parameterEntityAt: aName		ifAbsent: [nil]! !!DTDDoctypeDefinition methodsFor: 'accessing'!parameterEntityAt: aName ifAbsent: aBlock	^ self parameterEntities		at: aName		ifAbsent: aBlock! !!DTDDoctypeDefinition methodsFor: 'processing'!processStartTag: anElement attributes: aDictionary	self hasAttributeValidators		ifFalse: [^ self].	(self		attributeValidatorsAt: anElement		ifAbsent: [^ self])		valuesDo: [:each | each processAttributes: aDictionary]! !!DTDDoctypeDefinition methodsFor: 'removing'!removeElementIDReferences	self hasElementIDReferences		ifTrue: [self elementIDValidator removeIDReferences]! !!DTDDoctypeDefinition methodsFor: 'removing'!removeElementIDs	self hasElementIDs		ifTrue: [self elementIDValidator removeIDs]! !!DTDDoctypeDefinition methodsFor: 'accessing'!root	^ root ifNil: [root := '']! !!DTDDoctypeDefinition methodsFor: 'accessing'!root: aRootElement	root := aRootElement! !!DTDDoctypeDefinition methodsFor: 'accessing'!unparsedEntities	^ unparsedEntities ifNil: [unparsedEntities := Dictionary new]! !!DTDDoctypeDefinition methodsFor: 'accessing'!unparsedEntityValidator	^ unparsedEntityValidator		ifNil: [			unparsedEntityValidator :=				XMLUnparsedEntityValidator					unparsedEntities: self unparsedEntities					notations: self notations]! !!DTDDoctypeDefinition methodsFor: 'validation'!validateCompletedDefinition	self hasUnparsedEntities		ifTrue: [self unparsedEntityValidator validateUnparsedEntityDeclarations].	self hasNotationAttributeValidators		ifTrue: [self unparsedEntityValidator validateNotationAttributeDeclarationDefaults].! !!DTDEntity class methodsFor: 'instance creation'!name: aName	^ self named: aName! !!DTDEntity class methodsFor: 'instance creation'!named: aName	^ self new name: aName! !!DTDEntity methodsFor: 'converting'!asReference	^ String streamContents: [:stream | self printReferenceOn: stream]! !!DTDEntity methodsFor: 'testing'!isExternal	^ false! !!DTDEntity methodsFor: 'testing'!isParameter	^ false! !!DTDEntity methodsFor: 'testing'!isStandaloneExternal	^ false! !!DTDEntity methodsFor: 'testing'!isUnparsed	^ false! !!DTDEntity methodsFor: 'accessing'!name	^ name ifNil: [name := '']! !!DTDEntity methodsFor: 'accessing'!name: aName	name := aName! !!DTDEntity methodsFor: 'printing'!printNameOn: aStream	aStream nextPutAll: self name! !!DTDEntity methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	self printNameOn: aStream.	aStream nextPut: $).! !!DTDEntity methodsFor: 'printing'!printReferenceOn: aStream	aStream		nextPut: self referencePrefix;		nextPutAll: self name;		nextPut: $;! !!DTDEntity methodsFor: 'private '!referencePrefix	^ self isParameter		ifTrue: [$%]		ifFalse: [$&]! !!DTDEntity methodsFor: 'accessing'!uri	^ uri ifNil: [uri := '']! !!DTDEntity methodsFor: 'accessing'!uri: aURIString	uri := aURIString! !!DTDStandaloneExternalExternalGeneralParsedEntity methodsFor: 'testing'!isStandaloneExternal	^ true! !!DTDExternalParameterParsedEntity methodsFor: 'testing'!isParameter	^ true! !!DTDExternalParsedEntity class methodsFor: 'instance creation'!name: aName resolver: aResolver publicID: aPublicID systemID: aSystemID baseURI: aBaseURIString	^ self new		setName: aName		unresolvedReplacement:			(DTDUnresolvedExternalParsedEntityReplacement				resolver: aResolver				publicID: aPublicID				systemID: aSystemID				baseURI: aBaseURIString)! !!DTDExternalParsedEntity methodsFor: 'testing'!hasReplacement	^ self resolvedReplacement notEmpty! !!DTDExternalParsedEntity methodsFor: 'testing'!hasUnresolvedReplacement	^ self unresolvedReplacement notNil! !!DTDExternalParsedEntity methodsFor: 'testing'!isExternal	^ true! !!DTDExternalParsedEntity methodsFor: 'printing'!printNameOn: aStream	aStream		nextPut: ${;		nextPutAll: self uri;		nextPut: $}.	super printNameOn: aStream.! !!DTDExternalParsedEntity methodsFor: 'accessing'!replacement	^ self resolvedReplacement contents! !!DTDExternalParsedEntity methodsFor: 'accessing'!replacementStream	^ self resolvedReplacement readStream! !!DTDExternalParsedEntity methodsFor: 'resolving'!resolveUnresolvedReplacement	self hasUnresolvedReplacement		ifTrue: [self unresolvedReplacement resolveForExternalEntity: self]! !!DTDExternalParsedEntity methodsFor: 'accessing'!resolvedReplacement	self resolveUnresolvedReplacement.	^ resolvedReplacement.! !!DTDExternalParsedEntity methodsFor: 'accessing'!resolvedReplacement: aResolvedReplacement	resolvedReplacement := aResolvedReplacement! !!DTDExternalParsedEntity methodsFor: 'initialization'!setName: aName unresolvedReplacement: anUnresolvedReplacement	name := aName.	unresolvedReplacement := anUnresolvedReplacement.! !!DTDExternalParsedEntity methodsFor: 'accessing'!unresolvedReplacement	^ unresolvedReplacement! !!DTDExternalParsedEntity methodsFor: 'accessing'!unresolvedReplacement: anUnresolvedReplacement	unresolvedReplacement := anUnresolvedReplacement! !!DTDStandaloneExternalInternalGeneralParsedEntity methodsFor: 'testing'!isStandaloneExternal	^ true! !!DTDInternalParameterParsedEntity methodsFor: 'testing'!isParameter	^ true! !!DTDInternalParsedEntity class methodsFor: 'instance creation'!name: aName replacement: aReplacementString	^ self		name: aName		replacement: aReplacementString		uri: ''! !!DTDInternalParsedEntity class methodsFor: 'instance creation'!name: aName replacement: aReplacementString uri: aURIString	^ self new		setName: aName		replacement: aReplacementString		uri: aURIString! !!DTDInternalParsedEntity methodsFor: 'testing'!hasReplacement	^ self replacement notEmpty! !!DTDInternalParsedEntity methodsFor: 'accessing'!replacement	^ replacement ifNil: [replacement := '']! !!DTDInternalParsedEntity methodsFor: 'accessing'!replacement: aReplacementString	replacement := aReplacementString! !!DTDInternalParsedEntity methodsFor: 'accessing'!replacementStream	^ self replacement readStream! !!DTDInternalParsedEntity methodsFor: 'initialization'!setName: aName replacement: aReplacementString uri: aURIString	name := aName.	replacement := aReplacementString.	uri := aURIString.! !!DTDParsedEntity methodsFor: 'converting'!asPushedBackEntity	^ self isParameter		ifTrue: [XMLPushedBackParameterEntity entity: self]		ifFalse: [XMLPushedBackGeneralEntity entity: self]! !!DTDParsedEntity methodsFor: 'testing'!hasReplacement	self subclassResponsibility! !!DTDParsedEntity methodsFor: 'accessing'!replacement	self subclassResponsibility! !!DTDParsedEntity methodsFor: 'accessing'!replacementStream	self subclassResponsibility! !!DTDUnresolvableExternalParameterParsedEntity methodsFor: 'testing'!isParameter	^ true! !!DTDUnresolvableExternalParsedEntity methodsFor: 'private'!errorUnresolvableExternalEntity	XMLParserException		formatSignal:			'External entity {1} can''t be resolved unless resolution is ',			'enabled; use #resolvesExternalEntityReferences: before parsing ',			'to enable'		with: self asReference! !!DTDUnresolvableExternalParsedEntity methodsFor: 'testing'!hasReplacement	^ true! !!DTDUnresolvableExternalParsedEntity methodsFor: 'testing'!isExternal	^ true! !!DTDUnresolvableExternalParsedEntity methodsFor: 'accessing'!replacement	self errorUnresolvableExternalEntity! !!DTDUnresolvableExternalParsedEntity methodsFor: 'accessing'!replacementStream	self errorUnresolvableExternalEntity! !!DTDUnparsedEntity class methodsFor: 'instance creation'!name: aName publicID: aPublicID systemID: aSystemID ndata: aNotationName	^ self new		setName: aName		publicID: aPublicID		systemID: aSystemID		ndata: aNotationName! !!DTDUnparsedEntity methodsFor: 'testing'!isUnparsed	^ true! !!DTDUnparsedEntity methodsFor: 'accessing'!ndata	^ ndata ifNil: [ndata := '']! !!DTDUnparsedEntity methodsFor: 'accessing'!ndata: aNotationName	ndata := aNotationName! !!DTDUnparsedEntity methodsFor: 'accessing'!publicID	^ publicID ifNil: [publicID := '']! !!DTDUnparsedEntity methodsFor: 'accessing'!publicID: aPublicID	publicID := aPublicID! !!DTDUnparsedEntity methodsFor: 'initialization'!setName: aName publicID: aPublicID systemID: aSystemID ndata: aNotationName	name := aName.	publicID := aPublicID.	systemID := aSystemID.	ndata := aNotationName.! !!DTDUnparsedEntity methodsFor: 'accessing'!systemID	^ systemID ifNil: [systemID := '']! !!DTDUnparsedEntity methodsFor: 'accessing'!systemID: aSystemID	systemID := aSystemID! !!DTDEntityConfiguration methodsFor: 'accessing'!externalEntityResolver	"uses the caching resolver by default"	^ externalEntityResolver		ifNil: [externalEntityResolver := DTDExternalEntityResolver default]! !!DTDEntityConfiguration methodsFor: 'accessing'!externalEntityResolver: anExternalEntityResolver	externalEntityResolver := anExternalEntityResolver! !!DTDEntityConfiguration methodsFor: 'copying'!postCopy	super postCopy.	externalEntityResolver		ifNotNil: [externalEntityResolver := externalEntityResolver copy].! !!DTDEntityConfiguration methodsFor: 'accessing'!preservesUndeclaredEntityReferences	^ preservesUndeclaredEntityReferences		ifNil: [preservesUndeclaredEntityReferences := false]! !!DTDEntityConfiguration methodsFor: 'accessing'!preservesUndeclaredEntityReferences: aBoolean	preservesUndeclaredEntityReferences := aBoolean! !!DTDEntityConfiguration methodsFor: 'accessing'!replacesContentEntityReferences	^ replacesContentEntityReferences ifNil: [replacesContentEntityReferences := true]! !!DTDEntityConfiguration methodsFor: 'accessing'!replacesContentEntityReferences: aBoolean	replacesContentEntityReferences := aBoolean! !!DTDEntityConfiguration methodsFor: 'accessing'!resolvesExternalEntities	^ resolvesExternalEntities ifNil: [resolvesExternalEntities := false]! !!DTDEntityConfiguration methodsFor: 'accessing'!resolvesExternalEntities: aBoolean	resolvesExternalEntities := aBoolean! !!DTDEnumerationListParser class methodsFor: 'instance creation'!on: aString	^ self new on: aString! !!DTDEnumerationListParser methodsFor: 'private'!errorDuplicateListValue: aValue	XMLValidationException		formatSignal: 'Duplicate value "{1}" in list'		with: aValue! !!DTDEnumerationListParser methodsFor: 'private'!listEndOffset	^ 1 "')' size"! !!DTDEnumerationListParser methodsFor: 'private'!listStartOffset	^ 1 "'(' size"! !!DTDEnumerationListParser methodsFor: 'initialization'!on: aString	listString := aString! !!DTDEnumerationListParser methodsFor: 'parsing'!parse	"the tokenizer removes all spaces from lists"	| listStartIndex listEndIndex totalListValues listValues nextListValuesIndex nextValueStartIndex |	listStartIndex := 1 + self listStartOffset.	listEndIndex := listString size - self listEndOffset.	"count the values to preallocate an Array"	totalListValues := 1.	listStartIndex to: listEndIndex do: [:i |		(listString at: i) == $|			ifTrue: [totalListValues := totalListValues + 1]].	listValues := Array new: totalListValues.	nextListValuesIndex := 1.	nextValueStartIndex := listStartIndex.	listStartIndex to: listEndIndex do: [:i | 		(listString at: i) == $|			ifTrue: [				listValues					at: nextListValuesIndex					put:						(listString							copyFrom: nextValueStartIndex							to: i - 1).				nextListValuesIndex := nextListValuesIndex + 1.				nextValueStartIndex := i + 1]].	listValues		at: nextListValuesIndex		put:			(listString				copyFrom: nextValueStartIndex				to: listEndIndex).	^ listValues.! !!DTDMixedContentEnumerationListParser methodsFor: 'private'!listEndOffset	^ listString last == $*		ifTrue: [2] "')*' size"		ifFalse: [1] "')' size"! !!DTDNotationEnumerationListParser methodsFor: 'private'!listStartOffset	^ 10 "'NOTATION (' size"! !!DTDExternalEntityLimits class methodsFor: 'accessing'!defaultExternalSubsetReadLimit	^ XMLParserLimits defaultReadLimit		ifNotNil: [:limit | (limit / 4) asInteger]! !!DTDExternalEntityLimits class methodsFor: 'accessing'!defaultMaxExternalEntities	^ 20! !!DTDExternalEntityLimits class methodsFor: 'accessing'!defaultMaxExternalEntitySize	^ 2500000! !!DTDExternalEntityLimits methodsFor: 'accessing'!externalSubsetReadLimit	^ externalSubsetReadLimit! !!DTDExternalEntityLimits methodsFor: 'accessing'!externalSubsetReadLimit: anInteger	externalSubsetReadLimit := anInteger! !!DTDExternalEntityLimits methodsFor: 'initialization'!initialize	super initialize.	externalSubsetReadLimit := self class defaultExternalSubsetReadLimit.	maxExternalEntities := self class defaultMaxExternalEntities.	maxExternalEntitySize := self class defaultMaxExternalEntitySize.	resolvesLocalFromNonLocal := false.! !!DTDExternalEntityLimits methodsFor: 'accessing'!maxExternalEntities	^ maxExternalEntities! !!DTDExternalEntityLimits methodsFor: 'accessing'!maxExternalEntities: anInteger	maxExternalEntities := anInteger! !!DTDExternalEntityLimits methodsFor: 'accessing'!maxExternalEntitySize	^ maxExternalEntitySize! !!DTDExternalEntityLimits methodsFor: 'accessing'!maxExternalEntitySize: anInteger	maxExternalEntitySize := anInteger! !!DTDExternalEntityLimits methodsFor: 'removing'!removeAll	externalSubsetReadLimit := nil.	maxExternalEntities := nil.	maxExternalEntitySize := nil.	resolvesLocalFromNonLocal := true.! !!DTDExternalEntityLimits methodsFor: 'accessing'!resolvesLocalFromNonLocal	^ resolvesLocalFromNonLocal! !!DTDExternalEntityLimits methodsFor: 'accessing'!resolvesLocalFromNonLocal: aBoolean	resolvesLocalFromNonLocal := aBoolean! !!DTDCachingExternalEntityResolver class methodsFor: 'clearing'!clearEntityCache	"self clearEntityCache"	self entityCache clear! !!DTDCachingExternalEntityResolver class methodsFor: 'accessing'!entityCache	"a class variable so it's shared by all subclasses, but lazy initialized	so it isn't initialized unless needed"	^ EntityCache		ifNil: [EntityCache := XMLKeyValueCache maxSize: 64]! !!DTDCachingExternalEntityResolver class methodsFor: 'accessing'!entityCacheAtURI: anXMLURIOrURIString	^ self entityCache		at: anXMLURIOrURIString asXMLURI		ifAbsent: [nil]! !!DTDCachingExternalEntityResolver class methodsFor: 'accessing'!entityCacheAtURI: anXMLURIOrURIString ifAbsent: aBlock	^ self entityCache		at: anXMLURIOrURIString asXMLURI		ifAbsent: aBlock! !!DTDCachingExternalEntityResolver class methodsFor: 'accessing'!entityCacheAtURI: anXMLURIOrURIString ifAbsentPut: aBlock	^ self entityCache		at: anXMLURIOrURIString asXMLURI		ifAbsentPut: aBlock! !!DTDCachingExternalEntityResolver class methodsFor: 'accessing'!entityCacheAtURI: anXMLURIOrURIString put: aStringOrByteArray	^ self entityCache		at: anXMLURIOrURIString asXMLURI		put: aStringOrByteArray! !!DTDCachingExternalEntityResolver class methodsFor: 'class initialization'!initialize	"self initialize"	"reset to nil instead of just clearing to force reinitialization"	EntityCache := nil! !!DTDCachingExternalEntityResolver class methodsFor: 'accessing'!maxCachedEntities	^ self entityCache maxSize! !!DTDCachingExternalEntityResolver class methodsFor: 'accessing'!maxCachedEntities: anInteger	self entityCache maxSize: anInteger! !!DTDCachingExternalEntityResolver methodsFor: 'clearing'!clearEntityCache	self class clearEntityCache! !!DTDCachingExternalEntityResolver methodsFor: 'accessing'!maxCachedEntities	^ self class maxCachedEntities! !!DTDCachingExternalEntityResolver methodsFor: 'accessing'!maxCachedEntities: anInteger	self class maxCachedEntities: anInteger! !!DTDCachingExternalEntityResolver methodsFor: 'private'!resolveNonLocalExternalEntityURI: anXMLURIOrURIString upToLimit: aMaxSize	| uri |	uri := anXMLURIOrURIString asXMLURI.	"avoid #entityCacheAtURI:ifAbsent: and #entityCacheAtURI:ifAbsentPut:	so the cache isn't locked during resolution which could stall other	processes"	^ (self class entityCacheAtURI: uri)		ifNil: [			self class				entityCacheAtURI: uri				put:					(super						resolveNonLocalExternalEntityURI: uri						upToLimit: aMaxSize)].! !!DTDExternalEntityResolver class methodsFor: 'instance creation'!default	^ self defaultClass new! !!DTDExternalEntityResolver class methodsFor: 'accessing'!defaultClass	^ DTDCachingExternalEntityResolver! !!DTDExternalEntityResolver methodsFor: 'converting'!asLimitingExternalEntityResolver	^ DTDExternalEntityResolverLimitingDecorator externalEntityResolver: self! !!DTDExternalEntityResolver methodsFor: 'private'!errorLocalFromNonLocal	XMLLimitException signal:		'Local URI referenced from non-local URI; ',		'use #resolvesLocalFromNonLocal: to change'! !!DTDExternalEntityResolver methodsFor: 'configuring'!externalEntityLimits	^ externalEntityLimits		ifNil: [externalEntityLimits := DTDExternalEntityLimits new]! !!DTDExternalEntityResolver methodsFor: 'configuring'!externalEntityLimits: anExternalEntityLimits	externalEntityLimits := anExternalEntityLimits! !!DTDExternalEntityResolver methodsFor: 'resolving'!externalEntityURIFromPublicID: aPublicID systemID: aSystemID	^ aSystemID asXMLURI! !!DTDExternalEntityResolver methodsFor: 'resolving'!externalEntityURIFromPublicID: aPublicID systemID: aSystemID baseURI: aBaseXMLURIOrURIString	| baseURI externalEntityURI |	baseURI := aBaseXMLURIOrURIString asXMLURI.	externalEntityURI :=		baseURI combinedWith:			(self				externalEntityURIFromPublicID: aPublicID				systemID: aSystemID).	(externalEntityURI isLocal		and: [baseURI isLocal not			and: [self resolvesLocalFromNonLocal not]])		ifTrue: [self errorLocalFromNonLocal].	^ externalEntityURI.! !!DTDExternalEntityResolver methodsFor: 'configuring'!externalSubsetReadLimit	^ self externalEntityLimits externalSubsetReadLimit! !!DTDExternalEntityResolver methodsFor: 'configuring'!externalSubsetReadLimit: anInteger	"change the external subset read limit or nil to disable"	self externalEntityLimits externalSubsetReadLimit: anInteger! !!DTDExternalEntityResolver methodsFor: 'configuring'!maxExternalEntities	^ self externalEntityLimits maxExternalEntities! !!DTDExternalEntityResolver methodsFor: 'configuring'!maxExternalEntities: anInteger	self externalEntityLimits maxExternalEntities: anInteger! !!DTDExternalEntityResolver methodsFor: 'configuring'!maxExternalEntitySize	^ self externalEntityLimits maxExternalEntitySize! !!DTDExternalEntityResolver methodsFor: 'configuring'!maxExternalEntitySize: anInteger	self externalEntityLimits maxExternalEntitySize: anInteger! !!DTDExternalEntityResolver methodsFor: 'copying'!postCopy	super postCopy.	externalEntityLimits		ifNotNil: [externalEntityLimits := externalEntityLimits copy].! !!DTDExternalEntityResolver methodsFor: 'configuring'!removeLimits	self externalEntityLimits removeAll! !!DTDExternalEntityResolver methodsFor: 'resolving'!resolveExternalEntityURI: anXMLURIOrURIString	^ self		resolveExternalEntityURI: anXMLURIOrURIString		upToLimit: self maxExternalEntitySize! !!DTDExternalEntityResolver methodsFor: 'resolving'!resolveExternalEntityURI: anXMLURIOrURIString upToLimit: aMaxSize	| uri |	^ (uri := anXMLURIOrURIString asXMLURI) isLocal		ifTrue: [			self				resolveLocalExternalEntityURI: uri				upToLimit: aMaxSize]		ifFalse: [			self				resolveNonLocalExternalEntityURI: uri				upToLimit: aMaxSize]! !!DTDExternalEntityResolver methodsFor: 'private'!resolveLocalExternalEntityURI: anXMLURIOrURIString upToLimit: aMaxSize	^ DTDUndecodedResolvedExternalParsedEntityReplacement rawContents:		(anXMLURIOrURIString asXMLFileHandle			getUpToLimit: aMaxSize			decoding: false)! !!DTDExternalEntityResolver methodsFor: 'private'!resolveNonLocalExternalEntityURI: anXMLURIOrURIString upToLimit: aMaxSize	| response |	response :=		anXMLURIOrURIString asXMLHTTPRequest			resolveUpToLimit: aMaxSize			decoding: false.	"saves the undecoded replacement with its Content-Type	charset encoding tag for later decoding (if needed)"	^ DTDUndecodedResolvedExternalParsedEntityReplacement		rawContents: response content		encoding: response contentCharset.! !!DTDExternalEntityResolver methodsFor: 'configuring'!resolvesLocalFromNonLocal	^ self externalEntityLimits resolvesLocalFromNonLocal! !!DTDExternalEntityResolver methodsFor: 'configuring'!resolvesLocalFromNonLocal: aBoolean	"allow non-local (http) entities to reference local (file) entities?	(default disabled)"	self externalEntityLimits resolvesLocalFromNonLocal: aBoolean! !!DTDExternalEntityResolver methodsFor: 'resolving'!streamResolveExternalEntityURI: anXMLURIOrURIString	^ self		streamResolveExternalEntityURI: anXMLURIOrURIString		upToLimit: self maxExternalEntitySize! !!DTDExternalEntityResolver methodsFor: 'resolving'!streamResolveExternalEntityURI: anXMLURIOrURIString upToLimit: aMaxSize	| uri |	^ (uri := anXMLURIOrURIString asXMLURI) isLocal		ifTrue: [			self				streamResolveLocalExternalEntityURI: uri				upToLimit: aMaxSize]		ifFalse: [			self				streamResolveNonLocalExternalEntityURI: uri				upToLimit: aMaxSize]! !!DTDExternalEntityResolver methodsFor: 'private'!streamResolveLocalExternalEntityURI: anXMLURIOrURIString upToLimit: aMaxSize	"return our own decoding adapter on the raw, undecoded stream	to avoid looking for any byte-order mark until later"	^ XMLDecodingReadStreamAdapter nonDecodingOn:		(anXMLURIOrURIString asXMLFileHandle			streamGetUpToLimit: aMaxSize			decoding: false)! !!DTDExternalEntityResolver methodsFor: 'private'!streamResolveNonLocalExternalEntityURI: anXMLURIOrURIString upToLimit: aMaxSize	^ (self		resolveNonLocalExternalEntityURI: anXMLURIOrURIString		upToLimit: aMaxSize) readStream! !!DTDStaticExternalEntityResolver class methodsFor: 'instance creation'!externalEntities: anAssociationCollection	^ self new externalEntities: anAssociationCollection! !!DTDStaticExternalEntityResolver methodsFor: 'private'!errorMaxExternalEntitySize: aMaxSize exceededByURI: anXMLURIOrURIString	XMLLimitException		formatSignal: 'Entity exceeds max size of {1} bytes: {2}'		with: aMaxSize		with: anXMLURIOrURIString asString! !!DTDStaticExternalEntityResolver methodsFor: 'private'!errorUnresolvableExternalEntityURI: anXMLURIOrURIString	XMLParserException		formatSignal: 'Unresolvable external entity URI: {1}'		with: anXMLURIOrURIString asString! !!DTDStaticExternalEntityResolver methodsFor: 'accessing'!externalEntities	^ externalEntities ifNil: [externalEntities := Dictionary new]! !!DTDStaticExternalEntityResolver methodsFor: 'accessing'!externalEntities: anAssociationCollection	self hasExternalEntities		ifTrue: [self removeExternalEntities].	anAssociationCollection associationsDo: [:each |		self			externalEntityAtURI: each key			put: each value].! !!DTDStaticExternalEntityResolver methodsFor: 'accessing'!externalEntityAtURI: anXMLURIOrURIString	^ self		externalEntityAtURI: anXMLURIOrURIString asXMLURI		ifAbsent: ['']! !!DTDStaticExternalEntityResolver methodsFor: 'accessing'!externalEntityAtURI: anXMLURIOrURIString ifAbsent: aBlock	^ self externalEntities		at: anXMLURIOrURIString asXMLURI		ifAbsent: aBlock! !!DTDStaticExternalEntityResolver methodsFor: 'accessing'!externalEntityAtURI: anXMLURIOrURIString ifAbsentPut: aBlock	^ self externalEntities		at: anXMLURIOrURIString asXMLURI		ifAbsentPut: aBlock! !!DTDStaticExternalEntityResolver methodsFor: 'accessing'!externalEntityAtURI: anXMLURIOrURIString put: aReplacement	^ self externalEntities		at: anXMLURIOrURIString asXMLURI		put: aReplacement! !!DTDStaticExternalEntityResolver methodsFor: 'testing'!hasExternalEntities	^ self externalEntities notEmpty! !!DTDStaticExternalEntityResolver methodsFor: 'testing'!includesExternalEntityURI: anXMLURIOrURIString	^ self externalEntities includesKey: anXMLURIOrURIString asXMLURI! !!DTDStaticExternalEntityResolver methodsFor: 'copying'!postCopy	super postCopy.	externalEntities		ifNotNil: [externalEntities := externalEntities copy].! !!DTDStaticExternalEntityResolver methodsFor: 'removing'!removeExternalEntities	self externalEntities removeAll! !!DTDStaticExternalEntityResolver methodsFor: 'removing'!removeExternalEntityURI: anXMLURIOrURIString	^ self externalEntities removeKey: anXMLURIOrURIString asXMLURI! !!DTDStaticExternalEntityResolver methodsFor: 'removing'!removeExternalEntityURI: anXMLURIOrURIString ifAbsent: aBlock	^ self externalEntities		removeKey: anXMLURIOrURIString asXMLURI		ifAbsent: aBlock! !!DTDStaticExternalEntityResolver methodsFor: 'resolving'!resolveExternalEntityURI: anXMLURIOrURIString upToLimit: aMaxSize	| replacement |	replacement :=		self			externalEntityAtURI: anXMLURIOrURIString			ifAbsent: [				self errorUnresolvableExternalEntityURI: anXMLURIOrURIString].	(aMaxSize notNil		and: [replacement size > aMaxSize])		ifTrue: [			self				errorMaxExternalEntitySize: aMaxSize				exceededByURI: anXMLURIOrURIString].		^ DTDUndecodedResolvedExternalParsedEntityReplacement rawContents: replacement.! !!DTDStaticExternalEntityResolver methodsFor: 'resolving'!streamResolveExternalEntityURI: anXMLURIOrURIString upToLimit: aMaxSize	^ (self		resolveExternalEntityURI: anXMLURIOrURIString		upToLimit: aMaxSize) readStream! !!DTDExternalEntityResolverLimitingDecorator class methodsFor: 'instance creation'!externalEntityResolver: anExternalEntityResolver	^ self new externalEntityResolver: anExternalEntityResolver! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'converting'!asLimitingExternalEntityResolver	^ self! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'private'!checkExternalEntityLimit	| maxExternalEntities |	((maxExternalEntities := self externalEntityResolver maxExternalEntities) notNil		and: [self totalResolvedExternalEntities >= maxExternalEntities])		ifTrue: [self erorrExternalEntityLimitExceeded]! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'private'!erorrExternalEntityLimitExceeded	XMLLimitException signal:		'External entity limit exceeded; ',		'use #maxExternalEntities: to change or disable'! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'configuring'!externalEntityLimits	^ self externalEntityResolver externalEntityLimits! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'configuring'!externalEntityLimits: anExternalEntityLimits	self externalEntityResolver externalEntityLimits: anExternalEntityLimits! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'accessing'!externalEntityResolver	^ externalEntityResolver! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'accessing'!externalEntityResolver: anExternalEntityResolver	externalEntityResolver := anExternalEntityResolver! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'resolving'!externalEntityURIFromPublicID: aPublicID systemID: aSystemID	^ self externalEntityResolver		externalEntityURIFromPublicID: aPublicID		systemID: aSystemID! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'resolving'!externalEntityURIFromPublicID: aPublicID systemID: aSystemID baseURI: aBaseXMLURIOrURIString	^ self externalEntityResolver		externalEntityURIFromPublicID: aPublicID		systemID: aSystemID		baseURI: aBaseXMLURIOrURIString! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'configuring'!externalSubsetReadLimit	^ self externalEntityResolver externalSubsetReadLimit! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'configuring'!externalSubsetReadLimit: anInteger	self externalEntityResolver externalSubsetReadLimit: anInteger! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'private'!incrementTotalResolvedExternalEntities	totalResolvedExternalEntities :=		totalResolvedExternalEntities			ifNil: [1]			ifNotNil: [totalResolvedExternalEntities + 1]! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'configuring'!maxExternalEntities	^ self externalEntityResolver maxExternalEntities! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'configuring'!maxExternalEntities: anInteger	self externalEntityResolver maxExternalEntities: anInteger! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'configuring'!maxExternalEntitySize	^ self externalEntityResolver maxExternalEntitySize! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'configuring'!maxExternalEntitySize: anInteger	self externalEntityResolver maxExternalEntitySize: anInteger! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		print: self externalEntityResolver;		nextPut: $).! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'configuring'!removeLimits	self externalEntityResolver removeLimits! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'resolving'!resolveExternalEntityURI: anXMLURIOrURIString	^ self resolveExternalEntityWith: [		self externalEntityResolver resolveExternalEntityURI:			anXMLURIOrURIString]! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'resolving'!resolveExternalEntityURI: anXMLURIOrURIString upToLimit: aMaxSize	^ self resolveExternalEntityWith: [		self externalEntityResolver			resolveExternalEntityURI: anXMLURIOrURIString			upToLimit: aMaxSize]! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'private'!resolveExternalEntityWith: aBlock	| result |	self checkExternalEntityLimit.	result := aBlock value.	self incrementTotalResolvedExternalEntities.	^ result.! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'configuring'!resolvesLocalFromNonLocal	^ self externalEntityResolver resolvesLocalFromNonLocal! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'configuring'!resolvesLocalFromNonLocal: aBoolean	self externalEntityResolver resolvesLocalFromNonLocal: aBoolean! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'resolving'!streamResolveExternalEntityURI: anXMLURIOrURIString	^ self resolveExternalEntityWith: [		self externalEntityResolver streamResolveExternalEntityURI:			anXMLURIOrURIString]! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'resolving'!streamResolveExternalEntityURI: anXMLURIOrURIString upToLimit: aMaxSize	^ self resolveExternalEntityWith: [		self externalEntityResolver			streamResolveExternalEntityURI: anXMLURIOrURIString			upToLimit: aMaxSize]! !!DTDExternalEntityResolverLimitingDecorator methodsFor: 'accessing'!totalResolvedExternalEntities	^ totalResolvedExternalEntities ifNil: [totalResolvedExternalEntities := 0]! !!DTDNotation class methodsFor: 'instance creation'!name: aName publicID: aPublicID	^ self		name: aName		publicID: aPublicID		systemID: ''! !!DTDNotation class methodsFor: 'instance creation'!name: aName publicID: aPublicID systemID: aSystemID	^ self new		setName: aName		publicID: aPublicID		systemID: aSystemID! !!DTDNotation methodsFor: 'accessing'!name	^ name ifNil: [name := '']! !!DTDNotation methodsFor: 'accessing'!name: aName	name := aName! !!DTDNotation methodsFor: 'accessing'!publicID	^ publicID ifNil: [publicID := '']! !!DTDNotation methodsFor: 'accessing'!publicID: aPublicID	publicID := aPublicID! !!DTDNotation methodsFor: 'initialization'!setName: aName publicID: aPublicID systemID: aSystemID	name := aName.	publicID := aPublicID.	systemID := aSystemID.! !!DTDNotation methodsFor: 'accessing'!systemID	^ systemID ifNil: [systemID := '']! !!DTDNotation methodsFor: 'accessing'!systemID: aSystemID	systemID := aSystemID! !!DTDDecodedResolvedExternalParsedEntityReplacement class methodsFor: 'instance creation'!contents: aString	^ self new setContents: aString! !!DTDDecodedResolvedExternalParsedEntityReplacement methodsFor: 'accessing'!contents	^ contents! !!DTDDecodedResolvedExternalParsedEntityReplacement methodsFor: 'testing'!isEmpty	^ self contents isEmpty! !!DTDDecodedResolvedExternalParsedEntityReplacement methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		nextPutAll: self contents;		nextPut: $).! !!DTDDecodedResolvedExternalParsedEntityReplacement methodsFor: 'accessing'!readStream	^ self contents readStream! !!DTDDecodedResolvedExternalParsedEntityReplacement methodsFor: 'initialization'!setContents: aString	contents := aString! !!DTDResolvedExternalParsedEntityReplacement methodsFor: 'converting'!asString	^ self contents! !!DTDResolvedExternalParsedEntityReplacement methodsFor: 'accessing'!contents	self subclassResponsibility! !!DTDResolvedExternalParsedEntityReplacement methodsFor: 'testing'!isEmpty	self subclassResponsibility! !!DTDResolvedExternalParsedEntityReplacement methodsFor: 'testing'!notEmpty	^ self isEmpty not! !!DTDResolvedExternalParsedEntityReplacement methodsFor: 'accessing'!readStream	self subclassResponsibility! !!DTDUndecodedResolvedExternalParsedEntityReplacement class methodsFor: 'instance creation'!rawContents: aString	^ self		rawContents: aString		encoding: ''! !!DTDUndecodedResolvedExternalParsedEntityReplacement class methodsFor: 'instance creation'!rawContents: aString encoding: anEncodingName	^ self new		setRawContents: aString		encoding: anEncodingName! !!DTDUndecodedResolvedExternalParsedEntityReplacement methodsFor: 'accessing'!contents	^ self readStream upToEnd! !!DTDUndecodedResolvedExternalParsedEntityReplacement methodsFor: 'accessing'!encoding	^ encoding! !!DTDUndecodedResolvedExternalParsedEntityReplacement methodsFor: 'testing'!isEmpty	^ self rawContents isEmpty! !!DTDUndecodedResolvedExternalParsedEntityReplacement methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		nextPutAll: self encoding;		nextPut: $).! !!DTDUndecodedResolvedExternalParsedEntityReplacement methodsFor: 'accessing'!rawContents	^ rawContents! !!DTDUndecodedResolvedExternalParsedEntityReplacement methodsFor: 'accessing'!readStream	^ XMLDecodingReadStreamAdapter		on: self rawContents readStream		streamConverter: self encoding asXMLStreamConverter! !!DTDUndecodedResolvedExternalParsedEntityReplacement methodsFor: 'initialization'!setRawContents: aString encoding: anEncodingName	rawContents := aString.	encoding := anEncodingName.! !!DTDUnresolvedExternalParsedEntityReplacement class methodsFor: 'instance creation'!resolver: aResolver publicID: aPublicID systemID: aSystemID baseURI: aBaseURIString	^ self new		setResolver: aResolver		publicID: aPublicID		systemID: aSystemID		baseURI: aBaseURIString! !!DTDUnresolvedExternalParsedEntityReplacement methodsFor: 'accessing'!baseURI	^ baseURI ifNil: [baseURI := '']! !!DTDUnresolvedExternalParsedEntityReplacement methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	self publicID isEmpty		ifTrue: [aStream nextPutAll: 'SYSTEM']		ifFalse: [			aStream				nextPutAll: 'PUBLIC "';				nextPutAll: self publicID;				nextPut: $"].	aStream		nextPutAll: ' "';		nextPutAll: self systemID;		nextPutAll: '")'.! !!DTDUnresolvedExternalParsedEntityReplacement methodsFor: 'accessing'!publicID	^ publicID ifNil: [publicID := '']! !!DTDUnresolvedExternalParsedEntityReplacement methodsFor: 'resolving'!resolveForExternalEntity: anExternalEntity	| externalEntityURI |	externalEntityURI :=		self resolver			externalEntityURIFromPublicID: self publicID			systemID: self systemID			baseURI: self baseURI.	anExternalEntity		resolvedReplacement:			(self resolver resolveExternalEntityURI: externalEntityURI);		uri: externalEntityURI asString;		unresolvedReplacement: nil.! !!DTDUnresolvedExternalParsedEntityReplacement methodsFor: 'accessing'!resolver	^ resolver ifNil: [resolver := DTDExternalEntityResolver default]! !!DTDUnresolvedExternalParsedEntityReplacement methodsFor: 'initialization'!setResolver: aResolver publicID: aPublicID systemID: aSystemID baseURI: aBaseURIString	resolver := aResolver.	publicID := aPublicID.	systemID := aSystemID.	baseURI := aBaseURIString.! !!DTDUnresolvedExternalParsedEntityReplacement methodsFor: 'accessing'!systemID	^ systemID ifNil: [systemID := '']! !!Object methodsFor: '*XML-Parser'!isXMLBinaryOrExternalStream	"Not every stream or stream-like object is a subclass of Stream, so this	must be defined here.	At a minimum, these streams must accept binary objects (like SmallIntegers	and ByteArrays) when writing. When reading, they can return byte values	as SmallIntegers or Characters and collections of byte values as ByteArrays	or ByteStrings."	^ self isStream		and: [(self respondsTo: #isBinary)			and: [self isBinary]]! !!Object methodsFor: '*XML-Parser'!isXMLConvertingStreamAdapter	^ false! !!SAX2ContentHandler class methodsFor: 'instance creation'!parser: aParser	^ self new parser: aParser! !!SAX2ContentHandler methodsFor: 'handling - content'!characters: aString	"Handles character data in an element, such as the 'test' in	'<characters>test</characters>' or in the CDATA section '<!![CDATA[test]]>'.		It may be sent multiple times for different sections of character data	in a single element if they're separated by other nodes or entity	references like in '<characters>one<!!--comment-->two</characters>'.		See ignorableWhitespace:"! !!SAX2ContentHandler methodsFor: 'handling - content'!endDocument	"Handles the end of an XML document. No more handlers are invoked after this."! !!SAX2ContentHandler methodsFor: 'handling - content'!endElement: aQualifiedName	"Handles the end of an element if a subclass doesn't implement	#endElement:prefix:uri:localName: or #endElement:prefix:uri:."! !!SAX2ContentHandler methodsFor: 'handling - content'!endElement: aQualifiedName prefix: aPrefix uri: aURI	"Handles the end of an element if a subclass doesn't implement	#endElement:prefix:uri:localName:. By default it forwards to a simpler	handler, #endElement:.		aQualifiedName - the full name, including any prefix, such as 'prefix:name'	aPrefix - the prefix of the qualified name or an empty string	aURI - the namespace URI of the element or an empty string"	self endElement: aQualifiedName! !!SAX2ContentHandler methodsFor: 'handling - content'!endElement: aQualifiedName prefix: aPrefix uri: aURI localName: aLocalName	"Handles the end of an element, either an end tag like '</end>' or a	self-closed tag like '<empty/>'. By default it forwards to a simpler handler,	#endElement:prefix:uri:.		aQualifiedName - the full name, including any prefix, such as 'prefix:name'	aPrefix - the prefix of the qualified name or an empty string	aURI - the namespace URI of the element or an empty string	aLocalName - the local part of the qualified name"	self		endElement: aQualifiedName		prefix: aPrefix		uri:  aURI! !!SAX2ContentHandler methodsFor: 'handling - content'!endPrefixMapping: aPrefix	"Handles the end of a namespace prefix/URI mapping when namespaces are	enabled. After, aPrefix (empty for the default namespace) will be either	unmapped or mapped to a different URI. The 'xml' prefix is predefined	and never unmapped."! !!SAX2ContentHandler methodsFor: 'handling - content'!ignorableWhitespace: aString	"When validation is enabled and a DTD with element declarations is	present, this can be used to handle ignorable whitespace in elements	with 'element content' (meaning they can only contain other elements	and no PCDATA), such as between '<element-content>' and '<mixed-content>'	or between '</mixed-content>' and '</element-content>' in this sample:		'<!!DOCTYPE element-content [			<!!--this has element content, so its whitespace is ignorable-->			<!!ELEMENT element-content (mixed-content)>			<!!--this has mixed content, so its whitespace is not ignorable-->			<!!ELEMENT mixed-content (#PCDATA|any-content)*>			<!!--this has any content, so its whitespace is not ignorable-->			<!!ELEMENT any-content ANY>		]>		<element-content>			<mixed-content>				<any-content> any </any-content>			</mixed-content>		</element-content>'	Not sent if validation is disabled or if there's no DTD with element	declarations."! !!SAX2ContentHandler methodsFor: 'accessing'!parser	"Returns the SAX2Parser this handler was injected into"	^ parser! !!SAX2ContentHandler methodsFor: 'accessing'!parser: aParser	parser := aParser! !!SAX2ContentHandler methodsFor: 'handling - content'!processingInstruction: aTargetString data: aDataString	"Handles processing instructions like '<?name value?>', where 'name' is	the target and 'value' is the data.		XML declarations may look like PIs but are different and are handled	with xmlVersion:encoding:standalone: instead."! !!SAX2ContentHandler methodsFor: 'handling - content'!skippedEntity: anEntityName	"Sent when a general parsed entity reference like '&name;' is	unreplaced in content. Only sent when validation is turned off	or entity replacement is disabled."! !!SAX2ContentHandler methodsFor: 'handling - content'!startDocument	"Handles the start of an XML document, the first handler invoked."! !!SAX2ContentHandler methodsFor: 'handling - content'!startElement: aQualifiedName attributes: anAttributeDictionary	"Handles the start of an element if a subclass doesn't implement	#startElement:prefix:uri:localName:attributes: or	#startElement:prefix:uri:attributes:.	aQualifiedName - the full name, including any prefix, such as 'prefix:name'	anAttributeDictionary - an XMLAttributeDictionary of attributes"! !!SAX2ContentHandler methodsFor: 'handling - content'!startElement: aQualifiedName prefix: aPrefix uri: aURI attributes: anAttributeDictionary	"Handles the start of an element if a subclass doesn't implement	#startElement:prefix:uri:localName:attributes:. By default it forwards	to a simpler handler, #startElement:attributes:.		aQualifiedName - the full name, including any prefix, such as 'prefix:name'	aPrefix - the prefix of the qualified name or an empty string	aURI - the namespace URI of the element or an empty string	anAttributeDictionary - an XMLAttributeDictionary of attributes"	self		startElement: aQualifiedName		attributes: anAttributeDictionary! !!SAX2ContentHandler methodsFor: 'handling - content'!startElement: aQualifiedName prefix: aPrefix uri: aURI localName: aLocalName attributes: anAttributeDictionary	"Handles the start of an element, either a start tag like '<start>' or a	self-closed tag like '<empty/>'. By default it forwards to a simpler handler,	#startElement:prefix:uri:attributes:.		aQualifiedName - the full name, including any prefix, such as 'prefix:name'	aPrefix - the prefix of the qualified name or an empty string	aURI - the namespace URI of the element or an empty string	aLocalName - the local part of the qualified name	anAttributeDictionary - an XMLAttributeDictionary of attributes"	self		startElement: aQualifiedName		prefix: aPrefix		uri: aURI		attributes: anAttributeDictionary! !!SAX2ContentHandler methodsFor: 'handling - content'!startPrefixMapping: aPrefix uri: aURI	"Handles the start of a namespace prefix/URI mapping when namespaces are	enabled. The 'xml' prefix is predefined and never remapped.	aPrefix - the prefix of the namespace (empty for the default namesapce)	aURI - the namespace URI"! !!SAX2DeclarationHandler class methodsFor: 'instance creation'!parser: aParser	^ self new parser: aParser! !!SAX2DeclarationHandler methodsFor: 'handling - declaration'!attributeDeclaration: anElementName name: anAttributeName type: aType defaultPragma: aDefaultPragma defaultValue: aDefaultValue! !!SAX2DeclarationHandler methodsFor: 'handling - declaration'!elementDeclaration: anElementName contentModel: aContentModel! !!SAX2DeclarationHandler methodsFor: 'handling - declaration'!generalEntityDeclaration: aName publicID: aPublicID systemID: aSystemID ndata: aNotationName! !!SAX2DeclarationHandler methodsFor: 'handling - declaration'!generalEntityDeclaration: aName replacement: aReplacement! !!SAX2DeclarationHandler methodsFor: 'handling - declaration'!notationDeclaration: aName publicID: aPublicID systemID: aSystemID! !!SAX2DeclarationHandler methodsFor: 'handling - declaration'!parameterEntityDeclaration: aName publicID: aPublicID systemID: aSystemID! !!SAX2DeclarationHandler methodsFor: 'handling - declaration'!parameterEntityDeclaration: aName replacement: aReplacement! !!SAX2DeclarationHandler methodsFor: 'accessing'!parser	"Returns the SAX2Parser this handler was injected into"	^ parser! !!SAX2DeclarationHandler methodsFor: 'accessing'!parser: aParser	parser := aParser! !!SAX2ElementCharacterHandler methodsFor: 'accessing'!characters	"This returns the combined #characters: events handled by the receiver	as a string."	^ characters ifNil: [characters := '']! !!SAX2ElementCharacterHandler methodsFor: 'handling - content'!characters: aString	"building the string this way is simpler and performs as well in tests	as using a write stream"	characters :=		characters			ifNil: [aString]			ifNotNil: [characters, aString]! !!SAX2ElementHandler class methodsFor: 'parsing'!parser: aParser	^ self		parser: aParser		parent: aParser elementHandler		parentFactory: aParser elementHandlerFactory! !!SAX2ElementHandler class methodsFor: 'parsing'!parser: aParser parent: anElementHandler parentFactory: anElementHandlerFactory	^ self new		setParser: aParser		parent: anElementHandler		parentFactory: anElementHandlerFactory! !!SAX2ElementHandler methodsFor: 'accessing'!ancestors		"Returns a list of all ancestor element handlers of the receiver."	| ancestors |	ancestors := XMLOrderedList new.	self ancestorsDo: [:each | ancestors addLast: each].	^ ancestors.! !!SAX2ElementHandler methodsFor: 'enumerating'!ancestorsDo: aBlock	| ancestor |	ancestor := self parent.	[ancestor notNil]		whileTrue: [			aBlock value: ancestor.			ancestor := ancestor parent].! !!SAX2ElementHandler methodsFor: 'accessing'!characters	"This handler ignores #characters: events, so this always returns	an empty string."	^ ''! !!SAX2ElementHandler methodsFor: 'handling - content'!characters: aString	"Handles character data in an element, such as the 'test' in	'<characters>test</characters>' or in the CDATA section '<!![CDATA[test]]>'.		It may be sent multiple times for different sections of character data	in a single element if they're separated by other nodes or entity	references like in '<characters>one<!!--comment-->two</characters>'."! !!SAX2ElementHandler methodsFor: 'accessing'!elementHandlerFactory	"Can be overridden to return a default factory to use by a factory	mapper when no other factory is mapped to the receiver."	^ nil! !!SAX2ElementHandler methodsFor: 'handling - content'!endElement: aQualifiedName	"Handles the end of an element if a subclass doesn't implement	#endElement:prefix:uri:localName: or #endElement:prefix:uri:."! !!SAX2ElementHandler methodsFor: 'handling - content'!endElement: aQualifiedName prefix: aPrefix uri: aURI	"Handles the end of an element if a subclass doesn't implement	#endElement:prefix:uri:localName:. By default it forwards to a simpler	handler, #endElement:.		aQualifiedName - the full name, including any prefix, such as 'prefix:name'	aPrefix - the prefix of the qualified name or an empty string	aURI - the namespace URI of the element or an empty string"	self endElement: aQualifiedName! !!SAX2ElementHandler methodsFor: 'handling - content'!endElement: aQualifiedName prefix: aPrefix uri: aURI localName: aLocalName	"Handles the end of an element, either an end tag like '</end>' or a	self-closed tag like '<empty/>'. By default it forwards to a simpler handler,	#endElement:prefix:uri:.		aQualifiedName - the full name, including any prefix, such as 'prefix:name'	aPrefix - the prefix of the qualified name or an empty string	aURI - the namespace URI of the element or an empty string	aLocalName - the local part of the qualified name"	self		endElement: aQualifiedName		prefix: aPrefix		uri:  aURI! !!SAX2ElementHandler methodsFor: 'testing'!hasParent	"Returns true if the receiver has a parent element handler (meaning it's	not the root element handler)"	^ parent notNil! !!SAX2ElementHandler methodsFor: 'accessing'!parent	"Returns the parent element handler or nil if there isn't one (if	the receiver is handling the root element)."	^ parent! !!SAX2ElementHandler methodsFor: 'accessing'!parentFactory	"Returns the factory that created the receiver."	^ parentFactory! !!SAX2ElementHandler methodsFor: 'accessing'!parser	"Returns the SAX2ElementParser"	^ parser! !!SAX2ElementHandler methodsFor: 'initialization'!setParser: aParser parent: anElementHandler parentFactory: anElementHandlerFactory	parser := aParser.	parent := anElementHandler.	parentFactory := anElementHandlerFactory.! !!SAX2ElementHandler methodsFor: 'handling - content'!startElement: aQualifiedName attributes: anAttributeDictionary	"Handles the start of an element if a subclass doesn't implement	#startElement:prefix:uri:localName:attributes: or	#startElement:prefix:uri:attributes:.	aQualifiedName - the full name, including any prefix, such as 'prefix:name'	anAttributeDictionary - an XMLAttributeDictionary of attributes"! !!SAX2ElementHandler methodsFor: 'handling - content'!startElement: aQualifiedName prefix: aPrefix uri: aURI attributes: anAttributeDictionary	"Handles the start of an element if a subclass doesn't implement	#startElement:prefix:uri:localName:attributes:. By default it forwards	to a simpler handler, #startElement:attributes:.		aQualifiedName - the full name, including any prefix, such as 'prefix:name'	aPrefix - the prefix of the qualified name or an empty string	aURI - the namespace URI of the element or an empty string	anAttributeDictionary - an XMLAttributeDictionary of attributes"	self		startElement: aQualifiedName		attributes: anAttributeDictionary! !!SAX2ElementHandler methodsFor: 'handling - content'!startElement: aQualifiedName prefix: aPrefix uri: aURI localName: aLocalName attributes: anAttributeDictionary	"Handles the start of an element, either a start tag like '<start>' or a	self-closed tag like '<empty/>'. By default it forwards to a simpler handler,	#startElement:prefix:uri:attributes:.		aQualifiedName - the full name, including any prefix, such as 'prefix:name'	aPrefix - the prefix of the qualified name or an empty string	aURI - the namespace URI of the element or an empty string	aLocalName - the local part of the qualified name	anAttributeDictionary - an XMLAttributeDictionary of attributes"	self		startElement: aQualifiedName		prefix: aPrefix		uri: aURI		attributes: anAttributeDictionary! !!SAX2ElementHandlerFactory methodsFor: 'accessing'!classForElement: aQualifiedName namespaceURI: aURI localName: aLocalName attributes: anAssociationCollection	^ self elementHandlerClass! !!SAX2ElementHandlerFactory methodsFor: 'accessing'!elementHandlerClass	^ SAX2ElementHandler! !!SAX2PluggableElementHandlerFactory methodsFor: 'accessing'!classForElement: aQualifiedName namespaceURI: aURI localName: aLocalName attributes: anAssociationCollection	^ elementClassMapper		classForElement: aQualifiedName		namespaceURI: aURI		attributes: anAssociationCollection		ifNone: [self elementHandlerClass]! !!SAX2PluggableElementHandlerFactory methodsFor: 'private'!elementClassMapper	^ elementClassMapper! !!SAX2PluggableElementHandlerFactory methodsFor: 'private'!elementClassMapper: anElementClassMapper	elementClassMapper := anElementClassMapper! !!SAX2PluggableElementHandlerFactory methodsFor: 'defaults'!elementClassMapperClass	^ XMLBasicElementClassMapper! !!SAX2PluggableElementHandlerFactory methodsFor: 'accessing'!elementHandlerClass	^ elementHandlerClass! !!SAX2PluggableElementHandlerFactory methodsFor: 'accessing'!elementHandlerClass: aClass	"set the default element handler class"	elementHandlerClass := aClass! !!SAX2PluggableElementHandlerFactory methodsFor: 'handling'!handleElement: anElementName attributes: aCollectionOrAttributeSpec withClass: aClass	"aCollectionOrAttributeSpec can be some kind of XMLAttributeSpec or a	collection of associations of required attribute names and values, and the	required values can be strings, blocks, or nil meaning the attribute is	required but can take any value"	elementClassMapper		mapElement: anElementName		attributeSpec: aCollectionOrAttributeSpec asXMLAttributeSpec		toClass: aClass! !!SAX2PluggableElementHandlerFactory methodsFor: 'handling'!handleElement: anElementName namespaceURI: aURI attributes: aCollectionOrAttributeSpec withClass: aClass	"aCollectionOrAttributeSpec can be some kind of XMLAttributeSpec or a	collection of associations of required attribute names and values, and the	required values can be strings, blocks, or nil meaning the attribute is	required but can take any value"	elementClassMapper		mapElement: anElementName		namespaceURI: aURI		attributeSpec: aCollectionOrAttributeSpec asXMLAttributeSpec		toClass: aClass! !!SAX2PluggableElementHandlerFactory methodsFor: 'handling'!handleElement: anElementName namespaceURI: aURI withClass: aClass	elementClassMapper		mapElement: anElementName		namespaceURI: aURI		toClass: aClass! !!SAX2PluggableElementHandlerFactory methodsFor: 'handling'!handleElement: anElementName withClass: aClass	elementClassMapper		mapElement: anElementName		toClass: aClass! !!SAX2PluggableElementHandlerFactory methodsFor: 'handling'!handleElements: anElementNameCollection namespaceURI: aNamespaceURI withClass: aClass	elementClassMapper		mapElements: anElementNameCollection		namespaceURI: aNamespaceURI		toClass: aClass! !!SAX2PluggableElementHandlerFactory methodsFor: 'handling'!handleElements: anElementNameCollection withClass: aClass	elementClassMapper		mapElements: anElementNameCollection		toClass: aClass! !!SAX2PluggableElementHandlerFactory methodsFor: 'handling'!handleElementsMatchingClass: aClass	"This will handle all elements matching the name of a class with that	class, but igoring the class's prefix and any 'Element' or 'ElementHandler'	suffix.	For example, it will match MyUserDefinedElement to:		<UserDefined>		<userDefined>		<user-defined>		<user_defined>"	elementClassMapper		mapAllMatchingElementsToClass: aClass		ignoringSuffixes: self ignorableClassNameSuffixes! !!SAX2PluggableElementHandlerFactory methodsFor: 'handling'!handleElementsMatchingClasses: aClassCollection	"See the comment in #handleElementsMatchingClass:"	elementClassMapper		mapAllMatchingElementsToClasses: aClassCollection		ignoringSuffixes: self ignorableClassNameSuffixes! !!SAX2PluggableElementHandlerFactory methodsFor: 'defaults'!ignorableClassNameSuffixes	^ #('Element' 'ElementHandler')! !!SAX2PluggableElementHandlerFactory methodsFor: 'initialization'!initialize	super initialize.	elementClassMapper := self elementClassMapperClass new.	elementHandlerClass := SAX2ElementHandler.! !!SAX2PluggableElementHandlerFactory methodsFor: 'copying'!postCopy	super postCopy.	elementClassMapper := elementClassMapper copy.! !!SAX2ElementHandlerFactoryMapper methodsFor: 'accessing'!elementHandlerFactory	"Can be overridden to return a default element handler factory to use	if no other mapping is defined for it."	^ nil! !!SAX2ElementHandlerFactoryMapper methodsFor: 'accessing'!factoryForElementHandler: anElementHandler	^ self		factoryForElementHandler: anElementHandler		ifNone: [nil]! !!SAX2ElementHandlerFactoryMapper methodsFor: 'accessing'!factoryForElementHandler: anElementHandler ifNone: aBlock	^ anElementHandler elementHandlerFactory		ifNil: [			self elementHandlerFactory				ifNil: [aBlock value]]! !!SAX2PluggableElementHandlerFactoryMapper methodsFor: 'defaults'!defaultElementHandlerFactoryClass	^ SAX2ElementHandlerFactory! !!SAX2PluggableElementHandlerFactoryMapper methodsFor: 'accessing'!elementHandlerFactory	^ elementHandlerFactory! !!SAX2PluggableElementHandlerFactoryMapper methodsFor: 'accessing'!elementHandlerFactory: anElementHandlerFactory	"set the default element handler factory"	elementHandlerFactory := anElementHandlerFactory! !!SAX2PluggableElementHandlerFactoryMapper methodsFor: 'private'!elementHandlerFactoryMap	^ elementHandlerFactoryMap! !!SAX2PluggableElementHandlerFactoryMapper methodsFor: 'accessing'!factoryForElementHandler: anElementHandler ifNone: aBlock	"optimization to skip any unneeded hash lookups"	elementHandlerFactoryMap size > 0		ifTrue: [			^ elementHandlerFactoryMap				at: anElementHandler class				ifAbsent: [					super						factoryForElementHandler: anElementHandler						ifNone: aBlock]]		ifFalse: [			^ super				factoryForElementHandler: anElementHandler				ifNone: aBlock]! !!SAX2PluggableElementHandlerFactoryMapper methodsFor: 'initialization'!initialize	super initialize.	elementHandlerFactoryMap := IdentityDictionary new.	elementHandlerFactory := self defaultElementHandlerFactoryClass new.! !!SAX2PluggableElementHandlerFactoryMapper methodsFor: 'mapping'!mapElementHandlerClass: aClass toFactory: aFactory	elementHandlerFactoryMap		at: aClass		put: aFactory! !!SAX2PluggableElementHandlerFactoryMapper methodsFor: 'copying'!postCopy	super postCopy.	elementHandlerFactoryMap := elementHandlerFactoryMap copy.! !!SAX2LexicalHandler class methodsFor: 'instance creation'!parser: aParser	^ self new parser: aParser! !!SAX2LexicalHandler methodsFor: 'handling - lexical'!comment: aString	"Handles '<!!--comment-->' sections in documents."! !!SAX2LexicalHandler methodsFor: 'handling - lexical'!endCData	"Sent after the character data of a '<!![CDATA[...]]>' section."! !!SAX2LexicalHandler methodsFor: 'handling - lexical'!endDTD! !!SAX2LexicalHandler methodsFor: 'handling - lexical'!endEntity: anEntityName	"Handles the end of some general entity's replacement in content.	Not sent if the entity is undeclared or if content entity replacement	is disabled."! !!SAX2LexicalHandler methodsFor: 'accessing'!parser	"Returns the SAX2Parser this handler was injected into"	^ parser! !!SAX2LexicalHandler methodsFor: 'accessing'!parser: aParser	parser := aParser! !!SAX2LexicalHandler methodsFor: 'handling - lexical'!startCData	"Sent before the character data of a '<!![CDATA[...]]>' section."! !!SAX2LexicalHandler methodsFor: 'handling - lexical'!startDTD: aRootElementName publicID: aPublicID systemID: aSystemID	"Handles the start of a '<!!DOCTYPE ...>' declaration. Any events	after this and until endDTD is sent are part of the internal subset	of the DTD.		aRootElementName - the expected name of the document's root element	aPublicID - the public ID of the external DTD subset or an empty string	aSystemID - the URI where the external subset can be found or an empty string"! !!SAX2LexicalHandler methodsFor: 'handling - lexical'!startEntity: anEntityName	"Handles the start of some general entity's replacement in content.	Not sent if the entity is undeclared or if content entity replacement	is disabled."! !!SAX2LexicalHandler methodsFor: 'handling - lexical'!xmlVersion: aVersionFloat encoding: anEncoding standalone: aBoolean	"Handles the '<?xml ...?>' declaration of a document.		aVersionFloat - the version of XML the document uses, usually 1.0	anEncoding - the name of the encoding or an empty string	aBoolean - true if standalone='yes'"! !!SAX2ElementParser methodsFor: 'handling - content'!characters: aString	self elementHandler characters: aString! !!SAX2ElementParser methodsFor: 'defaults'!defaultElementHandlerFactoryClass	^ SAX2ElementHandlerFactory! !!SAX2ElementParser methodsFor: 'defaults'!defaultElementHandlerFactoryMapperClass	^ SAX2ElementHandlerFactoryMapper! !!SAX2ElementParser methodsFor: 'accessing'!elementHandler	^ elementHandler! !!SAX2ElementParser methodsFor: 'accessing'!elementHandler: anElementHandler	elementHandler := anElementHandler! !!SAX2ElementParser methodsFor: 'accessing'!elementHandlerFactory	^ elementHandlerFactory! !!SAX2ElementParser methodsFor: 'accessing'!elementHandlerFactory: anElementHandlerFactory	elementHandlerFactory := anElementHandlerFactory! !!SAX2ElementParser methodsFor: 'accessing'!elementHandlerFactoryMapper	^ elementHandlerFactoryMapper! !!SAX2ElementParser methodsFor: 'accessing'!elementHandlerFactoryMapper: anElementHandlerFactoryMapper	elementHandlerFactoryMapper := anElementHandlerFactoryMapper! !!SAX2ElementParser methodsFor: 'handling - content'!endElement: aQualifiedName prefix: aPrefix uri: aURI localName: aLocalName	| oldElementHandler |	(oldElementHandler := self elementHandler)		endElement: aQualifiedName		prefix: aPrefix		uri: aURI		localName: aLocalName.	self		elementHandler: oldElementHandler parent;		elementHandlerFactory: oldElementHandler parentFactory.! !!SAX2ElementParser methodsFor: 'initialization'!on: aStringOrStream	super on: aStringOrStream.	elementHandlerFactory := self defaultElementHandlerFactoryClass new.	elementHandlerFactoryMapper := self defaultElementHandlerFactoryMapperClass new.! !!SAX2ElementParser methodsFor: 'handling - content'!startElement: aQualifiedName prefix: aPrefix uri: aURI localName: aLocalName attributes: anAttributeDictionary	| newElementHandler |	newElementHandler :=		(self elementHandlerFactory			classForElement: aQualifiedName			namespaceURI: aURI			localName: aLocalName			attributes: anAttributeDictionary)				parser: self				parent: self elementHandler				parentFactory: self elementHandlerFactory.	self		elementHandler: newElementHandler;		elementHandlerFactory:			(self elementHandlerFactoryMapper				factoryForElementHandler: newElementHandler				ifNone: [self elementHandlerFactory]).	newElementHandler		startElement: aQualifiedName		prefix: aPrefix		uri: aURI		localName: aLocalName		attributes: anAttributeDictionary.! !!SAX2Parser class methodsFor: 'private '!generateHandlerForwardingMethods	"	self generateHandlerForwardingMethods	"	(Array		with: 'contentHandler' -> #'handling - content'		with: 'lexicalHandler' -> #'handling - lexical'		with: 'declarationHandler' -> #'handling - declaration')		do: [:handlerAccessorAndCategory | | handlerAccessor handlerCategory |			handlerAccessor := handlerAccessorAndCategory key.			handlerCategory := handlerAccessorAndCategory value.			(SAXHandler selectorsInCategory: handlerCategory) do: [:each | | parsedMethod sourceStream |				parsedMethod := RBParser parseMethod: (SAXHandler sourceCodeAt: each).				(sourceStream := String new writeStream)					nextPutAll: parsedMethod selectorAndArgumentNames;					cr;					nextPutAll: '	self ';					nextPutAll: handlerAccessor.				1 to: parsedMethod keywords size do: [:i |					parsedMethod keywords size > 1						ifTrue: [							sourceStream								cr;								tab;								tab]						ifFalse: [sourceStream space].					sourceStream nextPutAll: (parsedMethod keywords at: i).					parsedMethod argumentNames						ifNotEmpty: [							sourceStream								space;								nextPutAll: (parsedMethod argumentNames at: i)]].				self					compile: sourceStream contents					classified: handlerCategory]]! !!SAX2Parser class methodsFor: 'private '!generateMethodsInHandlerClasses	"	self generateMethodsInHandlerClasses	"	(Array		with: SAX2ContentHandler -> #'handling - content'		with: SAX2LexicalHandler -> #'handling - lexical'		with: SAX2DeclarationHandler -> #'handling - declaration')		do: [:handlerClassAndCategory | | handlerClass handlerCategory |			handlerClass := handlerClassAndCategory key.			handlerCategory := handlerClassAndCategory value.			(SAXHandler selectorsInCategory: handlerCategory) do: [:each |				handlerClass					compile: (SAXHandler sourceCodeAt: each)					classified: handlerCategory]]! !!SAX2Parser methodsFor: 'handling - declaration'!attributeDeclaration: anElementName name: anAttributeName type: aType defaultPragma: aDefaultPragma defaultValue: aDefaultValue	self declarationHandler		attributeDeclaration: anElementName		name: anAttributeName		type: aType		defaultPragma: aDefaultPragma		defaultValue: aDefaultValue! !!SAX2Parser methodsFor: 'handling - content'!characters: aString	self contentHandler characters: aString! !!SAX2Parser methodsFor: 'handling - lexical'!comment: aString	self lexicalHandler comment: aString! !!SAX2Parser methodsFor: 'accessing'!contentHandler	^ contentHandler! !!SAX2Parser methodsFor: 'accessing'!contentHandler: aContentHandler	(contentHandler :=		aContentHandler ifNil: [self defaultContentHandlerClass new])			parser: self! !!SAX2Parser methodsFor: 'accessing'!declarationHandler	^ declarationHandler! !!SAX2Parser methodsFor: 'accessing'!declarationHandler: aDeclarationHandler	(declarationHandler :=		aDeclarationHandler ifNil: [self defaultDeclarationHandlerClass new])			parser: self! !!SAX2Parser methodsFor: 'defaults'!defaultContentHandlerClass	^ SAX2ContentHandler! !!SAX2Parser methodsFor: 'defaults'!defaultDeclarationHandlerClass	^ SAX2DeclarationHandler! !!SAX2Parser methodsFor: 'defaults'!defaultLexicalHandlerClass	^ SAX2LexicalHandler! !!SAX2Parser methodsFor: 'defaults'!defaultParsingResult	"the default parsing result of SAXHandler"	^ self! !!SAX2Parser methodsFor: 'handling - declaration'!elementDeclaration: anElementName contentModel: aContentModel	self declarationHandler		elementDeclaration: anElementName		contentModel: aContentModel! !!SAX2Parser methodsFor: 'handling - lexical'!endCData	self lexicalHandler endCData! !!SAX2Parser methodsFor: 'handling - lexical'!endDTD	self lexicalHandler endDTD! !!SAX2Parser methodsFor: 'handling - content'!endDocument	self contentHandler endDocument! !!SAX2Parser methodsFor: 'handling - content'!endElement: aQualifiedName prefix: aPrefix uri: aURI localName: aLocalName	self contentHandler		endElement: aQualifiedName		prefix: aPrefix		uri: aURI		localName: aLocalName! !!SAX2Parser methodsFor: 'handling - lexical'!endEntity: anEntityName	self lexicalHandler endEntity: anEntityName! !!SAX2Parser methodsFor: 'handling - content'!endPrefixMapping: aPrefix	self contentHandler endPrefixMapping: aPrefix! !!SAX2Parser methodsFor: 'handling - declaration'!generalEntityDeclaration: aName publicID: aPublicID systemID: aSystemID ndata: aNotationName	self declarationHandler		generalEntityDeclaration: aName		publicID: aPublicID		systemID: aSystemID		ndata: aNotationName! !!SAX2Parser methodsFor: 'handling - declaration'!generalEntityDeclaration: aName replacement: aReplacement	self declarationHandler		generalEntityDeclaration: aName		replacement: aReplacement! !!SAX2Parser methodsFor: 'handling - content'!ignorableWhitespace: aString	self contentHandler ignorableWhitespace: aString! !!SAX2Parser methodsFor: 'accessing'!lexicalHandler	^ lexicalHandler! !!SAX2Parser methodsFor: 'accessing'!lexicalHandler: aLexicalHandler	(lexicalHandler :=		aLexicalHandler ifNil: [self defaultLexicalHandlerClass new])			parser: self! !!SAX2Parser methodsFor: 'handling - declaration'!notationDeclaration: aName publicID: aPublicID systemID: aSystemID	self declarationHandler		notationDeclaration: aName		publicID: aPublicID		systemID: aSystemID! !!SAX2Parser methodsFor: 'initialization'!on: aStringOrStream	super on: aStringOrStream.	contentHandler := self defaultContentHandlerClass parser: self.	lexicalHandler := self defaultLexicalHandlerClass parser: self.	declarationHandler := self defaultDeclarationHandlerClass parser: self.	parsingResult := self defaultParsingResult.! !!SAX2Parser methodsFor: 'handling - declaration'!parameterEntityDeclaration: aName publicID: aPublicID systemID: aSystemID	self declarationHandler		parameterEntityDeclaration: aName		publicID: aPublicID		systemID: aSystemID! !!SAX2Parser methodsFor: 'handling - declaration'!parameterEntityDeclaration: aName replacement: aReplacement	self declarationHandler		parameterEntityDeclaration: aName		replacement: aReplacement! !!SAX2Parser methodsFor: 'parsing'!parsingResult	^ parsingResult! !!SAX2Parser methodsFor: 'parsing'!parsingResult: anObject	parsingResult := anObject! !!SAX2Parser methodsFor: 'handling - content'!processingInstruction: aTargetString data: aDataString	self contentHandler		processingInstruction: aTargetString		data: aDataString! !!SAX2Parser methodsFor: 'handling - content'!skippedEntity: anEntityName	self contentHandler skippedEntity: anEntityName! !!SAX2Parser methodsFor: 'handling - lexical'!startCData	self lexicalHandler startCData! !!SAX2Parser methodsFor: 'handling - lexical'!startDTD: aRootElementName publicID: aPublicID systemID: aSystemID	self lexicalHandler		startDTD: aRootElementName		publicID: aPublicID		systemID: aSystemID! !!SAX2Parser methodsFor: 'handling - content'!startDocument	self contentHandler startDocument! !!SAX2Parser methodsFor: 'handling - content'!startElement: aQualifiedName prefix: aPrefix uri: aURI localName: aLocalName attributes: aDictionary	self contentHandler		startElement: aQualifiedName		prefix: aPrefix		uri: aURI		localName: aLocalName		attributes: aDictionary! !!SAX2Parser methodsFor: 'handling - lexical'!startEntity: anEntityName	self lexicalHandler startEntity: anEntityName! !!SAX2Parser methodsFor: 'handling - content'!startPrefixMapping: aPrefix uri: aURI	self contentHandler		startPrefixMapping: aPrefix		uri: aURI! !!SAX2Parser methodsFor: 'handling - lexical'!xmlVersion: aVersionFloat encoding: anEncoding standalone: aBoolean	self lexicalHandler		xmlVersion: aVersionFloat		encoding: anEncoding		standalone: aBoolean! !!SAXHandler class methodsFor: 'instance creation'!new	Error signal:		'Parsers should be created with #on: or ',		'some other "instance creation" message'! !!SAXHandler class methodsFor: 'instance creation'!on: aStringOrStream	"Returns a new parser on the string or stream argument but doesn't parse it.	Can be used to configure a parser with 'configuring' messages before	parsing with #parseDocument."	^ self basicNew initialize on: aStringOrStream! !!SAXHandler class methodsFor: 'instance creation'!on: aStringOrStream documentURI: aURIString	"Returns a new parser on the string or stream argument treating the	specified URI as the base URI of the document but doesn't parse it.	Can be used to configure a parser with 'configuring' messages before	parsing with #parseDocument."	^ (self on: aStringOrStream) documentURI: aURIString! !!SAXHandler class methodsFor: 'instance creation'!onFileNamed: aFileName	"Returns a new parser on the specified file but doesn't parse it.	If aFileName is a relative path, it will be resolved in the context of	the current working directory.	Can be used to configure file parsers with 'configuring' messages before	parsing with #parseDocument."	^ self		on:			"return an XMLDecodingReadStreamAdapter on the undecoded file			stream so we can do our own decoding looking at byte order			marks and <?xml ...?> encoding attributes"			(XMLDecodingReadStreamAdapter nonDecodingOn:				aFileName asXMLFileHandle rawReadStream)		documentURI: aFileName! !!SAXHandler class methodsFor: 'instance creation'!onURL: aURLString	"Fetches the URL and returns new parser on the response content but doesn't	parse it. If the URL has no scheme, it will be treated as a file path.	Can be used to configure URL parsers with 'configuring' messages before	parsing with #parseDocument."	^ self		onURL: aURLString		upToLimit: XMLParserLimits defaultDocumentReadLimit! !!SAXHandler class methodsFor: 'instance creation'!onURL: aURLString upToLimit: aMaxSize	"Fetches a URL and returns new parser on the response content up to the	input limit (use nil to disable) but doesn't parse it. If the URL has	no scheme, it will be treated as a file path.	Can be used to configure limited URL parsers with 'configuring' messages	before parsing with #parseDocument."	^ (self		on:			(DTDExternalEntityResolver new				streamResolveExternalEntityURI: aURLString				upToLimit: aMaxSize)		documentURI: aURLString)			documentReadLimit: aMaxSize! !!SAXHandler class methodsFor: 'parsing'!parse: aStringOrStream	"Parses the document in the string or stream argument"	^ (self on: aStringOrStream) parseDocument! !!SAXHandler class methodsFor: 'parsing'!parse: aStringOrStream documentURI: aURIString	"Parses the document in the string or stream argument treating the specified	URI as the base URI of the document."	^ (self		on: aStringOrStream		documentURI: aURIString) parseDocument! !!SAXHandler class methodsFor: 'parsing'!parse: aStringOrStream usingNamespaces: aBoolean	"Parses the document in the string or stream argument possibly with namespace	checking enabled (default)"	^ (self on: aStringOrStream)		usesNamespaces: aBoolean;		parseDocument! !!SAXHandler class methodsFor: 'parsing'!parse: aStringOrStream usingNamespaces: aNamespaceBoolean validation: aValidationBoolean	"Parses the document in the string or stream argument possibly with namespace	checking (default) and validation (default) enabled."	^ (self on: aStringOrStream)		usesNamespaces: aNamespaceBoolean;		isValidating: aValidationBoolean;		parseDocument! !!SAXHandler class methodsFor: 'parsing'!parse: aStringOrStream usingNamespaces: aNamespaceBoolean validation: aValidationBoolean externalEntities: anEntityResolutionBoolean	"Parses the document in the string or stream argument possibly with namespace	checking (default), validation (default), or external entity resolution (not	default) enabled."	^ (self on: aStringOrStream)		usesNamespaces: aNamespaceBoolean;		isValidating: aValidationBoolean;		resolvesExternalEntities: anEntityResolutionBoolean;		parseDocument! !!SAXHandler class methodsFor: 'deprecated'!parseDocumentFrom: aStringOrStream	self deprecated: 'Use #parse: instead'.	^ self parse: aStringOrStream.! !!SAXHandler class methodsFor: 'deprecated'!parseDocumentFromFileNamed: aFileName	self deprecated: 'Use #parseFileNamed: instead'.	^ self parseFileNamed: aFileName.! !!SAXHandler class methodsFor: 'parsing'!parseFileNamed: aFileNameString	"Parses the specified file. If aFileName is a relative path, it will be	resolved in the context of the current working directory."	^ (self onFileNamed: aFileNameString) parseDocument! !!SAXHandler class methodsFor: 'parsing'!parseURL: aURLString	"Fetches the URL and parses the response content. If the URL has no scheme,	it will be treated as a file path."	^ (self onURL: aURLString) parseDocument! !!SAXHandler class methodsFor: 'parsing'!parseURL: aURLString upToLimit: aMaxSize	"Fetches the URL upto the input limit (nil to disable) and parses the	response content. If the URL has no scheme, it will be treated as a file	path."	^ (self		onURL: aURLString		upToLimit: aMaxSize) parseDocument! !!SAXHandler methodsFor: 'handling - declaration'!attributeDeclaration: anElementName name: anAttributeName type: aType defaultPragma: aDefaultPragma defaultValue: aDefaultValue! !!SAXHandler methodsFor: 'handling - content'!characters: aString	"Handles character data in an element, such as the 'test' in	'<characters>test</characters>' or in the CDATA section '<!![CDATA[test]]>'.		It may be sent multiple times for different sections of character data	in a single element if they're separated by other nodes or entity	references like in '<characters>one<!!--comment-->two</characters>'.		See #isInCDataSection and #ignorableWhitespace:"! !!SAXHandler methodsFor: 'handling - lexical'!comment: aString	"Handles '<!!--comment-->' sections in documents."! !!SAXHandler methodsFor: 'accessing'!configuration	^ configuration! !!SAXHandler methodsFor: 'accessing'!configuration: aConfiguration	(configuration := aConfiguration) parserHandlerClass: self class! !!SAXHandler methodsFor: 'defaults'!configurationClass	^ XMLConfiguration! !!SAXHandler methodsFor: 'configuring'!decodesCharacters	^ self configuration decodesCharacters! !!SAXHandler methodsFor: 'configuring'!decodesCharacters: aBoolean	"When enabled, encoding detection and character decoding will be attemped if:		1) the input stream or string is binary/external		2) it starts with a byte-order mark (BOM) byte sequence		3) the input is wrapped with an XMLDecodingReadStreamAdapter that has			a null or implicit stream converter	(Default.)"	self configuration decodesCharacters: aBoolean! !!SAXHandler methodsFor: 'defaults'!defaultDocumentURI	^ ''! !!SAXHandler methodsFor: 'private'!doctypeDefinition: aDoctypeDefinition! !!SAXHandler methodsFor: 'configuring'!documentReadLimit	^ self configuration documentReadLimit! !!SAXHandler methodsFor: 'configuring'!documentReadLimit: anInteger	"change the document read limit (maximum number of chars that can be read)	or nil to disable"	self configuration documentReadLimit: anInteger! !!SAXHandler methodsFor: 'accessing'!documentURI	"Returns current document base URI string"	^ documentURI ifNil: [documentURI := self defaultDocumentURI]! !!SAXHandler methodsFor: 'accessing'!documentURI: aURIString	documentURI := aURIString! !!SAXHandler methodsFor: 'defaults'!driverClass	^ SAXParserDriver! !!SAXHandler methodsFor: 'handling - declaration'!elementDeclaration: anElementName contentModel: aContentModel! !!SAXHandler methodsFor: 'handling - lexical'!endCData	"Sent after the character data of a '<!![CDATA[...]]>' section."! !!SAXHandler methodsFor: 'handling - lexical'!endDTD! !!SAXHandler methodsFor: 'handling - content'!endDocument	"Handles the end of an XML document. No more handlers are invoked after this."! !!SAXHandler methodsFor: 'handling - content'!endElement: aQualifiedName	"Handles the end of an element if a subclass doesn't implement	#endElement:prefix:uri:localName: or #endElement:prefix:uri:."! !!SAXHandler methodsFor: 'handling - content'!endElement: aQualifiedName prefix: aPrefix uri: aURI	"Handles the end of an element if a subclass doesn't implement	#endElement:prefix:uri:localName:. By default it forwards to a simpler	handler, #endElement:.		aQualifiedName - the full name, including any prefix, such as 'prefix:name'	aPrefix - the prefix of the qualified name or an empty string	aURI - the namespace URI of the element or an empty string"	self endElement: aQualifiedName! !!SAXHandler methodsFor: 'handling - content'!endElement: aQualifiedName prefix: aPrefix uri: aURI localName: aLocalName	"Handles the end of an element, either an end tag like '</end>' or a	self-closed tag like '<empty/>'. By default it forwards to a simpler handler,	#endElement:prefix:uri:.		aQualifiedName - the full name, including any prefix, such as 'prefix:name'	aPrefix - the prefix of the qualified name or an empty string	aURI - the namespace URI of the element or an empty string	aLocalName - the local part of the qualified name"	self		endElement: aQualifiedName		prefix: aPrefix		uri:  aURI! !!SAXHandler methodsFor: 'handling - lexical'!endEntity: anEntityName	"Handles the end of some general entity's replacement in content.	Not sent if the entity is undeclared or if content entity replacement	is disabled."! !!SAXHandler methodsFor: 'handling - content'!endPrefixMapping: aPrefix	"Handles the end of a namespace prefix/URI mapping when namespaces are	enabled. After, aPrefix (empty for the default namespace) will be either	unmapped or mapped to a different URI. The 'xml' prefix is predefined	and never unmapped."! !!SAXHandler methodsFor: 'private'!errorInstancesCannotHaveMultipleParsers	XMLParserException		formatSignal: 'Instances of {1} cannot have multiple parsers'		with: self class name! !!SAXHandler methodsFor: 'configuring'!externalEntityResolver	^ self configuration externalEntityResolver! !!SAXHandler methodsFor: 'configuring'!externalEntityResolver: anExternalEntityResolver	"This can be used to set a different DTDExternalEntityResolver"	self configuration externalEntityResolver: anExternalEntityResolver! !!SAXHandler methodsFor: 'handling - declaration'!generalEntityDeclaration: aName publicID: aPublicID systemID: aSystemID ndata: aNotationName! !!SAXHandler methodsFor: 'handling - declaration'!generalEntityDeclaration: aName replacement: aReplacement! !!SAXHandler methodsFor: 'testing'!hasParser	^ hasParser! !!SAXHandler methodsFor: 'handling - content'!ignorableWhitespace: aString	"When validation is enabled and a DTD with ELEMENT declarations is	present, this can be used to handle ignorable whitespace in elements	with 'element content' (meaning they can only contain other elements	and no PCDATA), such as between '<element-content>' and '<mixed-content>'	or between '</mixed-content>' and '</element-content>' in this sample:		'<!!DOCTYPE element-content [			<!!--this has element content, so its whitespace is ignorable-->			<!!ELEMENT element-content (mixed-content)>			<!!--this has mixed content, so its whitespace is not ignorable-->			<!!ELEMENT mixed-content (#PCDATA|any-content)*>			<!!--this has any content, so its whitespace is not ignorable-->			<!!ELEMENT any-content ANY>		]>		<element-content>			<mixed-content>				<any-content> any </any-content>			</mixed-content>		</element-content>'	Not sent if validation is disabled or if there's no DTD with element	declarations."! !!SAXHandler methodsFor: 'initialization'!initializeParser: aParser! !!SAXHandler methodsFor: 'accessing'!input	"the input being parsed or to be parsed"	^ input! !!SAXHandler methodsFor: 'private'!input: aStringOrStream	"here for backwards compatibility; use #on: instead"	input := aStringOrStream! !!SAXHandler methodsFor: 'parsing'!interruptParsing	"Can be sent within a handler to stop parsing;	will be silently caught within #parseDocument or other parsing methods"	XMLParsingInterruptException signal! !!SAXHandler methodsFor: 'testing'!isInCDataSection	"Can be used by characters: handlers to distinguish ordinary character	data from characters within '<!![CDATA[...]]>' sections"	^ isInCDataSection! !!SAXHandler methodsFor: 'private'!isInCDataSection: aBoolean	isInCDataSection := aBoolean! !!SAXHandler methodsFor: 'testing'!isInContent	"True if parsing has reached the first element of the document."	^ isInContent! !!SAXHandler methodsFor: 'configuring'!isValidating	^ self configuration isValidating! !!SAXHandler methodsFor: 'configuring'!isValidating: aBoolean	"If true and the document has a schema (like a DTD with ELEMENT and ATTLIST	declarations) the document will be validated against it. Otherwise only	entity references and xml:id attributes will be validated.		(This is unlike the standard which requires validating parsers to reject	all documents without DTDs or other schemas. To get that behavior,	use requiresDocumentConstraints:)	Enabling disables preservesUndeclaredEntityReferences.	Disabling disables requiresDocumentConstraints."	self configuration isValidating: aBoolean! !!SAXHandler methodsFor: 'configuring'!maxEntityReplacementDepth	^ self configuration maxEntityReplacementDepth! !!SAXHandler methodsFor: 'configuring'!maxEntityReplacementDepth: anInteger	"change the max replacement depth or nil to disable"	self configuration maxEntityReplacementDepth: anInteger! !!SAXHandler methodsFor: 'handling - declaration'!notationDeclaration: aName publicID: aPublicID systemID: aSystemID! !!SAXHandler methodsFor: 'initialization'!on: aStringOrStream	input := aStringOrStream.	"a single instance can parse multiple documents with #on:,	so each variable must be reset"	documentURI := nil.	configuration		ifNil: [self configuration: self configurationClass new]		ifNotNil: [self configuration: configuration copy].	hasParser := false.	isInContent := false.	isInCDataSection := false.! !!SAXHandler methodsFor: 'configuring'!optimizeForLargeDocuments	"use this for faster parsing/less memory use with large documents"	self		isValidating: false;		usesNamespaces: false;		documentReadLimit: nil! !!SAXHandler methodsFor: 'handling - declaration'!parameterEntityDeclaration: aName publicID: aPublicID systemID: aSystemID! !!SAXHandler methodsFor: 'handling - declaration'!parameterEntityDeclaration: aName replacement: aReplacement! !!SAXHandler methodsFor: 'parsing'!parseDocument	"Parse the entire input string or stream and return the result"	self parser parseDocument.	^ self parsingResult.! !!SAXHandler methodsFor: 'parsing'!parseDocumentUntil: aBlock	"Parse the input string or stream only until aBlock evalautes as true	and return the result"	self parser parseDocumentUntil: aBlock.	^ self parsingResult.! !!SAXHandler methodsFor: 'parsing'!parseDocumentWhile: aBlock	"Parse the input string or stream only as long as aBlock evalautes as true	and return the result"	self parser parseDocumentWhile: aBlock.	^ self parsingResult.! !!SAXHandler methodsFor: 'parsing'!parser	"returns a new XMLParser object for this handler"	| parser |	hasParser		ifTrue: [self errorInstancesCannotHaveMultipleParsers].	hasParser := true.	parser :=		self parserClass			driver: (self driverClass saxHandler: self)			on: self input.	self initializeParser: parser.	^ parser.! !!SAXHandler methodsFor: 'defaults'!parserClass	^ XMLParser! !!SAXHandler methodsFor: 'parsing'!parsingResult	"value returned by parseDocument and other parsing methods"	^ self! !!SAXHandler methodsFor: 'configuring'!preservesUndeclaredEntityReferences	^ self configuration preservesUndeclaredEntityReferences! !!SAXHandler methodsFor: 'configuring'!preservesUndeclaredEntityReferences: aBoolean	"If true, references to undeclared entities in content are	preserved (not default).	Disables validation.		(See also replacesContentEntityReferences:, which is usually more appropriate.)"	self configuration preservesUndeclaredEntityReferences: aBoolean! !!SAXHandler methodsFor: 'handling - content'!processingInstruction: aTargetString data: aDataString	"Handles processing instructions like '<?name value?>', where 'name' is	the target and 'value' is the data.		XML declarations may look like PIs but are different and are handled	with #xmlVersion:encoding:standalone: instead."! !!SAXHandler methodsFor: 'configuring'!removeLimits	"remove all input security limits (unsafe)"	self configuration removeLimits! !!SAXHandler methodsFor: 'configuring'!replacesContentEntityReferences	^ self configuration replacesContentEntityReferences! !!SAXHandler methodsFor: 'configuring'!replacesContentEntityReferences: aBoolean	"Replace general parsed entity and character references	in content (default)"	self configuration replacesContentEntityReferences: aBoolean! !!SAXHandler methodsFor: 'deprecated'!requiresDocumentConstraints	"will be deprecated; use #requiresSchema instead"	^ self requiresSchema! !!SAXHandler methodsFor: 'deprecated'!requiresDocumentConstraints: aBoolean	"will be deprecated; use #requiresSchema: instead"	self requiresSchema: aBoolean! !!SAXHandler methodsFor: 'configuring'!requiresSchema	^ self configuration requiresSchema! !!SAXHandler methodsFor: 'configuring'!requiresSchema: aBoolean	"If true, a schema containing constraints on elements and attributes	(like a DTD with ELEMENT and ATTLIST declarations) will be required.	Enables validation.	(Not default)."	self configuration requiresSchema: aBoolean! !!SAXHandler methodsFor: 'configuring'!resolvesExternalEntities	^ self configuration resolvesExternalEntities! !!SAXHandler methodsFor: 'configuring'!resolvesExternalEntities: aBoolean	"When true, external DTDs and parsed entities will be	fetched (not default)."	self configuration resolvesExternalEntities: aBoolean! !!SAXHandler methodsFor: 'private'!schema	^ nil! !!SAXHandler methodsFor: 'handling - content'!skippedEntity: anEntityName	"Sent when a general parsed entity reference like '&name;' is	unreplaced in content. Only sent when validation is turned off	or entity replacement is disabled."! !!SAXHandler methodsFor: 'handling - lexical'!startCData	"Sent before the character data of a '<!![CDATA[...]]>' section."! !!SAXHandler methodsFor: 'private'!startContent	isInContent := true! !!SAXHandler methodsFor: 'handling - lexical'!startDTD: aRootElementName publicID: aPublicID systemID: aSystemID	"Handles the start of a '<!!DOCTYPE ...>' declaration. Any events	after this and until #endDTD is sent are part of the internal subset	of the DTD.		aRootElementName - the expected name of the document's root element	aPublicID - the public ID of the external DTD subset or an empty string	aSystemID - the URI where the external subset can be found or an empty string"! !!SAXHandler methodsFor: 'handling - content'!startDocument	"Handles the start of an XML document, the first handler invoked."! !!SAXHandler methodsFor: 'handling - content'!startElement: aQualifiedName attributes: anAttributeDictionary	"Handles the start of an element if a subclass doesn't implement	#startElement:prefix:uri:localName:attributes: or	#startElement:prefix:uri:attributes:.	aQualifiedName - the full name, including any prefix, such as 'prefix:name'	anAttributeDictionary - an XMLAttributeDictionary of attributes"! !!SAXHandler methodsFor: 'handling - content'!startElement: aQualifiedName prefix: aPrefix uri: aURI attributes: anAttributeDictionary	"Handles the start of an element if a subclass doesn't implement	#startElement:prefix:uri:localName:attributes:. By default it forwards	to a simpler handler, #startElement:attributes:.		aQualifiedName - the full name, including any prefix, such as 'prefix:name'	aPrefix - the prefix of the qualified name or an empty string	aURI - the namespace URI of the element or an empty string	anAttributeDictionary - an XMLAttributeDictionary of attributes"	self		startElement: aQualifiedName		attributes: anAttributeDictionary! !!SAXHandler methodsFor: 'handling - content'!startElement: aQualifiedName prefix: aPrefix uri: aURI localName: aLocalName attributes: anAttributeDictionary	"Handles the start of an element, either a start tag like '<start>' or a	self-closed tag like '<empty/>'. By default it forwards to a simpler handler,	#startElement:prefix:uri:attributes:.		aQualifiedName - the full name, including any prefix, such as 'prefix:name'	aPrefix - the prefix of the qualified name or an empty string	aURI - the namespace URI of the element or an empty string	aLocalName - the local part of the qualified name	anAttributeDictionary - an XMLAttributeDictionary of attributes"	self		startElement: aQualifiedName		prefix: aPrefix		uri: aURI		attributes: anAttributeDictionary! !!SAXHandler methodsFor: 'handling - lexical'!startEntity: anEntityName	"Handles the start of some general entity's replacement in content.	Not sent if the entity is undeclared or if content entity replacement	is disabled."! !!SAXHandler methodsFor: 'handling - content'!startPrefixMapping: aPrefix uri: aURI	"Handles the start of a namespace prefix/URI mapping when namespaces are	enabled. The 'xml' prefix is predefined and never remapped.	aPrefix - the prefix of the namespace (empty for the default namesapce)	aURI - the namespace URI"! !!SAXHandler methodsFor: 'private'!startScope: aNamespaceScope! !!SAXHandler methodsFor: 'configuring'!usesNamespaces	^ self configuration usesNamespaces! !!SAXHandler methodsFor: 'configuring'!usesNamespaces: aBoolean	"Namespace checking when true (default)"	self configuration usesNamespaces: aBoolean! !!SAXHandler methodsFor: 'handling - lexical'!xmlVersion: aVersionFloat encoding: anEncoding standalone: aBoolean	"Handles the '<?xml ...?>' declaration of a document.		aVersionFloat - the version of XML the document uses, usually 1.0	anEncoding - the name of the encoding or an empty string	aBoolean - true if standalone='yes'"! !!XMLDOMParser methodsFor: 'handling - declaration'!attributeDeclaration: anElementName name: anAttributeName type: aType defaultPragma: aDefaultPragma defaultValue: aDefaultValue	self topNodeAdd:		(self nodeFactory attributeDeclarationClass			element: anElementName			attribute: anAttributeName			type: aType			defaultPragma: aDefaultPragma			defaultValue: aDefaultValue)! !!XMLDOMParser methodsFor: 'handling - content'!characters: aString	(self isInCDataSection		and: [self preservesCDataNodes])		ifTrue: [self topNodeAdd: (self nodeFactory newCData: aString)]		ifFalse: [self topNodeAddString: aString]! !!XMLDOMParser methodsFor: 'handling - lexical'!comment: aString	self preservesCommentNodes		ifTrue: [self topNodeAdd: (self nodeFactory newComment: aString)]! !!XMLDOMParser methodsFor: 'defaults'!configurationClass	^ XMLDOMConfiguration! !!XMLDOMParser methodsFor: 'private'!doctypeDefinition: aDoctypeDefinition	self document doctypeDefinition: aDoctypeDefinition! !!XMLDOMParser methodsFor: 'accessing'!document	^ document! !!XMLDOMParser methodsFor: 'accessing'!document: aDocument	document := aDocument! !!XMLDOMParser methodsFor: 'handling - declaration'!elementDeclaration: anElementName contentModel: aContentModel	self topNodeAdd:		(self nodeFactory elementDeclarationClass			element: anElementName			contentModel: aContentModel)! !!XMLDOMParser methodsFor: 'handling - lexical'!endDTD	self popNode! !!XMLDOMParser methodsFor: 'handling - content'!endDocument	"nodeStack is not popped here for efficiency because #document keeps	a reference to the root too, and there may not be a root to pop	anyway if it's an inner XML parser"! !!XMLDOMParser methodsFor: 'handling - content'!endElement: aQualifiedName prefix: aPrefix uri: aURI localName: aLocalName	self popNode! !!XMLDOMParser methodsFor: 'handling - declaration'!generalEntityDeclaration: aName publicID: aPublicID systemID: aSystemID ndata: aNotationName	self topNodeAdd:		(self nodeFactory generalEntityDeclarationClass			name: aName			publicID: aPublicID			systemID: aSystemID			ndata: aNotationName)! !!XMLDOMParser methodsFor: 'handling - declaration'!generalEntityDeclaration: aName replacement: aReplacement	self topNodeAdd:		(self nodeFactory generalEntityDeclarationClass			name: aName			replacement: aReplacement)! !!XMLDOMParser methodsFor: 'handling - content'!ignorableWhitespace: aString	self preservesIgnorableWhitespace		ifTrue: [self characters: aString]! !!XMLDOMParser methodsFor: 'initialization'!initializeInnerXMLParser: aParser	self document		ifNotNil: [			aParser driver isStandalone: self document isStandalone.			self document hasDoctypeDefinition				ifTrue: [					aParser driver doctypeDefinition addGeneralEntitiesFrom:						self document doctypeDefinition]].	self nodeStack do: [:each |		each isElement			ifTrue: [				self					startInnerXMLElement: each					forParser: aParser]].	aParser state: self topNode newInnerXMLState.	aParser state isContentState		ifTrue: [self startContent].! !!XMLDOMParser methodsFor: 'initialization'!initializeParser: aParser	super initializeParser: aParser.	self nodeStack size > 0		ifTrue: [self initializeInnerXMLParser: aParser].! !!XMLDOMParser methodsFor: 'private'!innerXMLRootNode: aRootNode	self		configuration: aRootNode configuration;		document: aRootNode document;		pushNode: aRootNode! !!XMLDOMParser methodsFor: 'configuring'!nodeFactory	^ self configuration nodeFactory! !!XMLDOMParser methodsFor: 'configuring'!nodeFactory: aNodeFactory	self configuration nodeFactory: aNodeFactory! !!XMLDOMParser methodsFor: 'deprecated'!nodeListClass	"will be deprecated"	^ self configuration nodeListClass! !!XMLDOMParser methodsFor: 'deprecated'!nodeListClass: aClass	"will be deprecated"	self configuration nodeListClass: aClass! !!XMLDOMParser methodsFor: 'private'!nodeStack	^ nodeStack! !!XMLDOMParser methodsFor: 'handling - declaration'!notationDeclaration: aName publicID: aPublicID systemID: aSystemID	self topNodeAdd:		(self nodeFactory notationDeclarationClass			name: aName			publicID: aPublicID			systemID: aSystemID)! !!XMLDOMParser methodsFor: 'initialization'!on: aStringOrStream	super on: aStringOrStream.	document := nil.	nodeStack := OrderedCollection new: 10.	currentScope := nil.! !!XMLDOMParser methodsFor: 'configuring'!optimizeForLargeDocuments	super optimizeForLargeDocuments.	"use the non-caching attribute list class to save memory"	self configuration attributeListClass: XMLAttributeList.! !!XMLDOMParser methodsFor: 'handling - declaration'!parameterEntityDeclaration: aName publicID: aPublicID systemID: aSystemID	self topNodeAdd:		(self nodeFactory parameterEntityDeclarationClass			name: aName			publicID: aPublicID			systemID: aSystemID)! !!XMLDOMParser methodsFor: 'handling - declaration'!parameterEntityDeclaration: aName replacement: aReplacement	self topNodeAdd:		(self nodeFactory parameterEntityDeclarationClass			name: aName			replacement: aReplacement)! !!XMLDOMParser methodsFor: 'parsing'!parsingResult	^ self document! !!XMLDOMParser methodsFor: 'private'!popNode	^ self nodeStack removeLast! !!XMLDOMParser methodsFor: 'configuring'!preservesCDataNodes	^ self configuration preservesCDataNodes! !!XMLDOMParser methodsFor: 'configuring'!preservesCDataNodes: aBoolean	"if enabled, <!![CDATA[...]]> sections will be preserved as CDATA nodes	and not ordinary string nodes and won't be merged with adjacent string	nodes (not default)"	self configuration preservesCDataNodes: aBoolean! !!XMLDOMParser methodsFor: 'configuring'!preservesCommentNodes	^ self configuration preservesCommentNodes! !!XMLDOMParser methodsFor: 'configuring'!preservesCommentNodes: aBoolean	"if enabled, comments will be preserved as comment nodes (not default)"	self configuration preservesCommentNodes: aBoolean! !!XMLDOMParser methodsFor: 'configuring'!preservesIgnorableWhitespace	^ self configuration preservesIgnorableWhitespace! !!XMLDOMParser methodsFor: 'configuring'!preservesIgnorableWhitespace: aBoolean	"If enabled, ignorable whitespace (identified by DTD element declarations	with element content) will be preserved as string nodes. Enables validation.	(Not default)"	self configuration preservesIgnorableWhitespace: aBoolean! !!XMLDOMParser methodsFor: 'handling - content'!processingInstruction: aTargetString data: aDataString	self topNodeAdd:		(self nodeFactory newPI			target: aTargetString;			data: aDataString)! !!XMLDOMParser methodsFor: 'private'!pushElement: anElement	self topNodeAdd: anElement.	^ self pushNode: anElement.! !!XMLDOMParser methodsFor: 'private'!pushNode: aNode	^ self nodeStack addLast: aNode! !!XMLDOMParser methodsFor: 'handling - lexical'!startDTD: aRootElementName publicID: aPublicID systemID: aSystemID	| doctypeDeclaration |	doctypeDeclaration := 		self nodeFactory doctypeDeclarationClass			root: aRootElementName			publicID: aPublicID			systemID: aSystemID.	self pushNode: doctypeDeclaration.	self document doctypeDeclaration: doctypeDeclaration.! !!XMLDOMParser methodsFor: 'handling - content'!startDocument	"inner XML parsers should ignore this event"	self nodeStack size > 0		ifFalse: [			self				document: self nodeFactory newDocument;				pushNode: self document.			self document configuration: self configuration]! !!XMLDOMParser methodsFor: 'handling - content'!startElement: aQualifiedName prefix: aPrefix uri: aURI localName: aLocalName attributes: anAttributeDictionary	self pushElement:		((self nodeFactory			classForElement: aQualifiedName			namespaceURI: aURI			localName: aLocalName			attributes: anAttributeDictionary) new				setConfiguration: self configuration				name: aQualifiedName				localName: aLocalName				attributes: anAttributeDictionary				namespaceScope: currentScope)! !!XMLDOMParser methodsFor: 'private'!startInnerXMLElement: anElement forParser: aParser	aParser driver currentElement: anElement name.	anElement hasNamespaces		ifTrue: [aParser driver currentScope: anElement namespaceScope].! !!XMLDOMParser methodsFor: 'private'!startScope: aNamespaceScope	currentScope := aNamespaceScope! !!XMLDOMParser methodsFor: 'accessing'!topNode	^ self nodeStack xmlLastOrNil! !!XMLDOMParser methodsFor: 'private'!topNodeAdd: aNode	^ self nodeStack last addNode: aNode! !!XMLDOMParser methodsFor: 'private'!topNodeAddString: aString	^ self nodeStack last addString: aString! !!XMLDOMParser methodsFor: 'handling - lexical'!xmlVersion: aVersionFloat encoding: anEncoding standalone: aBoolean	self document ifNotNil: [		self document			version: aVersionFloat;			encoding: anEncoding;			isStandalone: aBoolean]! !!XMLAbstractFactory class methodsFor: 'testing'!canBeImplemented	^ false! !!XMLAbstractFactory class methodsFor: 'clearing'!clearAllImplementations	"self clearAllImplementations"	self		implementation: nil;		allSubclassesDo: [:each | each implementation: nil]! !!XMLAbstractFactory class methodsFor: 'finding'!findSupportedImplementation	self canBeImplemented		ifTrue: [			self isSupportedImplementation				ifTrue: [^ self].			(self preferredImplementation notNil				and: [self preferredImplementation isSupportedImplementation])				ifTrue: [^ self preferredImplementation].			self allSubclassesDo: [:each |				each isSupportedImplementation					ifTrue: [^ each]]].	^ nil.! !!XMLAbstractFactory class methodsFor: 'testing'!hasSupportedImplementation	^ self findSupportedImplementation notNil! !!XMLAbstractFactory class methodsFor: 'accessing'!implementation	^ implementation		ifNil: [			"avoid assigning to the class inst var unless an implementation			was found to minimize write conflicts on GS"			self findSupportedImplementation				ifNil: [self noSupportedImplementationFound]				ifNotNil: [:supportedImplementation |					implementation := supportedImplementation].			implementation]! !!XMLAbstractFactory class methodsFor: 'accessing'!implementation: aClassOrNil	implementation := aClassOrNil! !!XMLAbstractFactory class methodsFor: 'instance creation'!implementationNew	^ self implementation basicNew initialize! !!XMLAbstractFactory class methodsFor: 'class initialization'!initialize	"self initialize"	self clearAllImplementations! !!XMLAbstractFactory class methodsFor: 'testing'!isSupportedImplementation	^ false! !!XMLAbstractFactory class methodsFor: 'instance creation'!new	^ self implementationNew! !!XMLAbstractFactory class methodsFor: 'finding'!noSupportedImplementationFound	Error signal: 'No implementation available'! !!XMLAbstractFactory class methodsFor: 'defaults'!preferredImplementation	^ nil! !!XMLFileDirectoryFileHandle class methodsFor: 'basic'!basicCurrentWorkingDirectory	^ (XMLClassFinder classNamed: #FileDirectory) default pathName! !!XMLFileDirectoryFileHandle class methodsFor: 'testing'!isSupportedImplementation	^ XMLClassFinder hasClassNamed: #FileDirectory! !!XMLFileDirectoryFileHandle methodsFor: 'basic'!basicDelete	"FileDirectory's deleteFileNamed: is used because DirectoryEntry	doesn't understand #delete on GS"	self fileDirectory deleteFileNamed: self path! !!XMLFileDirectoryFileHandle methodsFor: 'basic'!basicFileSize	^ self directoryEntry fileSize! !!XMLFileDirectoryFileHandle methodsFor: 'accessing'!directoryEntry	"a bug on Squeak (but not GS) with the handling of dot relative paths	like './file.xml' requires fully qualifying the path before creating	the DirectoryEntry"	^ self fileDirectory directoryEntryFor:		(self fileDirectory fullPathFor: self path)! !!XMLFileDirectoryFileHandle methodsFor: 'testing'!exists	^ self directoryEntry notNil! !!XMLFileDirectoryFileHandle methodsFor: 'accessing'!fileDirectory	^ fileDirectory		ifNil: [fileDirectory := (XMLClassFinder classNamed: #FileDirectory) default]! !!XMLFileDirectoryFileHandle methodsFor: 'testing'!isFile	^ self exists		and: [self directoryEntry isDirectory not]! !!XMLFileHandle class methodsFor: 'basic'!basicCurrentWorkingDirectory	self subclassResponsibility! !!XMLFileHandle class methodsFor: 'testing'!canBeImplemented	^ true! !!XMLFileHandle class methodsFor: 'accessing'!currentWorkingDirectory	"returns a path string for the current working directory"	^ self implementation basicCurrentWorkingDirectory! !!XMLFileHandle class methodsFor: 'finding'!noSupportedImplementationFound	XMLFileException signal: 'File IO unsupported'! !!XMLFileHandle class methodsFor: 'instance creation'!path: aPathString	^ self new setPath: aPathString! !!XMLFileHandle class methodsFor: 'defaults'!preferredImplementation	^ XMLFileSystemFileHandle! !!XMLFileHandle class methodsFor: 'accessing'!xmlDocumentFileExtensions	"a class variable so it's shared by all subclasses, but lazy initialized	so it isn't initialized unless needed"	^ XMLDocumentFileExtensions		ifNil: [			XMLDocumentFileExtensions :=				#('atom' "Atom Syndication Format"					'dbk' "DocBook XML"					'docm' "Office Open XML Document"					'docx' "Office Open XML Document"					'pptm' "Office Open XML Presentation"					'pptx' "Office Open XML Presentation"					'rdf' "Resource Description Framework"					'rss' "Rich Site Summary"					'svg' "Scalable Vector Graphics"					'xbel' "XML Bookmark Exchange Language"					'xfd' "Extensible Forms Description Language"					'xfdl' "Extensible Forms Description Language"					'xhtml'					'xlsm' "Office Open XML Workbook"					'xlsx' "Office Open XML Workbook"					'xml'					'xsd' "XML Schema Definition"					'xspf' "XML Shareable Playlist Format"					'xul' "XML User Interface Language"				) asSet]! !!XMLFileHandle class methodsFor: 'accessing'!xmlDocumentFileExtensions: aCollectionOrNil	XMLDocumentFileExtensions :=		aCollectionOrNil			ifNotNil: [aCollectionOrNil asSet]! !!XMLFileHandle methodsFor: 'converting'!asXMLFileHandle	^ self! !!XMLFileHandle methodsFor: 'basic'!basicDelete	self subclassResponsibility! !!XMLFileHandle methodsFor: 'basic'!basicFileSize	"This is named #basicFileSize instead of #basicSize to avoid conflicting	with the Object>>#basicSize primitive"	self subclassResponsibility! !!XMLFileHandle methodsFor: 'accessing'!contents	^ self readStreamDo: [:readStream | readStream upToEnd]! !!XMLFileHandle methodsFor: 'deleting'!delete	self exists		ifFalse: [self errorFileDoesNotExist].	[self basicDelete]		on: Error		do: [:error | XMLFileException signalMessageFrom: error].! !!XMLFileHandle methodsFor: 'private'!errorFileDoesNotExist	XMLFileException		formatSignal: 'File does does not exist: {1}'		with: self path! !!XMLFileHandle methodsFor: 'private'!errorFileExceedsMaxSize: aMaxSize	XMLLimitException		formatSignal: 'File exceeds max size of {1} bytes: {2}'		with: aMaxSize		with: self path! !!XMLFileHandle methodsFor: 'private'!errorNotAFile	XMLFileException		formatSignal: 'Not a file: {1}'		with: self path! !!XMLFileHandle methodsFor: 'testing'!exists	"returns true if the file exists"	self subclassResponsibility! !!XMLFileHandle methodsFor: 'accessing'!extension	"Returns the file extension, everything after the first '.' of the	last path segment:		'one.two/three.txt' asXMLFileHandle extension = 'txt'.		'one.two/three.tar.gz' asXMLFileHandle extension = 'tar.gz'.		'one.two/three.four/' asXMLFileHandle extension = ''.	"	| i |	^ ((i := self path lastIndexOf: $/) > 0		ifTrue: [self path copyFrom: i + 1 to: self path size]		ifFalse: [self path]) copyAfter: $.! !!XMLFileHandle methodsFor: 'resolving'!get	^ self		getUpToLimit: nil		decoding: true! !!XMLFileHandle methodsFor: 'resolving'!getUpToLimit: aMaxSize decoding: aBoolean	| stream contents |	"can be safely implemented using streamGetUpToLimit:decoding: rather	than the other way around like XMLHTTPRequest requires, because files	are local and can be safely read incrementally, unlike an HTTP response	which must be read immediately and stored entirely in memory"	stream :=		self			streamGetUpToLimit: aMaxSize			decoding: aBoolean.	contents := stream upToEnd.	stream close.	^ contents.! !!XMLFileHandle methodsFor: 'testing'!isFile	"returns true if the file exists and is a file (not a directory)"	self subclassResponsibility! !!XMLFileHandle methodsFor: 'testing'!isXMLDocumentFile	"Returns true if the file has a known extension of an XML document format	such as .xml, .xhtml, .xul, but not .dtd, .ent, or other XML-related	formats that aren't proper XML documents."	^ self class xmlDocumentFileExtensions includes: self extension asLowercase! !!XMLFileHandle methodsFor: 'instance creation'!newFileReadStreamOnPath	^ XMLFileReadStreamFactory onPath: self path! !!XMLFileHandle methodsFor: 'instance creation'!newFileWriteStreamOnPath	^ XMLFileWriteStreamFactory onPath: self path! !!XMLFileHandle methodsFor: 'accessing'!path	^ path ifNil: [path := '']! !!XMLFileHandle methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		nextPutAll: self path;		nextPut: $).! !!XMLFileHandle methodsFor: 'reading'!rawReadStream	"returns a raw file read stream with no decoding"	self exists		ifFalse: [self errorFileDoesNotExist].	self isFile		ifFalse: [self errorNotAFile].		^ [self newFileReadStreamOnPath]		on: Error		do: [:error | XMLFileException signalMessageFrom: error].! !!XMLFileHandle methodsFor: 'writing'!rawWriteStream	"returns a raw file write stream with no encoding; truncates existing files"	^ [self newFileWriteStreamOnPath]		on: Error		do: [:error | XMLFileException signalMessageFrom: error]! !!XMLFileHandle methodsFor: 'reading'!readStream	"returns a file read stream with decoding"	^ (XMLDecodingReadStreamAdapter nonDecodingOn: self rawReadStream)		detectEncoding! !!XMLFileHandle methodsFor: 'reading'!readStreamDo: aBlock	"evaluates aBlock with a file read stream with decoding and automatically	closes it after"	| readStream |	readStream := self readStream.	^ [aBlock value: readStream]		ensure: [readStream close].! !!XMLFileHandle methodsFor: 'initialization'!setPath: aPathString	path := aPathString! !!XMLFileHandle methodsFor: 'accessing'!size	self exists		ifFalse: [self errorFileDoesNotExist].	^ self basicFileSize.! !!XMLFileHandle methodsFor: 'resolving'!streamGet	^ self		streamGetUpToLimit: nil		decoding: true! !!XMLFileHandle methodsFor: 'resolving'!streamGetUpToLimit: aMaxSize decoding: aBoolean	(aMaxSize notNil		and: [self size > aMaxSize])		ifTrue: [self errorFileExceedsMaxSize: aMaxSize].	^ aBoolean		ifTrue: [self readStream]		ifFalse: [self rawReadStream].! !!XMLFileHandle methodsFor: 'writing'!writeStream	"returns a file write stream with encoding; truncates existing files"	^ XMLEncodingWriteStreamAdapter on: self rawWriteStream! !!XMLFileHandle methodsFor: 'writing'!writeStreamDo: aBlock	"evaluates aBlock with a file write stream with encoding and	automatically closes it after; truncates existing files"	| writeStream |	writeStream := self writeStream.	^ [aBlock value: writeStream]		ensure: [writeStream close].! !!XMLFileSystemFileHandle class methodsFor: 'basic'!basicCurrentWorkingDirectory	"avoid the class #workingDirectory message for Pharo1x compatibility"	^ (XMLClassFinder classNamed: #FileSystem) disk workingDirectory pathString! !!XMLFileSystemFileHandle class methodsFor: 'instance creation'!fileReference: aFileReference	^ self new setFileReference: aFileReference! !!XMLFileSystemFileHandle class methodsFor: 'testing'!isSupportedImplementation	^ XMLClassFinder hasClassNamed: #FileSystem! !!XMLFileSystemFileHandle methodsFor: 'basic'!basicDelete	self fileReference delete! !!XMLFileSystemFileHandle methodsFor: 'basic'!basicFileSize	^ self fileReference size! !!XMLFileSystemFileHandle methodsFor: 'testing'!exists	^ self fileReference exists! !!XMLFileSystemFileHandle methodsFor: 'accessing'!fileReference	^ fileReference ifNil: [fileReference := self path asFileReference]! !!XMLFileSystemFileHandle methodsFor: 'testing'!isFile	^ self fileReference isFile! !!XMLFileSystemFileHandle methodsFor: 'instance creation'!newFileReadStreamOnPath	"memory file references need special handling"	self usesMemoryStore		ifTrue: [^ self fileReference readStream].	^ super newFileReadStreamOnPath.! !!XMLFileSystemFileHandle methodsFor: 'instance creation'!newFileWriteStreamOnPath	"memory file references need special handling"	self usesMemoryStore		ifTrue: [^ self fileReference writeStream].	^ super newFileWriteStreamOnPath.! !!XMLFileSystemFileHandle methodsFor: 'initialization'!setFileReference: aFileReference	fileReference := aFileReference.	self setPath: aFileReference fullName.! !!XMLFileSystemFileHandle methodsFor: 'testing'!usesMemoryStore	"Pharo 3.0 has memory stores but lacks #isMemoryFileSystem, so	this test is used instead for backwards compatibility"	^ self fileReference fileSystem store class ==		(XMLClassFinder classNamed: #MemoryStore)! !!XMLFileReadStreamFactory class methodsFor: 'basic'!basicOnPath: aPathString	self subclassResponsibility! !!XMLFileReadStreamFactory class methodsFor: 'testing'!canBeImplemented	^ true! !!XMLFileReadStreamFactory class methodsFor: 'finding'!noSupportedImplementationFound	XMLFileException signal: 'File reading unsupported'! !!XMLFileReadStreamFactory class methodsFor: 'instance creation'!onPath: aPathString	^ self implementation basicOnPath: aPathString! !!XMLFileReadStreamFactory class methodsFor: 'defaults'!preferredImplementation	^ XMLStandardFileStreamReadStreamFactory! !!XMLStandardFileStreamReadStreamFactory class methodsFor: 'basic'!basicOnPath: aPathString	^ ((XMLClassFinder classNamed: #StandardFileStream)		readOnlyFileNamed: aPathString)			binary;			yourself! !!XMLStandardFileStreamReadStreamFactory class methodsFor: 'testing'!isSupportedImplementation	^ XMLClassFinder hasClassNamed: #StandardFileStream! !!XMLFileWriteStreamFactory class methodsFor: 'basic'!basicOnPath: aPathString	self subclassResponsibility! !!XMLFileWriteStreamFactory class methodsFor: 'testing'!canBeImplemented	^ true! !!XMLFileWriteStreamFactory class methodsFor: 'finding'!noSupportedImplementationFound	XMLFileException signal: 'File writing unsupported'! !!XMLFileWriteStreamFactory class methodsFor: 'instance creation'!onPath: aPathString	^ self implementation basicOnPath: aPathString! !!XMLFileWriteStreamFactory class methodsFor: 'defaults'!preferredImplementation	^ XMLStandardFileStreamWriteStreamFactory! !!XMLStandardFileStreamWriteStreamFactory class methodsFor: 'basic'!basicOnPath: aPathString	"use forceNewFileNamed: to ensure truncation of existing files before writing"	^ ((XMLClassFinder classNamed: #StandardFileStream)		forceNewFileNamed: aPathString)			binary;			yourself! !!XMLStandardFileStreamWriteStreamFactory class methodsFor: 'testing'!isSupportedImplementation	^ XMLClassFinder hasClassNamed: #StandardFileStream! !!XMLHTTPMessage methodsFor: 'adding'!addHeader: anAssociation	self		headerValuesAt: anAssociation key		add: anAssociation value.	^ anAssociation.! !!XMLHTTPMessage methodsFor: 'accessing'!content	"Returns the response content as a String or ByteArray"	"Requests with content aren't supported yet"	^ content ifNil: [content := '']! !!XMLHTTPMessage methodsFor: 'accessing'!content: aStringOrByteArray	content := aStringOrByteArray! !!XMLHTTPMessage methodsFor: 'accessing'!contentCharset	| contentType charset |	^ ((contentType := self contentType) isNil		or: [(charset := contentType charset) isEmpty])		ifTrue: [self defaultContentCharset]		ifFalse: [charset]! !!XMLHTTPMessage methodsFor: 'accessing'!contentEncoding	"Returns the non-identity content encoding compression schemes	in the order they were applied"	^ self encodingNamesFromHeaderValuesAt: 'Content-Encoding'! !!XMLHTTPMessage methodsFor: 'accessing'!contentEncoding: aStringOrCollection	self		encodingNamesFromHeaderValuesAt: 'Content-Encoding'		put: aStringOrCollection! !!XMLHTTPMessage methodsFor: 'accessing'!contentLength	^ XMLIntegerReader		readFrom:			(self				headerAt: 'Content-Length'				ifAbsent: [^ nil]) readStream		withBase: 10! !!XMLHTTPMessage methodsFor: 'accessing'!contentLength: anInteger	anInteger		ifNil: [			self				removeHeaderAt: 'Content-Length'				ifAbsent: []]		ifNotNil: [			self				headerAt: 'Content-Length'				put: anInteger asString]! !!XMLHTTPMessage methodsFor: 'accessing'!contentType	"Returns an XMLMIMEType object for the Content-Type header value"	^ XMLHTTPMIMEType fromString:		(self			headerAt: 'Content-Type'			ifAbsent: [^ nil])! !!XMLHTTPMessage methodsFor: 'accessing'!contentType: aMIMETypeOrString	aMIMETypeOrString		ifNil: [			self				removeHeaderAt: 'Content-Type'				ifAbsent: []]		ifNotNil: [			self				headerAt: 'Content-Type'				put: aMIMETypeOrString asString]! !!XMLHTTPMessage methodsFor: 'defaults'!defaultContentCharset	^ XMLHTTPMIMEType defaultCharset! !!XMLHTTPMessage methodsFor: 'private'!encodingNamesFromHeaderValuesAt: aKey	"Returns the non-identity encoding compression schemes	in the order they were applied from the value(s) of the	specified header"	| encodingNames |	encodingNames := OrderedCollection new.	self		headerValuesAt: aKey		do: [:headerValue |			$,				xmlSplit: headerValue				do: [:headerValueField | | encodingName |					encodingName :=						headerValueField xmlCopyWithoutWhitespace asLowercase.					(encodingName isEmpty						or: [encodingName = 'identity'])						ifFalse: [encodingNames addLast: encodingName]]].	^ encodingNames.! !!XMLHTTPMessage methodsFor: 'private'!encodingNamesFromHeaderValuesAt: aKey put: aStringOrCollection	aStringOrCollection isEmpty		ifTrue: [			self				removeHeaderAt: aKey				ifAbsent: []]		ifFalse: [			self				headerAt: aKey				put:					(aStringOrCollection isString						ifTrue: [aStringOrCollection]						ifFalse: [							String streamContents: [:stream |								aStringOrCollection									do: [:each | stream nextPutAll: each]									separatedBy: [stream nextPutAll: ', ']]])]! !!XMLHTTPMessage methodsFor: 'private'!errorRemovingAbsentHeader: aKey	XMLHTTPException		formatSignal: 'Cannot remove absent HTTP header "{1}" from message'		with: aKey! !!XMLHTTPMessage methodsFor: 'testing'!hasContent	^ self content notEmpty! !!XMLHTTPMessage methodsFor: 'testing'!hasHeaders	self headerKeysDo: [:key | ^ true].	^ false.! !!XMLHTTPMessage methodsFor: 'accessing'!headerAt: aKey	^ self		headerAt: aKey		ifAbsent: ['']! !!XMLHTTPMessage methodsFor: 'accessing'!headerAt: aKey ifAbsent: aBlock	self subclassResponsibility! !!XMLHTTPMessage methodsFor: 'accessing'!headerAt: aKey ifAbsentPut: aBlock	^ self		headerAt: aKey		ifAbsent: [			self				headerAt: aKey				put: aBlock value]! !!XMLHTTPMessage methodsFor: 'accessing'!headerAt: aKey put: aValue	self subclassResponsibility! !!XMLHTTPMessage methodsFor: 'accessing'!headerKeys	| keys |	keys := OrderedCollection new.	self headerKeysDo: [:key |		keys addLast: key].	^ keys.! !!XMLHTTPMessage methodsFor: 'enumerating'!headerKeysAndValuesDo: aTwoArgumentBlock	self subclassResponsibility! !!XMLHTTPMessage methodsFor: 'enumerating'!headerKeysDo: aBlock	self headerKeysAndValuesDo: [:key :value |		aBlock value: key]! !!XMLHTTPMessage methodsFor: 'accessing'!headerValuesAt: aKey	| values |	values := OrderedCollection new.	self		headerValuesAt: aKey		do: [:each | values addLast: each].	^ values.! !!XMLHTTPMessage methodsFor: 'adding'!headerValuesAt: aKey add: aValue	self subclassResponsibility! !!XMLHTTPMessage methodsFor: 'enumerating'!headerValuesAt: aKey do: aBlock	self subclassResponsibility! !!XMLHTTPMessage methodsFor: 'accessing'!headers	| headers |	headers := OrderedCollection new.	self headerKeysAndValuesDo: [:key :value |		headers addLast: key -> value].	^ headers.! !!XMLHTTPMessage methodsFor: 'testing'!includesHeaderAt: aKey	self		headerAt: aKey		ifAbsent: [^ false].	^ true.! !!XMLHTTPMessage methodsFor: 'removing'!removeHeaderAt: aKey	^ self		removeHeaderAt: aKey		ifAbsent: [self errorRemovingAbsentHeader: aKey]! !!XMLHTTPMessage methodsFor: 'removing'!removeHeaderAt: aKey ifAbsent: aBlock	self subclassResponsibility! !!XMLHTTPMessage methodsFor: 'removing'!removeHeaders	self headerKeys do: [:each |		self			removeHeaderAt: each			ifAbsent: []]! !!XMLHTTPRequest class methodsFor: 'testing'!canBeImplemented	^ true! !!XMLHTTPRequest class methodsFor: 'instance creation'!new	^ self url: ''! !!XMLHTTPRequest class methodsFor: 'finding'!noSupportedImplementationFound	XMLHTTPException signal: 'HTTP unsupported; install Zinc or WebClient'! !!XMLHTTPRequest class methodsFor: 'defaults'!preferredImplementation	^ XMLHTTPZincRequest! !!XMLHTTPRequest class methodsFor: 'instance creation'!url: aURLString	^ self implementationNew setURL: aURLString! !!XMLHTTPRequest methodsFor: 'accessing'!acceptEncoding	^ self encodingNamesFromHeaderValuesAt: 'Accept-Encoding'! !!XMLHTTPRequest methodsFor: 'accessing'!acceptEncoding: aStringOrCollection	"NOTE: only gzip is currently supported"	self		encodingNamesFromHeaderValuesAt: 'Accept-Encoding'		put: aStringOrCollection! !!XMLHTTPRequest methodsFor: 'converting'!asXMLHTTPRequest	^ self! !!XMLHTTPRequest methodsFor: 'basic'!basicCleanup	"can be overridden to handle cleanup after sending the	request and reading the response"! !!XMLHTTPRequest methodsFor: 'basic'!basicSend	self subclassResponsibility! !!XMLHTTPRequest methodsFor: 'defaults'!defaultAcceptEncoding	^ #()! !!XMLHTTPRequest methodsFor: 'defaults'!defaultMethod	^ 'GET'! !!XMLHTTPRequest methodsFor: 'defaults'!defaultTimeout	^ 30! !!XMLHTTPRequest methodsFor: 'accessing'!enableCompression	"NOTE: only gzip is currently supported"	self acceptEncoding: 'gzip'! !!XMLHTTPRequest methodsFor: 'private'!errorBadResponse: aResponse	XMLHTTPException		formatSignal: '{1} ({2})'		with: aResponse statusDescription		with: aResponse statusCode! !!XMLHTTPRequest methodsFor: 'resolving'!get	^ self		getUpToLimit: nil		decoding: true! !!XMLHTTPRequest methodsFor: 'resolving'!getUpToLimit: aMaxSize decoding: aBoolean	self method: 'GET'.	^ (self		resolveUpToLimit: aMaxSize		decoding: aBoolean) content! !!XMLHTTPRequest methodsFor: 'accessing'!method	self subclassResponsibility! !!XMLHTTPRequest methodsFor: 'accessing'!method: aString	self subclassResponsibility! !!XMLHTTPRequest methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		nextPutAll: self method;		space;		nextPutAll: self url;		nextPut: $).! !!XMLHTTPRequest methodsFor: 'resolving - response'!resolve	"Sends and retrieves the response as an XMLHTTPResponse object."	^ self		resolveUpToLimit: nil		decoding: true! !!XMLHTTPRequest methodsFor: 'resolving - response'!resolveUpToLimit: aMaxSize decoding: aBoolean	| response |	[		[			(response := self basicSend) isSuccess				ifFalse: [self errorBadResponse: response].			response				readContentUpToLimit: aMaxSize				decoding: aBoolean]			on: Error			do: [:error |				error isXMLParserException					ifTrue: [error pass]					ifFalse: [XMLHTTPException signalMessageFrom: error]]		] ensure: [self basicCleanup].	^ response.! !!XMLHTTPRequest methodsFor: 'defaults'!responseClass	self subclassResponsibility! !!XMLHTTPRequest methodsFor: 'initialization'!setURL: aURLString	url := aURLString.	self		timeout: self defaultTimeout;		method: self defaultMethod;		"even if #defaultAcceptEncoding returns an empty collection,		#acceptEncoding: must still be sent here to override any default		setting of the underlying HTTP library that we don't support"		acceptEncoding: self defaultAcceptEncoding.! !!XMLHTTPRequest methodsFor: 'resolving'!streamGet	^ self		streamGetUpToLimit: nil		decoding: true! !!XMLHTTPRequest methodsFor: 'resolving'!streamGetUpToLimit: aMaxSize decoding: aBoolean	"must be implemented using getUpToLimit:decoding: rather than the other	way around like XMLFileHandle does, because HTTP responses must be read	immediately and stored entirely in memory, unlike a file stream which	can safely be left open and read from incrementally"	^ (self		getUpToLimit: aMaxSize		decoding: aBoolean) readStream! !!XMLHTTPRequest methodsFor: 'accessing'!timeout	self subclassResponsibility! !!XMLHTTPRequest methodsFor: 'accessing'!timeout: anInteger	self subclassResponsibility! !!XMLHTTPRequest methodsFor: 'accessing'!url	^ url ifNil: [url := '']! !!XMLHTTPWebClientRequest class methodsFor: 'testing'!isSupportedImplementation	^ XMLClassFinder hasClassNamed: #WebClient! !!XMLHTTPWebClientRequest methodsFor: 'basic'!basicCleanup	self webClientClient close! !!XMLHTTPWebClientRequest methodsFor: 'basic'!basicSend	^ self responseClass		request: self		webClientResponse:			(self webClientClient				"#sendRequest: unfortunately requires #initializeFromUrl:				to be sent first"				initializeFromUrl: self url;				sendRequest: self webClientRequest)! !!XMLHTTPWebClientRequest methodsFor: 'accessing'!headerAt: aKey ifAbsent: aBlock	^ self webClientRequest		headerAt: aKey		ifAbsent: aBlock! !!XMLHTTPWebClientRequest methodsFor: 'accessing'!headerAt: aKey put: aValue	self webClientRequest		removeHeader: aKey;		addHeader: aKey value: aValue.	^ aValue.! !!XMLHTTPWebClientRequest methodsFor: 'enumerating'!headerKeysAndValuesDo: aTwoArgumentBlock	self webClientRequest headersDo: aTwoArgumentBlock! !!XMLHTTPWebClientRequest methodsFor: 'adding'!headerValuesAt: aKey add: aValue	self webClientRequest		addHeader: aKey		value: aValue.	^ aValue.! !!XMLHTTPWebClientRequest methodsFor: 'enumerating'!headerValuesAt: aKey do: aBlock	self webClientRequest		headersAt: aKey		do: aBlock! !!XMLHTTPWebClientRequest methodsFor: 'accessing'!method	^ self webClientRequest method! !!XMLHTTPWebClientRequest methodsFor: 'accessing'!method: aString	self webClientRequest method: aString! !!XMLHTTPWebClientRequest methodsFor: 'removing'!removeHeaderAt: aKey ifAbsent: aBlock	| removedValues |	removedValues :=		self webClientRequest			headersAt: aKey			ifAbsent: [^ aBlock value].	self webClientRequest removeHeader: aKey.	^ removedValues asOrderedCollection.! !!XMLHTTPWebClientRequest methodsFor: 'defaults'!responseClass	^ XMLHTTPWebClientResponse! !!XMLHTTPWebClientRequest methodsFor: 'accessing'!timeout	^ self webClientClient timeout! !!XMLHTTPWebClientRequest methodsFor: 'accessing'!timeout: anInteger	self webClientClient timeout: anInteger! !!XMLHTTPWebClientRequest methodsFor: 'private'!webClientClient	^ webClientClient		ifNil: [			webClientClient := (XMLClassFinder classNamed: #WebClient) new]! !!XMLHTTPWebClientRequest methodsFor: 'private'!webClientRequest	^ webClientRequest		ifNil: [			webClientRequest :=				(XMLClassFinder classNamed: #WebRequest) new					initializeFromUrl: self url;					yourself]! !!XMLHTTPZincRequest class methodsFor: 'testing'!isSupportedImplementation	^ XMLClassFinder hasClassNamed: #ZnClient! !!XMLHTTPZincRequest methodsFor: 'basic'!basicCleanup	self zincClient close! !!XMLHTTPZincRequest methodsFor: 'basic'!basicSend	^ self responseClass		request: self		zincResponse:			(self zincClient				request: self zincRequest;				execute;				response)! !!XMLHTTPZincRequest methodsFor: 'accessing'!headerAt: aKey ifAbsent: aBlock	self zincRequest headers		at: aKey		ifPresent: [:value |			^ value isArray				ifTrue: [value first]				ifFalse: [value]].	^ aBlock value.! !!XMLHTTPZincRequest methodsFor: 'accessing'!headerAt: aKey put: aValue	self zincRequest headers		at: aKey		put: aValue.	^ aValue.! !!XMLHTTPZincRequest methodsFor: 'enumerating'!headerKeysAndValuesDo: aTwoArgumentBlock	self zincRequest headersDo: aTwoArgumentBlock! !!XMLHTTPZincRequest methodsFor: 'adding'!headerValuesAt: aKey add: aValue	self zincRequest headers		at: aKey		add: aValue.	^ aValue.! !!XMLHTTPZincRequest methodsFor: 'enumerating'!headerValuesAt: aKey do: aBlock	self zincRequest headers		at: aKey		ifPresent: [:value |			value isArray				ifTrue: [value do: aBlock]				ifFalse: [aBlock value: value]]! !!XMLHTTPZincRequest methodsFor: 'accessing'!method	^ self zincRequest method asString! !!XMLHTTPZincRequest methodsFor: 'accessing'!method: aString	self zincRequest method: aString asSymbol! !!XMLHTTPZincRequest methodsFor: 'removing'!removeHeaderAt: aKey ifAbsent: aBlock	| removedValues |	removedValues :=		self zincRequest headers			removeKey: aKey			ifAbsent: [^ aBlock value].	^ removedValues isString		ifTrue: [OrderedCollection with: removedValues]		ifFalse: [removedValues asOrderedCollection].! !!XMLHTTPZincRequest methodsFor: 'defaults'!responseClass	^ XMLHTTPZincResponse! !!XMLHTTPZincRequest methodsFor: 'accessing'!timeout	^ self zincClient timeout! !!XMLHTTPZincRequest methodsFor: 'accessing'!timeout: anInteger	self zincClient timeout: anInteger! !!XMLHTTPZincRequest methodsFor: 'private '!zincClient	^ zincClient		ifNil: [			zincClient :=				(XMLClassFinder classNamed: #ZnClient) new					streaming: true;					yourself]! !!XMLHTTPZincRequest methodsFor: 'private '!zincRequest	^ zincRequest		ifNil: [			zincRequest :=				(XMLClassFinder classNamed: #ZnRequest)					get: self url]! !!XMLHTTPResponse class methodsFor: 'testing'!canBeImplemented	^ true! !!XMLHTTPResponse class methodsFor: 'finding'!noSupportedImplementationFound	XMLHTTPRequest noSupportedImplementationFound! !!XMLHTTPResponse class methodsFor: 'defaults'!preferredImplementation	^ XMLHTTPZincResponse! !!XMLHTTPResponse class methodsFor: 'instance creation'!request: aRequest	^ self new setRequest: aRequest! !!XMLHTTPResponse methodsFor: 'defaults'!contentReaderClass	self subclassResponsibility! !!XMLHTTPResponse methodsFor: 'defaults'!defaultProtocol	^ 'HTTP/1.1'! !!XMLHTTPResponse methodsFor: 'defaults'!defaultStatusCode	^ 200! !!XMLHTTPResponse methodsFor: 'testing'!isChunked	^ (self		headerAt: 'Transfer-Encoding'		ifAbsent: [^ false]) beginsWith: 'chunked'! !!XMLHTTPResponse methodsFor: 'testing'!isSuccess	self subclassResponsibility! !!XMLHTTPResponse methodsFor: 'instance creation'!newContentReader	^ self contentReaderClass response: self! !!XMLHTTPResponse methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		nextPutAll: self statusLine;		nextPut: $).! !!XMLHTTPResponse methodsFor: 'accessing'!protocol	self subclassResponsibility! !!XMLHTTPResponse methodsFor: 'accessing'!protocol: aString	self		setProtocol: aString		statusCode: self statusCode! !!XMLHTTPResponse methodsFor: 'reading'!readContentUpToLimit: aMaxSize decoding: aBoolean	self content:		(self newContentReader			readUpToLimit: aMaxSize			decoding: aBoolean)! !!XMLHTTPResponse methodsFor: 'converting'!readStream	^ self content readStream! !!XMLHTTPResponse methodsFor: 'accessing'!request	"Returns the XMLHTTPRequest object that created this response"	^ request! !!XMLHTTPResponse methodsFor: 'initialization'!setProtocol: aString statusCode: anInteger	self subclassResponsibility! !!XMLHTTPResponse methodsFor: 'initialization'!setRequest: aRequest	request := aRequest! !!XMLHTTPResponse methodsFor: 'accessing'!statusCode	"Returns the status code as an integer"	self subclassResponsibility! !!XMLHTTPResponse methodsFor: 'accessing'!statusCode: anInteger	self		setProtocol: self protocol		statusCode: anInteger! !!XMLHTTPResponse methodsFor: 'accessing'!statusDescription	| delimiter |	delimiter := Character space.	^ (self statusLine copyAfter: delimiter)		copyAfter: delimiter! !!XMLHTTPResponse methodsFor: 'accessing'!statusLine	"Returns the status line as a string"	self subclassResponsibility! !!XMLHTTPWebClientResponse class methodsFor: 'testing'!isSupportedImplementation	^ XMLClassFinder hasClassNamed: #WebResponse! !!XMLHTTPWebClientResponse class methodsFor: 'instance creation'!request: aRequest webClientResponse: aWebClientResponse	^ (self request: aRequest)		setWebClientResponse: aWebClientResponse! !!XMLHTTPWebClientResponse methodsFor: 'defaults'!contentReaderClass	^ XMLHTTPWebClientResponseContentReader! !!XMLHTTPWebClientResponse methodsFor: 'accessing'!headerAt: aKey ifAbsent: aBlock	^ self webClientResponse		headerAt: aKey		ifAbsent: aBlock! !!XMLHTTPWebClientResponse methodsFor: 'accessing'!headerAt: aKey put: aValue	self webClientResponse		removeHeader: aKey;		addHeader: aKey value: aValue.	^ aValue.! !!XMLHTTPWebClientResponse methodsFor: 'enumerating'!headerKeysAndValuesDo: aTwoArgumentBlock	self webClientResponse headersDo: aTwoArgumentBlock! !!XMLHTTPWebClientResponse methodsFor: 'adding'!headerValuesAt: aKey add: aValue	self webClientResponse		addHeader: aKey		value: aValue.	^ aValue.! !!XMLHTTPWebClientResponse methodsFor: 'enumerating'!headerValuesAt: aKey do: aBlock	self webClientResponse		headersAt: aKey		do: aBlock! !!XMLHTTPWebClientResponse methodsFor: 'testing'!isSuccess	^ self webClientResponse isSuccess! !!XMLHTTPWebClientResponse methodsFor: 'accessing'!protocol	^ self webClientResponse protocol! !!XMLHTTPWebClientResponse methodsFor: 'removing'!removeHeaderAt: aKey ifAbsent: aBlock	| removedValues |	removedValues :=		self webClientResponse			headersAt: aKey			ifAbsent: [^ aBlock value].	self webClientResponse removeHeader: aKey.	^ removedValues asOrderedCollection.! !!XMLHTTPWebClientResponse methodsFor: 'initialization'!setProtocol: aString statusCode: anInteger	self webClientResponse		protocol: aString		code: anInteger! !!XMLHTTPWebClientResponse methodsFor: 'initialization'!setWebClientResponse: aWebClientResponse	webClientResponse := aWebClientResponse! !!XMLHTTPWebClientResponse methodsFor: 'accessing'!statusCode	^ self webClientResponse code! !!XMLHTTPWebClientResponse methodsFor: 'accessing'!statusLine	^ self webClientResponse status! !!XMLHTTPWebClientResponse methodsFor: 'private'!webClientResponse	^ webClientResponse		ifNil: [			webClientResponse :=				(XMLClassFinder classNamed: #WebResponse)					protocol: self defaultProtocol					code: self defaultStatusCode]! !!XMLHTTPZincResponse class methodsFor: 'testing'!isSupportedImplementation	^ XMLClassFinder hasClassNamed: #ZnResponse! !!XMLHTTPZincResponse class methodsFor: 'instance creation'!request: aRequest zincResponse: aZincResponse	^ (self request: aRequest)		setZincResponse: aZincResponse! !!XMLHTTPZincResponse methodsFor: 'defaults'!contentReaderClass	^ XMLHTTPZincResponseContentReader! !!XMLHTTPZincResponse methodsFor: 'accessing'!headerAt: aKey ifAbsent: aBlock	self zincResponse headers		at: aKey		ifPresent: [:value |			^ value isArray				ifTrue: [value first]				ifFalse: [value]].	^ aBlock value.! !!XMLHTTPZincResponse methodsFor: 'accessing'!headerAt: aKey put: aValue	self zincResponse headers		at: aKey		put: aValue.	^ aValue.! !!XMLHTTPZincResponse methodsFor: 'enumerating'!headerKeysAndValuesDo: aTwoArgumentBlock	self zincResponse headersDo: aTwoArgumentBlock! !!XMLHTTPZincResponse methodsFor: 'adding'!headerValuesAt: aKey add: aValue	self zincResponse headers		at: aKey		add: aValue.	^ aValue.! !!XMLHTTPZincResponse methodsFor: 'enumerating'!headerValuesAt: aKey do: aBlock	self zincResponse headers		at: aKey		ifPresent: [:value |			value isArray				ifTrue: [value do: aBlock]				ifFalse: [aBlock value: value]]! !!XMLHTTPZincResponse methodsFor: 'testing'!isSuccess	^ self zincResponse isSuccess! !!XMLHTTPZincResponse methodsFor: 'accessing'!protocol	^ self zincResponse statusLine version! !!XMLHTTPZincResponse methodsFor: 'removing'!removeHeaderAt: aKey ifAbsent: aBlock	| removedValues |	removedValues :=		self zincResponse headers			removeKey: aKey			ifAbsent: [^ aBlock value].	^ removedValues isString		ifTrue: [OrderedCollection with: removedValues]		ifFalse: [removedValues asOrderedCollection].! !!XMLHTTPZincResponse methodsFor: 'initialization'!setProtocol: aString statusCode: anInteger	self zincResponse statusLine:		((ZnStatusLine code: anInteger)			version: aString;			yourself)! !!XMLHTTPZincResponse methodsFor: 'initialization'!setZincResponse: aZincResponse	zincResponse := aZincResponse! !!XMLHTTPZincResponse methodsFor: 'accessing'!statusCode	^ self zincResponse status! !!XMLHTTPZincResponse methodsFor: 'accessing'!statusLine	| statusLine |		statusLine := self zincResponse statusLine.	^ String streamContents: [:stream |		stream			nextPutAll: statusLine version;			space.		statusLine printCodeAndReasonOn: stream].! !!XMLHTTPZincResponse methodsFor: 'private'!zincResponse	^ zincResponse		ifNil: [			zincResponse :=				(XMLClassFinder classNamed: #ZnResponse) new					statusLine:						((ZnStatusLine code: self defaultStatusCode)							version: self defaultProtocol;							yourself);					yourself]! !!XMLKeyValueCache class methodsFor: 'testing'!canBeImplemented	^ true! !!XMLKeyValueCache class methodsFor: 'defaults'!defaultMaxSize	^ 32! !!XMLKeyValueCache class methodsFor: 'instance creation'!maxSize: anInteger	^ self implementationNew setMaxSize: anInteger! !!XMLKeyValueCache class methodsFor: 'instance creation'!new	^ self maxSize: self defaultMaxSize! !!XMLKeyValueCache class methodsFor: 'finding'!noSupportedImplementationFound	Error signal: 'No supported key-value cache class available'! !!XMLKeyValueCache class methodsFor: 'defaults'!preferredImplementation	^ XMLStandardKeyValueCache! !!XMLKeyValueCache methodsFor: 'accessing'!at: aKey	^ self		at: aKey		ifAbsent: [nil]! !!XMLKeyValueCache methodsFor: 'accessing'!at: aKey ifAbsent: aBlock	^ self critical: [		self collection			at: aKey			ifAbsent: aBlock]! !!XMLKeyValueCache methodsFor: 'accessing'!at: aKey ifAbsentPut: aBlock	^ self		at: aKey		ifAbsent: [			self				at: aKey				put: aBlock value]! !!XMLKeyValueCache methodsFor: 'accessing'!at: aKey ifPresent: aBlock	^ self critical: [		"Gemstone's at:ifAbsentPut: does not use cull:"		aBlock cull:			(self collection				at: aKey				ifAbsent: [^ nil])]! !!XMLKeyValueCache methodsFor: 'accessing'!at: aKey ifPresent: aPresentBlock put: aValueBlock	"Looks up the value of aKey and if present, evaluates aPresentBlock	optionally with it, and if aPresentBlock returns true, replaces the old	value with the result of evaluating aValueBlock."	^ self		at: aKey		ifPresent: [:value |			(aPresentBlock cull: value)				ifTrue: [						self						at: aKey						put: aValueBlock value]				ifFalse: [value]]! !!XMLKeyValueCache methodsFor: 'accessing'!at: aKey put: aValue	^ self critical: [		(self collection includesKey: aKey)			ifFalse: [				self collection size >= self maxSize					ifTrue: [self collection removeAll]].		self collection			at: aKey			put: aValue]! !!XMLKeyValueCache methodsFor: 'accessing'!capacity	^ self maxSize! !!XMLKeyValueCache methodsFor: 'clearing'!clear	self removeAll! !!XMLKeyValueCache methodsFor: 'accessing'!collection	self subclassResponsibility! !!XMLKeyValueCache methodsFor: 'defaults'!collectionClass	^ Dictionary! !!XMLKeyValueCache methodsFor: 'copying'!copy	^ self critical: [self shallowCopy postCopy]! !!XMLKeyValueCache methodsFor: 'mutual exclusion'!critical: aBlock	"Can be used to lock the cache during one or more operations in aBlock"	^ self mutex critical: aBlock! !!XMLKeyValueCache methodsFor: 'testing'!includesKey: aKey	^ self critical: [self collection includesKey: aKey]! !!XMLKeyValueCache methodsFor: 'testing'!isEmpty	^ self size = 0! !!XMLKeyValueCache methodsFor: 'accessing'!keys	^ self critical: [self collection keys]! !!XMLKeyValueCache methodsFor: 'enumerating'!keysAndValuesDo: aTwoArgumentBlock	self critical: [self collection keysAndValuesDo: aTwoArgumentBlock]! !!XMLKeyValueCache methodsFor: 'enumerating'!keysDo: aBlock	self critical: [self collection keysDo: aBlock]! !!XMLKeyValueCache methodsFor: 'accessing'!loadFactor	^ (self size / self maxSize) asFraction! !!XMLKeyValueCache methodsFor: 'accessing'!maxSize	^ maxSize! !!XMLKeyValueCache methodsFor: 'accessing'!maxSize: anInteger	self critical: [| oldMaxSize |		oldMaxSize := maxSize.		(maxSize := anInteger) < oldMaxSize			ifTrue: [self collection removeAll]]! !!XMLKeyValueCache methodsFor: 'private'!mutex	^ mutex! !!XMLKeyValueCache methodsFor: 'testing'!notEmpty	^ self size > 0! !!XMLKeyValueCache methodsFor: 'copying'!postCopy	super postCopy.	mutex := XMLReentrantMutex new.	self setCollection: self collection copy.! !!XMLKeyValueCache methodsFor: 'printing'!printOn: aStream	| loadFactor |	super printOn: aStream.	loadFactor := self loadFactor.	aStream		nextPut: $(;		print: loadFactor numerator;		nextPut: $/;		print: loadFactor denominator;		nextPut: $).! !!XMLKeyValueCache methodsFor: 'removing'!removeAll	self critical: [self collection removeAll]! !!XMLKeyValueCache methodsFor: 'removing'!removeKey: aKey	"this attempts to remove a key, but to support concurrent removal, it	does not raise errors if it was already removed"	^ self critical: [		self collection			removeKey: aKey			ifAbsent: [nil]]! !!XMLKeyValueCache methodsFor: 'removing'!removeKey: aKey ifAbsent: aBlock	^ self critical: [		self collection			removeKey: aKey			ifAbsent: aBlock]! !!XMLKeyValueCache methodsFor: 'removing'!removeKey: aKey ifPresent: aBlock	"Looks up the value of aKey and if present, evaluates aPresentBlock	optionally with it, and if aPresentBlock returns true, removes the	key from the cache and returns its old value."	^ self		at: aKey		ifPresent: [:value |			(aBlock cull: value)				ifTrue: [self removeKey: aKey]				ifFalse: [value]]! !!XMLKeyValueCache methodsFor: 'initialization'!setCollection: aKeyValueCollection	self subclassResponsibility! !!XMLKeyValueCache methodsFor: 'initialization'!setMaxSize: anInteger	maxSize := anInteger.	mutex := XMLReentrantMutex new.	self setCollection: self collectionClass new.! !!XMLKeyValueCache methodsFor: 'accessing'!size	^ self collection size! !!XMLKeyValueCache methodsFor: 'accessing'!values	^ self critical: [self collection values]! !!XMLKeyValueCache methodsFor: 'enumerating'!valuesDo: aBlock	self critical: [self collection valuesDo: aBlock]! !!XMLStandardKeyValueCache class methodsFor: 'testing'!isSupportedImplementation	"need some type of reentrant mutex"	XMLReentrantMutex hasSupportedImplementation		ifFalse: [^ false].	"MUST use the transient class on GS to avoid persisting and causing	write conflicts"	XMLClassFinder		classNamed: #XMLTransientKeyValueCache		ifPresent: [:transientKeyValueCacheClass |			transientKeyValueCacheClass isSupportedImplementation				ifTrue: [^ false]].	^ true.! !!XMLStandardKeyValueCache methodsFor: 'accessing'!collection	^ collection! !!XMLStandardKeyValueCache methodsFor: 'initialization'!setCollection: aKeyValueCollection	collection := aKeyValueCollection! !!XMLReentrantMutex class methodsFor: 'testing'!canBeImplemented	^ true! !!XMLReentrantMutex class methodsFor: 'finding'!noSupportedImplementationFound	Error signal: 'No supported reentrant mutex class available'! !!XMLReentrantMutex class methodsFor: 'defaults'!preferredImplementation	"Prefer the Pharo/Squeak Mutex-based implementation"	^ XMLStandardReentrantMutex! !!XMLReentrantMutex methodsFor: 'mutual exclusion'!critical: aBlock	self subclassResponsibility! !!XMLStandardReentrantMutex class methodsFor: 'testing'!isSupportedImplementation	(XMLClassFinder hasClassNamed: #Mutex)		ifFalse: [^ false].	"MUST use the transient class on GS to avoid persisting and causing	write conflicts"	XMLClassFinder		classNamed: #XMLTransientReentrantMutex		ifPresent: [:transientReentrantMutexClass |			transientReentrantMutexClass isSupportedImplementation				ifTrue: [^ false]].	^ true.! !!XMLStandardReentrantMutex methodsFor: 'mutual exclusion'!critical: aBlock	^ mutex critical: aBlock! !!XMLStandardReentrantMutex methodsFor: 'initialization'!initialize	super initialize.	mutex := (XMLClassFinder classNamed: #Mutex) new.! !!XMLAbstractReadStream class methodsFor: 'basic'!basicOn: anObject	^ self basicNew initialize on: anObject! !!XMLAbstractReadStream class methodsFor: 'instance creation'!new	self shouldNotImplement! !!XMLAbstractReadStream class methodsFor: 'instance creation'!on: anObject	^ self basicOn: anObject! !!XMLAbstractReadStream methodsFor: 'testing'!atEnd	self subclassResponsibility! !!XMLAbstractReadStream methodsFor: 'closing'!close! !!XMLAbstractReadStream methodsFor: 'accessing'!contents	self subclassResponsibility! !!XMLAbstractReadStream methodsFor: 'testing'!isBinary	^ false! !!XMLAbstractReadStream methodsFor: 'testing'!isStream	^ true! !!XMLAbstractReadStream methodsFor: 'testing'!isXMLBinaryOrExternalStream	^ self isBinary! !!XMLAbstractReadStream methodsFor: 'instance creation'!newWriteStream	^ (self writeStreamCollectionClass new: 128) writeStream! !!XMLAbstractReadStream methodsFor: 'accessing'!next	self subclassResponsibility! !!XMLAbstractReadStream methodsFor: 'accessing'!next: anInteger	| writeStream i |	writeStream := self newWriteStream.	i := 0.	[self atEnd		or: [i >= anInteger]]		whileFalse: [			writeStream nextPut: self next.			i := i + 1].	^ writeStream contents.! !!XMLAbstractReadStream methodsFor: 'initialization'!on: anObject	self subclassResponsibility! !!XMLAbstractReadStream methodsFor: 'accessing'!peek	self subclassResponsibility! !!XMLAbstractReadStream methodsFor: 'accessing'!peekFor: anObject	(self atEnd not		and: [self peek = anObject])		ifTrue: [			self next.			^ true]		ifFalse: [^ false]! !!XMLAbstractReadStream methodsFor: 'positioning'!position	self subclassResponsibility! !!XMLAbstractReadStream methodsFor: 'positioning'!position: anInteger	self subclassResponsibility! !!XMLAbstractReadStream methodsFor: 'positioning'!reset	self subclassResponsibility! !!XMLAbstractReadStream methodsFor: 'positioning'!skip: anInteger	"only supports skipping forwards"	1 to: anInteger do: [:i |		self atEnd			ifTrue: [^ self].		self next]! !!XMLAbstractReadStream methodsFor: 'positioning'!skipSeparators	"we use #isXMLWhitespace instead of the narrower, XML-specific	#isXMLSeparator, because this class can be used for non-XML	streams too"	[self atEnd not		and: [self peek isXMLWhitespace]]		whileTrue: [self next]! !!XMLAbstractReadStream methodsFor: 'positioning'!skipTo: anObject	[self atEnd]		whileFalse: [			self next = anObject				ifTrue: [^ true]].	^ false.! !!XMLAbstractReadStream methodsFor: 'accessing'!upTo: anObject	| writeStream next |	writeStream := self newWriteStream.	[self atEnd		or: [(next := self next) = anObject]]		whileFalse: [writeStream nextPut: next].	^ writeStream contents.! !!XMLAbstractReadStream methodsFor: 'accessing'!upToEnd	| writeStream |	writeStream := self newWriteStream.	[self atEnd]		whileFalse: [writeStream nextPut: self next].	^ writeStream contents.! !!XMLAbstractReadStream methodsFor: 'writing'!writeStreamCollectionClass	self isBinary		ifTrue: [^ ByteArray]		ifFalse: [^ String]! !!XMLNullReadStream class methodsFor: 'class initialization'!initialize	"self initialize"	instance := self basicOn: nil! !!XMLNullReadStream class methodsFor: 'instance creation'!new	^ instance! !!XMLNullReadStream class methodsFor: 'instance creation'!on: anObject	^ instance! !!XMLNullReadStream methodsFor: 'testing'!atEnd	^ true! !!XMLNullReadStream methodsFor: 'accessing'!contents	^ String new! !!XMLNullReadStream methodsFor: 'accessing'!next	^ nil! !!XMLNullReadStream methodsFor: 'initialization'!on: anObject! !!XMLNullReadStream methodsFor: 'accessing'!peek	^ nil! !!XMLNullReadStream methodsFor: 'positioning'!position	^ 0! !!XMLNullReadStream methodsFor: 'positioning'!position: anInteger! !!XMLNullReadStream methodsFor: 'positioning'!reset! !!XMLSingleCharacterReadStream methodsFor: 'testing'!atEnd	^ atEnd! !!XMLSingleCharacterReadStream methodsFor: 'closing'!close	atEnd := true! !!XMLSingleCharacterReadStream methodsFor: 'accessing'!contents	^ String with: character! !!XMLSingleCharacterReadStream methodsFor: 'accessing'!next	atEnd		ifTrue: [^ nil]		ifFalse: [			atEnd := true.			^ character]! !!XMLSingleCharacterReadStream methodsFor: 'initialization'!on: aCharacter	character := aCharacter.	atEnd := false.! !!XMLSingleCharacterReadStream methodsFor: 'accessing'!peek	atEnd		ifTrue: [^ nil]		ifFalse: [^ character]! !!XMLSingleCharacterReadStream methodsFor: 'positioning'!position	^ atEnd		ifTrue: [1]		ifFalse: [0]! !!XMLSingleCharacterReadStream methodsFor: 'positioning'!position: anInteger	atEnd := anInteger > 0! !!XMLSingleCharacterReadStream methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		print: character;		nextPut: $).! !!XMLSingleCharacterReadStream methodsFor: 'positioning'!reset	atEnd := false! !!XMLAbstractReadStreamParser class methodsFor: 'instance creation'!new	self shouldNotImplement! !!XMLAbstractReadStreamParser class methodsFor: 'instance creation'!on: aStringOrStream	^ self basicNew initialize on: aStringOrStream! !!XMLAbstractReadStreamParser methodsFor: 'tokenizing'!nextDelimitedBy: aCharacter	writeStream reset.	[readStream atEnd		or: [readStream peek = aCharacter]]		whileFalse: [writeStream nextPut: readStream next].	^ writeStream contents.! !!XMLAbstractReadStreamParser methodsFor: 'tokenizing'!nextDelimitedByAny: aCharacterCollection	writeStream reset.	[readStream atEnd		or: [aCharacterCollection includes: readStream peek]]		whileFalse: [writeStream nextPut: readStream next].	^ writeStream contents.! !!XMLAbstractReadStreamParser methodsFor: 'initialization'!on: aStringOrStream	readStream :=		XMLReadStreamAdapter on:			(aStringOrStream isStream				ifTrue: [aStringOrStream]				ifFalse: [aStringOrStream readStream]).	writeStream := (String new: 64) writeStream.! !!XMLHTTPMIMETypeParser class methodsFor: 'class initialization'!initialize	"self initialize"	self initializeTokenDelimiters! !!XMLHTTPMIMETypeParser class methodsFor: 'class initialization'!initializeTokenDelimiters	"String streamContents: [:writeStream | | readStream current previous |		readStream := self tspecialsTemplate readStream.		[readStream atEnd]			whileFalse: [				previous := current.				current := readStream next.				(#('""' '<>') anySatisfy: [:each |					previous = each first						and: [readStream peek = each last]])					ifTrue: [writeStream nextPut: current]]]"	TokenDelimiters :=		BitmapCharacterSet newFrom: '()<>@,;:\"/[]?.=', Character xmlWhitespace! !!XMLHTTPMIMETypeParser class methodsFor: 'private'!tspecialsTemplate	^ '	tspecials :=  "(" / ")" / "<" / ">" / "@"  ; Must be in                       /  "," / ";" / ":" / "\" / <">  ; quoted-string,                       /  "/" / "[" / "]" / "?" / "."  ; to use within                       /  "="                        ; parameter values'! !!XMLHTTPMIMETypeParser methodsFor: 'private'!nextOptionalQuotedString	| isEscaping nextChar |	(readStream		skipSeparators;		peekFor: $")		ifFalse: [^ nil].	writeStream		reset;		nextPut: $".	isEscaping := false.	[(nextChar := readStream next) isNil		or: [isEscaping not			and: [nextChar == $"]]]		whileFalse: [			isEscaping :=				isEscaping not					and: [nextChar == $\].			writeStream nextPut: nextChar].	^ writeStream		nextPut: $";		contents.! !!XMLHTTPMIMETypeParser methodsFor: 'private'!nextToken	readStream skipSeparators.	^ self nextDelimitedByAny: TokenDelimiters.! !!XMLHTTPMIMETypeParser methodsFor: 'private'!nextTokenOrQuotedString	^ self nextOptionalQuotedString		ifNil: [self nextToken]! !!XMLHTTPMIMETypeParser methodsFor: 'parsing'!parseMainType	"main types are case insensitive and are converted to	lowercase for consistentcy"	^ self nextToken asLowercase! !!XMLHTTPMIMETypeParser methodsFor: 'parsing'!parseParameters	| parameters attributes totalAttributes |	parameters := OrderedCollection new.	totalAttributes := 0.	[(readStream		skipSeparators;		peekFor: $;)			and: [				(readStream					skipSeparators;					atEnd) not]]		whileTrue: [| attribute value hasValue |			"attributes are case insensitive and are converted			to lowercase for convenience"			attribute := self nextToken asLowercase.			(hasValue :=				readStream					skipSeparators;					peekFor: $=)				ifTrue: [value := self nextTokenOrQuotedString]				ifFalse: [value := ''].			(attribute notEmpty				or: [hasValue])				ifTrue: [					"only initialize if needed"					((attributes ifNil: [attributes := Set new])						add: attribute;						size) > totalAttributes						ifTrue: [							parameters addLast: attribute -> value.							totalAttributes := totalAttributes + 1]]].	^ parameters.! !!XMLHTTPMIMETypeParser methodsFor: 'parsing'!parseSubType	"sub types are case insensitive and are converted to	lowercase for consistentcy"	readStream		skipSeparators;		peekFor: $/.	^ self nextToken asLowercase.! !!XMLURIParser class methodsFor: 'class initialization'!initialize	"self initialize"	self		initializeSchemeDelimiters;		initializeUserInfoDelimiters;		initializeHostDelimiters;		initializePathDelimiters;		initializeQueryKeyDelimiters;		initializeQueryValueDelimiters! !!XMLURIParser class methodsFor: 'class initialization'!initializeHostDelimiters	HostDelimiters := BitmapCharacterSet newFrom: ':/?#'! !!XMLURIParser class methodsFor: 'class initialization'!initializePathDelimiters	PathDelimiters := BitmapCharacterSet newFrom: '/?#'! !!XMLURIParser class methodsFor: 'class initialization'!initializeQueryKeyDelimiters	QueryKeyDelimiters := BitmapCharacterSet newFrom: '=&#'! !!XMLURIParser class methodsFor: 'class initialization'!initializeQueryValueDelimiters	QueryValueDelimiters := BitmapCharacterSet newFrom: '&#'! !!XMLURIParser class methodsFor: 'class initialization'!initializeSchemeDelimiters	"including % disallows percent encoding in schemes"	SchemeDelimiters := BitmapCharacterSet newFrom: ':@/?#%'! !!XMLURIParser class methodsFor: 'class initialization'!initializeUserInfoDelimiters	UserInfoDelimiters := BitmapCharacterSet newFrom: '@/?#'! !!XMLURIParser methodsFor: 'parsing'!parseAuthorityPrefix	| oldPosition |	oldPosition := readStream position.	((readStream peekFor: $/)		and: [readStream peekFor: $/])		ifTrue: [^ true]		ifFalse: [			readStream position: oldPosition.			^ false].! !!XMLURIParser methodsFor: 'parsing'!parseFragment	(readStream peekFor: $#)		ifTrue: [^ readStream upToEnd]		ifFalse: [^ '']! !!XMLURIParser methodsFor: 'parsing'!parseHost	| host |	readStream peek == $[		ifTrue: [			host := (self nextDelimitedBy: $]) copyWith: $].			readStream peekFor: $]]		ifFalse: [host := self nextDelimitedByAny: HostDelimiters].	^ host.! !!XMLURIParser methodsFor: 'parsing'!parsePathSegments	| pathSegments segment |	pathSegments := OrderedCollection new.	segment := self nextDelimitedByAny: PathDelimiters.	[readStream peekFor: $/]		whileTrue: [			pathSegments addLast: segment.			segment := self nextDelimitedByAny: PathDelimiters].	(pathSegments isEmpty		and: [segment isEmpty])		ifFalse: [pathSegments addLast: segment].	^ pathSegments.! !!XMLURIParser methodsFor: 'parsing'!parsePort	| port |	(readStream peekFor: $:)		ifTrue: [			"do not limit the number of chars read, because port			number literals can have an arbitrary number of			leading zeros"			port :=				XMLSmallIntegerReader					readFrom: readStream					withBase: 10.			[readStream atEnd				or: [PathDelimiters includes: readStream peek]]				whileFalse: [readStream next]].	^ port.! !!XMLURIParser methodsFor: 'parsing'!parseQuery	"parse the query as an OrderedCollection of name=value associations	to handle multiple values for the same key and different encoded keys	that later percent/plus decode to the same key"	| query key value |	(readStream peekFor: $?)		ifFalse: [^ OrderedCollection new: 0].	query := OrderedCollection new.	[readStream atEnd		or: [(key := self nextDelimitedByAny: QueryKeyDelimiters) isEmpty			and: [readStream peek == $#]]]		whileFalse: [| hasValue |			(hasValue := readStream peekFor: $=)				ifTrue: [value := self nextDelimitedByAny: QueryValueDelimiters]				ifFalse: [value := ''].			(key notEmpty				or: [hasValue])				ifTrue: [query addLast: key -> value].			readStream peekFor: $&].	^ query.! !!XMLURIParser methodsFor: 'parsing'!parseScheme	| oldPosition scheme |	oldPosition := readStream position.	scheme := self nextDelimitedByAny: SchemeDelimiters.	(readStream peekFor: $:)		ifTrue: [^ scheme asLowercase]		ifFalse: [			readStream position: oldPosition.			^ ''].! !!XMLURIParser methodsFor: 'parsing'!parseUserInfo	| userInfo oldPosition |	oldPosition := readStream position.	userInfo := self nextDelimitedByAny: UserInfoDelimiters.	(readStream peekFor: $@)		ifTrue: [^ userInfo]		ifFalse: [			readStream position: oldPosition.			^ ''].! !!XMLAttributeDefaultValidator class methodsFor: 'instance creation'!attribute: anAttribute	^ self		attribute: anAttribute		value: ''! !!XMLAttributeDefaultValidator class methodsFor: 'instance creation'!attribute: anAttribute value: aDefaultValue	^ self new		setAttribute: anAttribute		value: aDefaultValue! !!XMLAttributeDefaultValidator class methodsFor: 'defaults'!standaloneExternalClass	^ self! !!XMLAttributeDefaultValidator methodsFor: 'accessing'!attribute	^ attribute! !!XMLAttributeDefaultValidator methodsFor: 'testing'!isFixedValue	^ false! !!XMLAttributeDefaultValidator methodsFor: 'testing'!isImplied	^ false! !!XMLAttributeDefaultValidator methodsFor: 'testing'!isRequired	^ false! !!XMLAttributeDefaultValidator methodsFor: 'testing'!isValue	^ false! !!XMLAttributeDefaultValidator methodsFor: 'printing'!printNameAndValueOn: aStream	aStream		nextPutAll: self attribute;		nextPutAll: '="';		nextPutAll: self value;		nextPut: $"! !!XMLAttributeDefaultValidator methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	self printNameAndValueOn: aStream.	aStream nextPut: $).! !!XMLAttributeDefaultValidator methodsFor: 'processing'!processedDefaultForAbsentAttributeValue	^ nil! !!XMLAttributeDefaultValidator methodsFor: 'processing'!processedDefaultForPresentAttributeValue: anAttributeValue	^ anAttributeValue! !!XMLAttributeDefaultValidator methodsFor: 'initialization'!setAttribute: anAttribute value: aDefaultValue	attribute := anAttribute! !!XMLAttributeDefaultValidator methodsFor: 'validating'!validatedDefaultForAbsentAttributeValue	^ nil! !!XMLAttributeDefaultValidator methodsFor: 'validating'!validatedDefaultForPresentAttributeValue: anAttributeValue	^ anAttributeValue! !!XMLAttributeDefaultValidator methodsFor: 'accessing'!value	^ ''! !!XMLAttributeImpliedDefaultValidator methodsFor: 'testing'!isImplied	^ true! !!XMLAttributeRequiredDefaultValidator methodsFor: 'private'!errorRequiredAttributeMissing	XMLValidationException		formatSignal: 'Required attribute "{1}" is missing'		with: self attribute! !!XMLAttributeRequiredDefaultValidator methodsFor: 'testing'!isRequired	^ true! !!XMLAttributeRequiredDefaultValidator methodsFor: 'validating'!validatedDefaultForAbsentAttributeValue	self errorRequiredAttributeMissing! !!XMLAttributeFixedValueDefaultValidator class methodsFor: 'defaults'!standaloneExternalClass	^ XMLStandaloneExternalAttributeFixedValueDefaultValidator! !!XMLAttributeFixedValueDefaultValidator methodsFor: 'private'!errorFixedAttributeValueCannotChange	XMLValidationException		formatSignal: 'Fixed attribute "{1}" can only have "{2}" as its value'		with: self attribute		with: self value! !!XMLAttributeFixedValueDefaultValidator methodsFor: 'testing'!isFixedValue	^ true! !!XMLAttributeFixedValueDefaultValidator methodsFor: 'processing'!processedDefaultForPresentAttributeValue: anAttributeValue	^ self value! !!XMLAttributeFixedValueDefaultValidator methodsFor: 'validating'!validatedDefaultForPresentAttributeValue: anAttributeValue	anAttributeValue = self value		ifFalse: [self errorFixedAttributeValueCannotChange].	^ anAttributeValue.! !!XMLStandaloneExternalAttributeFixedValueDefaultValidator methodsFor: 'private'!errorStandaloneExternalAttributeDefaultFixedValueUsed	XMLValidationException		formatSignal:			'Externally defined attribute "{1}" fixed default value ',			'cannot be used by elements when standalone="yes"'		with: self attribute! !!XMLStandaloneExternalAttributeFixedValueDefaultValidator methodsFor: 'validating'!validatedDefaultForAbsentAttributeValue	self errorStandaloneExternalAttributeDefaultFixedValueUsed! !!XMLAttributeValueDefaultValidator class methodsFor: 'defaults'!standaloneExternalClass	^ XMLStandaloneExternalAttributeValueDefaultValidator! !!XMLAttributeValueDefaultValidator methodsFor: 'testing'!isValue	^ true! !!XMLAttributeValueDefaultValidator methodsFor: 'processing'!processedDefaultForAbsentAttributeValue	^ self value! !!XMLAttributeValueDefaultValidator methodsFor: 'initialization'!setAttribute: anAttribute value: aDefaultValue	attribute := anAttribute.	value := aDefaultValue.! !!XMLAttributeValueDefaultValidator methodsFor: 'validating'!validatedDefaultForAbsentAttributeValue	^ self value! !!XMLAttributeValueDefaultValidator methodsFor: 'accessing'!value	^ value! !!XMLAttributeValueDefaultValidator methodsFor: 'accessing'!value: aDefaultValue	value := aDefaultValue! !!XMLStandaloneExternalAttributeValueDefaultValidator methodsFor: 'private'!errorStandaloneExternalAttributeDefaultValueUsed	XMLValidationException		formatSignal:			'Externally defined attribute "{1}" default value ',			'cannot be used by elements when standalone="yes"'		with: self attribute! !!XMLStandaloneExternalAttributeValueDefaultValidator methodsFor: 'validating'!validatedDefaultForAbsentAttributeValue	self errorStandaloneExternalAttributeDefaultValueUsed! !!XMLAttributeSpec methodsFor: 'converting'!asXMLAttributeSpec	^ self! !!XMLAttributeSpec methodsFor: 'matching'!matchesAttributes: anAttributeDictionary	self subclassResponsibility! !!XMLBasicAttributeSpec class methodsFor: 'instance creation'!attributes: aDictionaryOrCollectionOfAssociationsAndStrings	^ self new setAttributes: aDictionaryOrCollectionOfAssociationsAndStrings! !!XMLBasicAttributeSpec methodsFor: 'adding'!addAttribute: anAttribute	^ attributeSpec		at: anAttribute		ifAbsentPut: [nil]! !!XMLBasicAttributeSpec methodsFor: 'adding'!addAttributeAssociation: anAssociation	^ self		addAttributeName: anAssociation key		value: anAssociation value! !!XMLBasicAttributeSpec methodsFor: 'adding'!addAttributeName: aName value: aValue	^ attributeSpec		at: aName		put: aValue! !!XMLBasicAttributeSpec methodsFor: 'initialization'!initialize	super initialize.	attributeSpec := Dictionary new.! !!XMLBasicAttributeSpec methodsFor: 'matching'!matchesAttributes: anAttributeDictionary	attributeSpec keysAndValuesDo: [:specName :specValue |		specValue			ifNil: [				"nil values mean the attribute has to be present and can have				any value"				(anAttributeDictionary includesKey: specName)					ifFalse: [^ false]]			ifNotNil: [				(specValue isBlock					ifTrue: [						specValue value:							(anAttributeDictionary								at: specName								ifAbsent: [^ false])]					ifFalse: [						specValue =							(anAttributeDictionary								at: specName								ifAbsent: [^ false])])							ifFalse: [^ false]]].	^ true.! !!XMLBasicAttributeSpec methodsFor: 'initialization'!setAttributes: aDictionaryOrCollectionOfAssociationsAndStrings	attributeSpec removeAll.	"associationsDo: works for dictionaries and non-dictionaries, including	arrays, to support specs like {'one'. 'two'->'three'}"	aDictionaryOrCollectionOfAssociationsAndStrings associationsDo: [:each |		each isString			ifTrue: [self addAttribute: each]			ifFalse: [self addAttributeAssociation: each]].! !!XMLPluggableAttributeSpec class methodsFor: 'generated'!block: aOneArgumentBlock	^ self new block: aOneArgumentBlock! !!XMLPluggableAttributeSpec methodsFor: 'accessing'!block	^ block! !!XMLPluggableAttributeSpec methodsFor: 'accessing'!block: aOneArgumentBlock	block := aOneArgumentBlock! !!XMLPluggableAttributeSpec methodsFor: 'matching'!matchesAttributes: anAttributeDictionary	"if there's no block, then it automatically matches, similar to an	XMLBasicAttributeSpec with no attributes"	block		ifNil: [^ true]		ifNotNil: [^ block value: anAttributeDictionary]! !!XMLAttributeValidator class methodsFor: 'instance creation'!element: anElement attribute: anAttribute defaultValidator: aDefaultValidator	^ self new		setElement: anElement		attribute: anAttribute		defaultValidator: aDefaultValidator! !!XMLAttributeValidator class methodsFor: 'class initialization'!initialize	"self initialize"	"stored in a class var for faster access"	NormalizedSpace := Character space! !!XMLAttributeValidator class methodsFor: 'defaults'!standaloneExternalClass	^ self! !!XMLAttributeValidator methodsFor: 'accessing'!attribute	^ attribute! !!XMLAttributeValidator methodsFor: 'accessing'!defaultValidator	^ defaultValidator! !!XMLAttributeValidator methodsFor: 'accessing'!element	^ element! !!XMLAttributeValidator methodsFor: 'private'!errorInvalidDefaultAttributeValue: aDefaultValue	XMLValidationException		formatSignal:			'Invalid default value "{1}" in declaration for ',			'attribute "{2}" of element <3>'		with: aDefaultValue		with: self attribute		with: self element! !!XMLAttributeValidator methodsFor: 'private'!errorInvalidXMLIDAttributeDeclaration	XMLValidationException signal:		'All "xml:id" attributes must be declared to be of ID type'! !!XMLAttributeValidator methodsFor: 'private'!errorInvalidXMLSpaceAttributeDeclaration	XMLValidationException		formatSignal:			'Attribute "xml:space" of element <{1}> must be declared as ',			'an enumeration type with "default" and/or "preserve" values'		with: self element! !!XMLAttributeValidator methodsFor: 'private'!errorNormalizedStandaloneExternalAttribute	XMLValidationException		formatSignal:			'Externally defined attribute "{1}" of element <{2}> required ',			'further value normalizaiton in standalone="yes" document'		with: self attribute		with: self element! !!XMLAttributeValidator methodsFor: 'private'!furtherNormalizeAttributeValue: aSemiNormalizedAttributeValue	"The tokenizer normalizes all non-char escaped whitespace in attribute	values to spaces (0x20). This further normalizes them by removing leading	and trailing spaces and turing multiple spaces to single spaces."	| writeStream isInWhitespace |	aSemiNormalizedAttributeValue size > 0 "optimization"		ifFalse: [^ aSemiNormalizedAttributeValue].	"must use #writeStream instead of 'WriteStream on:' to get a 0-based stream	on Gemstone"	writeStream := (String new: aSemiNormalizedAttributeValue size) writeStream.	isInWhitespace := false.	"use #to:do: for speed"	1 to: aSemiNormalizedAttributeValue size do: [:i | | nextChar |		(nextChar := aSemiNormalizedAttributeValue at: i) == NormalizedSpace			ifTrue: [				isInWhitespace					ifFalse: [isInWhitespace := true]]			ifFalse: [				isInWhitespace					ifTrue: [						writeStream position > 0							ifTrue: [writeStream nextPut: NormalizedSpace].						isInWhitespace := false].				writeStream nextPut: nextChar]].	^ writeStream contents.! !!XMLAttributeValidator methodsFor: 'initialization'!initializeWithValidatorsFrom: aValidatorContainer	(self mustFurtherNormalizeAttributeValue		and: [self defaultValidator isValue])		ifTrue: [			self defaultValidator value:				(self furtherNormalizeAttributeValue:					self defaultValidator value)]! !!XMLAttributeValidator methodsFor: 'testing'!isCData	^ false! !!XMLAttributeValidator methodsFor: 'testing'!isEntities	^ false! !!XMLAttributeValidator methodsFor: 'testing'!isEntity	^ false! !!XMLAttributeValidator methodsFor: 'testing'!isEnumeration	^ false! !!XMLAttributeValidator methodsFor: 'testing'!isID	^ false! !!XMLAttributeValidator methodsFor: 'testing'!isIDRef	^ false! !!XMLAttributeValidator methodsFor: 'testing'!isIDRefs	^ false! !!XMLAttributeValidator methodsFor: 'testing'!isNmtoken	^ false! !!XMLAttributeValidator methodsFor: 'testing'!isNmtokens	^ false! !!XMLAttributeValidator methodsFor: 'testing'!isNotationEnumeration	^ false! !!XMLAttributeValidator methodsFor: 'testing'!isStandaloneExternal	"this is overridden in each standalone external subclass to return	true instead of just returning a boolean inst var to save memory"	^ false! !!XMLAttributeValidator methodsFor: 'testing'!isXMLID	^ false! !!XMLAttributeValidator methodsFor: 'testing'!mustFurtherNormalizeAttributeValue	^ true! !!XMLAttributeValidator methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream		nextPutAll: '(<';		nextPutAll: self element;		space.	self defaultValidator printNameAndValueOn: aStream.	aStream nextPutAll: '>)'.! !!XMLAttributeValidator methodsFor: 'processing'!processAttributes: aDictionary	| attributeAssociation normalizedValue |	attributeAssociation :=		aDictionary			associationAt: self attribute			ifAbsent: [				self defaultValidator processedDefaultForAbsentAttributeValue					ifNotNil: [:defaultValue |						aDictionary							at: self attribute							put: defaultValue].				^ self].	self mustFurtherNormalizeAttributeValue		ifTrue: [			normalizedValue :=				self furtherNormalizeAttributeValue:					attributeAssociation value]		ifFalse: [normalizedValue := attributeAssociation value].	attributeAssociation value:		(self defaultValidator processedDefaultForPresentAttributeValue:			normalizedValue).! !!XMLAttributeValidator methodsFor: 'initialization'!setElement: anElement attribute: anAttribute defaultValidator: aDefaultValidator	element := anElement.	attribute := anAttribute.	defaultValidator := aDefaultValidator.! !!XMLAttributeValidator methodsFor: 'private'!spaceSeparatedListValuesIn: aSpaceSeparatedList do: aBlock	NormalizedSpace		xmlSplit: aSpaceSeparatedList		do: aBlock! !!XMLAttributeValidator methodsFor: 'validating'!validateAttributeDeclaration	(self attribute at: 1) == $x "optimization"		ifTrue: [			(self attribute = 'xml:id')				ifTrue: [^ self validateXMLIDAttributeDeclaration].			(self attribute = 'xml:space')				ifTrue: [^ self validateXMLSpaceAttributeDeclaration]].	self defaultValidator isValue		ifTrue: [				self validateAttributeDefaultValue:				self defaultValidator value].! !!XMLAttributeValidator methodsFor: 'validating'!validateAttributeDefaultValue: aDefaultValue	"This is overridden in subclasses to check default values when validating	the declaration, but CDATA types should not be validated, and ID types	cannot have default values at all"! !!XMLAttributeValidator methodsFor: 'validating'!validateAttributeValue: aValue	"This is overridden in subclasses to check attribute values"! !!XMLAttributeValidator methodsFor: 'validating'!validateAttributes: aDictionary	| attributeAssociation wasAbsent |	wasAbsent := false.	attributeAssociation :=		aDictionary			associationAt: self attribute			ifAbsent: [				wasAbsent := true.				self defaultValidator validatedDefaultForAbsentAttributeValue					ifNil: [^ self]					ifNotNil: [:defaultValue |						aDictionary add: self attribute -> defaultValue]].	wasAbsent		ifFalse: [| normalizedValue |			self mustFurtherNormalizeAttributeValue				ifTrue: [					normalizedValue :=						self furtherNormalizeAttributeValue:							attributeAssociation value.					self isStandaloneExternal						ifTrue: [							"since further normalization just condences multiple spaces							to single spaces and removes trailing and leading spaces,							comparing the sizes after is enough to detect if it was							done"							normalizedValue size = attributeAssociation value size								ifFalse: [									self errorNormalizedStandaloneExternalAttribute]]]				ifFalse: [normalizedValue := attributeAssociation value].			attributeAssociation value:				(self defaultValidator validatedDefaultForPresentAttributeValue:					normalizedValue)].	self validateAttributeValue: attributeAssociation value.! !!XMLAttributeValidator methodsFor: 'validating'!validateXMLIDAttributeDeclaration	self errorInvalidXMLIDAttributeDeclaration! !!XMLAttributeValidator methodsFor: 'validating'!validateXMLSpaceAttributeDeclaration	self errorInvalidXMLSpaceAttributeDeclaration! !!XMLCDataAttributeValidator class methodsFor: 'defaults'!standaloneExternalClass	^ XMLStandaloneExternalCDataAttributeValidator! !!XMLCDataAttributeValidator methodsFor: 'testing'!isCData	^ true! !!XMLCDataAttributeValidator methodsFor: 'testing'!mustFurtherNormalizeAttributeValue	^ false! !!XMLStandaloneExternalCDataAttributeValidator methodsFor: 'testing'!isStandaloneExternal	^ true! !!XMLEntitiesAttributeValidator class methodsFor: 'defaults'!standaloneExternalClass	^ XMLStandaloneExternalEntitiesAttributeValidator! !!XMLEntitiesAttributeValidator methodsFor: 'testing'!isEntities	^ true! !!XMLEntitiesAttributeValidator methodsFor: 'validating'!validateAttributeDefaultValue: aDefaultValue	self		spaceSeparatedListValuesIn: aDefaultValue		do: [:each |			each isXMLName				ifFalse: [self errorInvalidDefaultAttributeValue: aDefaultValue]]! !!XMLEntitiesAttributeValidator methodsFor: 'validating'!validateAttributeValue: aValue	self		spaceSeparatedListValuesIn: aValue		do: [:each |			self unparsedEntityValidator				validateEntityReference: each				inAttribute: self attribute]! !!XMLStandaloneExternalEntitiesAttributeValidator methodsFor: 'testing'!isStandaloneExternal	^ true! !!XMLEntityAttributeValidator class methodsFor: 'defaults'!standaloneExternalClass	^ XMLStandaloneExternalEntityAttributeValidator! !!XMLEntityAttributeValidator methodsFor: 'initialization'!initializeWithValidatorsFrom: aValidatorContainer	super initializeWithValidatorsFrom: aValidatorContainer.	unparsedEntityValidator := aValidatorContainer unparsedEntityValidator! !!XMLEntityAttributeValidator methodsFor: 'testing'!isEntity	^ true! !!XMLEntityAttributeValidator methodsFor: 'accessing'!unparsedEntityValidator	^ unparsedEntityValidator! !!XMLEntityAttributeValidator methodsFor: 'validating'!validateAttributeDefaultValue: aDefaultValue	aDefaultValue isXMLName		ifFalse: [self errorInvalidDefaultAttributeValue: aDefaultValue]! !!XMLEntityAttributeValidator methodsFor: 'validating'!validateAttributeValue: aValue	self unparsedEntityValidator		validateEntityReference: aValue		inAttribute: self attribute! !!XMLStandaloneExternalEntityAttributeValidator methodsFor: 'testing'!isStandaloneExternal	^ true! !!XMLEnumerationAttributeValidator class methodsFor: 'defaults'!standaloneExternalClass	^ XMLStandaloneExternalEnumerationAttributeValidator! !!XMLEnumerationAttributeValidator methodsFor: 'accessing'!allowedValues	^ allowedValues ifNil: [allowedValues := Set new]! !!XMLEnumerationAttributeValidator methodsFor: 'accessing'!allowedValues: anAllowedValuesCollection	allowedValues := anAllowedValuesCollection! !!XMLEnumerationAttributeValidator methodsFor: 'private '!errorEnumerationContainsDuplicateValues	XMLValidationException		formatSignal:			'Declaration for enumeration attribute "{1}" of element ',			'<{2}> contains duplicate values'		with: self attribute		with: self element! !!XMLEnumerationAttributeValidator methodsFor: 'private '!errorInvalidValue: aValue	XMLValidationException		formatSignal: 'Invalid value "{1}" for attribute "{2}" of element <{3}>'		with: aValue		with: self attribute		with: self element! !!XMLEnumerationAttributeValidator methodsFor: 'testing'!isEnumeration	^ true! !!XMLEnumerationAttributeValidator methodsFor: 'validating'!validateAttributeDeclaration	| oldAllowedValues |	oldAllowedValues := self allowedValues.	self allowedValues: oldAllowedValues asSet.	(self allowedValues size < oldAllowedValues size)		ifTrue: [self errorEnumerationContainsDuplicateValues].	super validateAttributeDeclaration.! !!XMLEnumerationAttributeValidator methodsFor: 'validating'!validateAttributeDefaultValue: aDefaultValue	(self allowedValues includes: aDefaultValue)		ifFalse: [self errorInvalidDefaultAttributeValue: aDefaultValue]! !!XMLEnumerationAttributeValidator methodsFor: 'validating'!validateAttributeValue: aValue	(self allowedValues includes: aValue)		ifFalse: [self errorInvalidValue: aValue]! !!XMLEnumerationAttributeValidator methodsFor: 'validating'!validateXMLSpaceAttributeDeclaration	self allowedValues size > 2		ifTrue: [self errorInvalidXMLSpaceAttributeDeclaration].	self allowedValues do: [:each |		(each = 'preserve'			or: [each = 'default'])			ifFalse: [self errorInvalidXMLSpaceAttributeDeclaration]].! !!XMLNotationEnumerationAttributeValidator class methodsFor: 'defaults'!standaloneExternalClass	^ XMLStandaloneExternalNotationEnumerationAttributeValidator! !!XMLNotationEnumerationAttributeValidator methodsFor: 'initialization'!initializeWithValidatorsFrom: aValidatorContainer	super initializeWithValidatorsFrom: aValidatorContainer.	unparedEntityValidator := aValidatorContainer unparsedEntityValidator.! !!XMLNotationEnumerationAttributeValidator methodsFor: 'testing'!isNotationEnumeration	^ true! !!XMLNotationEnumerationAttributeValidator methodsFor: 'accessing'!unparsedEntityValidator	^ unparedEntityValidator! !!XMLNotationEnumerationAttributeValidator methodsFor: 'validating'!validateAttributeDeclaration	self unparsedEntityValidator validateNotationAttributeDeclaration: self.	super validateAttributeDeclaration.! !!XMLNotationEnumerationAttributeValidator methodsFor: 'validating'!validateXMLSpaceAttributeDeclaration	self errorInvalidXMLSpaceAttributeDeclaration! !!XMLStandaloneExternalNotationEnumerationAttributeValidator methodsFor: 'testing'!isStandaloneExternal	^ true! !!XMLStandaloneExternalEnumerationAttributeValidator methodsFor: 'testing'!isStandaloneExternal	^ true! !!XMLIDAttributeValidator class methodsFor: 'defaults'!standaloneExternalClass	^ XMLStandaloneExternalIDAttributeValidator! !!XMLIDAttributeValidator methodsFor: 'accessing'!elementIDValidator	^ elementIDValidator! !!XMLIDAttributeValidator methodsFor: 'accessing'!elementIDValidator: anElementIDValidator	elementIDValidator := anElementIDValidator! !!XMLIDAttributeValidator methodsFor: 'private'!errorIDAttributeMustBeRequiredOrImplied	XMLValidationException		formatSignal:			'Attribute "{1}" of element <{2}> is of ID type and must ',			'be declared #REQUIRED or #IMPLIED'		with: self attribute		with: self element! !!XMLIDAttributeValidator methodsFor: 'initialization'!initializeWithValidatorsFrom: aValidatorContainer	super initializeWithValidatorsFrom: aValidatorContainer.	elementIDValidator := aValidatorContainer elementIDValidator.! !!XMLIDAttributeValidator methodsFor: 'testing'!isID	^ true! !!XMLIDAttributeValidator methodsFor: 'validating'!validateAttributeDeclaration	self elementIDValidator		validateIDAttribute: self attribute		forElement: self element.	super validateAttributeDeclaration.! !!XMLIDAttributeValidator methodsFor: 'validating'!validateAttributeDefaultValue: aDefaultValue	self errorIDAttributeMustBeRequiredOrImplied! !!XMLIDAttributeValidator methodsFor: 'validating'!validateAttributeValue: aValue	self elementIDValidator		validateID: aValue		inAttribute: self attribute! !!XMLStandaloneExternalIDAttributeValidator methodsFor: 'testing'!isStandaloneExternal	^ true! !!XMLStandaloneExternalXMLIDAttributeValidator methodsFor: 'testing'!isStandaloneExternal	^ true! !!XMLXMLIDAttributeValidator class methodsFor: 'defaults'!standaloneExternalClass	^ XMLStandaloneExternalXMLIDAttributeValidator! !!XMLXMLIDAttributeValidator methodsFor: 'testing'!isXMLID	^ true! !!XMLXMLIDAttributeValidator methodsFor: 'validating'!validateAttributeValue: aValue	self elementIDValidator validateXMLID: aValue! !!XMLXMLIDAttributeValidator methodsFor: 'validating'!validateXMLIDAttributeDeclaration! !!XMLIDRefAttributeValidator class methodsFor: 'defaults'!standaloneExternalClass	^ XMLStandaloneExternalIDRefAttributeValidator! !!XMLIDRefAttributeValidator methodsFor: 'accessing'!elementIDValidator	^ elementIDValidator! !!XMLIDRefAttributeValidator methodsFor: 'initialization'!initializeWithValidatorsFrom: aValidatorContainer	super initializeWithValidatorsFrom: aValidatorContainer.	elementIDValidator := aValidatorContainer elementIDValidator.! !!XMLIDRefAttributeValidator methodsFor: 'testing'!isIDRef	^ true! !!XMLIDRefAttributeValidator methodsFor: 'validating'!validateAttributeDefaultValue: aDefaultValue	aDefaultValue isXMLName		ifFalse: [self errorInvalidDefaultAttributeValue: aDefaultValue]! !!XMLIDRefAttributeValidator methodsFor: 'validating'!validateAttributeValue: aValue	self elementIDValidator		validateIDReference: aValue		inAttribute: self attribute! !!XMLIDRefsAttributeValidator class methodsFor: 'defaults'!standaloneExternalClass	^ XMLStandaloneExternalIDRefsAttributeValidator! !!XMLIDRefsAttributeValidator methodsFor: 'testing'!isIDRefs	^ true! !!XMLIDRefsAttributeValidator methodsFor: 'validating'!validateAttributeDefaultValue: aDefaultValue	self		spaceSeparatedListValuesIn: aDefaultValue		do: [:each |			each isXMLName				ifFalse: [self errorInvalidDefaultAttributeValue: aDefaultValue]]! !!XMLIDRefsAttributeValidator methodsFor: 'validating'!validateAttributeValue: aValue	self		spaceSeparatedListValuesIn: aValue		do: [:each |			self elementIDValidator				validateIDReference: each				inAttribute: self attribute]! !!XMLStandaloneExternalIDRefsAttributeValidator methodsFor: 'testing'!isStandaloneExternal	^ true! !!XMLStandaloneExternalIDRefAttributeValidator methodsFor: 'testing'!isStandaloneExternal	^ true! !!XMLNmtokenAttributeValidator class methodsFor: 'defaults'!standaloneExternalClass	^ XMLStandaloneExternalNmtokenAttributeValidator! !!XMLNmtokenAttributeValidator methodsFor: 'private'!errorInvalidNmtoken: aName	XMLValidationException		formatSignal: 'Invalid Nmtoken name "{1}" in attribute "{2}" of element <{3}>'		with: aName		with: self attribute		with: self element! !!XMLNmtokenAttributeValidator methodsFor: 'testing'!isNmtoken	^ true! !!XMLNmtokenAttributeValidator methodsFor: 'validating'!validateAttributeDefaultValue: aDefaultValue	aDefaultValue isXMLNmtoken		ifFalse: [self errorInvalidDefaultAttributeValue: aDefaultValue]! !!XMLNmtokenAttributeValidator methodsFor: 'validating'!validateAttributeValue: aValue	self validateNmtoken: aValue! !!XMLNmtokenAttributeValidator methodsFor: 'validating'!validateNmtoken: aName	aName isXMLNmtoken		ifFalse: [self errorInvalidNmtoken: aName]! !!XMLNmtokensAttributeValidator class methodsFor: 'defaults'!standaloneExternalClass	^ XMLStandaloneExternalNmtokensAttributeValidator! !!XMLNmtokensAttributeValidator methodsFor: 'testing'!isNmtokens	^ true! !!XMLNmtokensAttributeValidator methodsFor: 'validating'!validateAttributeDefaultValue: aDefaultValue	self		spaceSeparatedListValuesIn: aDefaultValue		do: [:each |			each isXMLNmtoken				ifFalse: [self errorInvalidDefaultAttributeValue: aDefaultValue]]! !!XMLNmtokensAttributeValidator methodsFor: 'validating'!validateAttributeValue: aValue	self		spaceSeparatedListValuesIn: aValue		do: [:each | self validateNmtoken: each]! !!XMLStandaloneExternalNmtokensAttributeValidator methodsFor: 'testing'!isStandaloneExternal	^ true! !!XMLStandaloneExternalNmtokenAttributeValidator methodsFor: 'testing'!isStandaloneExternal	^ true! !!XMLClassFinder class methodsFor: 'accessing'!classNamed: aClassName	^ self		classNamed: aClassName		ifAbsent: [nil]! !!XMLClassFinder class methodsFor: 'accessing'!classNamed: aClassName ifAbsent: aBlock	"'self environment at:' is the proper way to get a class that may not	exist, not 'Smalltalk at:', 'Smalltalk globals at:' or '#ClassName asClass'	(assuming both this class and aClassName class are in the same environment)"	^ self environment		at: aClassName asSymbol		ifAbsent: aBlock! !!XMLClassFinder class methodsFor: 'accessing'!classNamed: aClassName ifPresent: aBlock	^ aBlock cull:		(self			classNamed: aClassName			ifAbsent: [^ nil])! !!XMLClassFinder class methodsFor: 'accessing'!classNamed: aClassName ifPresent: aPresentBlock ifAbsent: anAbsentBlock	^ aPresentBlock cull:		(self			classNamed: aClassName			ifAbsent: [^ anAbsentBlock value])! !!XMLClassFinder class methodsFor: 'testing'!hasClassNamed: aClassName	self		classNamed: aClassName		ifAbsent: [^ false].	^ true.! !!XMLConfiguration methodsFor: 'accessing'!decodesCharacters	^ decodesCharacters! !!XMLConfiguration methodsFor: 'accessing'!decodesCharacters: aBoolean	decodesCharacters := aBoolean! !!XMLConfiguration methodsFor: 'defaults'!defaultParserHandlerClass	^ SAXHandler! !!XMLConfiguration methodsFor: 'accessing'!documentReadLimit	^ self parserLimits documentReadLimit! !!XMLConfiguration methodsFor: 'accessing'!documentReadLimit: anInteger	self parserLimits documentReadLimit: anInteger! !!XMLConfiguration methodsFor: 'accessing'!entityConfiguration	^ entityConfiguration ifNil: [entityConfiguration := DTDEntityConfiguration new]! !!XMLConfiguration methodsFor: 'accessing'!entityConfiguration: anEntityConfiguration	entityConfiguration := anEntityConfiguration! !!XMLConfiguration methodsFor: 'accessing'!externalEntityResolver	^ self entityConfiguration externalEntityResolver! !!XMLConfiguration methodsFor: 'accessing'!externalEntityResolver: anExternalEntityResolver	self entityConfiguration externalEntityResolver: anExternalEntityResolver! !!XMLConfiguration methodsFor: 'initialization'!initialize	super initialize.	"always used, so explicitly initialized"	isValidating := true.	usesNamespaces := true.	decodesCharacters := true.	requiresSchema := false.	parserLimits := XMLParserLimits new.! !!XMLConfiguration methodsFor: 'accessing'!isValidating	^ isValidating! !!XMLConfiguration methodsFor: 'accessing'!isValidating: aBoolean	(isValidating := aBoolean)		ifTrue: [self preservesUndeclaredEntityReferences: false]		ifFalse: [self requiresSchema: false]! !!XMLConfiguration methodsFor: 'accessing'!maxEntityReplacementDepth	^ self parserLimits maxEntityReplacementDepth! !!XMLConfiguration methodsFor: 'accessing'!maxEntityReplacementDepth: anInteger	self parserLimits maxEntityReplacementDepth: anInteger! !!XMLConfiguration methodsFor: 'accessing'!parserHandlerClass	^ parserHandlerClass ifNil: [parserHandlerClass := self defaultParserHandlerClass]! !!XMLConfiguration methodsFor: 'accessing'!parserHandlerClass: aClass	parserHandlerClass := aClass! !!XMLConfiguration methodsFor: 'accessing'!parserLimits	^ parserLimits! !!XMLConfiguration methodsFor: 'accessing'!parserLimits: aParserLimits	parserLimits := aParserLimits! !!XMLConfiguration methodsFor: 'copying'!postCopy	super postCopy.	parserLimits := parserLimits copy.	entityConfiguration		ifNotNil: [entityConfiguration := entityConfiguration copy].! !!XMLConfiguration methodsFor: 'accessing'!preservesUndeclaredEntityReferences	^ self entityConfiguration preservesUndeclaredEntityReferences! !!XMLConfiguration methodsFor: 'accessing'!preservesUndeclaredEntityReferences: aBoolean	self entityConfiguration preservesUndeclaredEntityReferences: aBoolean.	aBoolean		ifTrue: [self isValidating: false].! !!XMLConfiguration methodsFor: 'removing'!removeLimits	self parserLimits removeAll.	self externalEntityResolver removeLimits.! !!XMLConfiguration methodsFor: 'accessing'!replacesContentEntityReferences	^ self entityConfiguration replacesContentEntityReferences! !!XMLConfiguration methodsFor: 'accessing'!replacesContentEntityReferences: aBoolean	self entityConfiguration replacesContentEntityReferences: aBoolean! !!XMLConfiguration methodsFor: 'deprecated'!requiresDocumentConstraints	^ self requiresSchema! !!XMLConfiguration methodsFor: 'deprecated'!requiresDocumentConstraints: aBoolean	"will be deprecated; use #requiresSchema: instead"	self requiresSchema: aBoolean! !!XMLConfiguration methodsFor: 'accessing'!requiresSchema	^ requiresSchema! !!XMLConfiguration methodsFor: 'accessing'!requiresSchema: aBoolean	(requiresSchema := aBoolean)		ifTrue: [self isValidating: true]! !!XMLConfiguration methodsFor: 'accessing'!resolvesExternalEntities	^ self entityConfiguration resolvesExternalEntities! !!XMLConfiguration methodsFor: 'accessing'!resolvesExternalEntities: aBoolean	self entityConfiguration resolvesExternalEntities: aBoolean! !!XMLConfiguration methodsFor: 'accessing'!usesNamespaces	^ usesNamespaces! !!XMLConfiguration methodsFor: 'accessing'!usesNamespaces: aBoolean	usesNamespaces := aBoolean! !!XMLDOMConfiguration methodsFor: 'accessing'!attributeListClass	^ self nodeFactory attributeListClass! !!XMLDOMConfiguration methodsFor: 'accessing'!attributeListClass: aClass	self nodeFactory:		(self nodeFactory asPluggableNodeFactory attributeListClass: aClass)! !!XMLDOMConfiguration methodsFor: 'defaults'!defaultNodeFactoryClass	^ XMLNodeFactory! !!XMLDOMConfiguration methodsFor: 'defaults'!defaultParserHandlerClass	^ XMLDOMParser! !!XMLDOMConfiguration methodsFor: 'initialization'!initialize	super initialize.	"always used, so explicitly initialized"	preservesCDataNodes := false.	preservesCommentNodes := false.	preservesIgnorableWhitespace := false.	nodeFactory := self defaultNodeFactoryClass new.! !!XMLDOMConfiguration methodsFor: 'accessing'!isValidating: aBoolean	aBoolean		ifFalse: [self preservesIgnorableWhitespace: false].	super isValidating: aBoolean.! !!XMLDOMConfiguration methodsFor: 'accessing'!nodeFactory	^ nodeFactory! !!XMLDOMConfiguration methodsFor: 'accessing'!nodeFactory: aFactory	nodeFactory := aFactory! !!XMLDOMConfiguration methodsFor: 'accessing'!nodeListClass	^ self nodeFactory nodeListClass! !!XMLDOMConfiguration methodsFor: 'accessing'!nodeListClass: aClass	self nodeFactory:		(self nodeFactory asPluggableNodeFactory nodeListClass: aClass)! !!XMLDOMConfiguration methodsFor: 'copying'!postCopy	super postCopy.	nodeFactory := nodeFactory copy.! !!XMLDOMConfiguration methodsFor: 'accessing'!preservesCDataNodes	^ preservesCDataNodes! !!XMLDOMConfiguration methodsFor: 'accessing'!preservesCDataNodes: aBoolean	preservesCDataNodes := aBoolean! !!XMLDOMConfiguration methodsFor: 'accessing'!preservesCommentNodes	^ preservesCommentNodes! !!XMLDOMConfiguration methodsFor: 'accessing'!preservesCommentNodes: aBoolean	preservesCommentNodes := aBoolean! !!XMLDOMConfiguration methodsFor: 'accessing'!preservesIgnorableWhitespace	^ preservesIgnorableWhitespace! !!XMLDOMConfiguration methodsFor: 'accessing'!preservesIgnorableWhitespace: aBoolean	(preservesIgnorableWhitespace := aBoolean)		ifTrue: [self isValidating: true]! !!XMLDFAState class methodsFor: 'instance creation'!nfaStates: anNFAStateSet	^ self		nfaStates: anNFAStateSet		dfaStateCache: nil! !!XMLDFAState class methodsFor: 'instance creation'!nfaStates: anNFAStateSet dfaStateCache: aDFAStateCache	^ self new		setNFAStates: anNFAStateSet		dfaStateCache: aDFAStateCache! !!XMLDFAState methodsFor: 'private'!addDFAStateTransitionMatching: aMatcher	| matchingNFAStates totalMatched matchingDFAState |	self dfaStateTransitions size >= self maxDFAStateTransitions		ifTrue: [self removeDFAStateTransitions].	matchingNFAStates := XMLNFAStateSet new.	totalMatched := 0.	self nfaStatesDo: [:state |		(state matches: aMatcher)			ifTrue: [				state nextState addTo: matchingNFAStates.				totalMatched := totalMatched + 1]].	matchingNFAStates size > 0		ifTrue: [			matchingDFAState :=				dfaStateCache dfaStateForNFAStates: matchingNFAStates.			totalMatched > 1				ifTrue: [matchingDFAState hasNonDeterminism: true]].	^ self dfaStateTransitions		at: aMatcher		put: matchingDFAState. "nil if no match"! !!XMLDFAState methodsFor: 'private'!dfaStateCache	^ dfaStateCache! !!XMLDFAState methodsFor: 'private'!dfaStateTransitions	^ dfaStateTransitions ifNil: [dfaStateTransitions := Dictionary new]! !!XMLDFAState methodsFor: 'testing'!hasNonDeterminism	^ hasNonDeterminism! !!XMLDFAState methodsFor: 'accessing'!hasNonDeterminism: aBoolean	hasNonDeterminism := aBoolean! !!XMLDFAState methodsFor: 'testing'!isAccepting	^ nfaStates isAccepting! !!XMLDFAState methodsFor: 'private'!maxDFAStateTransitions	^ 64! !!XMLDFAState methodsFor: 'matching'!nextDFAStateMatching: aMatcher	^ self		nextDFAStateMatching: aMatcher		ifNone: [nil]! !!XMLDFAState methodsFor: 'matching'!nextDFAStateMatching: aMatcher ifNone: aBlock	^ (self dfaStateTransitions		at: aMatcher		ifAbsent: [self addDFAStateTransitionMatching: aMatcher])			ifNil: [aBlock value]! !!XMLDFAState methodsFor: 'accessing'!nfaStates	^ nfaStates! !!XMLDFAState methodsFor: 'enumerating'!nfaStatesDo: aBlock	nfaStates do: aBlock! !!XMLDFAState methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		print: self nfaStates;		nextPut: $).! !!XMLDFAState methodsFor: 'private'!removeDFAStateTransitions	dfaStateTransitions := nil! !!XMLDFAState methodsFor: 'initialization'!setNFAStates: anNFAStateSet dfaStateCache: aDFAStateCache	nfaStates := anNFAStateSet.	dfaStateCache :=		aDFAStateCache				ifNil: [XMLDFAStateCache firstDFAState: self].	hasNonDeterminism := false.! !!XMLDFAStateCache class methodsFor: 'instance creation'!firstDFAState: aDFAState	^ self new setFirstDFAState: aDFAState! !!XMLDFAStateCache methodsFor: 'private'!addDFAStateForNFAStates: anNFAStateSet	cachedDFAStates size >= self maxCachedDFAStates		ifTrue: [self removeDFAStates].	^ cachedDFAStates		at: anNFAStateSet		put: (anNFAStateSet asDFAStateWithStateCache: self).! !!XMLDFAStateCache methodsFor: 'private'!cachedDFAStates	^ cachedDFAStates! !!XMLDFAStateCache methodsFor: 'accessing'!dfaStateForNFAStates: anNFAStateSet	^ cachedDFAStates		at: anNFAStateSet		ifAbsent: [self addDFAStateForNFAStates: anNFAStateSet]! !!XMLDFAStateCache methodsFor: 'accessing'!firstDFAState	^ firstDFAState! !!XMLDFAStateCache methodsFor: 'private'!maxCachedDFAStates	^ 64! !!XMLDFAStateCache methodsFor: 'private'!removeDFAStates	cachedDFAStates		valuesDo: [:each | each removeDFAStateTransitions];		removeAll.	cachedDFAStates		at: firstDFAState nfaStates		put: firstDFAState.! !!XMLDFAStateCache methodsFor: 'initialization'!setFirstDFAState: aDFAState	firstDFAState := aDFAState.	(cachedDFAStates := Dictionary new: 5)		at: firstDFAState nfaStates		put: firstDFAState.! !!DTDDocumentValidator class methodsFor: 'instance creation'!doctypeDefinition: aDoctypeDefinition	^ self new doctypeDefinition: aDoctypeDefinition! !!DTDDocumentValidator methodsFor: 'accessing'!attributeValidatorsFor: anElement ifNone: aBlock	^ self doctypeDefinition		attributeValidatorsAt: anElement		ifAbsent: aBlock! !!DTDDocumentValidator methodsFor: 'accessing'!doctypeDefinition	^ doctypeDefinition! !!DTDDocumentValidator methodsFor: 'accessing'!doctypeDefinition: aDoctypeDefinition	doctypeDefinition := aDoctypeDefinition! !!DTDDocumentValidator methodsFor: 'accessing'!elementValidatorFor: anElement ifNone: aBlock	^ self doctypeDefinition		elementValidatorsAt: anElement		ifAbsent: aBlock! !!DTDDocumentValidator methodsFor: 'private'!errorInvalidRootElement: anElement	XMLValidationException		formatSignal:			'Root element must be <{1}> according to DOCTYPE declaration, not <{2}>'		with: self doctypeDefinition root		with: anElement! !!DTDDocumentValidator methodsFor: 'testing'!hasAttributeValidators	^ self doctypeDefinition hasAttributeValidators! !!DTDDocumentValidator methodsFor: 'testing'!hasElementValidators	^ self doctypeDefinition hasElementValidators! !!DTDDocumentValidator methodsFor: 'validating'!unvalidatedAttributes: anAttributeCollection inElement: anElement	XMLValidationException		formatSignal: 'Undeclared attribute "{1}" in element <{2}>'		with: anAttributeCollection anyOne		with: anElement! !!DTDDocumentValidator methodsFor: 'validating'!unvalidatedElement: anElement	XMLValidationException		formatSignal: 'Undeclared element <{1}>'		with: anElement! !!DTDDocumentValidator methodsFor: 'validating'!validateIDReferences	self doctypeDefinition hasElementIDReferences		ifTrue: [self doctypeDefinition elementIDValidator validateIDReferences]! !!DTDDocumentValidator methodsFor: 'validating'!validateRootElement: anElement	(self doctypeDefinition hasRoot		and: [self doctypeDefinition root ~= anElement])		ifTrue: [self errorInvalidRootElement: anElement]! !!XMLDocumentValidator methodsFor: 'accessing'!attributeValidatorsFor: anElement	^ self		attributeValidatorsFor: anElement		ifNone: [nil]! !!XMLDocumentValidator methodsFor: 'accessing'!attributeValidatorsFor: anElement ifNone: aBlock	self subclassResponsibility! !!XMLDocumentValidator methodsFor: 'accessing'!currentElementValidator	^ self elementValidatorStack xmlLastOrNil! !!XMLDocumentValidator methodsFor: 'accessing'!defaultElementValidatorFor: aName	^ XMLAnyElementValidator element: aName! !!XMLDocumentValidator methodsFor: 'private'!defaultXMLIDValidator	"used to validate xml:id attributes if there's no DTD or other validators"	^ defaultXMLIDValidator		ifNil: [			defaultXMLIDValidator :=				XMLXMLIDAttributeValidator					element: ''					attribute: 'xml:id'					defaultValidator:						(XMLAttributeImpliedDefaultValidator attribute: 'xml:id').			defaultXMLIDValidator				elementIDValidator: XMLElementIDValidator new;				yourself]! !!XMLDocumentValidator methodsFor: 'accessing'!elementValidatorFor: anElement	^ self		elementValidatorFor: anElement		ifNone: [nil]! !!XMLDocumentValidator methodsFor: 'accessing'!elementValidatorFor: anElement ifNone: aBlock	self subclassResponsibility! !!XMLDocumentValidator methodsFor: 'accessing'!elementValidatorStack	^ elementValidatorStack ifNil: [elementValidatorStack := OrderedCollection new]! !!XMLDocumentValidator methodsFor: 'private'!errorUnexpectEndOfElement: anElement	XMLValidationException		formatSignal: 'Element <{1}> terminated prematurely'		with: anElement! !!XMLDocumentValidator methodsFor: 'testing'!hasAttributeValidators	self subclassResponsibility! !!XMLDocumentValidator methodsFor: 'testing'!hasCurrentElementValidator	"optimized to avoid lazy initialization"	elementValidatorStack == nil		ifTrue: [^ false].	^ elementValidatorStack size > 0.! !!XMLDocumentValidator methodsFor: 'testing'!hasElementValidators	self subclassResponsibility! !!XMLDocumentValidator methodsFor: 'testing'!isCurrentElementWhitespaceIgnorable	^ self hasCurrentElementValidator		and: [self currentElementValidator ignoresWhitespace]! !!XMLDocumentValidator methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	self hasCurrentElementValidator		ifTrue: [			aStream				nextPut: $(;				print: self currentElementValidator;				nextPut: $)].! !!XMLDocumentValidator methodsFor: 'validating'!unvalidatedAttributes: anAttributeCollection inElement: anElement	"sent when at least one attribute of an element wasn't validated by an	attribute validator and there are element or attribute validators defined"! !!XMLDocumentValidator methodsFor: 'validating'!unvalidatedElement: anElement	"sent when an element was not validated by an element validator	and there are element or attribute validators defined"! !!XMLDocumentValidator methodsFor: 'validating'!validateAttributes: aDictionary withAttributeValidatorsFor: anElement	| totalUnvalidatedAttributes validatedAttributes |	totalUnvalidatedAttributes := aDictionary size.	(self attributeValidatorsFor: anElement)		ifNotNil: [:attributeValidators |			attributeValidators keysAndValuesDo: [:attribute :validator |				(aDictionary includesKey: attribute)					ifTrue: [						"only initialize if needed, and as an OrderedCollection that						is only converted to a Set later if needed, for permformance"						(validatedAttributes							ifNil: [								validatedAttributes :=									OrderedCollection new: totalUnvalidatedAttributes])							addLast: attribute.						totalUnvalidatedAttributes := totalUnvalidatedAttributes - 1].				validator validateAttributes: aDictionary]].	totalUnvalidatedAttributes > 0		ifTrue: [			self				unvalidatedAttributes:					(validatedAttributes						ifNil: [aDictionary keys]						ifNotNil: [| validatedAttributesSet |							validatedAttributesSet := validatedAttributes asSet.							aDictionary keys reject: [:each |								validatedAttributesSet includes: each]])				inElement: anElement].! !!XMLDocumentValidator methodsFor: 'validating'!validateComment: aString	self hasCurrentElementValidator		ifTrue: [self currentElementValidator validateComment: aString]! !!XMLDocumentValidator methodsFor: 'validating'!validateEndDocument	self validateIDReferences! !!XMLDocumentValidator methodsFor: 'validating'!validateEndTag: anElement	self hasCurrentElementValidator		ifTrue: [			self currentElementValidator atEnd				ifFalse: [self errorUnexpectEndOfElement: anElement].			self elementValidatorStack removeLast]! !!XMLDocumentValidator methodsFor: 'validating'!validateIDReferences	self subclassResponsibility! !!XMLDocumentValidator methodsFor: 'validating'!validatePCData: aString	self hasCurrentElementValidator		ifTrue: [self currentElementValidator validatePCData: aString]! !!XMLDocumentValidator methodsFor: 'validating'!validatePI: aTargetString data: aDataString	self hasCurrentElementValidator		ifTrue: [			self currentElementValidator				validatePI: aTargetString				data: aDataString]! !!XMLDocumentValidator methodsFor: 'validating'!validateRootElement: anElement! !!XMLDocumentValidator methodsFor: 'validating'!validateStartTag: anElement	self currentElementValidator		ifNotNil: [:elementValidator |			elementValidator validateStartTag: anElement].	self elementValidatorStack addLast:		(self			elementValidatorFor: anElement			ifNone: [				self					unvalidatedElement: anElement;					defaultElementValidatorFor: anElement]) asReadyElementValidator.! !!XMLDocumentValidator methodsFor: 'validating'!validateStartTag: anElement attributes: aDictionary	(self hasElementValidators		or: [self hasAttributeValidators])		ifTrue: [			self validateStartTag: anElement.			self				validateAttributes: aDictionary				withAttributeValidatorsFor: anElement]! !!XMLDocumentValidator methodsFor: 'validating'!validateXMLIDAttributeIn: aDictionary	self hasAttributeValidators		ifFalse: [self defaultXMLIDValidator validateAttributes: aDictionary]! !!XMLBasicElementClassMapper methodsFor: 'accessing'!classForElement: aQualifiedName attributes: anAssociationCollection ifNone: aBlock	^ self		classForElement: aQualifiedName		namespaceURI: ''		attributes: anAssociationCollection		ifNone: aBlock! !!XMLBasicElementClassMapper methodsFor: 'accessing'!classForElement: aQualifiedName ifNone: aBlock	^ self		classForElement: aQualifiedName		namespaceURI: ''		attributes: XMLLazyAttributeDictionary  new		ifNone: aBlock! !!XMLBasicElementClassMapper methodsFor: 'accessing'!classForElement: aQualifiedName namespaceURI: aURI attributes: anAssociationCollection ifNone: aBlock	| localName attributeDictionary |	attributeDictionary := anAssociationCollection asXMLAttributeDictionary.	aURI size > 0 "optimization"		ifTrue: [			(self				elementClassMapAt: aQualifiedName -> aURI				attributes: attributeDictionary)				ifNotNil: [:class | ^ class].			(self				elementClassMapAt: aQualifiedName				attributes: attributeDictionary)				ifNotNil: [:class | ^ class].			(localName := aQualifiedName xmlLocalNameAfterPrefix) size <				aQualifiedName size				ifTrue: [					(self						elementClassMapAt: localName -> aURI						attributes: attributeDictionary)						ifNotNil: [:class | ^ class].					(self						elementClassMapAt: localName						attributes: attributeDictionary)						ifNotNil: [:class | ^ class]]]		ifFalse: [			(self				elementClassMapAt: aQualifiedName				attributes: attributeDictionary)				ifNotNil: [:class | ^ class].			(localName := aQualifiedName xmlLocalNameAfterPrefix) size <				aQualifiedName size				ifTrue: [					(self						elementClassMapAt: localName						attributes: attributeDictionary)						ifNotNil: [:class | ^ class]]].	^ aBlock value.! !!XMLBasicElementClassMapper methodsFor: 'accessing'!classForElement: aQualifiedName namespaceURI: aURI ifNone: aBlock	^ self		classForElement: aQualifiedName		namespaceURI: aURI		attributes: XMLLazyAttributeDictionary new		ifNone: aBlock! !!XMLBasicElementClassMapper methodsFor: 'accessing'!classForElement: aQualifiedName namespaceURI: aURI localName: aLocalName attributes: anAssociationCollection ifNone: aBlock	| attributeDictionary |	attributeDictionary := anAssociationCollection.	aURI size > 0 "optimization"		ifTrue: [			(self				elementClassMapAt: aQualifiedName -> aURI				attributes: attributeDictionary)				ifNotNil: [:class | ^ class].			(self				elementClassMapAt: aQualifiedName				attributes: attributeDictionary)				ifNotNil: [:class | ^ class].			aLocalName size < aQualifiedName size				ifTrue: [					(self						elementClassMapAt: aLocalName -> aURI						attributes: attributeDictionary)						ifNotNil: [:class | ^ class].					(self						elementClassMapAt: aLocalName						attributes: attributeDictionary)						ifNotNil: [:class | ^ class]]]		ifFalse: [			(self				elementClassMapAt: aQualifiedName				attributes: attributeDictionary)				ifNotNil: [:class | ^ class].			aLocalName size < aQualifiedName size				ifTrue: [					(self						elementClassMapAt: aLocalName						attributes: attributeDictionary)						ifNotNil: [:class | ^ class]]].	^ aBlock value.! !!XMLBasicElementClassMapper methodsFor: 'private'!elementClassMap	^ elementClassMap! !!XMLBasicElementClassMapper methodsFor: 'private'!elementClassMapAt: aKey attributes: anAttributeDictionary	| classOrCollection |	classOrCollection :=		elementClassMap			at: aKey			ifAbsent: [^ nil].	classOrCollection isCollection		ifTrue: [			"to:do: for speed"			1 to: classOrCollection size - 1 do: [:i |				((classOrCollection at: i) key					matchesAttributes: anAttributeDictionary)					ifTrue: [^ (classOrCollection at: i) value]].			^ classOrCollection last]		ifFalse: [^ classOrCollection].! !!XMLBasicElementClassMapper methodsFor: 'initialization'!initialize	super initialize.	elementClassMap := Dictionary new.! !!XMLBasicElementClassMapper methodsFor: 'mapping'!mapElement: anElement attributeSpec: anAttributeSpec toClass: aClass	| classOrCollection |	classOrCollection :=		elementClassMap			at: anElement			ifAbsent: [nil].	classOrCollection isCollection		ifTrue: [			"new mappings have precedence over old"			classOrCollection addFirst: anAttributeSpec -> aClass]		ifFalse: [			elementClassMap				at: anElement				put:					(OrderedCollection						with: anAttributeSpec -> aClass						with: classOrCollection)].! !!XMLBasicElementClassMapper methodsFor: 'mapping'!mapElement: anElement namespaceURI: aURI attributeSpec: anAttributeSpec toClass: aClass	self		mapElement:			(aURI size > 0				ifTrue: [anElement -> aURI]				ifFalse: [anElement])		attributeSpec: anAttributeSpec		toClass: aClass! !!XMLBasicElementClassMapper methodsFor: 'mapping'!mapElement: anElement namespaceURI: aURI toClass: aClass	self		mapElement:			(aURI size > 0				ifTrue: [anElement -> aURI]				ifFalse: [anElement])		toClass: aClass! !!XMLBasicElementClassMapper methodsFor: 'mapping'!mapElement: anElement toClass: aClass	| classOrCollection |	classOrCollection :=		elementClassMap			at: anElement			ifAbsent: [nil].	classOrCollection isCollection		ifTrue: [			classOrCollection				at: classOrCollection size				put: aClass]		ifFalse: [			elementClassMap				at: anElement				put: aClass].! !!XMLBasicElementClassMapper methodsFor: 'copying'!postCopy	super postCopy.	elementClassMap := elementClassMap copy.	"each val is either a class or an OrderedCollection, which needs	to be copied so new mappings in either the copy or original don't	effect the other"	elementClassMap associationsDo: [:each |		each value isCollection			ifTrue: [each value: each value copy]].! !!XMLElementClassMapper methodsFor: 'private'!camelCasedNameFromClassNameSegments: aNameSegmentCollection	^ String streamContents: [:stream |		aNameSegmentCollection withIndexDo: [:each :i |			stream nextPutAll:				(i > 1					ifTrue: [each]					ifFalse: [each asLowercase])]]! !!XMLElementClassMapper methodsFor: 'accessing'!classForElement: aQualifiedName	^ self		classForElement: aQualifiedName		ifNone: [nil]! !!XMLElementClassMapper methodsFor: 'accessing'!classForElement: aQualifiedName attributes: anAssociationCollection	^ self		classForElement: aQualifiedName		attributes: anAssociationCollection		ifNone: [nil]! !!XMLElementClassMapper methodsFor: 'accessing'!classForElement: aQualifiedName attributes: anAssociationCollection ifNone: aBlock	self subclassResponsibility! !!XMLElementClassMapper methodsFor: 'accessing'!classForElement: aQualifiedName ifNone: aBlock	self subclassResponsibility! !!XMLElementClassMapper methodsFor: 'accessing'!classForElement: aQualifiedName namespaceURI: aURI	^ self		classForElement: aQualifiedName		namespaceURI: aURI		ifNone: [nil]! !!XMLElementClassMapper methodsFor: 'accessing'!classForElement: aQualifiedName namespaceURI: aURI attributes: anAssociationCollection	^ self		classForElement: aQualifiedName		namespaceURI: aURI		attributes: anAssociationCollection		ifNone: [nil]! !!XMLElementClassMapper methodsFor: 'accessing'!classForElement: aQualifiedName namespaceURI: aURI attributes: anAssociationCollection ifNone: aBlock	self subclassResponsibility! !!XMLElementClassMapper methodsFor: 'accessing'!classForElement: aQualifiedName namespaceURI: aURI ifNone: aBlock	self subclassResponsibility! !!XMLElementClassMapper methodsFor: 'accessing'!classForElement: aQualifiedName namespaceURI: aURI localName: aLocalName attributes: anAssociationCollection	^ self		classForElement: aQualifiedName		namespaceURI: aURI		localName: aLocalName		attributes: anAssociationCollection		ifNone: [nil]! !!XMLElementClassMapper methodsFor: 'accessing'!classForElement: aQualifiedName namespaceURI: aURI localName: aLocalName attributes: anAssociationCollection ifNone: aBlock	self subclassResponsibility! !!XMLElementClassMapper methodsFor: 'private'!classNameFrom: aClass withoutIgnorableSuffixes: aSuffixCollection	| className |	className := aClass name asString.	aSuffixCollection do: [:each |		(className endsWith: each)			ifTrue: [^ className allButLast: each size]].	^ className.! !!XMLElementClassMapper methodsFor: 'private'!classNameSegmentsFrom: aString	| nameSegments startIndex |	nameSegments := OrderedCollection new.	startIndex := 1.	1 to: aString size do: [:i |		(((aString at: i) isLowercase			and: [aString size >= (i + 1)				and: [(aString at: i + 1) isLowercase not]])			or: [				((aString at: i) isUppercase					and: [aString size >= (i + 2)						and: [(aString at: i + 1) isUppercase							and: [(aString at: i + 2) isUppercase not]]])])			ifTrue: [				nameSegments addLast:					(aString						copyFrom: startIndex						to: i).				startIndex := i + 1]].	startIndex <= aString size		ifTrue: [			nameSegments addLast:				(aString					copyFrom: startIndex					to: aString size)].	^ nameSegments.! !!XMLElementClassMapper methodsFor: 'private'!hyphenatedNameFromClassNameSegments: aNameSegmentCollection	^ String streamContents: [:stream |		aNameSegmentCollection			do: [:each | stream nextPutAll: each asLowercase]			separatedBy: [stream nextPut: $-]]! !!XMLElementClassMapper methodsFor: 'mapping'!mapAllMatchingElementsToClass: aClass ignoringSuffixes: aSuffixCollection	| classNameWithoutSuffixes classNameSegments totalClassNameSegments |	classNameWithoutSuffixes :=		self			classNameFrom: aClass			withoutIgnorableSuffixes: aSuffixCollection.	classNameSegments := self classNameSegmentsFrom: classNameWithoutSuffixes.	(totalClassNameSegments := classNameSegments size) > 0		ifFalse: [^ self].	"remove the class prefix if any"	totalClassNameSegments > 1		ifTrue: [classNameSegments removeFirst].	self		mapElement:			(self nameFromClassNameSegments: classNameSegments)		toClass: aClass.	self		mapElement:			(self camelCasedNameFromClassNameSegments: classNameSegments)		toClass: aClass.	self		mapElement:			(self hyphenatedNameFromClassNameSegments: classNameSegments)		toClass: aClass.	self		mapElement:			(self underscoredNameFromClassNameSegments: classNameSegments)		toClass: aClass.! !!XMLElementClassMapper methodsFor: 'mapping'!mapAllMatchingElementsToClasses: aClassCollection ignoringSuffixes: aSuffixCollection	aClassCollection do: [:each |		self			mapAllMatchingElementsToClass: each			ignoringSuffixes: aSuffixCollection]! !!XMLElementClassMapper methodsFor: 'mapping'!mapElement: anElement attributeSpec: anAttributeSpec toClass: aClass	self subclassResponsibility! !!XMLElementClassMapper methodsFor: 'mapping'!mapElement: anElement namespaceURI: aURI attributeSpec: anAttributeSpec toClass: aClass	self subclassResponsibility! !!XMLElementClassMapper methodsFor: 'mapping'!mapElement: anElement namespaceURI: aURI toClass: aClass	self subclassResponsibility! !!XMLElementClassMapper methodsFor: 'mapping'!mapElement: anElement toClass: aClass	self subclassResponsibility! !!XMLElementClassMapper methodsFor: 'mapping'!mapElements: anElementCollection namespaceURI: aNamespaceURI toClass: aClass	anElementCollection do: [:each |		self			mapElement: each			namespaceURI: aNamespaceURI			toClass: aClass]! !!XMLElementClassMapper methodsFor: 'mapping'!mapElements: anElementCollection toClass: aClass	anElementCollection do: [:each |		self			mapElement: each			toClass: aClass]! !!XMLElementClassMapper methodsFor: 'private'!nameFromClassNameSegments: aNameSegmentCollection	"avoid join: for Squeak/GS portability"	^ String streamContents: [:stream |		aNameSegmentCollection do: [:each | stream nextPutAll: each]]! !!XMLElementClassMapper methodsFor: 'private'!underscoredNameFromClassNameSegments: aNameSegmentCollection	^ String streamContents: [:stream |		aNameSegmentCollection			do: [:each | stream nextPutAll: each asLowercase]			separatedBy: [stream nextPut: $_]]! !!XMLElementIDValidator methodsFor: 'accessing'!elementsAndIDAttributes	^ elementsAndIdAttributes ifNil: [elementsAndIdAttributes := Dictionary new]! !!XMLElementIDValidator methodsFor: 'private'!errorDuplicateID: anID inAttribute: anAttribute	XMLValidationException		formatSignal: 'Duplicate element ID "{1}" used in attribute "{2}"'		with: anID		with: anAttribute! !!XMLElementIDValidator methodsFor: 'private'!errorInvalidID: anID inAttribute: anAttribute	XMLValidationException		formatSignal: 'Invalid element ID value "{1}" in attribute "{2}"'		with: anID		with: anAttribute! !!XMLElementIDValidator methodsFor: 'private'!errorMultipleIDAttributesForElement: anElement	XMLValidationException		formatSignal: 'Element <{1}> has multiple ID attributes'		with: anElement! !!XMLElementIDValidator methodsFor: 'private'!errorUnknownIDReference: anID	XMLValidationException		formatSignal: 'Reference to unknown element ID "{1}"'		with: anID! !!XMLElementIDValidator methodsFor: 'testing'!hasIDReferences	^ idReferences notNil		and: [idReferences notEmpty]! !!XMLElementIDValidator methodsFor: 'testing'!hasIDs	^ ids notNil		and: [ids notEmpty]! !!XMLElementIDValidator methodsFor: 'accessing'!idReferences	^ idReferences ifNil: [idReferences := Set new]! !!XMLElementIDValidator methodsFor: 'accessing'!ids	^ ids ifNil: [ids := Set new]! !!XMLElementIDValidator methodsFor: 'removing'!removeIDReferences	"Gemstone's Set does not understand removeAll, so nil reassignment	is used instead (will be lazy initialized by accessors)"	idReferences := nil! !!XMLElementIDValidator methodsFor: 'removing'!removeIDs	"Gemstone's Set does not understand removeAll, so nil reassignment	is used instead (will be lazy initialized by accessors)"	ids := nil! !!XMLElementIDValidator methodsFor: 'validating'!validateID: anID inAttribute: anAttribute	anID isXMLName		ifFalse: [			self				errorInvalidID: anID				inAttribute: anAttribute].	self		validateUniquenessOfID: anID		inAttribute: anAttribute.! !!XMLElementIDValidator methodsFor: 'validating'!validateIDAttribute: anAttribute forElement: anElement	| oldSize |	"checking size after is faster than includes test"	oldSize := self elementsAndIDAttributes size.	(self elementsAndIDAttributes		at: anElement		put: anAttribute;		size) > oldSize		ifFalse: [self errorMultipleIDAttributesForElement: anElement].! !!XMLElementIDValidator methodsFor: 'validating'!validateIDReference: anID inAttribute: anAttribute	anID isXMLName		ifFalse: [			self				errorInvalidID: anID				inAttribute: anAttribute].	self idReferences add: anID.! !!XMLElementIDValidator methodsFor: 'validating'!validateIDReferences	self idReferences do: [:each |		(self ids includes: each)			ifFalse: [self errorUnknownIDReference: each]]! !!XMLElementIDValidator methodsFor: 'private'!validateUniquenessOfID: anID inAttribute: anAttribute	| oldSize |	"checking size after is faster than includes test"	oldSize := self ids size.	(self ids		add: anID;		size) > oldSize		ifFalse: [			self				errorDuplicateID: anID				inAttribute: anAttribute].! !!XMLElementIDValidator methodsFor: 'validating'!validateXMLID: anID	anID isXMLNCName		ifFalse: [			self				errorInvalidID: anID				inAttribute: 'xml:id'].	self		validateUniquenessOfID: anID		inAttribute: 'xml:id'.! !!XMLElementNester methodsFor: 'private'!copiedScopedAttributes	| copiedAttributes |	copiedAttributes :=		self hasScopedAttributes			ifTrue: [self scopedAttributes removeLast copy]			ifFalse: [Dictionary new].	self scopedAttributes addLast: copiedAttributes.	^ copiedAttributes.! !!XMLElementNester methodsFor: 'accessing'!currentElement	^ self openElements xmlLastOrNil! !!XMLElementNester methodsFor: 'accessing'!currentElement: anElement	self hasOpenElements		ifTrue: [			self openElements				at: self totalOpenElements				put: anElement]		ifFalse: [self setExternalRootElement: anElement]! !!XMLElementNester methodsFor: 'accessing'!currentScopedAttributes	^ self scopedAttributes xmlLastOrNil! !!XMLElementNester methodsFor: 'private'!elementPrintLimit	^ 5! !!XMLElementNester methodsFor: 'nesting'!endCurrentElement	(self openElements		removeLast;		size) > 0		ifFalse: [			isInElement := hasExternalRootElement.			wasRootElementEnded := hasExternalRootElement not].	self hasScopedAttributes		ifTrue: [self endScopedAttributes].! !!XMLElementNester methodsFor: 'private'!endScopedAttributes	scopedAttributes removeLast! !!XMLElementNester methodsFor: 'testing'!hasExternalRootElement	^ hasExternalRootElement! !!XMLElementNester methodsFor: 'testing'!hasOpenElement: anElement	^ self openElements includes: anElement! !!XMLElementNester methodsFor: 'testing'!hasOpenElements	^ self openElements size > 0! !!XMLElementNester methodsFor: 'testing'!hasScopedAttributes	"optimized to avoid lazy initialization"	scopedAttributes == nil		ifTrue: [^ false].	^ scopedAttributes size > 0.! !!XMLElementNester methodsFor: 'initialization'!initialize	super initialize.	openElements := OrderedCollection new: 10.	hasExternalRootElement := false.	wasRootElementEnded := false.	isInElement := false.! !!XMLElementNester methodsFor: 'testing'!isInElement	^ isInElement! !!XMLElementNester methodsFor: 'accessing'!openElements	^ openElements! !!XMLElementNester methodsFor: 'enumerating'!openElementsDo: aBlock	self openElements do: aBlock! !!XMLElementNester methodsFor: 'enumerating'!openElementsReverseDo: aBlock	"implemented for XMLParserHTML so it's always safe to remove at	the end while scanning backwards"	self openElements size to: 1 by: -1 do: [:i |			aBlock value: (self openElements at: i)]! !!XMLElementNester methodsFor: 'printing'!printElementsOn: aStream	self		printElementsStartingAt: 1		on: aStream! !!XMLElementNester methodsFor: 'printing'!printElementsStartingAt: aStart on: aStream	self		printElementsStartingAt: aStart		stoppingAt: aStart + self elementPrintLimit - 1		on: aStream! !!XMLElementNester methodsFor: 'printing'!printElementsStartingAt: aStart stoppingAt: aStop on: aStream	aStart		to: (aStop min: self openElements size)		do: [:i |			i > aStart				ifTrue: [aStream nextPutAll: ', '].			aStream				nextPut: $<;				nextPutAll: (self openElements at: i);				nextPut: $>].	(aStop < self openElements size)		ifTrue: [aStream nextPutAll: '...'].! !!XMLElementNester methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	self hasOpenElements		ifTrue: [			aStream nextPut: $(.			self				printElementsStartingAt: 1				on: aStream.			aStream nextPut: $)].! !!XMLElementNester methodsFor: 'printing'!printedElements	^ String streamContents: [:stream | self printElementsOn: stream]! !!XMLElementNester methodsFor: 'printing'!printedElementsEnclosedBy: anElement	^ String streamContents: [:stream |		self			printElementsStartingAt: (self openElements lastIndexOf: anElement) + 1			on: stream]! !!XMLElementNester methodsFor: 'accessing'!rootElement	^ rootElement! !!XMLElementNester methodsFor: 'accessing'!scopedAttributeAt: anAttribute	^ self		scopedAttributeAt: anAttribute		ifAbsent: ['']! !!XMLElementNester methodsFor: 'accessing'!scopedAttributeAt: anAttribute ifAbsent: aBlock	^ self currentScopedAttributes		ifNil: [aBlock value]		ifNotNil: [:attributes |			attributes				at: anAttribute				ifAbsent: aBlock]! !!XMLElementNester methodsFor: 'private'!scopedAttributes	^ scopedAttributes ifNil: [scopedAttributes := OrderedCollection new]! !!XMLElementNester methodsFor: 'accessing'!setExternalRootElement: anElement	rootElement := anElement.	hasExternalRootElement := true.	isInElement := true.! !!XMLElementNester methodsFor: 'accessing'!setScopedAttributesNamed: anAttributeCollection from: aDictionary	| attributes |	anAttributeCollection do: [:each |		aDictionary			at: each			ifPresent: [:value |				"used to copy only once if needed"				(attributes ifNil: [attributes := self copiedScopedAttributes])					at: each					put: value]]! !!XMLElementNester methodsFor: 'nesting'!startElement: anElement	self openElements addLast: anElement.	isInElement		ifFalse: [			isInElement := true.			rootElement				ifNil: [rootElement := anElement]].	self hasScopedAttributes		ifTrue: [self startScopedAttributes].! !!XMLElementNester methodsFor: 'private'!startScopedAttributes	scopedAttributes addLast: self currentScopedAttributes! !!XMLElementNester methodsFor: 'accessing'!totalOpenElements	^ self openElements size! !!XMLElementNester methodsFor: 'testing'!wasRootElementEnded	^ wasRootElementEnded! !!XMLAnyElementValidator methodsFor: 'testing'!atEnd	^ true! !!XMLAnyElementValidator methodsFor: 'testing'!isAny	^ true! !!XMLAnyElementValidator methodsFor: 'defaults'!typeName	^ 'ANY'! !!XMLDFAElementContentElementValidator methodsFor: 'testing'!ignoresWhitespace	^ true! !!XMLDFAElementContentElementValidator methodsFor: 'testing'!isElementContent	^ true! !!XMLDFAElementContentElementValidator methodsFor: 'defaults'!typeName	^ 'element content'! !!XMLDFAElementContentElementValidator methodsFor: 'validating'!validatePCData: aString	self errorUnexpectedPCData! !!XMLStandaloneExternalDFAElementContentElementValidator methodsFor: 'testing'!ignoresWhitespace	^ false! !!XMLDFAElementValidator class methodsFor: 'instance creation'!element: anElement dfa: aDFA	^ self new		setElement: anElement		dfa: aDFA! !!XMLDFAElementValidator methodsFor: 'converting'!asReadyElementValidator	^ self copy! !!XMLDFAElementValidator methodsFor: 'testing'!atEnd	^ currentState isAccepting! !!XMLDFAElementValidator methodsFor: 'accessing'!currentState	^ currentState! !!XMLDFAElementValidator methodsFor: 'accessing'!dfa	^ dfa! !!XMLDFAElementValidator methodsFor: 'private'!errorNonDeterminismInContentModelAfter: anElement	XMLValidationException		formatSignal:			'Content model for <{1}> becomes non-deterministic after <{2}>. ',			'Rewrite it deterministically; for example "{3}" instead ',			'of "{4}"'		with: self element		with: anElement		with: '(a,(b|c))'		with: '((a,b)|(a,c))'! !!XMLDFAElementValidator methodsFor: 'copying'!postCopy	currentState := dfa! !!XMLDFAElementValidator methodsFor: 'initialization'!setElement: anElement dfa: aDFA	element := anElement.	dfa := aDFA.	currentState := aDFA.! !!XMLDFAElementValidator methodsFor: 'validating'!validateStartTag: anElement	currentState :=		currentState			nextDFAStateMatching: anElement			ifNone: [self errorUnexpectedElement: anElement].	currentState hasNonDeterminism		ifTrue: [self errorNonDeterminismInContentModelAfter: anElement].! !!XMLElementValidator class methodsFor: 'instance creation'!element: anElement	^ self new element: anElement! !!XMLElementValidator methodsFor: 'converting'!asReadyElementValidator	^ self! !!XMLElementValidator methodsFor: 'testing'!atEnd	self subclassResponsibility! !!XMLElementValidator methodsFor: 'accessing'!element	^ element! !!XMLElementValidator methodsFor: 'accessing'!element: anElement	element := anElement! !!XMLElementValidator methodsFor: 'private'!errorUnexpected: aDescription	XMLValidationException		formatSignal: 'Unexpected {1} in {2} type element <{3}>'		with: aDescription		with: self typeName		with: self element! !!XMLElementValidator methodsFor: 'private'!errorUnexpectedComment	^ self errorUnexpected: 'comment'! !!XMLElementValidator methodsFor: 'private'!errorUnexpectedElement: anElement	XMLValidationException		formatSignal: 'Unexpected <{1}> element in {2} type element <{3}>'		with: anElement		with: self typeName		with: self element! !!XMLElementValidator methodsFor: 'private'!errorUnexpectedPCData	^ self errorUnexpected: 'PCDATA'! !!XMLElementValidator methodsFor: 'private'!errorUnexpectedPI	^ self errorUnexpected: 'processing instruction'! !!XMLElementValidator methodsFor: 'testing'!ignoresWhitespace	^ false! !!XMLElementValidator methodsFor: 'testing'!isAny	^ false! !!XMLElementValidator methodsFor: 'testing'!isElementContent	^ false! !!XMLElementValidator methodsFor: 'testing'!isEmpty	^ false! !!XMLElementValidator methodsFor: 'testing'!isMixedContent	^ false! !!XMLElementValidator methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream		nextPutAll: '(<';		nextPutAll: self element;		nextPutAll: '>)'.! !!XMLElementValidator methodsFor: 'defaults'!typeName	self subclassResponsibility! !!XMLElementValidator methodsFor: 'validating'!validateComment: aString! !!XMLElementValidator methodsFor: 'validating'!validateElementDeclaration! !!XMLElementValidator methodsFor: 'validating'!validatePCData: aString! !!XMLElementValidator methodsFor: 'validating'!validatePI: aTargetString data: aDataString! !!XMLElementValidator methodsFor: 'validating'!validateStartTag: anElement! !!XMLEmptyElementValidator methodsFor: 'testing'!atEnd	^ true! !!XMLEmptyElementValidator methodsFor: 'testing'!isEmpty	^ true! !!XMLEmptyElementValidator methodsFor: 'defaults'!typeName	^ 'EMPTY'! !!XMLEmptyElementValidator methodsFor: 'validating'!validateComment: aString	self errorUnexpectedComment! !!XMLEmptyElementValidator methodsFor: 'validating'!validatePCData: aString	self errorUnexpectedPCData! !!XMLEmptyElementValidator methodsFor: 'validating'!validatePI: aTargetString data: aDataString	self errorUnexpectedPI! !!XMLEmptyElementValidator methodsFor: 'validating'!validateStartTag: anElement	self errorUnexpectedElement: anElement! !!XMLMixedContentElementValidator class methodsFor: 'instance creation'!element: anElement allowedContent: anAllowedContentCollection	^ self new		setElement: anElement		allowedContent: anAllowedContentCollection! !!XMLMixedContentElementValidator methodsFor: 'accessing'!allowedContent	^ allowedContent! !!XMLMixedContentElementValidator methodsFor: 'accessing'!allowedContent: anAllowedContentCollection	allowedContent := anAllowedContentCollection! !!XMLMixedContentElementValidator methodsFor: 'testing'!atEnd	^ true! !!XMLMixedContentElementValidator methodsFor: 'private'!errorContentContainsDuplicates	XMLValidationException		formatSignal:			'Declaration for mixed content element <{1}> contains duplicate names'		with: self element! !!XMLMixedContentElementValidator methodsFor: 'testing'!isMixedContent	^ true! !!XMLMixedContentElementValidator methodsFor: 'initialization'!setElement: anElement allowedContent: anAllowedContentCollection	element := anElement.	allowedContent := anAllowedContentCollection.! !!XMLMixedContentElementValidator methodsFor: 'defaults'!typeName	^ 'mixed content'! !!XMLMixedContentElementValidator methodsFor: 'validating'!validateElementDeclaration	| oldAllowedContentCollection |	oldAllowedContentCollection := self allowedContent.	self allowedContent: oldAllowedContentCollection asSet.	(self allowedContent size < oldAllowedContentCollection size)		ifTrue: [self errorContentContainsDuplicates].! !!XMLMixedContentElementValidator methodsFor: 'validating'!validateStartTag: anElement	(self allowedContent includes: anElement)		ifFalse: [self errorUnexpectedElement: anElement]	! !!XMLEncodingDetector class methodsFor: 'class initialization'!initialize	"self initialize"	"stored in class vars for faster access"	UTF8BOMBytes :=		XMLUTF8StreamConverter byteOrderMarkBytes.	UTF16BigEndianBOMBytes :=		XMLUTF16BigEndianStreamConverter byteOrderMarkBytes.	UTF32BigEndianBOMBytes :=		XMLUTF32BigEndianStreamConverter byteOrderMarkBytes.	UTF32LittleEndianBOMBytes :=		XMLUTF32LittleEndianStreamConverter byteOrderMarkBytes.! !!XMLEncodingDetector class methodsFor: 'instance creation'!on: aStream	^ self new on: aStream! !!XMLEncodingDetector methodsFor: 'private'!atEnd	^ stream atEnd! !!XMLEncodingDetector methodsFor: 'private'!detectBigEndianUTF16BOM	2 to: UTF16BigEndianBOMBytes size do: [:i |		self next == (UTF16BigEndianBOMBytes at: i)			ifFalse: [				self resetStreamToStartPosition.				"no legal UTF-8 byte sequence begins with 16rFE, and:					UTF16BigEndianBOMBytes first = 16rFE				so it can't be implicit UTF-8"				^ nil]].	^ XMLUTF16BigEndianStreamConverter new.! !!XMLEncodingDetector methodsFor: 'private'!detectBigEndianUTF32BOMOrImplicitEncoding	2 to: UTF32BigEndianBOMBytes size do: [:i |		self peek == (UTF32BigEndianBOMBytes at: i)			ifTrue: [self next]			ifFalse: [| implicitConverterClass |				self detectsImplicitEncodings					ifTrue: [						i = 2							ifTrue: [								"(UTF32BigEndianBOMBytes at: 1) isZero"								self peekForASCII									ifTrue: [										"null char followed by an ASCII char;										implicit UTF-16 BE"										implicitConverterClass :=											XMLImplicitUTF16BigEndianStreamConverter]]							ifFalse: [								i = 3									ifTrue: [										"(UTF32BigEndianBOMBytes at: 2) isZero"										(self peekForNull											and: [self peekForASCII]) 											ifTrue: [												"three null chars followed by an ASCII char;												implicit UTF-32 BE"												implicitConverterClass :=													XMLImplicitUTF32BigEndianStreamConverter]]].						(implicitConverterClass isNil							and: [self peekForUTF8LeadingByte])							ifTrue: [								"any number of null chars followed by a leading UTF-8								byte char; implicit UTF-8"								implicitConverterClass :=									XMLImplicitUTF8StreamConverter]].				self resetStreamToStartPosition.				^ implicitConverterClass					ifNotNil: [implicitConverterClass new]]].	^ XMLUTF32BigEndianStreamConverter new.! !!XMLEncodingDetector methodsFor: 'private'!detectLittleEndianImplicitEncoding	| implicitConverterClass |	self detectsImplicitEncodings		ifTrue: [			implicitConverterClass :=				self peekForNull					ifTrue: [								(self peekForNull							and: [self peekForNull])							ifTrue: [								"a leading ASCII char followed by three nulls;								implicit little endian UTF-32"								XMLImplicitUTF32LittleEndianStreamConverter]							ifFalse: [								"a leading ASCII char followed by just one null;								implicit little endian UTF-16"								XMLImplicitUTF16LittleEndianStreamConverter]]					ifFalse: [						"an ASCII char; assume it's UTF-8"						XMLImplicitUTF8StreamConverter]].	self resetStreamToStartPosition.	^ implicitConverterClass		ifNotNil: [implicitConverterClass new].! !!XMLEncodingDetector methodsFor: 'private'!detectLittleEndianUTF32Or16BOM	2 to: UTF32LittleEndianBOMBytes size do: [:i |		self peek == (UTF32LittleEndianBOMBytes at: i)			ifTrue: [self next]			ifFalse: [				i > 2					ifTrue: [						"the 2 byte UTF-16 BOM begins the 4 byte UTF-32 BOM:							UTF32LittleEndianBOMBytes beginsWith:								XMLUTF16LittleEndianStreamConverter byteOrderMarkBytes"						stream position: startPosition + 2.						^ XMLUTF16LittleEndianStreamConverter new]					ifFalse: [						self resetStreamToStartPosition.						"no legal UTF-8 byte sequence begins with 16rFF, and:							UTF32LittleEndianBOMBytes first = 16rFF						so it can't be implicit UTF-8"						^ nil]]].	^ XMLUTF32LittleEndianStreamConverter new.! !!XMLEncodingDetector methodsFor: 'private'!detectUTF8BOM	2 to: UTF8BOMBytes size do: [:i |		self peek == (UTF8BOMBytes at: i)			ifTrue: [self next]			ifFalse: [| implicitConverter |				(self detectsImplicitEncodings					and: [self peekForUTF8NonLeadingByte])					ifTrue: [implicitConverter := XMLImplicitUTF8StreamConverter new].				self resetStreamToStartPosition.				^ implicitConverter]].	^ XMLUTF8StreamConverter new.! !!XMLEncodingDetector methodsFor: 'testing'!detectsImplicitEncodings	^ false! !!XMLEncodingDetector methodsFor: 'private'!isUTF8LeadingByte: aByte	^ aByte < 16r80		or: [aByte < 16rF8			and: [(aByte bitAnd: 16rE0) == 16rC0				or: [(aByte bitAnd: 16rF0) == 16rE0					or: [(aByte bitAnd: 16rF8) == 16rF0]]]]! !!XMLEncodingDetector methodsFor: 'private'!next	stream atEnd		ifTrue: [^ nil]		ifFalse: [^ stream next asInteger]! !!XMLEncodingDetector methodsFor: 'initialization'!on: aStream	stream := aStream.	startPosition := aStream position.! !!XMLEncodingDetector methodsFor: 'private'!peek	stream atEnd		ifTrue: [^ nil]		ifFalse: [^ stream peek asInteger]! !!XMLEncodingDetector methodsFor: 'private'!peekForASCII	| byte |	((byte := self peek) notNil		and: [byte < 16r80])		ifTrue: [			self next.			^ true]		ifFalse: [^ false]! !!XMLEncodingDetector methodsFor: 'private'!peekForNull	self peek == 0		ifTrue: [			self next.			^ true]		ifFalse: [^ false]! !!XMLEncodingDetector methodsFor: 'private'!peekForUTF8LeadingByte	| byte |	((byte := self peek) notNil		and: [self isUTF8LeadingByte: byte])		ifTrue: [			self next.			^ true]		ifFalse: [^ false]! !!XMLEncodingDetector methodsFor: 'private'!peekForUTF8NonLeadingByte	| byte |	((byte := self peek) notNil		and: [byte < 16rC0			and: [byte > 16r80]])		ifTrue: [			self next.			^ true]		ifFalse: [^ false]! !!XMLEncodingDetector methodsFor: 'private'!resetStreamToStartPosition	stream position: startPosition! !!XMLEncodingDetector methodsFor: 'detecting'!streamConverterForEncoding	| byte |	(byte := self next)		ifNil: [^ nil].	byte == 0		ifTrue: [^ self detectBigEndianUTF32BOMOrImplicitEncoding].	byte < 16r80		ifTrue: [^ self detectLittleEndianImplicitEncoding].	"(UTF8BOMBytes at: 1) >= 16r80"	byte == (UTF8BOMBytes at: 1)		ifTrue: [^ self detectUTF8BOM].	"(UTF16BigEndianBOMBytes at: 1) >= 16r80"	byte == (UTF16BigEndianBOMBytes at: 1)		ifTrue: [^ self detectBigEndianUTF16BOM].	"(UTF32LittleEndianBOMBytes at: 1) >= 16r80"	byte == (UTF32LittleEndianBOMBytes at: 1)		ifTrue: [^ self detectLittleEndianUTF32Or16BOM].	self resetStreamToStartPosition.	^ (self detectsImplicitEncodings		and: [self isUTF8LeadingByte: byte])		ifTrue: [XMLImplicitUTF8StreamConverter new]		ifFalse: [nil].! !!XMLImplicitEncodingDetector methodsFor: 'testing'!detectsImplicitEncodings	^ true! !!XMLHTTPDecompressingReadStreamAdapterFactory class methodsFor: 'basic'!basicCanDecompressCompression: aCompressionScheme	^ self compressionScheme = aCompressionScheme		and: [self isSupportedImplementation]! !!XMLHTTPDecompressingReadStreamAdapterFactory class methodsFor: 'testing'!canDecompressCompression: aCompressionScheme	^ self basicCanDecompressCompression: aCompressionScheme asLowercase! !!XMLHTTPDecompressingReadStreamAdapterFactory class methodsFor: 'accessing'!classForCompression: aCompressionScheme	| lowercaseCompressionScheme |	lowercaseCompressionScheme := aCompressionScheme asLowercase.	self allSubclassesDo: [:each |		(each basicCanDecompressCompression: lowercaseCompressionScheme)			ifTrue: [^ each]].	^ nil.! !!XMLHTTPDecompressingReadStreamAdapterFactory class methodsFor: 'accessing'!compressionScheme	self subclassResponsibility! !!XMLHTTPDecompressingReadStreamAdapterFactory class methodsFor: 'accessing'!decompressingReadStreamAdapterClass	self subclassResponsibility! !!XMLHTTPDecompressingReadStreamAdapterFactory class methodsFor: 'private '!errorUnsupportedCompression: aCompressionScheme	XMLHTTPException		formatSignal: 'Unsupported compression scheme "{1}" for HTTP content'		with: aCompressionScheme! !!XMLHTTPDecompressingReadStreamAdapterFactory class methodsFor: 'testing'!isSupportedImplementation	^ self decompressingReadStreamAdapterClass notNil! !!XMLHTTPDecompressingReadStreamAdapterFactory class methodsFor: 'instance creation'!on: aReadStream	^ self decompressingReadStreamAdapterClass on: aReadStream! !!XMLHTTPDecompressingReadStreamAdapterFactory class methodsFor: 'instance creation'!on: aReadStream compression: aCompressionScheme	^ (self classForCompression: aCompressionScheme)		ifNil: [self errorUnsupportedCompression: aCompressionScheme]		ifNotNil: [:classForCompression |			classForCompression on: aReadStream]! !!XMLHTTPDecompressingReadStreamAdapterFactory class methodsFor: 'accessing'!supportedCompressionSchemes	| supportedCompressionSchemes |	supportedCompressionSchemes := OrderedCollection new.	self allSubclassesDo: [:each |		each isSupportedImplementation			ifTrue: [supportedCompressionSchemes addLast: each compressionScheme]].	^ supportedCompressionSchemes.! !!XMLHTTPGZipDecompressingReadStreamAdapterFactory class methodsFor: 'accessing'!compressionScheme	^ 'gzip'! !!XMLHTTPGZipDecompressingReadStreamAdapterFactory class methodsFor: 'accessing'!decompressingReadStreamAdapterClass	^ XMLClassFinder classNamed: #GZipReadStream! !!XMLHTTPMIMEType class methodsFor: 'defaults'!defaultCharset	^ 'ISO-8859-1'! !!XMLHTTPMIMEType class methodsFor: 'instance creation'!fromString: aString	| parser |	parser := XMLHTTPMIMETypeParser on: aString.	^ self new		setMainType: parser parseMainType		subType: parser parseSubType		parameters: parser parseParameters.! !!XMLHTTPMIMEType class methodsFor: 'instance creation'!mainType: aMainType subType: aSubType	^ self		mainType: aMainType		subType: aSubType		parameters: #()! !!XMLHTTPMIMEType class methodsFor: 'instance creation'!mainType: aMainType subType: aSubType parameters: anAssociationCollection	| parameters attributes totalAttributes |	"convert the parameters to an OrderedCollection of attribute=value	associations, ignoring duplicate attributes"	parameters := OrderedCollection new: anAssociationCollection size.	totalAttributes := 0.	anAssociationCollection associationsDo: [:each | | attribute |		attribute := each key asLowercase.		"only initialize if needed"		((attributes ifNil: [attributes := Set new])			add: attribute;			size) > totalAttributes			ifTrue: [				parameters addLast: attribute -> each value.				totalAttributes := totalAttributes + 1]].	^ self new		setMainType: aMainType asLowercase		subType: aSubType asLowercase		parameters: parameters.! !!XMLHTTPMIMEType methodsFor: 'comparing'!= anObject	self == anObject		ifTrue: [^ true].	self species == anObject species		ifFalse: [^ false].	^ self mainType = anObject mainType		and: [self subType = anObject subType			and: [self parameters size = anObject parameters size				and: [					"order is irrelevant according to the spec"					self parameters asSet = anObject parameters asSet]]].! !!XMLHTTPMIMEType methodsFor: 'converting'!asString	"don't assume Object>>#asString is defined, for portability"	^ self printString! !!XMLHTTPMIMEType methodsFor: 'accessing'!charset	^ self		parameterAt: 'charset'		ifAbsent: [self defaultCharset]! !!XMLHTTPMIMEType methodsFor: 'defaults'!defaultCharset	^ self class defaultCharset! !!XMLHTTPMIMEType methodsFor: 'comparing'!hash	^ self species hash bitXor:		(self mainType hash bitXor:			(self subType hash bitXor:				"OrderedCollection>>#hash depends on order (and even if it				didn't, assuming it wouldn't in the future is too risky),				so instead the size is hashed"				self parameters size hash))! !!XMLHTTPMIMEType methodsFor: 'accessing'!mainType	^ mainType! !!XMLHTTPMIMEType methodsFor: 'accessing'!parameterAt: aKey	^ self		parameterAt: aKey		ifAbsent: ['']! !!XMLHTTPMIMEType methodsFor: 'accessing'!parameterAt: aKey ifAbsent: aBlock	self parameterKeysAndValuesDo: [:key :value |		key = aKey			ifTrue: [^ value]].	^ aBlock value.! !!XMLHTTPMIMEType methodsFor: 'enumerating'!parameterKeysAndValuesDo: aTwoArgumentBlock	self parameters do: [:each |		aTwoArgumentBlock			value: each key			value: each value]! !!XMLHTTPMIMEType methodsFor: 'enumerating'!parameterKeysDo: aBlock	self parameters do: [:each |		aBlock value: each key]! !!XMLHTTPMIMEType methodsFor: 'private'!parameters	^ parameters! !!XMLHTTPMIMEType methodsFor: 'printing'!printOn: aStream	aStream		nextPutAll: self mainType;		nextPut: $/;		nextPutAll: self subType.	self parameterKeysAndValuesDo: [:key :value |		aStream			nextPutAll: '; ';			nextPutAll: key;			nextPut: $=;			nextPutAll: value].! !!XMLHTTPMIMEType methodsFor: 'initialization'!setMainType: aMainType subType: aSubType parameters: aParameterCollection	mainType := aMainType.	subType := aSubType.	parameters := aParameterCollection.! !!XMLHTTPMIMEType methodsFor: 'accessing'!subType	^ subType! !!XMLHTTPResponseContentReader class methodsFor: 'accessing'!response: aResponse	^ self new setResponse: aResponse! !!XMLHTTPResponseContentReader methodsFor: 'private'!contentReadStreamUpToEnd	| contentWriteStream |	contentWriteStream := self newContentWriteStream.	[contentReadStream atEnd]		whileFalse: [contentWriteStream nextPut: contentReadStream next].	^ contentWriteStream contents.! !!XMLHTTPResponseContentReader methodsFor: 'private'!decodedContentReadStreamUpToEndWithCharset: aCharset	| streamConverter |	(streamConverter := aCharset asXMLStreamConverter) isNull		ifTrue: [self errorUnrecognizedContentTypeCharset: aCharset].	contentReadStream :=		XMLDecodingReadStreamAdapter			on: contentReadStream			streamConverter: streamConverter.	[^ self contentReadStreamUpToEnd]		on: XMLEncodingException		do: [:error |			"might actually be a limit exception"			self ensureContentReadStreamWasNotLimited.			error pass].! !!XMLHTTPResponseContentReader methodsFor: 'private'!ensureContentReadStreamWasNotLimited	(limitedContentReadStream notNil		and: [limitedContentReadStream atLimitedEnd])		ifTrue: [self errorContentLimitExceeded]! !!XMLHTTPResponseContentReader methodsFor: 'private'!errorContentLimitExceeded	XMLLimitException signal: 'HTTP reponse content limit exceeded'! !!XMLHTTPResponseContentReader methodsFor: 'private'!errorUnrecognizedContentTypeCharset: aCharset	XMLEncodingException		formatSignal:			'Unrecognized Content-Type charset "{1}" encoding for HTTP content'		with: aCharset! !!XMLHTTPResponseContentReader methodsFor: 'testing'!handlesDecompression	^ false! !!XMLHTTPResponseContentReader methodsFor: 'initialization'!initializeDecompressionWithSchemes: aCompressionSchemeSequence upToLimit: aMaxSize	isDecompressing := true.	aCompressionSchemeSequence reverseDo: [:each |		contentReadStream :=			XMLHTTPDecompressingReadStreamAdapterFactory				on: contentReadStream				compression: each].	aMaxSize		ifNotNil: [self limitContentReadStreamUpToLimit: aMaxSize].! !!XMLHTTPResponseContentReader methodsFor: 'accessing'!limitContentReadStreamUpToLimit: aMaxSize	limitedContentReadStream :=		XMLLimitedReadStreamAdapter			on: contentReadStream			limit: aMaxSize.	contentReadStream := limitedContentReadStream.! !!XMLHTTPResponseContentReader methodsFor: 'instance creation'!newContentWriteStream	^ (String new: rawContent size) writeStream! !!XMLHTTPResponseContentReader methodsFor: 'reading'!rawReadWithLength: aContentLength upToLimit: aMaxSize	self subclassResponsibility! !!XMLHTTPResponseContentReader methodsFor: 'reading'!readUpToLimit: aMaxSize decoding: aBoolean	| contentLength contentType compressionSchemes charset content |	contentLength := response contentLength.	(response isChunked		or: [contentLength isNil])		ifTrue: [contentLength := nil]		ifFalse: [			contentLength > 0				ifFalse: [^ ''].			(aMaxSize notNil				and: [contentLength > aMaxSize])				ifTrue: [self errorContentLimitExceeded]].	rawContent :=		self			rawReadWithLength: contentLength			upToLimit: aMaxSize.	contentReadStream := rawContent readStream.	(self handlesDecompression		and: [(compressionSchemes := response contentEncoding) notEmpty])		ifTrue: [			self				initializeDecompressionWithSchemes: compressionSchemes				upToLimit: aMaxSize].	(aBoolean		and: [(contentType := response contentType) notNil			and: [(charset := contentType charset) ~= contentType defaultCharset]])		ifTrue: [			content := self decodedContentReadStreamUpToEndWithCharset: charset]		ifFalse: [			content := self undecodedContentReadStreamUpToEnd].	self ensureContentReadStreamWasNotLimited.	^ content.! !!XMLHTTPResponseContentReader methodsFor: 'initialization'!setResponse: aResponse	response := aResponse.	isDecompressing := false.! !!XMLHTTPResponseContentReader methodsFor: 'streaming'!undecodedContentReadStreamUpToEnd	^ (isDecompressing		or: [limitedContentReadStream notNil])		ifTrue: [self contentReadStreamUpToEnd]		ifFalse: [rawContent]! !!XMLHTTPWebClientResponseContentReader methodsFor: 'testing'!handlesDecompression	"this class needs to handle decompression, since it uses the lower-level	WebClient #streamFrom:to:size:progress: interface"	^ true! !!XMLHTTPWebClientResponseContentReader methodsFor: 'reading'!rawReadWithLength: aContentLength upToLimit: aMaxSize	| socketStream rawContentWriteStream |	(socketStream := response webClientResponse stream) binary.	rawContentWriteStream :=		(ByteArray new:			(aContentLength				ifNil: [aMaxSize					ifNil: [4096]])) writeStream.	response webClientResponse		streamFrom: socketStream		to: rawContentWriteStream		size: aContentLength		progress:			((aContentLength isNil				and: [aMaxSize notNil])				ifTrue: [					[:ignored :total |						total > aMaxSize							ifTrue: [self errorContentLimitExceeded]]]				ifFalse: [nil]).	^ rawContentWriteStream contents.! !!XMLHTTPZincResponseContentReader methodsFor: 'reading'!rawReadWithLength: aContentLength upToLimit: aMaxSize	^ [| entityStream |		(entityStream := response zincResponse entity stream) binary.		ZnUtils			readUpToEnd: entityStream			limit: aMaxSize]		on: ZnEntityTooLarge		do: [:error | self errorContentLimitExceeded]! !!XMLIntegerReader class methodsFor: 'class initialization'!initialize	"self initialize"	self initializeCharacterDigitValues! !!XMLIntegerReader class methodsFor: 'class initialization'!initializeCharacterDigitValues	| temp |	"use an array instead of a dictionary for speed, and use a temp	to fully initialize it before assignment to avoid possible race	conditions during class reinitialization"	temp := Array new: 255.	#(#($0 $9 0) #($a $f 10) #($A $Z 10)) do: [:each |		| firstDigitValue lastDigitValue baseValue |		firstDigitValue := each first asciiValue.		lastDigitValue := each second asciiValue.		baseValue := each third.		firstDigitValue			to: lastDigitValue			do: [:i |				temp					at: i					put: i - firstDigitValue + baseValue]].	CharacterDigitValues := temp.! !!XMLIntegerReader class methodsFor: 'defaults'!maxBase	^ 16! !!XMLIntegerReader class methodsFor: 'defaults'!maxIntegerValue	^ nil! !!XMLIntegerReader class methodsFor: 'instance creation'!on: aStringOrStream	^ self new on: aStringOrStream! !!XMLIntegerReader class methodsFor: 'instance creation'!readFrom: aStream	^ (self on: aStream) nextInteger! !!XMLIntegerReader class methodsFor: 'reading'!readFrom: aStream withBase: aBase	^ (self on: aStream) nextIntegerWithBase: aBase! !!XMLIntegerReader class methodsFor: 'reading'!readFrom: aStream withBase: aFirstBase andPrefixes: aCharacterCollection orBase: aSecondBase	^ (self on: aStream)		nextIntegerWithBase: aFirstBase		andPrefixes: aCharacterCollection		orBase: aSecondBase! !!XMLIntegerReader class methodsFor: 'reading'!readFrom: aStream withBase: aFirstBase andPrefixes: aCharacterCollection orBase: aSecondBase upToLimit: aReadLimit	^ (self on: aStream)		nextIntegerWithBase: aFirstBase		andPrefixes: aCharacterCollection		orBase: aSecondBase		upToLimit: aReadLimit! !!XMLIntegerReader class methodsFor: 'reading'!readFrom: aStream withBase: aBase upToLimit: aReadLimit	^ (self on: aStream)		nextIntegerWithBase: aBase		upToLimit: aReadLimit! !!XMLIntegerReader methodsFor: 'testing'!atEnd	^ readStream atEnd! !!XMLIntegerReader methodsFor: 'private'!errorUnsupportedBase: aBase	Error signal: 'Unsupported base ', aBase printString! !!XMLIntegerReader methodsFor: 'private'!next	| nextChar |	self atEnd		ifFalse: [			nextChar := readStream next.			printStream				ifNotNil: [printStream nextPut: nextChar]].	^ nextChar.! !!XMLIntegerReader methodsFor: 'private'!nextDigitWithBase: aBase	| asciiValue digit |	((asciiValue := self peek asciiValue) > 0		and: [asciiValue <= CharacterDigitValues size			and: [(digit := CharacterDigitValues at: asciiValue) notNil				and: [digit < aBase]]])				ifTrue: [					self next.					^ digit]				ifFalse: [^ nil]! !!XMLIntegerReader methodsFor: 'reading'!nextInteger	^ self nextIntegerWithBase: 10! !!XMLIntegerReader methodsFor: 'reading'!nextIntegerWithBase: aBase	^ self		nextIntegerWithBase: aBase		upToLimit: nil! !!XMLIntegerReader methodsFor: 'reading'!nextIntegerWithBase: aFirstBase andPrefixes: aCharacterCollection orBase: aSecondBase	^ self		nextIntegerWithBase: aFirstBase		andPrefixes: aCharacterCollection		orBase: aSecondBase		upToLimit: nil! !!XMLIntegerReader methodsFor: 'reading'!nextIntegerWithBase: aFirstBase andPrefixes: aCharacterCollection orBase: aSecondBase upToLimit: aReadLimit	^ self		nextIntegerWithBase:			((self atEnd not				and: [aCharacterCollection includes: self peek])				ifTrue: [					self next.					aFirstBase]				ifFalse: [aSecondBase])		upToLimit: aReadLimit! !!XMLIntegerReader methodsFor: 'reading'!nextIntegerWithBase: aBase upToLimit: aReadLimit	| integer maxValue maxBaseValue digitValue readLimit |	(aBase > 1		and: [aBase <= self class maxBase])		ifFalse: [self errorUnsupportedBase: aBase].	self class maxIntegerValue		ifNotNil: [:maxIntegerValue |			maxValue := maxIntegerValue.			maxBaseValue := (maxValue / aBase) floor].	readLimit := aReadLimit.	[self atEnd		or: [(readLimit notNil and: [readLimit <= 0])			or: [(digitValue := self nextDigitWithBase: aBase) isNil]]]		whileFalse: [			integer				ifNil: [integer := 0].				maxBaseValue				ifNotNil: [					integer > maxBaseValue						ifTrue: [							self overflowed.							"handle overflow with saturation"							^ maxValue]].			integer := integer * aBase.			maxValue				ifNotNil: [					integer > (maxValue - digitValue)						ifTrue: [							self overflowed.							"handle overflow with saturation"							^ maxValue]].			integer := integer + digitValue.			readLimit				ifNotNil: [readLimit := readLimit - 1]].	^ integer.! !!XMLIntegerReader methodsFor: 'initialization'!on: aStringOrStream	readStream :=		aStringOrStream isStream			ifTrue: [aStringOrStream]			ifFalse: [aStringOrStream readStream]! !!XMLIntegerReader methodsFor: 'private'!overflowed	"can override to raise a warning or error"! !!XMLIntegerReader methodsFor: 'private'!peek	self atEnd		ifTrue: [^ nil]		ifFalse: [^ readStream peek]! !!XMLIntegerReader methodsFor: 'accessing'!printStream: aStream	printStream := aStream! !!XMLSmallIntegerReader class methodsFor: 'class initialization'!initialize	"self initialize"	SmallIntegerMaxValue := SmallInteger maxVal! !!XMLSmallIntegerReader class methodsFor: 'defaults'!maxIntegerValue	^ SmallIntegerMaxValue! !!XMLNFABuilder methodsFor: 'applying'!applyAccepting	| totalFragments |	(totalFragments := self totalFragments) > 0		ifTrue: [			1 to: totalFragments - 1 do: [:i |				self applyConcatenation].			self topFragment connectToState:				XMLNFAAcceptingState new]		ifFalse: [			self pushFragment:				(XMLNFAFragment firstState: XMLNFAAcceptingState new)]! !!XMLNFABuilder methodsFor: 'applying'!applyBranch	| leftFragment rightFragment branchState |	leftFragment := self popFragment.	rightFragment := self popFragment.	branchState :=		XMLNFABranchingState			leftBranch: leftFragment firstState			rightBranch: rightFragment firstState.	self pushFragment:		(XMLNFAFragment			firstState: branchState			terminalStates:				(leftFragment terminalStatesWithAllFrom: rightFragment)).! !!XMLNFABuilder methodsFor: 'applying'!applyConcatenation	| firstFragment secondFragment |	secondFragment := self popFragment.	firstFragment := self popFragment.	firstFragment connectToFragment: secondFragment.	self pushFragment: firstFragment.! !!XMLNFABuilder methodsFor: 'applying'!applyOptional	| optionalFragment branchingState |	optionalFragment := self popFragment.	branchingState :=		XMLNFABranchingState branch: optionalFragment firstState.	self pushFragment:		(XMLNFAFragment			firstState: branchingState			terminalStates:				(optionalFragment terminalStatesWith: branchingState))! !!XMLNFABuilder methodsFor: 'applying'!applyPlus	| plusFragment |	plusFragment := self topFragment.	plusFragment connectToState:		(XMLNFABranchingState branch: plusFragment firstState).! !!XMLNFABuilder methodsFor: 'applying'!applyStar	| branchState starFragment |	starFragment := self popFragment.	branchState := XMLNFABranchingState branch: starFragment firstState.	starFragment connectToState: branchState.	self pushFragment:		(XMLNFAFragment			firstState: branchState			terminalState: branchState).! !!XMLNFABuilder methodsFor: 'converting'!asAcceptingNFA	^ (self		applyAccepting;		popFragment) firstState! !!XMLNFABuilder methodsFor: 'private'!fragmentStack	^ fragmentStack! !!XMLNFABuilder methodsFor: 'testing'!hasFragments	^ self totalFragments > 0! !!XMLNFABuilder methodsFor: 'initialization'!initialize	super initialize.	fragmentStack := OrderedCollection new.! !!XMLNFABuilder methodsFor: 'accessing'!popFragment	^ self fragmentStack removeLast! !!XMLNFABuilder methodsFor: 'accessing'!pushFragment: aFragment	^ self fragmentStack addLast: aFragment! !!XMLNFABuilder methodsFor: 'accessing'!pushFragmentMatching: aMatcher	^ self pushFragment:		(XMLNFAFragment firstState:			(XMLNFAMatchingState matcher: aMatcher))! !!XMLNFABuilder methodsFor: 'accessing'!topFragment	^ self fragmentStack last! !!XMLNFABuilder methodsFor: 'accessing'!totalFragments	^ self fragmentStack size! !!XMLNFAFragment class methodsFor: 'instance creation'!firstState: aFirstState	^ self new		setFirstState: aFirstState		terminalStateOrStates: aFirstState! !!XMLNFAFragment class methodsFor: 'instance creation'!firstState: aFirstState terminalState: aTerminalState	^ self new		setFirstState: aFirstState		terminalStateOrStates: aTerminalState! !!XMLNFAFragment class methodsFor: 'instance creation'!firstState: aFirstState terminalStates: aTerminalStateCollection	^ self new		setFirstState: aFirstState		terminalStateOrStates: aTerminalStateCollection! !!XMLNFAFragment methodsFor: 'private'!connectTerminalStatesToState: aState	terminalStateOrStates isCollection		ifTrue: [			"use #to:do: for speed"			1 to: terminalStateOrStates size do: [:i |				(terminalStateOrStates at: i) connectToState: aState]]		ifFalse: [terminalStateOrStates connectToState: aState]! !!XMLNFAFragment methodsFor: 'connecting'!connectToFragment: aFragment	self connectTerminalStatesToState: aFragment firstState.	terminalStateOrStates := aFragment terminalStateOrStates.! !!XMLNFAFragment methodsFor: 'connecting'!connectToState: aState	self connectTerminalStatesToState: aState.	terminalStateOrStates := aState.! !!XMLNFAFragment methodsFor: 'accessing'!firstState	^ firstState! !!XMLNFAFragment methodsFor: 'accessing'!firstState: aFirstState	firstState := aFirstState! !!XMLNFAFragment methodsFor: 'private'!newTerminalStatesWith: aFirstTerminalState and: aSecondTerminalState	"avoid #with:with: to control the capacity"	^ (OrderedCollection new: 4)		addLast: aFirstTerminalState;		addLast: aSecondTerminalState;		yourself! !!XMLNFAFragment methodsFor: 'initialization'!setFirstState: aFirstState terminalStateOrStates: aTerminalStateOrStateCollection	firstState := aFirstState.	terminalStateOrStates := aTerminalStateOrStateCollection.! !!XMLNFAFragment methodsFor: 'accessing'!terminalState: aTerminalState	terminalStateOrStates := aTerminalState! !!XMLNFAFragment methodsFor: 'private'!terminalStateOrStates	^ terminalStateOrStates! !!XMLNFAFragment methodsFor: 'accessing'!terminalStates	^ terminalStateOrStates isCollection		ifTrue: [terminalStateOrStates]		ifFalse: [OrderedCollection with: terminalStateOrStates]! !!XMLNFAFragment methodsFor: 'accessing'!terminalStates: aTerminalStateCollection	terminalStateOrStates := aTerminalStateCollection! !!XMLNFAFragment methodsFor: 'private'!terminalStatesAddedTo: aTerminalStateCollection	terminalStateOrStates isCollection		ifTrue: [			"#to:do: for speed"			1 to: terminalStateOrStates size do: [:i |				aTerminalStateCollection addLast: (terminalStateOrStates at: i)]]		ifFalse: [aTerminalStateCollection addLast: terminalStateOrStates].	^ aTerminalStateCollection.! !!XMLNFAFragment methodsFor: 'converting'!terminalStatesWith: aTerminalState	terminalStateOrStates isCollection		ifTrue: [			terminalStateOrStates addLast: aTerminalState.			^ terminalStateOrStates]		ifFalse: [			^ self				newTerminalStatesWith: terminalStateOrStates				and: aTerminalState]! !!XMLNFAFragment methodsFor: 'converting'!terminalStatesWithAllFrom: aFragment	terminalStateOrStates isCollection		ifTrue: [^ aFragment terminalStatesAddedTo: terminalStateOrStates].	aFragment terminalStateOrStates isCollection		ifTrue: [^ self terminalStatesAddedTo: aFragment terminalStateOrStates].	^ self		newTerminalStatesWith: terminalStateOrStates		and: aFragment terminalStateOrStates.! !!XMLNFAAcceptingState methodsFor: 'testing'!isAccepting	^ true! !!XMLNFAAcceptingState methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	self printLabelOn: aStream.	aStream nextPut: $).! !!XMLNFABranchingState class methodsFor: 'instance creation'!branch: aLeftBranch	^ self new		setLeftBranch: aLeftBranch		rightBranch: nil! !!XMLNFABranchingState class methodsFor: 'instance creation'!leftBranch: aLeftBranch rightBranch: aRightBranch	^ self new		setLeftBranch: aLeftBranch		rightBranch: aRightBranch! !!XMLNFABranchingState methodsFor: 'adding'!addTo: aStateSet	lastAddedTo == aStateSet		ifFalse: [			"to detect and handle cycles"			lastAddedTo := aStateSet.			"this is effectively a non-matching, non-accepting state			with epsilon transitions, so it can be skipped and its			branches can be followed (in other words, the epsilon			closure of this state, minus this state)"			leftBranch				ifNotNil: [leftBranch addTo: aStateSet].			rightBranch				ifNotNil: [rightBranch addTo: aStateSet]]! !!XMLNFABranchingState methodsFor: 'connecting'!connectToState: aState	leftBranch		ifNil: [leftBranch := aState].	rightBranch		ifNil: [rightBranch := aState].! !!XMLNFABranchingState methodsFor: 'accessing'!leftBranch	^ leftBranch! !!XMLNFABranchingState methodsFor: 'enumerating'!nextStatesDo: aBlock	leftBranch		ifNotNil: [aBlock value: leftBranch].	rightBranch		ifNotNil: [aBlock value: rightBranch].! !!XMLNFABranchingState methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	self printLabelOn: aStream.	aStream nextPut: $(.	leftBranch		ifNotNil: [			leftBranch printLabelOn: aStream].	aStream nextPut: $|.	rightBranch		ifNotNil: [			rightBranch printLabelOn: aStream].	aStream nextPutAll: '))'.! !!XMLNFABranchingState methodsFor: 'accessing'!rightBranch	^ rightBranch! !!XMLNFABranchingState methodsFor: 'initialization'!setLeftBranch: aLeftBranch rightBranch: aRightBranch	leftBranch := aLeftBranch.	rightBranch := aRightBranch.! !!XMLNFAMatchingState class methodsFor: 'instance creation'!matcher: aMatcher	^ self new matcher: aMatcher! !!XMLNFAMatchingState methodsFor: 'connecting'!connectToState: aState	nextState		ifNil: [nextState := aState]! !!XMLNFAMatchingState methodsFor: 'accessing'!matcher	^ matcher! !!XMLNFAMatchingState methodsFor: 'accessing'!matcher: aMatcher	matcher := aMatcher! !!XMLNFAMatchingState methodsFor: 'testing'!matches: anObject	^ matcher = anObject! !!XMLNFAMatchingState methodsFor: 'accessing'!nextState	^ nextState! !!XMLNFAMatchingState methodsFor: 'enumerating'!nextStatesDo: aBlock	nextState		ifNotNil: [aBlock value: nextState]! !!XMLNFAMatchingState methodsFor: 'printing'!printLabelOn: aStream	aStream		print: self identityHash;		nextPut: $(;		print: matcher;		nextPut: $)! !!XMLNFAMatchingState methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	self printLabelOn: aStream.	aStream nextPutAll: '->'.	nextState		ifNotNil: [			nextState printLabelOn: aStream].	aStream nextPut: $).! !!XMLNFAState methodsFor: 'adding'!addTo: aStateSet	lastAddedTo == aStateSet		ifFalse: [			"to detect and handle cycles"			lastAddedTo := aStateSet.			aStateSet add: self]! !!XMLNFAState methodsFor: 'converting'!asDFAState	| nfaStates |	nfaStates := XMLNFAStateSet new.	self addTo: nfaStates.	^ nfaStates asDFAState.! !!XMLNFAState methodsFor: 'connecting'!connectToState: aState! !!XMLNFAState methodsFor: 'testing'!isAccepting	^ false! !!XMLNFAState methodsFor: 'testing'!matches: anObject	^ false! !!XMLNFAState methodsFor: 'enumerating'!nextStatesDo: aBlock! !!XMLNFAState methodsFor: 'printing'!printLabelOn: aStream	aStream print: self identityHash! !!XMLNamespaceScope class methodsFor: 'defaults'!xmlNamespaceURI	^ 'http://www.w3.org/XML/1998/namespace'! !!XMLNamespaceScope class methodsFor: 'defaults'!xmlnsNamespaceURI	^ 'http://www.w3.org/2000/xmlns/'! !!XMLNamespaceScope methodsFor: 'comparing'!= anObject	self == anObject		ifTrue: [^ true].	self species == anObject species		ifFalse: [^ false].	self hasNamespaces		ifFalse: [^ anObject hasNamespaces not].	"use #hasNamespaces first to avoid initializing anObject's prefixMappings"	anObject hasNamespaces		ifFalse: [^ false].	^ prefixMappings = anObject prefixMappings.! !!XMLNamespaceScope methodsFor: 'private'!copiedPrefixMappings	"replaces current mappings with copy for copy-on-write"	prefixMappings		ifNil: [^ self prefixMappings]		ifNotNil: [^ prefixMappings := prefixMappings copy]! !!XMLNamespaceScope methodsFor: 'copying'!copy	"copy-on-write allows copies to share state so no postCopy is needed"	^ self shallowCopy! !!XMLNamespaceScope methodsFor: 'accessing'!defaultNamespace	^ prefixMappings		ifNil: ['']		ifNotNil: [			prefixMappings				at: ''				ifAbsent: ['']]! !!XMLNamespaceScope methodsFor: 'accessing'!defaultNamespace: aURI	self		validatePrefix: ''		beforeMappingTo: aURI.	"copy-on-write"	self copiedPrefixMappings		at: ''		put: aURI.! !!XMLNamespaceScope methodsFor: 'private'!errorAttribute: anAttribute aliasesURI: aURI	XMLNamespaceException		formatSignal: 'Attribute "{1}" has alias for namespace URI "{2}"'		with: anAttribute		with: aURI! !!XMLNamespaceScope methodsFor: 'private'!errorCannotAliasPrefix: aFirstPrefix with: aSecondPrefix	aSecondPrefix isEmpty		ifTrue: [			XMLNamespaceException				formatSignal:					'Cannot use the "{1}" namespace URI as a ',					'default namespace URI'				with: aFirstPrefix]		ifFalse: [			XMLNamespaceException				formatSignal:					'Cannot alias the "{1}" namespace URI ',					'with the "{2}" prefix'				with: aFirstPrefix				with: aSecondPrefix]! !!XMLNamespaceScope methodsFor: 'private'!errorCannotAliasXMLNSPrefixWith: aPrefix	self		errorCannotAliasPrefix: 'xmlns'		with: aPrefix! !!XMLNamespaceScope methodsFor: 'private'!errorCannotAliasXMLPrefixWith: aPrefix	self		errorCannotAliasPrefix: 'xml'		with: aPrefix! !!XMLNamespaceScope methodsFor: 'private'!errorCannotMapPrefixToEmptyURI	XMLNamespaceException signal: 'Cannot map namespace prefixes to empty URIs'! !!XMLNamespaceScope methodsFor: 'private'!errorCannotMapXMLNSPrefix	XMLNamespaceException signal:		'Cannot map "xmlns" prefix to any namespace, even the current "xmlns" namespace'! !!XMLNamespaceScope methodsFor: 'private'!errorCannotRemapXMLPrefix	XMLNamespaceException signal: 'Cannot map the "xml" prefix to a new namespace URI'! !!XMLNamespaceScope methodsFor: 'private'!errorCannotUnmapPrefix: aPrefix	XMLNamespaceException		formatSignal: 'Prefix "{1}" was not mapped and cannot be unmapped'		with: aPrefix! !!XMLNamespaceScope methodsFor: 'private'!errorInvalidPrefix: aPrefix		XMLNamespaceException		formatSignal: 'Prefix "{1}" contains ":" character'		with: aPrefix! !!XMLNamespaceScope methodsFor: 'private'!errorInvalidUnprefixedAttribute: anAttribute	XMLNamespaceException		formatSignal: 'Unprefixed attribute "{1}" contains ":" character'		with: anAttribute! !!XMLNamespaceScope methodsFor: 'private'!errorInvalidUnprefixedElement: anElement	XMLNamespaceException		formatSignal: 'Unprefixed element <{1}> contains ":" character'		with: anElement! !!XMLNamespaceScope methodsFor: 'private'!errorUnmappedPrefix: aPrefix inAttribute: anAttribute	XMLNamespaceException		formatSignal: 'Unmapped namespace prefix "{1}" in "{2}" attribute'		with: aPrefix		with: anAttribute! !!XMLNamespaceScope methodsFor: 'private'!errorUnmappedPrefix: aPrefix inElement: anElement	XMLNamespaceException		formatSignal: 'Unmapped namespace prefix "{1}" in <{2}> element'		with: aPrefix		with: anElement! !!XMLNamespaceScope methodsFor: 'private'!errorXMLNSPrefixInAttribute: anAttribute	XMLNamespaceException		formatSignal: 'Attribute "{1}" uses reserved "xmlns" namespace prefix'		with: anAttribute! !!XMLNamespaceScope methodsFor: 'private'!errorXMLNSPrefixInElement: anElement	XMLNamespaceException		formatSignal: 'Element <{1}> uses reserved "xmlns" namespace prefix'		with: anElement! !!XMLNamespaceScope methodsFor: 'testing'!hasDefaultNamespace	^ self includesPrefix: ''! !!XMLNamespaceScope methodsFor: 'testing'!hasNamespaces	"optimized to avoid lazy initialization"	prefixMappings == nil		ifTrue: [^ false].	^ prefixMappings size > 0.! !!XMLNamespaceScope methodsFor: 'comparing'!hash	self hasNamespaces		ifTrue: [^ self species hash bitXor: self prefixMappings hash]		ifFalse: [^ self species hash]! !!XMLNamespaceScope methodsFor: 'testing'!includesPrefix: aPrefix	self		prefixMappingAt: aPrefix		ifAbsent: [^ false].	^ true.! !!XMLNamespaceScope methodsFor: 'testing'!includesPrefix: aPrefix mappedTo: aURI	^ (self		prefixMappingAt: aPrefix		ifAbsent: [^ false]) = aURI! !!XMLNamespaceScope methodsFor: 'accessing'!inheritMappingsFrom: anEnclosingScope	anEnclosingScope hasNamespaces		ifFalse: [^ self].	self hasNamespaces		ifTrue: [| copiedPrefixMappings |			anEnclosingScope prefixesAndURIsDo: [:prefix :uri |				(self includesPrefix: prefix)					ifFalse: [						"nil test ensures we only copy the first time when needed"						(copiedPrefixMappings							ifNil: [copiedPrefixMappings := self copiedPrefixMappings])							at: prefix							put: uri]]]		ifFalse: [			"can safely share anEnclosingScope's prefixMappings because of			copy-on-write behavior"			prefixMappings := anEnclosingScope prefixMappings].! !!XMLNamespaceScope methodsFor: 'accessing'!mapPrefix: aPrefix to: aURI	self		validatePrefix: aPrefix		beforeMappingTo: aURI.	"copy-on-write"	self copiedPrefixMappings		at: aPrefix		put: aURI.! !!XMLNamespaceScope methodsFor: 'accessing'!mapPrefixesAndURIs: anAssociationCollection	| copiedPrefixMappings |	anAssociationCollection associationsDo: [:each |		self			validatePrefix: each key			beforeMappingTo: each value.		"nil test ensures we only copy the first time when needed"		(copiedPrefixMappings			ifNil: [copiedPrefixMappings := self copiedPrefixMappings])			at: each key			put: each value]! !!XMLNamespaceScope methodsFor: 'accessing'!mappedPrefixes	^ prefixMappings		ifNil: [#()]		ifNotNil: [prefixMappings keys]! !!XMLNamespaceScope methodsFor: 'accessing'!prefixMappingAt: aPrefix	^ self		prefixMappingAt: aPrefix		ifAbsent: ['']! !!XMLNamespaceScope methodsFor: 'accessing'!prefixMappingAt: aPrefix ifAbsent: aBlock	^ prefixMappings		ifNil: [aBlock value]		ifNotNil: [			prefixMappings				at: aPrefix				ifAbsent: aBlock]! !!XMLNamespaceScope methodsFor: 'private'!prefixMappings	^ prefixMappings		ifNil: [prefixMappings := OrderPreservingStringDictionary new: 5]! !!XMLNamespaceScope methodsFor: 'enumerating'!prefixesAndURIsDo: aTwoArgumentBlock	prefixMappings		ifNotNil: [prefixMappings keysAndValuesDo: aTwoArgumentBlock]! !!XMLNamespaceScope methodsFor: 'printing'!printDeclarationsOn: aStream	| isFirst |	isFirst := true.	self prefixesAndURIsDo: [:prefix :uri |		isFirst 			ifTrue: [isFirst := false]			ifFalse: [aStream space].		aStream nextPutAll: 'xmlns'.		prefix			ifNotEmpty: [				aStream					nextPut: $:;					nextPutAll: prefix].		aStream			nextPut: $=;			nextPut: $";			nextPutAll: uri;			nextPut: $"].! !!XMLNamespaceScope methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	self printDeclarationsOn: aStream.	aStream nextPut: $).! !!XMLNamespaceScope methodsFor: 'resolving'!resolvePrefix: aPrefix	"Resolves the namespace URI of aPrefix (the defualt namespace URI if aPrefix	is empty), including the predefined 'xml' and 'xmlns' prefixes. Returns an	empty string if aPrefix is unresolvable."	^ self		resolvePrefix: aPrefix		ifUnresolvable: ''! !!XMLNamespaceScope methodsFor: 'resolving'!resolvePrefix: aPrefix ifUnresolvable: aBlock	"Resolves the namespace URI of aPrefix (the defualt namespace URI if aPrefix	is empty), including the predefined 'xml' and 'xmlns' prefixes. Returns the	value of aBlock if aPrefix is unresolvable."	aPrefix size > 0 "optimization"		ifTrue: [			(aPrefix at: 1) == $x "optimization"				ifTrue: [					aPrefix = 'xml'						ifTrue: [^ self xmlNamespaceURI].					aPrefix = 'xmlns'						ifTrue: [^ self xmlnsNamespaceURI]]].	^ self		prefixMappingAt: aPrefix		ifAbsent: aBlock.! !!XMLNamespaceScope methodsFor: 'resolving'!resolvePrefixesOfNamespaceURI: aURI	| prefixes |	"the 'xml' and 'xmlns' namespaces URIs can't be aliased"	aURI = self xmlNamespaceURI		ifTrue: [^ Set with: 'xml'].	aURI = self xmlnsNamespaceURI		ifTrue: [^ Set with: 'xmlns'].	prefixes := Set new.	self prefixesAndURIsDo: [:prefix :uri |		uri = aURI			ifTrue: [prefixes add: prefix]].	^ prefixes.! !!XMLNamespaceScope methodsFor: 'accessing'!size	^ prefixMappings		ifNil: [0]		ifNotNil: [prefixMappings size]! !!XMLNamespaceScope methodsFor: 'unmapping'!unmapPrefix: aPrefix	^ self		unmapPrefix: aPrefix		ifAbsent: [self errorCannotUnmapPrefix: aPrefix]! !!XMLNamespaceScope methodsFor: 'unmapping'!unmapPrefix: aPrefix ifAbsent: aBlock	prefixMappings		ifNil: [^ aBlock value]		ifNotNil: [			"copy-on-write"			^ self copiedPrefixMappings 				removeKey: aPrefix				ifAbsent: aBlock]! !!XMLNamespaceScope methodsFor: 'unmapping'!unmapPrefixes	self hasNamespaces		ifTrue: [			"copy-on-write"			self copiedPrefixMappings removeAll]! !!XMLNamespaceScope methodsFor: 'validating'!validateAndResolvePrefix: aPrefix ofAttribute: anAttribute	"performance critical method"	aPrefix size > 0 "optimization"		ifTrue: [			^ self				prefixMappingAt: aPrefix				ifAbsent: [					aPrefix = 'xml'						ifTrue: [self xmlNamespaceURI]						ifFalse: [												aPrefix = 'xmlns'								ifTrue: [									"this can't happen during parsing, because									'xmlns' attributes are treated as namespace									declarations, but it can happen through DOM tree									manipulation, for example:										attributeNode prefix: 'xmlns'									"									self errorXMLNSPrefixInAttribute: anAttribute]								ifFalse: [									self										errorUnmappedPrefix: aPrefix										inAttribute: anAttribute]]]]		ifFalse: [			"catch names like ':name' with an empty prefix"			(anAttribute size > 0				and: [(anAttribute at: 1) == $:])				ifTrue: [self errorInvalidUnprefixedAttribute: anAttribute].			^ '']! !!XMLNamespaceScope methodsFor: 'validating'!validateAndResolvePrefix: aPrefix ofElement: anElement	aPrefix size > 0 "optimization"		ifTrue: [			^ self				prefixMappingAt: aPrefix				ifAbsent: [					aPrefix = 'xml'						ifTrue: [self xmlNamespaceURI]						ifFalse: [												aPrefix = 'xmlns'								ifTrue: [self errorXMLNSPrefixInElement: anElement]								ifFalse: [									self										errorUnmappedPrefix: aPrefix										inElement: anElement]]]]		ifFalse: [			"catch names like ':name' with an empty prefix"			(anElement size > 0				and: [(anElement at: 1) == $:])				ifTrue: [self errorInvalidUnprefixedElement: anElement].			^ self defaultNamespace]! !!XMLNamespaceScope methodsFor: 'private'!validatePrefix: aPrefix beforeMappingTo: aURI	aPrefix size > 0 "optimization"		ifTrue: ["non-default namespace"			aPrefix = 'xml' "cannot be remapped"				ifTrue: [					aURI = self xmlNamespaceURI						ifFalse: [self errorCannotRemapXMLPrefix].					^ self].			aPrefix = 'xmlns' "cannot be mapped, even to the same URI"				ifTrue: [self errorCannotMapXMLNSPrefix].			(aPrefix indexOf: $:) > 0 				ifTrue: [self errorInvalidPrefix: aPrefix].			"non-default namespaces cannot be mapped to empty uris, even			to shadow an inherited namesapce"			aURI size > 0				ifFalse: [self errorCannotMapPrefixToEmptyURI]].	"these URIs cannot be aliased, even by the default namespace"	aURI = self xmlNamespaceURI		ifTrue: [self errorCannotAliasXMLPrefixWith: aPrefix].	aURI = self xmlnsNamespaceURI		ifTrue: [self errorCannotAliasXMLNSPrefixWith: aPrefix].! !!XMLNamespaceScope methodsFor: 'validating'!validatePrefixesOfAttributes: anAttributeCollection	^ self		validatePrefixesOfAttributes: anAttributeCollection asArray		from: 1		to: anAttributeCollection size! !!XMLNamespaceScope methodsFor: 'validating'!validatePrefixesOfAttributes: anAttributeCollection from: aStart to: aStop	"performance critical method"	| attributeLocalNamesAndURIs |	"#to:do: for speed"	aStart to: aStop do: [:i | | attribute prefix uri |		attribute := anAttributeCollection at: i.		prefix := attribute xmlPrefixBeforeLocalName.		(uri :=			self				validateAndResolvePrefix: prefix				ofAttribute: attribute) size > 0 "optimization"			ifTrue: [| oldSize |				oldSize :=					(attributeLocalNamesAndURIs						ifNil: [							"not initialized unless needed"							attributeLocalNamesAndURIs := Set new]) size.				(attributeLocalNamesAndURIs					add: (attribute xmlLocalNameAfterPrefix: prefix) -> uri;					size) > oldSize					ifFalse: [						self							errorAttribute: attribute xmlLocalNameAfterPrefix							aliasesURI: uri]]]! !!XMLNamespaceScope methodsFor: 'defaults'!xmlNamespaceURI	^ self class xmlNamespaceURI! !!XMLNamespaceScope methodsFor: 'defaults'!xmlnsNamespaceURI	^ self class xmlnsNamespaceURI! !!XMLNamespaceScopeAllocator methodsFor: 'accessing'!currentScope	| totalScopes |	^ (totalScopes := scopes size) > 0		ifTrue: [scopes at: totalScopes]		ifFalse: [self newEmptyScope]! !!XMLNamespaceScopeAllocator methodsFor: 'accessing'!currentScope: aScope	scopes size > 0		ifTrue: [			scopes				at: scopes size				put: aScope]		ifFalse: [scopes addLast: aScope]! !!XMLNamespaceScopeAllocator methodsFor: 'allocating'!enterScope	^ scopes addLast: self currentScope copy! !!XMLNamespaceScopeAllocator methodsFor: 'allocating'!exitScope	^ scopes removeLast! !!XMLNamespaceScopeAllocator methodsFor: 'testing'!hasCurentScope	^ scopes notEmpty! !!XMLNamespaceScopeAllocator methodsFor: 'initialization'!initialize	super initialize.	scopes := OrderedCollection new: 10.! !!XMLNamespaceScopeAllocator methodsFor: 'instance creation'!newEmptyScope	^ XMLNamespaceScope new! !!XMLNamespaceScopeAllocator methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	self hasCurentScope		ifTrue: [			aStream				nextPut: $(;				print: self currentScope;				nextPut: $)].! !!XMLNamespaceScopeAllocator methodsFor: 'accessing'!scopes	^ scopes! !!XMLNestedStreamReader class methodsFor: 'class initialization'!initialize	"self initialize"	"stored in class vars for faster access"	CRCharacter := Character cr.	LFCharacter := Character lf.	"a null stream that is already #atEnd and can safely be sent	#close repeatedly and #atEnd after"	NullReadStream := XMLNullReadStream new.! !!XMLNestedStreamReader class methodsFor: 'instance creation'!on: aStream	^ self		on: aStream		readLimit: nil! !!XMLNestedStreamReader class methodsFor: 'instance creation'!on: aStream readLimit: anInteger	^ self new		setStream: aStream		readLimit: anInteger! !!XMLNestedStreamReader methodsFor: 'testing'!atEnd	peekChar		ifNotNil: [^ false].	stream atEnd		ifFalse: [^ false].	"use #to:do: for speed"	1 to: nestedStreams size do: [:i |		(nestedStreams at: i) stream atEnd			ifFalse: [^ false]].	^ true.! !!XMLNestedStreamReader methodsFor: 'testing'!atQuote	^ self peek == $"		or: [peekChar == $']! !!XMLNestedStreamReader methodsFor: 'private'!closeStream: aStream	"must use respondsTo: to support streams only implementing the basic protocol"	(aStream respondsTo: #close)		ifTrue: [aStream close].! !!XMLNestedStreamReader methodsFor: 'closing'!closeStreams	"close the streams but do not evaluate their callbacks and	set the current stream to the null stream sending #closeStreams	again won't raise an error"	self		closeStream: stream;		setStreamToNull.	[nestedStreams size > 0]		whileTrue: [self closeStream: nestedStreams removeLast stream].! !!XMLNestedStreamReader methodsFor: 'decoding'!convertFromEncoding: anEncodingName	"Encoding attributes are ignored unless the stream is a converting adapter	that has a null/implicit converter.		This is the safest approach, because the encoding of a file can be easily	changed by a text editor or utility without automatically updating the	<?xml ...?> encoding attribute.		The BOM and out-of-band info (like HTTP headers) should be given precedence."	(stream isXMLConvertingStreamAdapter		and: [stream hasNullStreamConverter			or: [stream hasImplicitStreamConverter]])		ifTrue: [| streamConverter |			(streamConverter := anEncodingName asXMLStreamConverter) isNull				ifTrue: [self errorUnsupportedEncoding: anEncodingName].			self decodeStreamWithConverter: streamConverter]! !!XMLNestedStreamReader methodsFor: 'accessing'!currentColumnNumber	"recording the start pos. of the line and subtracting it from the current	pos. is faster than an explicit column var that would need to be incremented	each time through #next/#skipSeparators"	^ currentLineStartPosition		ifNotNil: [currentPosition - currentLineStartPosition]! !!XMLNestedStreamReader methodsFor: 'accessing'!currentLineNumber	^ currentLineNumber! !!XMLNestedStreamReader methodsFor: 'accessing'!currentPosition	^ currentPosition! !!XMLNestedStreamReader methodsFor: 'decoding'!decodeStreamWithConverter: aStreamConverter	stream isXMLConvertingStreamAdapter		ifTrue: [stream streamConverter: aStreamConverter]		ifFalse: [			stream :=				XMLDecodingReadStreamAdapter					on: stream					streamConverter: aStreamConverter]! !!XMLNestedStreamReader methodsFor: 'decoding'!detectEncoding	stream isXMLConvertingStreamAdapter		ifTrue: [stream detectEncoding]		ifFalse: [			"if it's not already an XMLDecodingReadStreamAdapter, just look			for an obvious leading byte-order mark and convert it if found,			and otherwise just leave it alone"			(XMLEncodingDetector on: stream) streamConverterForEncoding				ifNotNil: [:converter |					self decodeStreamWithConverter: converter]]! !!XMLNestedStreamReader methodsFor: 'private'!errorNestingLimitExceeded	XMLLimitException signal: 'Cannot further nest input streams'! !!XMLNestedStreamReader methodsFor: 'private'!errorReadLimitExceeded	XMLLimitException signal:		'Security input read limit exceeded; ',		'use #documentReadLimit: and #externalSubsetReadLimit: ',		'to change/disable it, or #defaultReadLimit: ',		'to persistently change/disable it'! !!XMLNestedStreamReader methodsFor: 'private'!errorUnsupportedEncoding: anEncodingName	XMLEncodingException		formatSignal: 'Encoding "{1}" is unsupported'		with: anEncodingName! !!XMLNestedStreamReader methodsFor: 'private'!hasNextAfterPoppingStreamsAtEnd	"always pop at least one stream, which makes the new current stream	the null stream if there aren't any nested streams"	self popCurrentStream.	[stream atEnd]		whileTrue: [			nestedStreams size > 0				ifFalse: [^ false].			self popCurrentStream].	^ true.! !!XMLNestedStreamReader methodsFor: 'testing'!hasPushedBackStreams	^ nestedStreams size > 0! !!XMLNestedStreamReader methodsFor: 'testing'!isBinary	^ false! !!XMLNestedStreamReader methodsFor: 'testing'!isStream	^ true! !!XMLNestedStreamReader methodsFor: 'testing'!isXMLBinaryOrExternalStream	^ self isBinary! !!XMLNestedStreamReader methodsFor: 'private'!maxNestedStreams	^ 32! !!XMLNestedStreamReader methodsFor: 'private'!nestedStreamsAddLast: aPushedBackStream	nestedStreams size >= self maxNestedStreams		ifTrue: [self errorNestingLimitExceeded].	nestedStreams addLast: aPushedBackStream.! !!XMLNestedStreamReader methodsFor: 'private'!newWriteStream	^ (self writeStreamCollectionClass new: 128) writeStream! !!XMLNestedStreamReader methodsFor: 'accessing'!next	| nextChar |	peekChar		ifNil: [			stream atEnd				ifTrue: [					self hasNextAfterPoppingStreamsAtEnd						ifFalse: [^ nil]].			nextChar := stream next.			isExternal				ifTrue: [					currentPosition := currentPosition + 1.					nextChar == LFCharacter						ifTrue: [							nextChar := normalizedLineEndingChar.							currentLineNumber := currentLineNumber + 1.							currentLineStartPosition := currentPosition]						ifFalse: [							nextChar == CRCharacter								ifTrue: [									stream atEnd										ifFalse: [											stream peek == LFCharacter												ifTrue: [stream next]].									nextChar := normalizedLineEndingChar.									currentLineNumber := currentLineNumber + 1.									currentLineStartPosition := currentPosition]]]]		ifNotNil: [			nextChar := peekChar.			peekChar := nil.			isExternal				ifTrue: [					currentPosition := currentPosition + 1.					nextChar == normalizedLineEndingChar						ifTrue: [							currentLineNumber := currentLineNumber + 1.							currentLineStartPosition := currentPosition]]].	readLimit		ifNotNil: [			(readLimit := readLimit - 1) >= 0				ifFalse: [self errorReadLimitExceeded]].	^ nextChar.! !!XMLNestedStreamReader methodsFor: 'accessing'!next: anInteger	| writeStream i |	writeStream := self newWriteStream.	i := 0.	[self atEnd		or: [i >= anInteger]]		whileFalse: [			writeStream nextPut: self next.			i := i + 1].	^ writeStream contents.! !!XMLNestedStreamReader methodsFor: 'accessing'!normalizedLineEndingChar	^ normalizedLineEndingChar! !!XMLNestedStreamReader methodsFor: 'accessing'!normalizedLineEndingChar: aCharacter	normalizedLineEndingChar := aCharacter! !!XMLNestedStreamReader methodsFor: 'accessing'!peek	peekChar		ifNotNil: [^ peekChar].	stream atEnd		ifTrue: [			self hasNextAfterPoppingStreamsAtEnd				ifFalse: [^ nil]].	peekChar := stream next.	isExternal		ifTrue: [			peekChar == LFCharacter				ifTrue: [^ peekChar := normalizedLineEndingChar].			peekChar == CRCharacter				ifTrue: [					stream atEnd						ifFalse: [							stream peek == LFCharacter								ifTrue: [stream next]].					^ peekChar := normalizedLineEndingChar]].	^ peekChar.! !!XMLNestedStreamReader methodsFor: 'accessing'!peekFor: aCharacter	(self atEnd not		and: [self peek = aCharacter])		ifTrue: [			self next.			^ true]		ifFalse: [^ false]! !!XMLNestedStreamReader methodsFor: 'private'!popCurrentStream	| callbackOfPoppedStream |	"close the stream first and pop it before evaluating the callback so any	exception it raises won't cause us to leak file streams or double close a	stream when XMLParser>>#handleParserError: sends #closeStreams"	self closeStream: stream.	callbackOfPoppedStream := whenPoppedDo.	nestedStreams size > 0		ifTrue: [| pushedBackStream |			pushedBackStream := nestedStreams removeLast.			stream := pushedBackStream stream.			whenPoppedDo := pushedBackStream whenPoppedDo.			isExternal := pushedBackStream isExternal.			currentPosition := pushedBackStream currentPosition.			currentLineNumber := pushedBackStream currentLineNumber.			currentLineStartPosition := pushedBackStream currentLineStartPosition]		ifFalse: [self setStreamToNull].	"now it's safe to evaluate the callback"	callbackOfPoppedStream		ifNotNil: [callbackOfPoppedStream value].! !!XMLNestedStreamReader methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		print: peekChar; "can be nil"		nextPutAll: '; ';		print: stream;		space;		print: nestedStreams;		nextPut: $).! !!XMLNestedStreamReader methodsFor: 'positioning'!pushBack: aString	aString size > 1		ifTrue: [^ self pushBackStream: aString readStream].	aString size = 1		ifTrue: [self pushBackCharacter: (aString at: 1)]! !!XMLNestedStreamReader methodsFor: 'positioning'!pushBackCharacter: aCharacter	self		pushBackStream: (XMLSingleCharacterReadStream on: aCharacter)		whenPoppedDo: nil		isExternal: false! !!XMLNestedStreamReader methodsFor: 'positioning'!pushBackStream: aStream	self		pushBackStream: aStream		whenPoppedDo: nil		isExternal: false! !!XMLNestedStreamReader methodsFor: 'positioning'!pushBackStream: aStream whenPoppedDo: aBlock isExternal: aBoolean	self nestedStreamsAddLast:		((isExternal			ifTrue: [XMLPushedBackExternalStream]			ifFalse: [XMLPushedBackInternalStream])				stream: stream				whenPoppedDo: whenPoppedDo				currentPosition: currentPosition				currentLineNumber: currentLineNumber				currentLineStartPosition: currentLineStartPosition).	peekChar		ifNotNil: [			self nestedStreamsAddLast:				(XMLPushedBackInternalStream					stream: (XMLSingleCharacterReadStream on: peekChar)					whenPoppedDo: nil					currentPosition: currentPosition					currentLineNumber: currentLineNumber					currentLineStartPosition: currentLineStartPosition).			peekChar := nil].	self stream: aStream.	whenPoppedDo := aBlock.	(isExternal := aBoolean)		ifTrue: [			currentPosition := 0.			currentLineNumber := 1.			currentLineStartPosition := 0].! !!XMLNestedStreamReader methodsFor: 'accessing'!readLimit	^ readLimit! !!XMLNestedStreamReader methodsFor: 'initialization'!setStream: aStream readLimit: anInteger	self stream: aStream.	isExternal := true.	currentPosition := 0.	currentLineNumber := 1.	currentLineStartPosition := 0.	nestedStreams := OrderedCollection new: 5.	readLimit := anInteger.	normalizedLineEndingChar := LFCharacter.! !!XMLNestedStreamReader methodsFor: 'private'!setStreamToNull	stream := NullReadStream.	whenPoppedDo := nil.	"do not reset the other stream properties, including position	and line number, so error messages will be accurate"! !!XMLNestedStreamReader methodsFor: 'positioning'!skip: anInteger	1 to: anInteger do: [:i |		self atEnd			ifTrue: [^ self].		self next]! !!XMLNestedStreamReader methodsFor: 'positioning'!skipSeparators	"This code is heavily optimized."	| isExternalNormalizedLineEnding |	[peekChar		ifNil: [			stream atEnd				ifTrue: [					self hasNextAfterPoppingStreamsAtEnd						ifFalse: [^ self]].			peekChar := stream next.			isExternal				ifTrue: [					peekChar == LFCharacter						ifTrue: [isExternalNormalizedLineEnding := true]						ifFalse: [							peekChar == CRCharacter								ifTrue: [									stream atEnd										ifFalse: [											stream peek == LFCharacter												ifTrue: [stream next]].									isExternalNormalizedLineEnding := true]								ifFalse: [									isExternalNormalizedLineEnding := false.									"nil understands #isXMLSeparator, so it									isn't tested for first"									peekChar isXMLSeparator]]]				ifFalse: [					"nil understands #isXMLSeparator, so it isn't tested for first"					peekChar isXMLSeparator]]			ifNotNil: [				isExternal					ifTrue: [						isExternalNormalizedLineEnding :=							peekChar == normalizedLineEndingChar].				peekChar isXMLSeparator]]		whileTrue: [			"inlined from #next"			peekChar := nil.			isExternal				ifTrue: [					currentPosition := currentPosition + 1.					isExternalNormalizedLineEnding						ifTrue: [							currentLineNumber := currentLineNumber + 1.							currentLineStartPosition := currentPosition].			readLimit				ifNotNil: [					(readLimit := readLimit - 1) >= 0						ifFalse: [self errorReadLimitExceeded]]]]! !!XMLNestedStreamReader methodsFor: 'positioning'!skipTo: aCharacter	[self atEnd]		whileFalse: [			self next = aCharacter				ifTrue: [^ true]].	^ false.! !!XMLNestedStreamReader methodsFor: 'accessing'!stream	^ stream! !!XMLNestedStreamReader methodsFor: 'accessing'!stream: aStream	"if the stream is not already a decoding adapter,	then only assume it needs one if it's binary"	stream := 		aStream isXMLConvertingStreamAdapter			ifTrue: [aStream]			ifFalse: [				(XMLDecodingReadStreamAdapter nonDecodingOnIfBinaryOrExternal: aStream)					ifNil: [aStream]]! !!XMLNestedStreamReader methodsFor: 'accessing'!upTo: aCharacter	| writeStream nextChar |	writeStream := self newWriteStream.	[self atEnd		or: [(nextChar := self next) = aCharacter]]		whileFalse: [writeStream nextPut: nextChar].	^ writeStream contents.! !!XMLNestedStreamReader methodsFor: 'accessing'!upToEnd	| writeStream |	writeStream := self newWriteStream.	[self atEnd]		whileFalse: [writeStream nextPut: self next].	^ writeStream contents.! !!XMLNestedStreamReader methodsFor: 'defaults'!writeStreamCollectionClass	^ String! !!XMLAttribute class methodsFor: 'instance creation'!name: aName	^ self named: aName! !!XMLAttribute class methodsFor: 'instance creation'!name: aName value: aValue	^ self new			setName: aName		value: aValue		element: nil! !!XMLAttribute class methodsFor: 'instance creation'!named: aName	^ self		name: aName		value: ''! !!XMLAttribute methodsFor: 'accessing'!element	"reuse an inst var to save memory"	^ parent! !!XMLAttribute methodsFor: 'accessing'!element: anElement	"reuse an inst var to save memory"	parent := anElement! !!XMLAttribute methodsFor: 'accessing'!expandedName	"Returns the expanded name of the attribute as a string in the form of	'{namespaceURI}localName' if there's a namespace URI or 'localName' if there	isn't"	^ self localName expandWithXMLNamespaceURI: self namespaceURI! !!XMLAttribute methodsFor: 'testing'!hasNamespaceURI	^ self namespaceURI notEmpty! !!XMLAttribute methodsFor: 'testing'!hasPrefix	^ (self name		indexOf: $:		startingAt: 2) > 0! !!XMLAttribute methodsFor: 'testing'!isAttribute	^ true! !!XMLAttribute methodsFor: 'testing'!isInLanguage: aLanguageTag	"Returns true if the receiver is an xml:lang attribute or if its element	or an ancestor element has an xml:lang attribute, and if the value is an IETF	language tag, like 'en-US', that matches aLanguageTag. Matching is	case-insensitive, and aLanguageTag can be partial, like 'en', and use	wildcards, like 'en-*'"	self name = 'xml:lang'		ifTrue: [^ self matchesLanguage: aLanguageTag]		ifFalse: [^ super isInLanguage: aLanguageTag]! !!XMLAttribute methodsFor: 'testing'!isNamed: aName	"Does the receiver's qualified or local name match the argument?"	^ self name isXMLQualifiedOrLocalName: aName! !!XMLAttribute methodsFor: 'testing'!isNamedAny: aNameCollection	"Does the receiver's qualified or local name match any of the names	in aNameCollection?"	^ aNameCollection includesXMLName: self name! !!XMLAttribute methodsFor: 'accessing'!localName	"Returns the local name of the receiver, the name minus any leading	prefix and colon like 'local' in 'prefix:local'"	"this is recomputed from the name to save memory instead of	being stored in an inst var like it is for XMLElement"	^ self name xmlLocalNameAfterPrefix! !!XMLAttribute methodsFor: 'testing'!matchesLanguage: aLanguageTag	"Returns true if the value is an IETF language tag that matches aLanguageTag.	Matching is case-insensitive, and aLanguageTag can be partial, like 'en',	and use wildcards, like 'en-*'"	| sourceLanguageTag targetLanguageTag i |	((sourceLanguageTag := self value asLowercase) isEmpty		or: [(targetLanguageTag := aLanguageTag asLowercase) isEmpty])		ifTrue: [^ false].	sourceLanguageTag = targetLanguageTag		ifTrue: [^ true].	sourceLanguageTag := $- xmlSplit: sourceLanguageTag.	i := 0.	$-		xmlSplit: targetLanguageTag		do: [:each | | sourceLanguageSubTag |			sourceLanguageSubTag :=				sourceLanguageTag					at: (i := i + 1)					ifAbsent: [^ false].			(sourceLanguageSubTag = each				or: [each = '*'])				ifFalse: [^ false]].	^ true.! !!XMLAttribute methodsFor: 'accessing'!name	^ name ifNil: [name := '']! !!XMLAttribute methodsFor: 'accessing'!name: aName	self renameWith: [name := aName]! !!XMLAttribute methodsFor: 'accessing'!namespaceURI	^ self resolvePrefix: self prefix! !!XMLAttribute methodsFor: 'accessing'!prefix	"Returns the prefix of the receiver's name or an empty string if there	isn't one."	"this is recomputed from the qualified name instead of being stored	in an inst var to save memory."	^ self name xmlPrefixBeforeLocalName! !!XMLAttribute methodsFor: 'accessing'!prefix: aPrefix	self renameWith: [name := self localName qualifyWithXMLPrefix:  aPrefix]! !!XMLAttribute methodsFor: 'private'!renameWith: aBlock	| oldName |	oldName := self name.	aBlock value.	(self name ~= oldName		and: [self hasParent])			ifTrue: [				self parent					renamedAttribute: self					from: oldName					to: self name].! !!XMLAttribute methodsFor: 'namespacing'!resolvePrefix: aPrefix	"This resolves the attribute prefix aPrefix or returns an empty string	if aPrefix is empty (attributes must be prefixed to have a namespace) or	undeclared"	^ self		resolvePrefix: aPrefix		ifUnresolvable: ''! !!XMLAttribute methodsFor: 'namespacing'!resolvePrefix: aPrefix ifUnresolvable: aBlock	"This resolves the attribute prefix aPrefix or returns the result of	evaluated aBlock if aPrefix is empty (attributes must be prefixed to have	a namespace) or undeclared"	^ (self hasParent		and: [aPrefix size > 0]) "no default namespace for attributes"		ifTrue: [			self parent				resolvePrefix: aPrefix				ifUnresolvable: aBlock]		ifFalse: [aBlock value]! !!XMLAttribute methodsFor: 'initialization'!setName: aName value: aValue element: anElement	name := aName.	value := aValue.	parent := anElement.! !!XMLAttribute methodsFor: 'accessing'!sortKey	^ self name! !!XMLAttribute methodsFor: 'accessing'!value	^ value ifNil: [value := '']! !!XMLAttribute methodsFor: 'accessing'!value: aString	value := aString! !!XMLAttribute methodsFor: 'printing'!writeXMLOn: aWriter	aWriter		writeStringName: self name;		nextPut: $=;		writeEscapedContentString: self value! !!XMLComment class methodsFor: 'instance creation'!string: aString	^ self new string: aString! !!XMLComment methodsFor: 'visiting'!acceptNodeVisitor: aNodeVisitor	^ aNodeVisitor visitComment: self! !!XMLComment methodsFor: 'testing'!isComment	^ true! !!XMLComment methodsFor: 'accessing'!sortKey	^ self string! !!XMLComment methodsFor: 'accessing'!string	^ string ifNil: [string := '']! !!XMLComment methodsFor: 'accessing'!string: aString	string := aString! !!XMLComment methodsFor: 'printing'!writeXMLOn: aWriter	aWriter comment: self string! !!XMLAttributeDeclaration class methodsFor: 'instance creation'!element: anElementName attribute: anAttributeName type: aType defaultPragma: aDefaultPragma defaultValue: aDefaultValue	^ self new		element: anElementName;		attribute: anAttributeName;		type: aType;		defaultPragma: aDefaultPragma;		defaultValue: aDefaultValue! !!XMLAttributeDeclaration methodsFor: 'accessing'!attribute	^ attribute ifNil: [attribute := '']! !!XMLAttributeDeclaration methodsFor: 'accessing'!attribute: anAttributeName	attribute := anAttributeName! !!XMLAttributeDeclaration methodsFor: 'accessing'!defaultPragma	^ defaultPragma ifNil: [defaultPragma := '']! !!XMLAttributeDeclaration methodsFor: 'accessing'!defaultPragma: aDefaultPragma	defaultPragma := aDefaultPragma! !!XMLAttributeDeclaration methodsFor: 'accessing'!defaultValue	^ defaultValue ifNil: [defaultValue := '']! !!XMLAttributeDeclaration methodsFor: 'accessing'!defaultValue: aDefaultValue	defaultValue := aDefaultValue! !!XMLAttributeDeclaration methodsFor: 'accessing'!element	^ element ifNil: [element := '']! !!XMLAttributeDeclaration methodsFor: 'accessing'!element: anElementName	element := anElementName! !!XMLAttributeDeclaration methodsFor: 'accessing'!type	^ type ifNil: [type := '']! !!XMLAttributeDeclaration methodsFor: 'accessing'!type: aType 	type := aType! !!XMLAttributeDeclaration methodsFor: 'printing'!writeXMLOn: aWriter	aWriter attributeDeclaration		element: self element;		attribute: self attribute;		type: self type;		defaultPragma: self defaultPragma;		defaultValue: self defaultValue;		write! !!XMLDeclarationNode methodsFor: 'testing'!isDeclaration	^ true! !!XMLElementDeclaration class methodsFor: 'instance creation'!element: anElementName contentModel: aContentModel	^ self new		element: anElementName;		contentModel: aContentModel! !!XMLElementDeclaration methodsFor: 'accessing'!contentModel	^ contentModel ifNil: [contentModel := '']! !!XMLElementDeclaration methodsFor: 'accessing'!contentModel: aContentModel	contentModel := aContentModel! !!XMLElementDeclaration methodsFor: 'accessing'!element	^ element ifNil: [element := '']! !!XMLElementDeclaration methodsFor: 'accessing'!element: anElementName	element := anElementName! !!XMLElementDeclaration methodsFor: 'printing'!writeXMLOn: aWriter	aWriter elementDeclaration		element: self element;		contentModel: self contentModel;		write! !!XMLEntityDeclaration class methodsFor: 'instance creation'!name: aName publicID: aPublicID systemID: aSystemID	^ self new		name: aName;		publicID: aPublicID;		systemID: aSystemID! !!XMLEntityDeclaration class methodsFor: 'instance creation'!name: aName replacement: aReplacement	^ self new		name: aName;		replacement: aReplacement! !!XMLEntityDeclaration methodsFor: 'testing'!isExternal	^ self systemID notEmpty		or: [self publicID notEmpty]! !!XMLEntityDeclaration methodsFor: 'testing'!isParameter	^ false! !!XMLEntityDeclaration methodsFor: 'testing'!isUnparsed	^ false! !!XMLEntityDeclaration methodsFor: 'accessing'!name	^ name ifNil: [name := '']! !!XMLEntityDeclaration methodsFor: 'accessing'!name: aName	name := aName! !!XMLEntityDeclaration methodsFor: 'accessing'!publicID	^ publicID ifNil: [publicID := '']! !!XMLEntityDeclaration methodsFor: 'accessing'!publicID: aPublicID	publicID := aPublicID! !!XMLEntityDeclaration methodsFor: 'accessing'!replacement	^ replacement ifNil: [replacement := '']! !!XMLEntityDeclaration methodsFor: 'accessing'!replacement: aReplacement	replacement := aReplacement! !!XMLEntityDeclaration methodsFor: 'accessing'!systemID	^ systemID ifNil: [systemID := '']! !!XMLEntityDeclaration methodsFor: 'accessing'!systemID: aSystemID	systemID := aSystemID! !!XMLGeneralEntityDeclaration class methodsFor: 'instance creation'!name: aName publicID: aPublicID systemID: aSystemID ndata: aNotationName	^ self new		name: aName;		publicID: aPublicID;		systemID: aSystemID;		ndata: aNotationName! !!XMLGeneralEntityDeclaration methodsFor: 'testing'!isUnparsed	^ self ndata notEmpty! !!XMLGeneralEntityDeclaration methodsFor: 'accessing'!ndata	^ ndata ifNil: [ndata := '']! !!XMLGeneralEntityDeclaration methodsFor: 'accessing'!ndata: aNotationName	ndata := aNotationName! !!XMLGeneralEntityDeclaration methodsFor: 'printing'!writeXMLOn: aWriter	aWriter entityDeclaration		name: self name;		isParameter: false;		replacement: self replacement;		publicID: self publicID;		systemID: self systemID;		ndata: self ndata;		write! !!XMLParameterEntityDeclaration methodsFor: 'testing'!isParameter	^ true! !!XMLParameterEntityDeclaration methodsFor: 'printing'!writeXMLOn: aWriter	aWriter entityDeclaration		name: self name;		isParameter: true;		replacement: self replacement;		publicID: self publicID;		systemID: self systemID;		write! !!XMLNotationDeclaration class methodsFor: 'instance creation'!name: aName publicID: aPublicID systemID: aSystemID	^ self new		name: aName;		publicID: aPublicID;		systemID: aSystemID! !!XMLNotationDeclaration methodsFor: 'accessing'!name	^ name ifNil: [name := '']! !!XMLNotationDeclaration methodsFor: 'accessing'!name: aName	name := aName! !!XMLNotationDeclaration methodsFor: 'accessing'!publicID	^ publicID ifNil: [publicID := '']! !!XMLNotationDeclaration methodsFor: 'accessing'!publicID: aPublicID	publicID := aPublicID! !!XMLNotationDeclaration methodsFor: 'accessing'!systemID	^ systemID ifNil: [systemID := '']! !!XMLNotationDeclaration methodsFor: 'accessing'!systemID: aSystemID	systemID := aSystemID! !!XMLNotationDeclaration methodsFor: 'printing'!writeXMLOn: aWriter	aWriter notationDeclaration		name: self name;		publicID: self publicID;		systemID: self systemID;		write! !!XMLNode methodsFor: 'visiting'!acceptNodeVisitor: aNodeVisitor	^ self! !!XMLNode methodsFor: 'deprecated'!addContent: aStringOrStringNode	"will be deprecated"	XMLDOMException signal: 'Node cannot contain string content'! !!XMLNode methodsFor: 'enumerating'!allNodesDo: aBlock	"evaluates aBlock for the receiver and all of its descendant nodes"	aBlock value: self! !!XMLNode methodsFor: 'accessing'!ancestorElements	"returns a node list with all ancestor elements of the receiver"	| ancestorElements |	ancestorElements := self newListForSelect.	self ancestorElementsDo: [:each | ancestorElements addLast: each].	^ ancestorElements.! !!XMLNode methodsFor: 'enumerating'!ancestorElementsDo: aBlock	| ancestor |	ancestor := self parent.	[ancestor notNil		and: [ancestor isElement]]		whileTrue: [			aBlock value: ancestor.			ancestor := ancestor parent].! !!XMLNode methodsFor: 'accessing'!ancestorNodes	"returns a node list with all ancestor nodes of the receiver"	| ancestors |	ancestors := self newListForSelect.	self ancestorNodesDo: [:each | ancestors addLast: each].	^ ancestors.! !!XMLNode methodsFor: 'enumerating'!ancestorNodesDo: aBlock	| ancestor |	ancestor := self parent.	[ancestor notNil]		whileTrue: [			aBlock value: ancestor.			ancestor := ancestor parent].! !!XMLNode methodsFor: 'converting'!asString	"Returns the full, untruncated XML source string, unlike #printString,	which may truncate long printed representations"		^ String streamContents: [:stream | self printOn: stream]! !!XMLNode methodsFor: 'testing'!canHaveChildren	"returns true if the receiver is a type of node that can have child nodes"	^ false! !!XMLNode methodsFor: 'testing'!canonicallyEquals: aNode	"returns true if the receiver and aNode have the same canonical	representation (http://www.w3.org/TR/xml-c14n)"	^ self canonicallyPrinted = aNode canonicallyPrinted! !!XMLNode methodsFor: 'printing'!canonicallyPrintOn: aStream 	"Prints on aStream as canonical XML (http://www.w3.org/TR/xml-c14n)"	self		printOn: aStream		beforeWritingDo: [:writer | writer isCanonical: true]! !!XMLNode methodsFor: 'printing'!canonicallyPrintToFileNamed: aFileName 	"Prints to the file aFileName as canonical XML (http://www.w3.org/TR/xml-c14n)"	self		printToFileNamed: aFileName		beforeWritingDo: [:writer | writer isCanonical: true]! !!XMLNode methodsFor: 'printing'!canonicallyPrinted 	"Prints as canonical XML (http://www.w3.org/TR/xml-c14n)"	^ String streamContents: [:stream | self canonicallyPrintOn: stream]! !!XMLNode methodsFor: 'accessing'!configuration	^ self parent ifNotNil: [:node | node configuration]! !!XMLNode methodsFor: 'accessing'!contentString 	"Returns a combined string of all descendant string values with spaces inserted	for readability when one string has no trailing space and the next has no	leading space.	See also #rawContentString."	^ String streamContents: [:stream | self printContentOn: stream]! !!XMLNode methodsFor: 'copying'!copy	"returns a deep copy of the receiver, including copies of any descendant nodes,	and copies the config"	^ self shallowCopy postCopy postCopyConfiguration! !!XMLNode methodsFor: 'copying'!copySharingConfiguration		"returns a deep copy of the receiver, including copies of any descendant nodes,	but does not copy the config"	^ self shallowCopy postCopy! !!XMLNode methodsFor: 'enumerating'!descendantNodesDo: aBlock! !!XMLNode methodsFor: 'deprecated'!descendentNodesDo: aBlock	self deprecated: 'use #descendantNodesDo: instead'.	^ self descendantNodesDo: aBlock.! !!XMLNode methodsFor: 'accessing'!document	"returns the document node that the receiver belongs to (the receiver if it's a	document) or nil if there isn't one"	^ self parent ifNotNil: [:node | node document]! !!XMLNode methodsFor: 'accessing'!documentRoot	"returns the root of the DOM tree, a document node if there is one or the	last ancestor or self otherwise"	| documentRoot |	documentRoot := self.	self ancestorNodesDo: [:each | documentRoot := each].	^ documentRoot.! !!XMLNode methodsFor: 'private'!errorXMLWritingUnsupported	XMLDOMException signal: 'The XMLWriter package is required for writng DOM objects'! !!XMLNode methodsFor: 'private'!escapesContentEntitiesWhenWriting	self hasParent		ifTrue: [^ self parent escapesContentEntitiesWhenWriting]		ifFalse: [^ true] "default to escaping"! !!XMLNode methodsFor: 'testing'!hasChildren	"returns true if the receiver has child nodes"	^ false! !!XMLNode methodsFor: 'private'!hasNodeList: aNodeList	^ false! !!XMLNode methodsFor: 'testing'!hasParent	"returns true if the receiver has a parent node"	^ parent notNil! !!XMLNode methodsFor: 'private'!hasParentWithNodeList: aNodeList	"optimized"	parent == nil		ifTrue: [^ false].	^ parent hasNodeList: aNodeList.! !!XMLNode methodsFor: 'private'!initializeFileWriteStream: aWriteStream	"This sets a stream converter on aWriteStream based on the document's encoding	attribute and writes the encoding's byte order mark."	| document |	aWriteStream		streamConverter:			(((document := self document) notNil				and: [document hasEncoding])				ifTrue: [document encoding asXMLStreamConverter]				ifFalse: [XMLStreamConverter default]);		nextPutByteOrderMark! !!XMLNode methodsFor: 'testing'!isAttribute	^ false! !!XMLNode methodsFor: 'testing'!isCData	^ false! !!XMLNode methodsFor: 'private'!isCoalescingStringNode	^ false! !!XMLNode methodsFor: 'testing'!isComment	^ false! !!XMLNode methodsFor: 'testing'!isContentNode	"returns true if the receiver is a content node (an element or string node)"	^ false! !!XMLNode methodsFor: 'testing'!isDeclaration	^ false! !!XMLNode methodsFor: 'testing'!isDocument	^ false! !!XMLNode methodsFor: 'testing'!isElement	^ false! !!XMLNode methodsFor: 'testing'!isElementNamed: aName	"returns true if the receiver is an element whose qualified name or local	name matches aName"	^ false! !!XMLNode methodsFor: 'testing'!isElementNamedAny: aNameCollection	"returns true if the receiver is an element whose qualified name or local	name matches any name in aNameCollection"	^ false! !!XMLNode methodsFor: 'testing'!isInLanguage: aLanguageTag	"Returns true if one of the ancestor elements of the receiver has an xml:lang	attribute, and if the value is an IETF language tag, like 'en-US', that matches	aLanguageTag. Matching is case-insensitive, and aLanguageTag can be partial,	like 'en', and use wildcards, like 'en-*'"	^ self hasParent		and: [self parent isInLanguage: aLanguageTag]! !!XMLNode methodsFor: 'testing'!isPI	"returns true if the receiver is a processing instruction node"	^ false! !!XMLNode methodsFor: 'testing'!isStringNode	^ false! !!XMLNode methodsFor: 'testing'!isStringNode: aStringOrStringNode	^ false! !!XMLNode methodsFor: 'instance creation'!newCData: aString	^ self nodeFactory newCData: aString! !!XMLNode methodsFor: 'instance creation'!newComment: aString	^ self nodeFactory newComment: aString! !!XMLNode methodsFor: 'instance creation'!newDocument	^ self nodeFactory newDocument		configuration: self configuration! !!XMLNode methodsFor: 'instance creation'!newElement	^ self nodeFactory newElement		configuration: self configuration! !!XMLNode methodsFor: 'instance creation'!newElementNamed: aName	^ (self nodeFactory classForElement: aName) new		configuration: self configuration;		name: aName! !!XMLNode methodsFor: 'instance creation'!newElementNamed: aName attributes: anAssociationCollection	^ (self nodeFactory		classForElement: aName		attributes: anAssociationCollection) new			configuration: self configuration;			name: aName;			setAttributes: anAssociationCollection! !!XMLNode methodsFor: 'instance creation'!newElementNamed: aName namespaceURI: aURI	^ (self nodeFactory		classForElement: aName		namespaceURI: aURI) new			configuration: self configuration;			name: aName namespaceURI: aURI! !!XMLNode methodsFor: 'instance creation'!newElementNamed: aName namespaceURI: aURI attributes: anAssociationCollection	^ (self nodeFactory		classForElement: aName		namespaceURI: aURI		attributes: anAssociationCollection) new			configuration: self configuration;			name: aName namespaceURI: aURI;			setAttributes: anAssociationCollection! !!XMLNode methodsFor: 'instance creation'!newListForCollect	"collect can return non-nodes, so a basic ordered list is used"	^ XMLOrderedList new: 10! !!XMLNode methodsFor: 'instance creation'!newListForSelect	"select returns only nodes, so a node list is used"	^ XMLNodeList new: 10! !!XMLNode methodsFor: 'instance creation'!newPI	^ self nodeFactory newPI! !!XMLNode methodsFor: 'instance creation'!newPITarget: aTargetString data: aDataString	^ self nodeFactory		newPITarget: aTargetString		data: aDataString! !!XMLNode methodsFor: 'instance creation'!newStringNode: aString	^ self nodeFactory newStringNode: aString! !!XMLNode methodsFor: 'accessing'!nextNode	"returns the first node after this one that is a child of the same parent (the next	sibling) or nil if there isn't one"	^ self parent ifNotNil: [:node | node nodeAfter: self]! !!XMLNode methodsFor: 'accessing'!nodeFactory	^ self configuration		ifNil: [XMLNodeFactory new]		ifNotNil: [:config | config nodeFactory]! !!XMLNode methodsFor: 'accessing'!parent	"returns the parent node of this node or nil if there isn't one"	^ parent! !!XMLNode methodsFor: 'private'!parent: aNode	parent := aNode! !!XMLNode methodsFor: 'defaults'!parserHandlerClass	^ self configuration		ifNil: [XMLDOMParser]		ifNotNil: [:config | config parserHandlerClass]! !!XMLNode methodsFor: 'copying'!postCopy	super postCopy.	parent := nil.! !!XMLNode methodsFor: 'copying'!postCopyConfiguration! !!XMLNode methodsFor: 'printing'!prettyPrintOn: aStream 	"Prints XML on aStream with whitespace formatting for readability"	self		printOn: aStream		beforeWritingDo: [:writer | writer enablePrettyPrinting]! !!XMLNode methodsFor: 'printing'!prettyPrintToFileNamed: aFileName 	"Prints XML to the file aFileName with whitespace formatting for readability"	self		printToFileNamed: aFileName		beforeWritingDo: [:writer | writer enablePrettyPrinting]! !!XMLNode methodsFor: 'printing'!prettyPrinted 	"Prints XML with whitespace formatting for readability"	^ String streamContents: [:stream | self prettyPrintOn: stream]! !!XMLNode methodsFor: 'accessing'!previousNode	"returns the first node before this one that is a child of the same parent	(the preivous sibling) or nil if there isn't one"	^ self parent ifNotNil: [:node | node nodeBefore: self]! !!XMLNode methodsFor: 'printing'!printContentOn: aStream 	"Prints on aStream the combined content strings of all descendants with	space inserted when one string has no trailing space and the next has	no leading space.	See also #printRawContentOn:"	self printRawContentOn: (XMLNodeContentWriteStreamAdapter on: aStream)! !!XMLNode methodsFor: 'printing'!printOn: aStream	"Uses XMLWriter if supported to print XML on aStream, uses the	basic Object>>printOn: otherwise"	self		withNewXMLWriterOn: aStream		do: [:writer |			self writeXMLOn: writer.			writer write]		whenAbsent: [super printOn: aStream]! !!XMLNode methodsFor: 'printing'!printOn: aStream beforeWritingDo: aBlock	"Prints XML on aStream using an XMLWriter object it creates but first	evaluates aBlock with the XMLWriter so it can be configured before writing.	Raises an error without XMLWriter support."	self		withNewXMLWriterOn: aStream		do: [:writer |			aBlock value: writer.			self writeXMLOn: writer.			writer write]! !!XMLNode methodsFor: 'printing'!printRawContentOn: aStream  	"Prints on aStream the content strings of all descendants	without spaces inserted.	See also #printContentOn:"! !!XMLNode methodsFor: 'printing'!printToFileNamed: aFileName	"Prints XML to the file aFileName. Uses the encoding specified in the	document's encoding attribute if supported or UTF-8 otherwise."	self		withNewWriteStreamOnFileNamed: aFileName		do: [:writeStream |			self				printOn: writeStream				beforeWritingDo: [:writer |					"use the platform's line break because we're writing to a file"					writer enablePlatformSpecificLineBreak]]! !!XMLNode methodsFor: 'printing'!printToFileNamed: aFileName beforeWritingDo: aBlock	"Prints XML to the file aFileName after evaluating aBlock with the XMLWriter.	Uses the encoding specified in the document's encoding attribute if	supported or UTF-8 otherwise."	self		withNewWriteStreamOnFileNamed: aFileName		do: [:writeStream |			self				printOn: writeStream				beforeWritingDo: [:writer |					"use the platform's line break because we're writing to a file"					writer enablePlatformSpecificLineBreak.					aBlock value: writer]]! !!XMLNode methodsFor: 'printing'!printWithoutSelfClosingTagsOn: aStream	"Prints XML on aStream with empty elements rendered as '<empty></empty>'	instead of self-closing '<empty/>' tags"	self		printOn: aStream		beforeWritingDo: [:writer | writer outputsSelfClosingTags: false]! !!XMLNode methodsFor: 'printing'!printWithoutSelfClosingTagsToFileNamed: aFileName	"Prints XML to the file aFileName with empty elements rendered	as '<empty></empty>' instead of self-closing '<empty/>' tags"	self		printToFileNamed: aFileName		beforeWritingDo: [:writer | writer outputsSelfClosingTags: false]! !!XMLNode methodsFor: 'printing'!printedWithoutSelfClosingTags	"Prints XML with empty elements rendered as '<empty></empty>' instead	of self-closing '<empty/>' tags"	^ String streamContents: [:stream | self printWithoutSelfClosingTagsOn: stream]! !!XMLNode methodsFor: 'accessing'!rawContentString 	"Returns a combined string of all descendant string values without any spaces	inserted for readability.		See also #contentString"	^ String streamContents: [:stream | self printRawContentOn: stream]! !!XMLNode methodsFor: 'accessing'!sortKey	"used to compare nodes when sorting"	^ self class name asString! !!XMLNode methodsFor: 'validating'!validate	"revalidate against the DTD it was parsed with (if any)"	self document ifNotNil: [:document | document validate]! !!XMLNode methodsFor: 'validating'!validateWith: aValidator	"revalidate against a custom DTD or other validator"	self document ifNotNil: [:document | document validateWith: aValidator]! !!XMLNode methodsFor: 'private'!withNewWriteStreamOnFileNamed: aFileName do: aBlock	aFileName asXMLFileHandle writeStreamDo: [:writeStream |		self initializeFileWriteStream: writeStream.		aBlock value: writeStream]! !!XMLNode methodsFor: 'private'!withNewXMLWriterOn: aStream do: aOneArgBlock	^ self		withNewXMLWriterOn: aStream		do: aOneArgBlock		whenAbsent: [self errorXMLWritingUnsupported]! !!XMLNode methodsFor: 'private'!withNewXMLWriterOn: aStream do: aOneArgBlock whenAbsent: aZeroArgBlock	| writer |	writer :=		(self xmlWriterClassOrNil			ifNil: [^ aZeroArgBlock value]) on: aStream.	self escapesContentEntitiesWhenWriting		ifFalse: [writer escapesContentEntityReferences: false].	^ aOneArgBlock value: writer.! !!XMLNode methodsFor: 'printing'!writeXMLOn: aWriter	"Template method used by nodes to write themselves on XMLWriters.	Sending with a customized XMLWriter instance as the argument can be used	to customize printing, but #printOn:beforeWritingDo: should be preferred."! !!XMLNode methodsFor: 'defaults'!xmlWriterClassOrNil	"can be overridden to return a custom XMLWriter subclass"	^ XMLClassFinder classNamed: #XMLWriter! !!XMLDoctypeDeclaration class methodsFor: 'instance creation'!root: aRootElementName publicID: aPublicID systemID: aSystemID	^ self new		root: aRootElementName;		publicID: aPublicID;		systemID: aSystemID! !!XMLDoctypeDeclaration methodsFor: 'instance creation'!newListForSelect	^ XMLInternalSubsetList new: 10! !!XMLDoctypeDeclaration methodsFor: 'defaults'!nodeListClass	^ XMLInternalSubsetList! !!XMLDoctypeDeclaration methodsFor: 'accessing'!publicID	^ publicID ifNil: [publicID := '']! !!XMLDoctypeDeclaration methodsFor: 'accessing'!publicID: aPublicID	publicID := aPublicID! !!XMLDoctypeDeclaration methodsFor: 'accessing'!root	^ root ifNil: [root := '']! !!XMLDoctypeDeclaration methodsFor: 'accessing'!root: aRootElementName	root := aRootElementName! !!XMLDoctypeDeclaration methodsFor: 'accessing'!systemID	^ systemID ifNil: [systemID := '']! !!XMLDoctypeDeclaration methodsFor: 'accessing'!systemID: aSystemID	systemID := aSystemID! !!XMLDoctypeDeclaration methodsFor: 'printing'!writeXMLOn: aWriter	aWriter doctype		root: self root;		publicID: self publicID;		systemID: self systemID;		with: [self writeInnerXMLOn: aWriter]! !!XMLNodeWithChildren methodsFor: 'adding'!addComment: aString	^ self addNode: (self newComment: aString)! !!XMLNodeWithChildren methodsFor: 'adding'!addNode: aNode	"Adds aNode to the end of the receiver's node list. Can be used for elements,	comments, and other types of nodes."	^ self nodes addLast: aNode! !!XMLNodeWithChildren methodsFor: 'adding'!addNode: aNode after: aPreviousNode	"Adds aNode to the receiver's node list after aPreviousNode raising an	error if aPreviousNode is absent"	^ self nodes		add: aNode		after: aPreviousNode! !!XMLNodeWithChildren methodsFor: 'adding'!addNode: aNode before: aNextNode	"Adds aNode to the receiver's node list before aNextNode raising an	error if aNextNode is absent"	^ self nodes		add: aNode		before: aNextNode! !!XMLNodeWithChildren methodsFor: 'adding'!addNodeFirst: aNode	"Adds aNode to the begining of the receiver's node list. Can be used for	elements, comments, and other types of nodes."	^ self nodes addFirst: aNode! !!XMLNodeWithChildren methodsFor: 'adding'!addNodes: aNodeCollection	^ self nodes addAll: aNodeCollection! !!XMLNodeWithChildren methodsFor: 'adding'!addPITarget: aTargetString data: aDataString	^ self addNode:		(self			newPITarget: aTargetString			data: aDataString)! !!XMLNodeWithChildren methodsFor: 'notifying'!addedNode: aNode	aNode parent		ifNotNil: [:nodeParent |			nodeParent == self				ifFalse: [nodeParent removeNode: aNode]].	aNode parent: self.! !!XMLNodeWithChildren methodsFor: 'accessing'!allNodes	"returns a node list with the receiver and all of its descendant nodes"	| allNodes |	allNodes := self newListForSelect.	self allNodesDo: [:each | allNodes addLast: each].	^ allNodes.! !!XMLNodeWithChildren methodsFor: 'enumerating'!allNodesCollect: aBlock	"returns an ordered list of the receiver and all of its descendant nodes	evaluated with aBlock"	| collectedObjects |	collectedObjects := self newListForCollect.	self allNodesDo: [:each | collectedObjects addLast: (aBlock value: each)].	^ collectedObjects.! !!XMLNodeWithChildren methodsFor: 'enumerating'!allNodesDetect: aBlock	^ self allNodesDetect: aBlock ifNone: [nil]! !!XMLNodeWithChildren methodsFor: 'enumerating'!allNodesDetect: aBlock ifNone: anExceptionBlock	self allNodesDo: [:each |		(aBlock value: each)			ifTrue: [^ each]].	^ anExceptionBlock value.! !!XMLNodeWithChildren methodsFor: 'enumerating'!allNodesDo: aBlock	"evaluates aBlock for the receiver and all of its descendant nodes"	aBlock value: self.	self hasChildren		ifTrue: [self nodesDo: [:each | each allNodesDo: aBlock]]! !!XMLNodeWithChildren methodsFor: 'enumerating'!allNodesSelect: aBlock	| selectedNodes |	selectedNodes := self newListForSelect.	self allNodesDo: [:each |		(aBlock value: each)			ifTrue: [selectedNodes addLast: each]].	^ selectedNodes.! !!XMLNodeWithChildren methodsFor: 'testing'!canHaveChildren	^ true! !!XMLNodeWithChildren methodsFor: 'accessing'!descendantNodes	"returns a node list with all descendant nodes of the receiver"	| descendentNodes |	descendentNodes := self newListForSelect.	self descendantNodesDo: [:each | descendentNodes addLast: each].	^ descendentNodes.! !!XMLNodeWithChildren methodsFor: 'enumerating'!descendantNodesCollect: aBlock	"returns an ordered list of the values of all descendant nodes of the	receiver evaluated with aBlock"	| collectedObjects |	collectedObjects := self newListForCollect.	self descendantNodesDo: [:each |		collectedObjects addLast: (aBlock value: each)].	^ collectedObjects.! !!XMLNodeWithChildren methodsFor: 'enumerating'!descendantNodesDetect: aBlock	"returns the first descendant node of the receiver that aBlock evaluates	true for or nil if there isn't one"	^ self		descendantNodesDetect: aBlock		ifNone: [nil]! !!XMLNodeWithChildren methodsFor: 'enumerating'!descendantNodesDetect: aBlock ifNone: anExceptionBlock	"returns the first descendant node of the receiver that aBlock evaluates	true for or the value of anExceptionBlock if there isn't one"	self descendantNodesDo: [:each |		(aBlock value: each)			ifTrue: [^ each]].	^ anExceptionBlock value.! !!XMLNodeWithChildren methodsFor: 'enumerating'!descendantNodesDo: aBlock	"evaluates aBlock for all descendant nodes of the receiver"	self hasChildren		ifTrue: [self nodesDo: [:each | each allNodesDo: aBlock]]! !!XMLNodeWithChildren methodsFor: 'enumerating'!descendantNodesSelect: aBlock	"returns a node list of all descendant nodes of the receiver that aBlock	evaluates true for"	| selectedNodes |	selectedNodes := self newListForSelect.	self descendantNodesDo: [:each |		(aBlock value: each)			ifTrue: [selectedNodes addLast: each]].	^ selectedNodes.! !!XMLNodeWithChildren methodsFor: 'deprecated'!descendentNodes	self deprecated: 'use #descendantNodes instead'.	^ self descendantNodes.! !!XMLNodeWithChildren methodsFor: 'deprecated'!descendentNodesCollect: aBlock	self deprecated: 'use #descendantNodesCollect: instead'.	^ self descendantNodesCollect: aBlock.! !!XMLNodeWithChildren methodsFor: 'deprecated'!descendentNodesDetect: aBlock	self deprecated: 'use #descendantNodesDetect: instead'.	^ self descendantNodesDetect: aBlock.! !!XMLNodeWithChildren methodsFor: 'deprecated'!descendentNodesDetect: aBlock ifNone: anExceptionBlock	self deprecated: 'use #descendantNodesDetect:ifNone: instead'.	^ self		descendantNodesDetect: aBlock		ifNone: anExceptionBlock.! !!XMLNodeWithChildren methodsFor: 'deprecated'!descendentNodesSelect: aBlock	self deprecated: 'use #descendantNodesSelect: instead'.	^ self descendantNodesSelect: aBlock.! !!XMLNodeWithChildren methodsFor: 'accessing'!firstNode	"returns the first child node of the receiver if it has one, nil otherwise"	^ self nodes first! !!XMLNodeWithChildren methodsFor: 'testing'!hasChildren	"optimized with nil test and size check to avoid lazy initializing"	nodes == nil		ifTrue: [^ false].	^ nodes size > 0.! !!XMLNodeWithChildren methodsFor: 'private'!hasNodeList: aNodeList	^ nodes == aNodeList! !!XMLNodeWithChildren methodsFor: 'testing'!includesNode: aNode	^ self nodes includes: aNode! !!XMLNodeWithChildren methodsFor: 'accessing'!innerXML	"Returns a string containing the XML source of all descendent nodes.		See #innerXML:"	^ String streamContents: [:stream | self printInnerXMLOn: stream]! !!XMLNodeWithChildren methodsFor: 'accessing'!innerXMLPrettyPrinted	"Pretty print version of #innerXML.		See #innerXML:"	^ String streamContents: [:stream |		self			printInnerXMLOn: stream			beforeWritingDo: [:writer | writer enablePrettyPrinting]]! !!XMLNodeWithChildren methodsFor: 'accessing'!lastNode	"returns the last child node of the receiver if it has one, nil otherwise"	^ self nodes last! !!XMLNodeWithChildren methodsFor: 'accessing'!nodeAfter: aNode	"returns the first child node of the receiver after aNode or nil if there	isn't one"	^ self nodes after: aNode! !!XMLNodeWithChildren methodsFor: 'accessing'!nodeAt: anIndex	"returns the child node at position anIndex or nil if there isn't one"	^ self nodes at: anIndex! !!XMLNodeWithChildren methodsFor: 'accessing'!nodeAt: anIndex ifAbsent: aBlock	"returns the child node at position anIndex or the value of aBlock	if there isn't one"	^ self nodes		at: anIndex		ifAbsent: aBlock! !!XMLNodeWithChildren methodsFor: 'accessing'!nodeAt: anIndex put: aNode	"replaces the child node at anIndex with aNode, raising an error if	anIndex is outside the current range of the node list"	^ self nodes		at: anIndex		put: aNode! !!XMLNodeWithChildren methodsFor: 'accessing'!nodeBefore: aNode	"returns the first child node of the receiver before aNode or nil if there	isn't one"	^ self nodes before: aNode! !!XMLNodeWithChildren methodsFor: 'defaults'!nodeListClass	^ XMLNodeList! !!XMLNodeWithChildren methodsFor: 'accessing'!nodes	"returns the internal node list; safe to modify, but adding or removing nodes	from it will have the effect of adding or removing them from the receiver"	^ nodes ifNil: [nodes := self nodeListClass observer: self]! !!XMLNodeWithChildren methodsFor: 'enumerating'!nodesCollect: aBlock	"returns an ordered list of the values of all node children of the	receiver evaluated with aBlock"	^ self nodes collect: aBlock! !!XMLNodeWithChildren methodsFor: 'enumerating'!nodesDetect: aBlock	^ self nodes detect: aBlock! !!XMLNodeWithChildren methodsFor: 'enumerating'!nodesDetect: aBlock ifNone: anExceptionBlock	^ self nodes detect: aBlock ifNone: anExceptionBlock! !!XMLNodeWithChildren methodsFor: 'enumerating'!nodesDo: aBlock	"evaluates aBlock for all child nodes of the receiver"	self nodes do: aBlock! !!XMLNodeWithChildren methodsFor: 'enumerating'!nodesSelect: aBlock	"returns a node list of all node children of the receiver that aBlock	evaluates true for"	^ self nodes select: aBlock! !!XMLNodeWithChildren methodsFor: 'copying'!postCopy	super postCopy.	nodes		ifNotNil: [| copiedNodes |			copiedNodes := nodes copyEmpty observer: self.			nodes do: [:each |				"copySharingConfiguration is used so the config is only ever copied				once when an element or doc is sent #copy and is done after all of the				descendants have been copied"				copiedNodes addLast: each copySharingConfiguration].			nodes := copiedNodes].! !!XMLNodeWithChildren methodsFor: 'printing'!printInnerXMLOn: aStream	self hasChildren		ifTrue: [			self				withNewXMLWriterOn: aStream				do: [:writer |					self writeInnerXMLOn: writer]]! !!XMLNodeWithChildren methodsFor: 'printing'!printInnerXMLOn: aStream beforeWritingDo: aBlock	self hasChildren		ifTrue: [			self				withNewXMLWriterOn: aStream				do: [:writer |					aBlock value: writer.					self writeInnerXMLOn: writer.					writer write]]! !!XMLNodeWithChildren methodsFor: 'removing'!removeNode: aNode	^ self nodes remove: aNode! !!XMLNodeWithChildren methodsFor: 'removing'!removeNode: aNode ifAbsent: aBlock	^ self nodes remove: aNode ifAbsent: aBlock! !!XMLNodeWithChildren methodsFor: 'removing'!removeNodes	self nodes removeAll! !!XMLNodeWithChildren methodsFor: 'removing'!removeNodes: aNodeCollection	^ self nodes removeAll: aNodeCollection! !!XMLNodeWithChildren methodsFor: 'notifying'!removedNode: aNode	aNode parent: nil! !!XMLNodeWithChildren methodsFor: 'accessing'!replaceNode: aNode with: aReplacementNode	"replaces aNode in the receiver with aReplacementNode, or if aReplacementNode	is already a child of the receiver, just swaps their locations"	| firstIndex secondIndex |	firstIndex := self nodes indexOf: aNode.	(secondIndex := self nodes indexOf: aReplacementNode) > 0		ifTrue: [			self nodes				swap: firstIndex				with: secondIndex]		ifFalse: [			self nodes				at: firstIndex				put: aReplacementNode].	^ aReplacementNode.! !!XMLNodeWithChildren methodsFor: 'printing'!writeInnerXMLOn: aWriter	self nodesDo: [:each | each writeXMLOn: aWriter]! !!XMLNodeWithChildren methodsFor: 'printing'!writeXMLOn: aWriter	self writeInnerXMLOn: aWriter! !!XMLDocument class methodsFor: 'instance creation'!root: aRoot	^ self new root: aRoot! !!XMLDocument methodsFor: 'visiting'!acceptNodeVisitor: aNodeVisitor	^ aNodeVisitor visitDocument: self! !!XMLDocument methodsFor: 'accessing'!doctypeDeclaration	^ doctypeDeclaration! !!XMLDocument methodsFor: 'accessing'!doctypeDeclaration: aDoctypeDeclaration	doctypeDeclaration		ifNotNil: [doctypeDeclaration parent: nil].	aDoctypeDeclaration		ifNotNil: [			aDoctypeDeclaration hasParent				ifTrue: [					"remove it from its current parent"					aDoctypeDeclaration parent doctypeDeclaration: nil].			aDoctypeDeclaration parent: self].	doctypeDeclaration := aDoctypeDeclaration.! !!XMLDocument methodsFor: 'accessing'!doctypeDefinition	^ doctypeDefinition! !!XMLDocument methodsFor: 'accessing'!doctypeDefinition: aDoctypeDefinition	doctypeDefinition := aDoctypeDefinition! !!XMLDocument methodsFor: 'accessing'!document	^ self! !!XMLDocument methodsFor: 'accessing'!documentRoot	"returns the root of the DOM tree"	^ self! !!XMLDocument methodsFor: 'accessing'!encoding		^ encoding ifNil: [encoding := '']! !!XMLDocument methodsFor: 'accessing'!encoding: aString		encoding := aString! !!XMLDocument methodsFor: 'private'!errorCannotHaveNonElementRoot	XMLDOMException signal: 'Cannot have non-element root'! !!XMLDocument methodsFor: 'testing'!hasDoctypeDeclaration	^ self doctypeDeclaration notNil! !!XMLDocument methodsFor: 'testing'!hasDoctypeDefinition	^ self doctypeDefinition notNil! !!XMLDocument methodsFor: 'testing'!hasEncoding	^ self encoding notEmpty! !!XMLDocument methodsFor: 'testing'!hasRoot	^ self root notNil! !!XMLDocument methodsFor: 'private'!innerXMLStateClass	^ XMLPostDoctypeDeclarationState! !!XMLDocument methodsFor: 'testing'!isDocument	^ true! !!XMLDocument methodsFor: 'testing'!isStandalone	^ isStandalone ifNil: [isStandalone := false]! !!XMLDocument methodsFor: 'accessing'!isStandalone: aBoolean	isStandalone := aBoolean! !!XMLDocument methodsFor: 'copying'!postCopy	super postCopy.	doctypeDeclaration		ifNotNil: [doctypeDeclaration := doctypeDeclaration copy].! !!XMLDocument methodsFor: 'accessing'!root	"Returns the current root element or nil if there isn't one"	^ self firstElement! !!XMLDocument methodsFor: 'accessing'!root: anElement	"Replaces the current root element (if any) with anElement,	leaving all other nodes in place"	anElement isElement		ifFalse: [self errorCannotHaveNonElementRoot].	self firstElement		ifNil: [self addNode: anElement]		ifNotNil: [:firstElement |			self				replaceNode: firstElement				with: anElement].! !!XMLDocument methodsFor: 'validating'!validate	"revalidate against the DTD it was parsed with (if any)"	self hasDoctypeDefinition		ifTrue: [			self doctypeDefinition				removeElementIDReferences;				removeElementIDs.			self validateWith: self doctypeDefinition newValidator]! !!XMLDocument methodsFor: 'validating'!validateWith: aValidator	"revalidate against a custom DTD or other validator"	(XMLValidatingNodeVisitor validator: aValidator) visitDocument: self! !!XMLDocument methodsFor: 'accessing'!version		^ version! !!XMLDocument methodsFor: 'accessing'!version: aVersionFloat	version := aVersionFloat! !!XMLDocument methodsFor: 'printing'!writeDoctypeDeclarationOn: aWriter	self hasDoctypeDeclaration		ifTrue: [self doctypeDeclaration writeXMLOn: aWriter]! !!XMLDocument methodsFor: 'printing'!writeXMLDeclarationOn: aWriter	self version		ifNotNil: [			aWriter xml				version: self version;				encoding: self encoding;				standalone: self isStandalone;				write]! !!XMLDocument methodsFor: 'printing'!writeXMLOn: aWriter	self		writeXMLDeclarationOn: aWriter;		writeDoctypeDeclarationOn: aWriter;		writeInnerXMLOn: aWriter! !!XMLElement class methodsFor: 'instance creation'!name: aLocalName	^ self named: aLocalName! !!XMLElement class methodsFor: 'instance creation'!name: aLocalName attributes: anAssociationCollection	"Returns a new element with the specified name and attributes.	Both aLocalName and the attributes must not be prefixed or a namespace	exception will be thrown.	The anAssociationCollection argument can be a dictionary or any collection	of associations."	^ (self named: aLocalName)		setAttributes: anAssociationCollection! !!XMLElement class methodsFor: 'instance creation'!name: aQualifiedName namespaceURI: aURI	"Returns a new element with the specified name and namespace URI.	If aQualifiedName has a prefix, then aURI must be non-empty and the prefix	will be bound to it. Otherwise aURI will be declared as the default namespace."	^ self new		name: aQualifiedName		namespaceURI: aURI! !!XMLElement class methodsFor: 'instance creation'!name: aQualifiedName namespaceURI: aURI attributes: anAssociationCollection	"Returns a new element with the specified name, namespace URI, and attributes.	If aQualifiedName has a prefix, then aURI must be non-empty and the prefix	will be bound to it. Otherwise aURI will be declared as the default namespace.	If the attributes are prefixed, then aQualifiedName must have the same prefix	or a namespace exception will be thrown.	The anAssociationCollection argument can be a dictionary or any collection	of associations."	^ (self		name: aQualifiedName		namespaceURI: aURI)			setAttributes: anAssociationCollection! !!XMLElement class methodsFor: 'instance creation'!name: aQualifiedName namespaces: anAssociationCollection	"Returns a new element with the specified name and namespaces.	If aQualifiedName has a prefix, then anAssociationCollection must contain	an association for it or a namespace exception will be thrown.	The anAssociationCollection argument can be a dictionary or any collection	of associations. An association with an empty string key sets the default	namespace."	^ self new		declareNamespaces: anAssociationCollection;		name: aQualifiedName! !!XMLElement class methodsFor: 'instance creation'!name: aQualifiedName namespaces: aNamespaceAssociationCollection attributes: anAttributeAssociationCollection	"Returns a new element with the specified name, namespaces, and attributes.	If aQualifiedName or one of the attributes has a prefix, then	aNamespaceAssociationCollection must contain an association for it or a	namespace exception will be thrown.	The aNamespaceAssociationCollection and anAttributeAssociationCollection	arguments can be dictionaries or any collection of associations. An	association with an empty string key sets the default namespace."	^ (self		name: aQualifiedName		namespaces: aNamespaceAssociationCollection)			setAttributes: anAttributeAssociationCollection! !!XMLElement class methodsFor: 'instance creation'!named: aLocalName	"Returns a new element with the specified name.	The argument must not be prefixed or a namespace exception will be thrown."	^ self new name: aLocalName! !!XMLElement methodsFor: 'visiting'!acceptNodeVisitor: aNodeVisitor	^ aNodeVisitor visitElement: self! !!XMLElement methodsFor: 'notifying'!addedAttribute: anAttribute	anAttribute element		ifNotNil: [:element |			element == self				ifFalse: [element removeAttributeNode: anAttribute]].	anAttribute element: self.	self validateNamespacePrefixOfAttribute: anAttribute.! !!XMLElement methodsFor: 'private'!addedElement: anElement	(self hasNamespaces		and: [self namespaceScope ~= anElement namespaceScope])		ifTrue: [			anElement allElementsDo: [:each |				each namespaceScope inheritMappingsFrom: self namespaceScope]]! !!XMLElement methodsFor: 'enumerating'!allElementsDo: aBlock	"evaluates aBlock for the receiver and all descendant elements"	aBlock value: self.	self hasChildren		ifTrue: [self elementsDo: [:each | each allElementsDo: aBlock]].! !!XMLElement methodsFor: 'private'!allNamespaceScopesRemapPrefix: aPrefix from: anOldURIOrNil to: aNewURI	(self namespaceScope		prefixMappingAt: aPrefix		ifAbsent: [anOldURIOrNil]) = anOldURIOrNil		ifTrue: [			self namespaceScope				mapPrefix: aPrefix				to: aNewURI.			"we only need to check the attributes if we've remapped an			existing, non-default namespace"			(anOldURIOrNil notNil				and: [aPrefix size > 0])				ifTrue: [self validateNamespacePrefixesOfAttributes].			self elementsDo: [:each |				each					allNamespaceScopesRemapPrefix: aPrefix					from: anOldURIOrNil					to: aNewURI]]! !!XMLElement methodsFor: 'private'!allNamespaceScopesUnmapPrefix: aPrefix mappedTo: aURI	(self namespaceScope		includesPrefix: aPrefix		mappedTo: aURI)		ifTrue: [			self namespaceScope unmapPrefix: aPrefix.			self				validateNamespacePrefix;				validateNamespacePrefixesOfAttributes.			self elementsDo: [:each |				each					allNamespaceScopesUnmapPrefix: aPrefix					mappedTo: aURI]]! !!XMLElement methodsFor: 'accessing'!attributeAssociations	"returns attribute name->value associations"	^ self attributeNodes attributeAssociations! !!XMLElement methodsFor: 'accessing'!attributeAt: aName	"returns the value of the attribute whose full name matches aName or an	empty string if there isn't any"	^ self attributeNodes attributeValueAt: aName! !!XMLElement methodsFor: 'accessing'!attributeAt: aName ifAbsent: aBlock	"returns the value of the attribute whose full name matches aName or the	value of aBlock if there isn't any"	^ self attributeNodes		attributeValueAt: aName		ifAbsent: aBlock! !!XMLElement methodsFor: 'accessing'!attributeAt: aName ifAbsentPut: aBlock	"sets the value of the attribute whose full name matches aName to the value	of aBlock if there isn't one already"	^ self attributeNodes		attributeValueAt: aName		ifAbsentPut: aBlock! !!XMLElement methodsFor: 'accessing'!attributeAt: aName put: aValue	"sets the value of the attribute whose full name matches aName to the value	aValue"	^ self attributeNodes		attributeValueAt: aName		put: aValue! !!XMLElement methodsFor: 'defaults'!attributeListClass	^ self configuration nodeFactory attributeListClass! !!XMLElement methodsFor: 'accessing'!attributeNames	^ self attributeNodes attributeNames! !!XMLElement methodsFor: 'enumerating'!attributeNamesAndValuesDo: aTwoArgumentBlock	self attributeNodes attributeNamesAndValuesDo: aTwoArgumentBlock! !!XMLElement methodsFor: 'enumerating'!attributeNamesDo: aBlock	self attributeNodes attributeNamesDo: aBlock! !!XMLElement methodsFor: 'accessing'!attributeNodeAt: aName	"returns the attribute node whose qualified or local name matches aName	(unlike attributeAt:, which matches the full name exactly), or nil if there	isn't any"	^ self attributeNodes attributeNodeAt: aName! !!XMLElement methodsFor: 'accessing'!attributeNodeAt: aName ifAbsent: aBlock	"returns the attribute node whose qualified or local name matches aName	(unlike attributeAt:ifAbsent:, which matches the full name exactly), or	the value of aBlock if there isn't any"	^ self attributeNodes		attributeNodeAt: aName		ifAbsent: aBlock! !!XMLElement methodsFor: 'accessing'!attributeNodeAt: aName namespaceURI: aURI	"returns the attribute node whose qualified or local name matches aName	(unlike attributeAt:, which matches the full name exactly) and whose	namespace URI matches aURI, or nil if there isn't any"	^ self attributeNodes		attributeNodeAt: aName		namespaceURI: aURI! !!XMLElement methodsFor: 'accessing'!attributeNodeAt: aName namespaceURI: aURI ifAbsent: aBlock	"returns the attribute node whose qualified or local name matches aName	(unlike attributeAt:ifAbsent:, which matches the full name exactly) and	whose namespace URI matches aURI, or the value of aBlock if there isn't any"	^ self attributeNodes		attributeNodeAt: aName		namespaceURI: aURI		ifAbsent: aBlock! !!XMLElement methodsFor: 'accessing'!attributeNodes	"Returns the attribute node list. Can be modified, but adding or removing	attributes also adds or removes them from the element. Copy before	modifying if you don't want that."	^ attributes ifNil: [attributes := self attributeListClass observer: self]! !!XMLElement methodsFor: 'enumerating'!attributeNodesDo: aBlock	self attributeNodes do: aBlock! !!XMLElement methodsFor: 'accessing'!attributes	"returns a new order preserving dictionary of attribute names and values"	^ self attributeNodes attributes! !!XMLElement methodsFor: 'namespacing'!declareNamespaces: anAssociationCollection	self ensureUsesNamespaces.	anAssociationCollection associationsDo: [:each |		self			declarePrefix: each key			uri: each value]! !!XMLElement methodsFor: 'namespacing'!declarePrefix: aPrefix uri: aURI	self ensureUsesNamespaces.	self		allNamespaceScopesRemapPrefix: aPrefix		from:			(self namespaceScope				prefixMappingAt: aPrefix				ifAbsent: [nil])		to: aURI.! !!XMLElement methodsFor: 'namespacing'!declaredPrefixes	^ self usesNamespaces "avoid lazy initializing the scope"		ifTrue: [self namespaceScope mappedPrefixes]		ifFalse: [#()]! !!XMLElement methodsFor: 'testing'!declaresDefaultNamespace	"Did the receiver declare a new default namespace rather than inheriting one?"	^ self namespaceScope hasDefaultNamespace		and: [self isRoot			or: [self defaultNamespace ~= self parent defaultNamespace]]! !!XMLElement methodsFor: 'testing'!declaresPrefix: aPrefix uri: aURI	"Did the receiver declare a new prefix/uri pair rather than inheriting it?"	^ (self isDeclaredPrefix: aPrefix uri: aURI)		and: [self isRoot			or: [(self parent isDeclaredPrefix: aPrefix uri: aURI) not]]! !!XMLElement methodsFor: 'namespacing'!defaultNamespace	^ self usesNamespaces "avoid lazy initializing the scope"		ifTrue: [self namespaceScope defaultNamespace]		ifFalse: ['']! !!XMLElement methodsFor: 'namespacing'!defaultNamespace: aURI	self		declarePrefix: ''		uri: aURI! !!XMLElement methodsFor: 'accessing'!expandedName	"Returns the expanded name of the element as a string in the form of	'{namespaceURI}localName' if there's a namespace URI or 'localName' if there	isn't"	^ self localName expandWithXMLNamespaceURI: self namespaceURI! !!XMLElement methodsFor: 'testing'!hasAttributes	"returns true if this element has attribute"	"optimized to avoid lazy initialization"	attributes == nil		ifTrue: [^ false].	^ attributes size > 0.! !!XMLElement methodsFor: 'testing'!hasID: anID	| document doctypeDefinition attributeValidators |	self hasAttributes		ifFalse: [^ false].	((document := self document) notNil		and: [(doctypeDefinition := document doctypeDefinition) notNil			and: [doctypeDefinition hasAttributeValidators				and: [					(attributeValidators :=						doctypeDefinition attributeValidatorsAt: self name) notNil]]])		ifTrue: [			^ self				hasUndeclaredOrDeclaredID: anID				declaredWith: attributeValidators]		ifFalse: [^ self hasUndeclaredID: anID].! !!XMLElement methodsFor: 'testing'!hasNamespaceURI	^ self namespaceURI notEmpty! !!XMLElement methodsFor: 'testing'!hasNamespaces	"returns true if the receiver declared or inherited namespace declarations"	"optimized to avoid lazy initialization"	namespaceScope == nil		ifTrue: [^ false].	^ namespaceScope hasNamespaces.! !!XMLElement methodsFor: 'testing'!hasPrefix	"returns true if the receiver's name is a qualified name with a prefix"	^ self name size > self localName size! !!XMLElement methodsFor: 'private'!hasUndeclaredID: anID	"just look for an 'xml:id' attribute if there were no declarations"	^ (self		attributeAt: 'xml:id'		ifAbsent: [^ false]) = anID! !!XMLElement methodsFor: 'private'!hasUndeclaredOrDeclaredID: anID declaredWith: anAttributeValidatorDictionary	self attributeNamesAndValuesDo: [:attributeName :attributeValue |		"only check its value if it's been declared as an ID attribute		or if it's named 'xml:id'"		((anAttributeValidatorDictionary			at: attributeName			ifAbsent: [nil])				ifNil: [attributeName = 'xml:id']				ifNotNil: [:attributeValidator | attributeValidator isID])			ifTrue: [				attributeValue = anID					ifTrue: [^ true]]].	^ false.! !!XMLElement methodsFor: 'testing'!includesAttribute: aName	^ self attributeNodes includesAttribute: aName! !!XMLElement methodsFor: 'testing'!includesAttributeNode: aName	^ self attributeNodes includesAttributeNode: aName! !!XMLElement methodsFor: 'testing'!includesAttributeNode: aName namespaceURI: aURI	^ self attributeNodes		includesAttributeNode: aName		namespaceURI: aURI! !!XMLElement methodsFor: 'testing'!isDeclaredPrefix: aPrefix	"is the namespace prefix aPrefix declared for the receiver and its descendants?"	^ self usesNamespaces		and: [self namespaceScope includesPrefix: aPrefix]! !!XMLElement methodsFor: 'testing'!isDeclaredPrefix: aPrefix uri: aURI	"is the namespace prefix aPrefix mapped to aURI for the receiver and	its descendants?"	^ self usesNamespaces		and: [			self namespaceScope				includesPrefix: aPrefix				mappedTo: aURI]! !!XMLElement methodsFor: 'testing'!isElement	^ true! !!XMLElement methodsFor: 'testing'!isElementNamed: aName	"returns true if the receiver's qualified name or local name matches aName"	^ self isNamed: aName! !!XMLElement methodsFor: 'testing'!isElementNamedAny: aNameCollection	"returns true if the receiver's qualified name or local name matches any	name in aNameCollection"	^ self isNamedAny: aNameCollection! !!XMLElement methodsFor: 'testing'!isInLanguage: aLanguageTag	"Returns true if the receiver or one of its ancestors has an xml:lang	attribute, and if the value is an IETF language tag, like 'En-US', that matches	aLanguageTag. Matching is case-insensitive, and aLanguageTag can be partial,	like 'En', and use wildcards, like 'En-*'"	^ (self		attributeNodeAt: 'xml:lang'		ifAbsent: [			^ self hasParent				and: [self parent isInLanguage: aLanguageTag]])			matchesLanguage: aLanguageTag! !!XMLElement methodsFor: 'testing'!isNamed: aName	"Does the receiver's qualified or local name match aName?"	^ self name isXMLQualifiedOrLocalName: aName! !!XMLElement methodsFor: 'testing'!isNamedAny: aNameCollection	"Does the receiver's qualified or local name match any of the names	in aNameCollection?"	^ aNameCollection includesXMLName: self name! !!XMLElement methodsFor: 'testing'!isRoot	"Is the receiver the root element of a DOM tree?"	^ (self hasParent and: [self parent isElement]) not! !!XMLElement methodsFor: 'accessing'!localName	"Returns the local name of the receiver, the name minus any leading	prefix and colon like 'local' in 'prefix:local'"	^ localName ifNil: [localName := self name xmlLocalNameAfterPrefix]! !!XMLElement methodsFor: 'accessing'!name	"returns the full name of the element, either a qualified name if it has a	prefix or just a local name if it doesn't"	^ name ifNil: [name := '']! !!XMLElement methodsFor: 'accessing'!name: aName	"Renames the element. If aName is a qualified name and namespace checking is	enabled (default), then the prefix must already have been declared. This can	be done while renaming using name:namespaceURI."	self renameWith: [		name := aName.		localName := aName xmlLocalNameAfterPrefix]! !!XMLElement methodsFor: 'accessing'!name: aName namespaceURI: aURI	"Renames the element and also declares a namespace URI in one step. If aName	is qualified, then it declares the prefix to be mapped to aURI. If aName has	no prefix, then aURI is declared as the default namespace URI."	self		declarePrefix: (aName xmlPrefixBeforeLocalName) uri: aURI;		name: aName! !!XMLElement methodsFor: 'private'!namespaceScope	^ namespaceScope ifNil: [namespaceScope := XMLNamespaceScope new]! !!XMLElement methodsFor: 'accessing'!namespaceURI	^ self resolvePrefix: self prefix! !!XMLElement methodsFor: 'private'!newNamespaceScopeForAddedElement	^ self usesNamespaces		ifTrue: [self namespaceScope copy]		ifFalse: [nil]! !!XMLElement methodsFor: 'accessing'!nextElement	"returns the first element after the receiver that is a child of the same	parent if there is one, nil otherwise"	^ self parent ifNotNil: [:node | node elementAfter: self]! !!XMLElement methodsFor: 'copying'!postCopy	super postCopy.	namespaceScope		ifNotNil: [namespaceScope := namespaceScope copy].	attributes		ifNotNil: [| copiedAttributes |			copiedAttributes := attributes copyEmpty observer: self.			attributes do: [:each | copiedAttributes addLast: each copy].			attributes := copiedAttributes].! !!XMLElement methodsFor: 'accessing'!prefix	"Returns the prefix of the receiver's name or an empty string if there	isn't one."	"this is recomputed from the qualified and local name instead of being	stored in an inst var to save memory."	^ self name xmlPrefixBeforeLocalName: self localName! !!XMLElement methodsFor: 'accessing'!prefix: aPrefix	"Changes the prefix of the name of the receiver to aPrefix. If namespace	checking is enabled (default) and aPrefix is non-empty, then aPrefix must	have been declared."	self renameWith: [name := self localName qualifyWithXMLPrefix:  aPrefix]! !!XMLElement methodsFor: 'accessing'!previousElement	"returns the first element before the receiver that is a child of the same	parent if there is one, nil otherwise"	^ self parent ifNotNil: [:node | node elementBefore: self]! !!XMLElement methodsFor: 'removing'!removeAttribute: aName	"Removes and returns the value of the attribute whose full name matches	aName or raises an error if it's absent."	^ (self attributeNodes removeAttribute: aName) value.! !!XMLElement methodsFor: 'removing'!removeAttribute: aName ifAbsent: aBlock	"Removes and returns the value of the attribute whose full name matches	aName or returns the value of aBlock if it's absent."	^ self attributeNodes		removeAttribute: aName		ifAbsent: aBlock! !!XMLElement methodsFor: 'removing'!removeAttributeNode: aNode	"Removes and returns the attribute node aNode or raises an error if	it's absent."	^ self attributeNodes remove: aNode! !!XMLElement methodsFor: 'removing'!removeAttributeNode: aNode ifAbsent: aBlock	"Removes and returns the attribute node aNode or returns the value	of aBlock if it's absent."	^ self attributeNodes		remove: aNode		ifAbsent: aBlock! !!XMLElement methodsFor: 'removing'!removeAttributes	self attributeNodes removeAll! !!XMLElement methodsFor: 'notifying'!removedAttribute: anAttribute	anAttribute element: nil! !!XMLElement methodsFor: 'private'!renameWith: aBlock	| oldName |	oldName := self name.	aBlock value.	self name = oldName		ifFalse: [			self validateNamespacePrefix.			self hasParent				ifTrue: [					self parent						renamedElement: self						from: oldName						to: self name]].! !!XMLElement methodsFor: 'notifying'!renamedAttribute: anAttribute from: anOldName to: aNewName	self attributeNodes			renamedAttribute: anAttribute		from: anOldName		to: aNewName.	self validateNamespacePrefixOfAttribute: anAttribute.! !!XMLElement methodsFor: 'namespacing'!resolvePrefix: aPrefix	"Resolves the namespace URI of aPrefix (the defualt namespace URI if aPrefix	is empty), including the predefined 'xml' and 'xmlns' prefixes. Returns an	empty string if aPrefix is unresolvable."	^ self		resolvePrefix: aPrefix		ifUnresolvable: ''! !!XMLElement methodsFor: 'namespacing'!resolvePrefix: aPrefix ifUnresolvable: aBlock	"Resolves the namespace URI of aPrefix (the defualt namespace URI if aPrefix	is empty), including the predefined 'xml' and 'xmlns' prefixes. Returns the	value of aBlock if aPrefix is unresolvable."	^ self hasNamespaces "avoid lazy initializing the scope"		ifTrue: [			self namespaceScope				resolvePrefix: aPrefix				ifUnresolvable: aBlock]		ifFalse: [aBlock value]! !!XMLElement methodsFor: 'namespacing'!resolvePrefixesOfNamespaceURI: aURI	"returns a set of all the namespace prefixes of aURI"	^ self usesNamespaces		ifTrue: [self namespaceScope resolvePrefixesOfNamespaceURI: aURI]		ifFalse: [Set new]! !!XMLElement methodsFor: 'initialization'!setAttributes: anAssociationCollection	self attributeNodes setAttributes: anAssociationCollection! !!XMLElement methodsFor: 'private'!setConfiguration: aConfiguration name: aName localName: aLocalName attributes: anAttributeDictionary namespaceScope: aNamespaceScope	"This should only be sent by DOM parsers/builders, not public API users"	configuration := aConfiguration.	name := aName.	localName := aLocalName.	anAttributeDictionary size > 0 "optimization"		ifTrue: [			"This consumes anAttributeDictionary, so it can never be used			again safely"			(attributes :=				self attributeListClass new: anAttributeDictionary size)				observer: self;				setAttributesFromOrderPreservingDictionary: 					anAttributeDictionary].	namespaceScope := aNamespaceScope.! !!XMLElement methodsFor: 'private'!setNamespaceScope: aNamespaceScope	namespaceScope := aNamespaceScope! !!XMLElement methodsFor: 'accessing'!sortKey	^ self name! !!XMLElement methodsFor: 'namespacing'!undeclareDefaultNamespace	self undeclarePrefix: ''! !!XMLElement methodsFor: 'namespacing'!undeclarePrefix: aPrefix	self ensureUsesNamespaces.	self		allNamespaceScopesUnmapPrefix: aPrefix		mappedTo:			(self namespaceScope				prefixMappingAt: aPrefix				ifAbsent: [^ self]).! !!XMLElement methodsFor: 'namespacing'!undeclarePrefixes	self ensureUsesNamespaces.	self declaredPrefixes do: [:each |		self undeclarePrefix: each].! !!XMLElement methodsFor: 'private'!validateNamespacePrefix	(self usesNamespaces		and: [self hasPrefix])		ifTrue: [			self namespaceScope				validateAndResolvePrefix: self prefix				ofElement: self name]! !!XMLElement methodsFor: 'private'!validateNamespacePrefixOfAttribute: anAttribute	| attributePrefix attributeLocalName attributeNamespaceURI |	self usesNamespaces		ifFalse: [^ self].	attributePrefix := anAttribute prefix.	"send #validateAndResolvePrefix:ofAttribute: even if attributePrefix is	empty, to catch names like ':name', and return if the resolved URI is empty,	since non-default namespace URIs can't be empty, and attribute namespaces	are always non-default"	(attributeNamespaceURI :=		self namespaceScope			validateAndResolvePrefix: attributePrefix			ofAttribute: anAttribute name) size > 0		ifFalse: [^ self].	attributeLocalName :=		anAttribute name xmlLocalNameAfterPrefix: attributePrefix.	self attributeNodesDo: [:each | | eachLocalName |		(each ~= anAttribute			and: [(eachLocalName := each localName) = attributeLocalName])			ifTrue: [				(self namespaceScope resolvePrefix:					(each name xmlPrefixBeforeLocalName: eachLocalName)) =						attributeNamespaceURI					ifTrue: [						self namespaceScope							errorAttribute: each							aliasesURI: attributeNamespaceURI]]].! !!XMLElement methodsFor: 'private'!validateNamespacePrefixesOfAttributes	(self usesNamespaces		and: [self hasAttributes])		ifTrue: [			self namespaceScope validatePrefixesOfAttributes:				self attributeNames]! !!XMLElement methodsFor: 'printing'!writeXMLOn: aWriter	| tagWriter |	tagWriter := aWriter tag: self name.	self hasNamespaces		ifTrue: [			"non-standard setXMLNSDeclarations: use for performance"			tagWriter setXMLNSDeclarations: self namespaceScope prefixMappings].	self hasAttributes		ifTrue: [			"non-standard setAttributes: use for performance"			tagWriter setAttributes: self attributeNodes].	self hasChildren		ifTrue: [tagWriter with: [self writeInnerXMLOn: aWriter]]		ifFalse: [tagWriter write].! !!XMLNodeWithElements methodsFor: 'visiting'!acceptNodeVisitor: aNodeVisitor	^ aNodeVisitor visitNodeWithElements: self! !!XMLNodeWithElements methodsFor: 'adding'!addCData: aString	^ self addNode: (self newCData: aString)! !!XMLNodeWithElements methodsFor: 'deprecated'!addContent: aStringOrStringNode	"will be deprecated; use #addString: instead"	(self hasChildren		and: [self lastNode isCoalescingStringNode])		ifTrue: [self lastNode append: aStringOrStringNode]		ifFalse: [self addNode:			(aStringOrStringNode isString				ifTrue: [self nodeFactory newStringNode: aStringOrStringNode]				ifFalse: [aStringOrStringNode])].	"returns self for backwards compatibility"! !!XMLNodeWithElements methodsFor: 'deprecated'!addElement: anElement	self deprecated:		'Use #addNode: with an element argument or #addElementNamed: instead'.	self addNode: anElement.	"returns self for backwards compatibility"! !!XMLNodeWithElements methodsFor: 'adding'!addElementNamed: aName	"adds and returns a new element with the specified name"	| addedElementNamespaceScope addedElementNamespaceURI addedElement |	addedElementNamespaceScope := self newNamespaceScopeForAddedElement.	addedElementNamespaceURI :=		self			namespaceURIOfAddedElementNamed: aName			withScope: addedElementNamespaceScope.	"added first to inherit the config before setting the name"	addedElement :=		self addNode:			((self nodeFactory				classForElement: aName				namespaceURI: addedElementNamespaceURI) new				setNamespaceScope: addedElementNamespaceScope).	^ addedElement name: aName.! !!XMLNodeWithElements methodsFor: 'adding'!addElementNamed: aName attributes: anAssociationCollection	"adds and returns a new element with the specified name and attributes"	| addedElementNamespaceScope addedElementNamespaceURI addedElementAttributeDictionary addedElement |	addedElementNamespaceScope := self newNamespaceScopeForAddedElement.	addedElementNamespaceURI :=		self			namespaceURIOfAddedElementNamed: aName			withScope: addedElementNamespaceScope.	addedElementAttributeDictionary :=		self			newAttributeDictionaryFrom: anAssociationCollection			forAddedElementWithScope: addedElementNamespaceScope.	"added first to inherit the config before setting the name and attributes"	addedElement :=		self addNode:			((self nodeFactory				classForElement: aName				namespaceURI: addedElementNamespaceURI				attributes: addedElementAttributeDictionary) new				setNamespaceScope: addedElementNamespaceScope).	^ addedElement		name: aName;		setAttributes: addedElementAttributeDictionary.! !!XMLNodeWithElements methodsFor: 'adding'!addElementNamed: aName namespaceURI: aURI	"adds and returns a new element with the specified name and namespace	URI"	| addedElementNamespaceScope addedElement |	addedElementNamespaceScope :=		self			newNamespaceScopeForAddedElementNamed: aName			namespaceURI: aURI.	"added first to inherit the config before setting the name"	addedElement :=		self addNode:			((self nodeFactory				classForElement: aName				namespaceURI: aURI) new				setNamespaceScope: addedElementNamespaceScope).	^ addedElement name: aName.! !!XMLNodeWithElements methodsFor: 'adding'!addElementNamed: aName namespaceURI: aURI attributes: anAssociationCollection	"adds and returns a new element with the specified name, namespace URI,	and attributes"	| addedElementNamespaceScope addedElementAttributeDictionary addedElement |	addedElementNamespaceScope :=		self			newNamespaceScopeForAddedElementNamed: aName			namespaceURI: aURI.	addedElementAttributeDictionary :=		self			newAttributeDictionaryFrom: anAssociationCollection			forAddedElementWithScope: addedElementNamespaceScope.	"added first to inherit the config before setting the name and attributes"	addedElement :=		self addNode:			((self nodeFactory				classForElement: aName				namespaceURI: aURI				attributes: addedElementAttributeDictionary) new				setNamespaceScope: addedElementNamespaceScope).	^ addedElement		name: aName;		setAttributes: addedElementAttributeDictionary.! !!XMLNodeWithElements methodsFor: 'adding'!addString: aString	"Adds a new string node for aString or just appends aString to the	last node if it's a coalescing string node (not CDATA).	Returns the new string node or the string node appeneded to."	| lastNode |	(self hasChildren		and: [(lastNode := self lastNode) isCoalescingStringNode])		ifTrue: [^ lastNode append: aString]		ifFalse: [^ self addNode: (self nodeFactory newStringNode: aString)]! !!XMLNodeWithElements methodsFor: 'private'!addedElement: anElement! !!XMLNodeWithElements methodsFor: 'notifying'!addedNode: aNode	super addedNode: aNode.	aNode isElement		ifTrue: [			aNode configuration: self configuration.			self addedElement: aNode].! !!XMLNodeWithElements methodsFor: 'accessing'!allElements	"returns a node list with all descendant elements (and the receiver if	it's an element)"	| allElements |	allElements := self newListForSelect.	self allElementsDo: [:each | allElements addLast: each].	^ allElements.! !!XMLNodeWithElements methodsFor: 'enumerating'!allElementsCollect: aBlock	"returns an ordered list of the values of evaluating all descendant	elements (and the receiver if it's an element) with aBlock"	| collectedObjects |	collectedObjects := self newListForCollect.	self allElementsDo: [:each | collectedObjects addLast: (aBlock value: each)].	^ collectedObjects.! !!XMLNodeWithElements methodsFor: 'enumerating'!allElementsDetect: aBlock	"Descend depth-first visiting each element with aBlock until one such evaluation	of aBlock with an element is true, then return that element. If no evaluation is	true, then return nil."	^ self allElementsDetect: aBlock ifNone: [nil]! !!XMLNodeWithElements methodsFor: 'enumerating'!allElementsDetect: aBlock ifNone: anExceptionBlock	"Descend depth-first visiting each element with aBlock until one such evaluation	of aBlock with an element is true, then return that element. If no evaluation is	true, then return the value of anExceptionBlock."	self allElementsDo: [:each |		(aBlock value: each)			ifTrue: [^ each]].	^ anExceptionBlock value.! !!XMLNodeWithElements methodsFor: 'enumerating'!allElementsDo: aBlock	"evaluates all descendant elements (and the receiver if it's an	element) with aBlock"	self hasChildren		ifTrue: [self elementsDo: [:each | each allElementsDo: aBlock]]! !!XMLNodeWithElements methodsFor: 'accessing'!allElementsNamed: aName	"returns a node list with all descendant elements (and the receiver if	it's an element) whose qualified or local names match aName"	^ self allElementsSelect: [:each | each isNamed: aName]! !!XMLNodeWithElements methodsFor: 'enumerating'!allElementsNamed: aName do: aBlock	"evaluates all descendant elements (and the receiver if it's an	element) whose qualified or local names match aName with aBlock"	self allElementsDo: [:each |		(each isNamed: aName)			ifTrue: [aBlock value: each]]! !!XMLNodeWithElements methodsFor: 'accessing'!allElementsNamed: aName namespaceURI: aURI	"returns a node list with all descendant elements (and the receiver if	it's an element) whose qualified or local names match aName and whose	namespace URIs matches aURI"	^ self allElementsSelect: [:each |		(each isNamed: aName)			and: [each namespaceURI = aURI]]! !!XMLNodeWithElements methodsFor: 'enumerating'!allElementsSelect: aBlock	"returns a new node list with all descendant elements (and the receiver	if it's an element) that aBlock evaluates true for"	| selectedElements |	selectedElements := self newListForSelect.	self allElementsDo: [:each |		(aBlock value: each)			ifTrue: [selectedElements addLast: each]].	^ selectedElements.! !!XMLNodeWithElements methodsFor: 'accessing'!configuration	^ configuration ifNil: [		self configuration: self configurationClass new.		configuration]! !!XMLNodeWithElements methodsFor: 'accessing'!configuration: aConfiguration	configuration := aConfiguration.	self hasChildren		ifTrue: [			self elementsDo: [:each |				each configuration: aConfiguration]].! !!XMLNodeWithElements methodsFor: 'defaults'!configurationClass	^ XMLDOMConfiguration! !!XMLNodeWithElements methodsFor: 'accessing'!contentNodes	"returns a node list of the receiver's element and string node children"	^ self nodes contentNodes! !!XMLNodeWithElements methodsFor: 'enumerating'!contentNodesDo: aBlock	"evaluates aBlock for all element and string node children of the receiver"	self nodes contentNodesDo: aBlock! !!XMLNodeWithElements methodsFor: 'deprecated'!contentString: aString	"will be deprecated; use #removeNodes and #addString: instead"	self		removeNodes;		addString: aString! !!XMLNodeWithElements methodsFor: 'accessing'!contentStringAt: aName	"Returns the content string of the first element child of the receiver	whose qualified or local name matches aName or an empty string if there	isn't one.	See also #rawContentStringAt:"	^ self nodes contentStringAt: aName! !!XMLNodeWithElements methodsFor: 'accessing'!descendantElements	"returns a node list of all descendant elements"	| descendentElements |	descendentElements := self newListForSelect.	self descendantElementsDo: [:each | descendentElements addLast: each].	^ descendentElements.! !!XMLNodeWithElements methodsFor: 'enumerating'!descendantElementsCollect: aBlock	"returns an ordered list of the values of evaluating all descendant	elements with aBlock"	| collectedObjects |	collectedObjects := self newListForCollect.	self descendantElementsDo: [:each |		collectedObjects addLast: (aBlock value: each)].	^ collectedObjects.! !!XMLNodeWithElements methodsFor: 'enumerating'!descendantElementsDetect: aBlock	"returns the first descendant element that aBlock evaluates true for or	nil if there isn't one"	^ self		descendantElementsDetect: aBlock		ifNone: [nil]! !!XMLNodeWithElements methodsFor: 'enumerating'!descendantElementsDetect: aBlock ifNone: anExceptionBlock	"returns the first descendant element that aBlock evaluates true for or	the value of anExceptionBlock if there isn't one"	self descendantElementsDo: [:each |		(aBlock value: each)			ifTrue: [^ each]].	^ anExceptionBlock value.! !!XMLNodeWithElements methodsFor: 'enumerating'!descendantElementsDo: aBlock	"evaluates all descendant elements with aBlock"	self hasChildren		ifTrue: [self elementsDo: [:each | each allElementsDo: aBlock]]! !!XMLNodeWithElements methodsFor: 'accessing'!descendantElementsNamed: aName	"returns a node list of all descendant elements whose qualified	or local names match aName"	^ self descendantElementsSelect: [:each | each isNamed: aName]! !!XMLNodeWithElements methodsFor: 'enumerating'!descendantElementsNamed: aName do: aBlock	"evaluates all descendant elements whose qualified or local names	match aName with aBlock"	self descendantElementsDo: [:each |		(each isNamed: aName)			ifTrue: [aBlock value: each]]! !!XMLNodeWithElements methodsFor: 'accessing'!descendantElementsNamed: aName namespaceURI: aURI	"returns a node list of all descendant elements whose qualified	or local names match aName and whose namespace URIs match aURI"	^ self descendantElementsSelect: [:each |		(each isNamed: aName)			and: [each namespaceURI = aURI]]! !!XMLNodeWithElements methodsFor: 'enumerating'!descendantElementsSelect: aBlock	"returns a new node list with all descendant elements that aBlock	evaluates true for"	| selectedElements |	selectedElements := self newListForSelect.	self descendantElementsDo: [:each |		(aBlock value: each)			ifTrue: [selectedElements addLast: each]].	^ selectedElements.! !!XMLNodeWithElements methodsFor: 'deprecated'!descendentElements	self deprecated: 'use #descendantElements instead'.	^ self descendantElements.! !!XMLNodeWithElements methodsFor: 'deprecated'!descendentElementsCollect: aBlock	self deprecated: 'use #descendantElementsCollect: instead'.	^ self descendantElementsCollect: aBlock.! !!XMLNodeWithElements methodsFor: 'deprecated'!descendentElementsDetect: aBlock	self deprecated: 'use #descendantElementsDetect: instead'.	^ self descendantElementsDetect: aBlock.! !!XMLNodeWithElements methodsFor: 'deprecated'!descendentElementsDetect: aBlock ifNone: anExceptionBlock	self deprecated: 'use #descendantElementsDetect:ifNone: instead'.	^ self		descendantElementsDetect: aBlock		ifNone: anExceptionBlock.! !!XMLNodeWithElements methodsFor: 'deprecated'!descendentElementsDo: aBlock	self deprecated: 'use #descendantElementsDo: instead'.	^ self descendantElementsDo: aBlock.! !!XMLNodeWithElements methodsFor: 'deprecated'!descendentElementsNamed: aName	self deprecated: 'use #descendantElementsNamed: instead"'.	^ self descendantElementsNamed: aName.! !!XMLNodeWithElements methodsFor: 'deprecated'!descendentElementsNamed: aName do: aBlock	self deprecated: 'use #descendantElementsNamed:do: instead'.	^ self		descendantElementsNamed: aName		do: aBlock.! !!XMLNodeWithElements methodsFor: 'deprecated'!descendentElementsNamed: aName namespaceURI: aURI	self deprecated: 'use #descendantElementsNamed:namespaceURI: instead'.	^ self		descendantElementsNamed: aName		namespaceURI: aURI.! !!XMLNodeWithElements methodsFor: 'deprecated'!descendentElementsSelect: aBlock	self deprecated: 'use #descendantElementsSelect: instead'.	^ self descendantElementsSelect: aBlock.! !!XMLNodeWithElements methodsFor: 'accessing'!elementAfter: anElement	"returns the first element child of the receiver after anElement or nil if	there isn't one"	^ self nodes elementAfter: anElement! !!XMLNodeWithElements methodsFor: 'accessing'!elementAt: aName	"returns the first element child of the receiver whose qualified or	local name matches aName or nil if there isn't one"	^ self nodes elementAt: aName! !!XMLNodeWithElements methodsFor: 'accessing'!elementAt: aName ifAbsent: aBlock	"returns the first element child of the receiver whose qualified or	local name matches aName or the value of aBlock if there isn't one"	^ self nodes		elementAt: aName		ifAbsent: aBlock! !!XMLNodeWithElements methodsFor: 'accessing'!elementAt: aName namespaceURI: aURI	"returns the first element child of the receiver whose qualified or	local name matches aName and whose namespace URI matches aURI or nil	if there isn't one"	^ self nodes		elementAt: aName		namespaceURI: aURI! !!XMLNodeWithElements methodsFor: 'accessing'!elementAt: aName namespaceURI: aURI ifAbsent: aBlock	"returns the first element child of the receiver whose qualified or	local name matches aName and whose namespace URI matches aURI or the	value of aBlock if there isn't one"	^ self nodes		elementAt: aName		namespaceURI: aURI		ifAbsent: aBlock! !!XMLNodeWithElements methodsFor: 'accessing'!elementBefore: anElement	"returns the first element child of the receiver before anElement or	nil if there isn't one"	^ self nodes elementBefore: anElement! !!XMLNodeWithElements methodsFor: 'accessing'!elementNames	^ self nodes elementNames! !!XMLNodeWithElements methodsFor: 'accessing'!elements	"returns a new node list of all of the receiver's elements"	^ self nodes elements! !!XMLNodeWithElements methodsFor: 'accessing'!elementsAt: aName	"returns a node list of all the receiver's elements whose qualified	or local names match aName"	^ self nodes elementsAt: aName! !!XMLNodeWithElements methodsFor: 'enumerating'!elementsAt: aName do: aBlock	"evaluates aBlock for all element children of the receiver whose	qualified or local names match aName"	self nodes		elementsAt: aName		do: aBlock! !!XMLNodeWithElements methodsFor: 'accessing'!elementsAt: aName namespaceURI: aURI	"returns a node list of all the receiver's elements whose qualified	or local names match aName and whose namespace URIs match aURI"	^ self nodes		elementsAt: aName		namespaceURI: aURI! !!XMLNodeWithElements methodsFor: 'enumerating'!elementsCollect: aBlock	"returns an ordered list of the values of evaluating the element	children of the receiver with aBlock"	^ self nodes elementsCollect: aBlock! !!XMLNodeWithElements methodsFor: 'enumerating'!elementsDetect: aBlock	"returns the first element child of the receiver that aBlock evaluates	true for or nil if there isn't one"	^ self nodes elementsDetect: aBlock! !!XMLNodeWithElements methodsFor: 'enumerating'!elementsDetect: aBlock ifNone: anExceptionBlock	"returns the first element child of the receiver that aBlock evaluates	true for or the value of anExceptionBlock if there isn't one"	^ self nodes		elementsDetect: aBlock		ifNone: anExceptionBlock! !!XMLNodeWithElements methodsFor: 'enumerating'!elementsDo: aBlock	"evaluates aBlock for all element children of the receiver"	self nodes elementsDo: aBlock! !!XMLNodeWithElements methodsFor: 'enumerating'!elementsSelect: aBlock	"returns a node list of all element children of the receiver that	aBlock evaluates true for"	^ self nodes elementsSelect: aBlock! !!XMLNodeWithElements methodsFor: 'private'!ensureUsesNamespaces	self usesNamespaces: true! !!XMLNodeWithElements methodsFor: 'private'!errorOuterXMLForAbsentNode	XMLDOMException signal: 'Cannot change outer XML for absent node'! !!XMLNodeWithElements methodsFor: 'private'!escapesContentEntitiesWhenWriting	"avoid initializing config; defualt to true"	^ configuration isNil		or: [configuration replacesContentEntityReferences]! !!XMLNodeWithElements methodsFor: 'searching'!findElementNamed: aName	"searches the receiver and all descendants for the first element whose	qualified or local name matches aName"	^ self allElementsDetect: [:each | each isNamed: aName]! !!XMLNodeWithElements methodsFor: 'searching'!findElementNamed: aName namespaceURI: aURI	"searches the receiver and all descendants for the first element whose	qualified or local name matches aName and whose namespace URI matches aURI"	^ self allElementsDetect: [:each |		(each isNamed: aName)			and: [each namespaceURI = aURI]]! !!XMLNodeWithElements methodsFor: 'searching'!findElementNamed: aName namespaceURI: aURI with: aBlock	"searches the receiver and all descendants for the first element whose	qualified or local name matches aName and whose namespace URI matches	aURI and that aBlock evaluates true for"	^ self allElementsDetect: [:each |		(each isNamed: aName)			and: [each namespaceURI = aURI				and: [aBlock value: each]]]! !!XMLNodeWithElements methodsFor: 'searching'!findElementNamed: aName with: aBlock	"searches the receiver and all descendants for the first element whose	qualified or local name matches aName and aBlock evaluates true for"	^ self allElementsDetect: [:each |		(each isNamed: aName)			and: [aBlock value: each]]! !!XMLNodeWithElements methodsFor: 'searching'!findElementWithID: anID	"Works like XML DOM Level 2's getElementByID(). It will scan attributes	identified as IDs by a DTD with '<!!ATTLIST ...>' declarations or any	attribute named 'xml:id'."	| document doctypeDefinition |		((document := self document) notNil		and: [(doctypeDefinition := document doctypeDefinition) notNil			and: [doctypeDefinition hasAttributeValidators]])		ifTrue: [			self allElementsDo: [:each |				each hasAttributes					ifTrue: [						(doctypeDefinition attributeValidatorsAt: each name)							ifNil: [								(each hasUndeclaredID: anID)									ifTrue: [^ each]]							ifNotNil: [:attributeValidators |								(each									hasUndeclaredOrDeclaredID: anID									declaredWith: attributeValidators)									ifTrue: [^ each]]]]]		ifFalse: [			self allElementsDo: [:each |				(each hasAttributes					and: [each hasUndeclaredID: anID])					ifTrue: [^ each]]].	^ nil.! !!XMLNodeWithElements methodsFor: 'accessing'!firstElement	"returns the first child element of the receiver or nil if there	isn't one"	^ self nodes firstElement! !!XMLNodeWithElements methodsFor: 'testing'!hasContentNodes	^ self nodes hasContentNodes! !!XMLNodeWithElements methodsFor: 'testing'!hasElements	"returns true if the receiver has element children"	"optimized with a nil test to avoid lazy initializing nodes"	nodes == nil		ifTrue: [^ false].	^ nodes hasElements.! !!XMLNodeWithElements methodsFor: 'testing'!hasStringNodes	^ self nodes hasStringNodes! !!XMLNodeWithElements methodsFor: 'testing'!includesElement: aName	"returns true if the receiver has a child element whose qualified or local name	matches aName"	^ self nodes includesElement: aName! !!XMLNodeWithElements methodsFor: 'testing'!includesElement: aName namespaceURI: aURI	"returns true if the receiver has a child element whose qualified or local name	matches aName and whose namespace URI matches aURI"	^ self nodes		includesElement: aName		namespaceURI: aURI! !!XMLNodeWithElements methodsFor: 'parsing'!innerXML: aStringOrStream	"Replaces the node children by parsing new inner XML from a string or stream	argument. By default the same parser configuration will be used to parse the	new inner XML."	self innerXMLParsedWith: (self parserHandlerClass on: aStringOrStream)! !!XMLNodeWithElements methodsFor: 'parsing'!innerXMLParsedWith: aParser	| removedNodes |	removedNodes := self nodes asArray.	self removeNodes.	[aParser		innerXMLRootNode: self;		parseDocument]		on: Error		do: [:error |			self				removeNodes;				addNodes: removedNodes.			error pass].! !!XMLNodeWithElements methodsFor: 'private'!innerXMLStateClass	^ XMLContentState! !!XMLNodeWithElements methodsFor: 'testing'!isContentNode	^ true! !!XMLNodeWithElements methodsFor: 'accessing'!lastElement	"returns the last child element of the receiver or nil if there	isn't one"	^ self nodes lastElement! !!XMLNodeWithElements methodsFor: 'private'!namespaceURIOfAddedElementNamed: aName withScope: aNamespaceScope	^ self usesNamespaces		ifTrue: [aNamespaceScope resolvePrefix: aName xmlPrefixBeforeLocalName]		ifFalse: ['']! !!XMLNodeWithElements methodsFor: 'private'!newAttributeDictionaryFrom: anAssociationCollection forAddedElementWithScope: aNamespaceScope	^ self usesNamespaces		ifTrue: [			(XMLNamespacedAttributeDictionary newFrom: anAssociationCollection)				setNamespaceScope: aNamespaceScope]		ifFalse: [XMLAttributeDictionary newFrom: anAssociationCollection]! !!XMLNodeWithElements methodsFor: 'private'!newInnerXMLState	^ self innerXMLStateClass new! !!XMLNodeWithElements methodsFor: 'private'!newNamespaceScopeForAddedElement	^ self usesNamespaces		ifTrue: [XMLNamespaceScope new]		ifFalse: [nil]! !!XMLNodeWithElements methodsFor: 'private'!newNamespaceScopeForAddedElementNamed: aName namespaceURI: aURI	self ensureUsesNamespaces.	^ self newNamespaceScopeForAddedElement		mapPrefix: aName xmlPrefixBeforeLocalName to: aURI;		yourself.! !!XMLNodeWithElements methodsFor: 'deprecated'!newString: aString	"will be deprecated; use #newStringNode: instead"	^ self newStringNode: aString! !!XMLNodeWithElements methodsFor: 'accessing'!nodeFactory	^ self configuration nodeFactory! !!XMLNodeWithElements methodsFor: 'accessing'!nodeFactory: aNodeFactory	self configuration nodeFactory: aNodeFactory! !!XMLNodeWithElements methodsFor: 'defaults'!nodeListClass	^ self configuration nodeFactory nodeListClass! !!XMLNodeWithElements methodsFor: 'parsing'!outerXML: aStringOrStream forNode: aNode	self		outerXMLForNode: aNode		parsedWith: (self parserHandlerClass on: aStringOrStream)! !!XMLNodeWithElements methodsFor: 'parsing'!outerXMLForNode: aNode parsedWith: aParser	| indexOfNode removedNodes |	indexOfNode :=		self nodes			indexOf: aNode			ifAbsent: [self errorOuterXMLForAbsentNode].	removedNodes :=		self nodes			copyFrom: indexOfNode			to: self nodes size.	self removeNodes: removedNodes.	[aParser		innerXMLRootNode: self;		parseDocument]		on: Error		do: [:error |			[self nodes size >= indexOfNode]				whileTrue: [self nodes removeLast].			self addNodes: removedNodes.			error pass].	2 to: removedNodes size do: [:i |		self addNode: (removedNodes at: i)].! !!XMLNodeWithElements methodsFor: 'defaults'!parserHandlerClass	^ self configuration parserHandlerClass! !!XMLNodeWithElements methodsFor: 'copying'!postCopyConfiguration	configuration		ifNotNil: [self configuration: configuration copy]! !!XMLNodeWithElements methodsFor: 'printing'!printRawContentOn: aStream	self contentNodesDo: [:each | each printRawContentOn: aStream]! !!XMLNodeWithElements methodsFor: 'accessing'!rawContentStringAt: aName	"Returns the raw content string (without space inserted) of the first	element child of the receiver whose qualified or local name matches aName	or an empty string if there isn't one.	See also #contentStringAt:"	^ self nodes rawContentStringAt: aName! !!XMLNodeWithElements methodsFor: 'removing'!removeAllFormattingNodes	"This is a convenience method to remove formatting string nodes from the	receiver and descendant elements. Empty/whitespace string nodes with	element siblings are assumed to be formatting, unless they have at least	one non-empty/non-whitespace sibling string node.	WARNING: 'mixed content' elements that can have both string and element	children, like this:		<row>one<sep/> <sep/>three</row>	aren't properly recognized when all of the string nodes are whitespace,	so this:		<row> <sep/> <sep/> </row>	will become this:		<row><sep/><sep/></row>	which might not be acceptable."	| hasFormattingStringNodes hasElements |	hasFormattingStringNodes := false.	hasElements := false.	self nodesDo: [:each |		each isStringNode			ifTrue: [				(hasFormattingStringNodes :=					each isWhitespace						or: [each isEmpty])					ifFalse: [^ self]]			ifFalse: [				hasElements					ifFalse: [hasElements := each isElement]]].	(hasFormattingStringNodes		and: [hasElements])		ifTrue: [| nodeList |			nodeList := self nodes.			nodeList size to: 1 by: -1 do: [:i | | node |				((node := nodeList at: i) isStringNode					and: [node isWhitespace						or: [node isEmpty]])					ifTrue: [nodeList removeAt: i]]].	hasElements		ifTrue: [			self elementsDo: [:each |				each removeAllFormattingNodes]].! !!XMLNodeWithElements methodsFor: 'notifying'!renamedElement: anElement from: anOldName to: aNewName	self nodes		renamedElement: anElement		from: anOldName		to: aNewName! !!XMLNodeWithElements methodsFor: 'accessing'!stringNodes	"returns a new node list of all string node children of the receiver"	^ self nodes stringNodes! !!XMLNodeWithElements methodsFor: 'enumerating'!stringNodesDo: aBlock	"evaluates each string node child of the receiver with aBlock"	self nodes stringNodesDo: aBlock! !!XMLNodeWithElements methodsFor: 'accessing'!strings	"returns an ordered list of the strings of the string nodes of the receiver"	^ self nodes strings! !!XMLNodeWithElements methodsFor: 'enumerating'!stringsDo: aBlock	"evaluates each string of each string node child of the receiver with	aBlock"	self nodes stringsDo: aBlock! !!XMLNodeWithElements methodsFor: 'testing'!usesNamespaces	"returns true if namespace checking is enabled (default)"	"optimized to avoid lazy initializing the config"	configuration == nil		ifTrue: [^ true].	^ configuration usesNamespaces.! !!XMLNodeWithElements methodsFor: 'accessing'!usesNamespaces: aBoolean	"can be used to disable namespace checking, which is enabled by default"	self configuration usesNamespaces: aBoolean! !!XMLPI class methodsFor: 'instance creation'!target: aTargetString data: aDataString	^ self new		target: aTargetString;		data: aDataString! !!XMLPI methodsFor: 'visiting'!acceptNodeVisitor: aNodeVisitor	^ aNodeVisitor visitPI: self! !!XMLPI methodsFor: 'accessing'!data	^ data ifNil: [data := '']! !!XMLPI methodsFor: 'accessing'!data: aString	data := aString! !!XMLPI methodsFor: 'testing'!hasData	^ self data notEmpty! !!XMLPI methodsFor: 'testing'!isPI	^ true! !!XMLPI methodsFor: 'accessing'!sortKey	^ self target! !!XMLPI methodsFor: 'accessing'!target	^ target ifNil: [target := '']! !!XMLPI methodsFor: 'accessing'!target: aString	target := aString! !!XMLPI methodsFor: 'printing'!writeXMLOn: aWriter	aWriter pi		target: self target;		data: self data;		write! !!XMLCData methodsFor: 'visiting'!acceptNodeVisitor: aNodeVisitor	^ aNodeVisitor visitCData: self! !!XMLCData methodsFor: 'testing'!isCData	^ true! !!XMLCData methodsFor: 'private'!isCoalescingStringNode	"this returns false to stop preserved CDATA nodes from coalescing	together or with ordinary string nodes"	^ false! !!XMLCData methodsFor: 'printing'!writeXMLOn: aWriter	aWriter cdata: self string! !!XMLString class methodsFor: 'instance creation'!string: aString	^ self new string: aString! !!XMLString methodsFor: 'visiting'!acceptNodeVisitor: aNodeVisitor	^ aNodeVisitor visitStringNode: self! !!XMLString methodsFor: 'deprecated'!addContent: aStringOrStringNode	"will be deprecated"	self append: aStringOrStringNode! !!XMLString methodsFor: 'appending/prepending'!append: aStringOrStringNode	string :=		string			ifNil: [aStringOrStringNode asString]			ifNotNil: [string, aStringOrStringNode asString]! !!XMLString methodsFor: 'converting'!asString	^ self string! !!XMLString methodsFor: 'converting'!asXMLEscapedString	^ self string asXMLEscapedString! !!XMLString methodsFor: 'deprecated'!asXMLString	"will be deprecated; use #asXMLStringNode instead"	^ self asXMLStringNode! !!XMLString methodsFor: 'converting'!asXMLStringNode	^ self! !!XMLString methodsFor: 'testing'!beginsWith: aStringOrStringNode	^ self string beginsWith: aStringOrStringNode asString! !!XMLString methodsFor: 'deprecated'!contentString: aString	"will be deprecated; use #string: instead"	self string: aString! !!XMLString methodsFor: 'replacing'!deleteFrom: aStart to: anEnd	self replaceFrom: aStart to: anEnd with: ''! !!XMLString methodsFor: 'testing'!endsWith: aStringOrStringNode	^ self string endsWith: aStringOrStringNode asString! !!XMLString methodsFor: 'testing'!includesSubstring: aStringOrStringNode	"avoid String>>includesSubstring: for backwards compatibility"	^ aStringOrStringNode isEmpty		or: [(self indexOfSubstring: aStringOrStringNode) > 0]! !!XMLString methodsFor: 'accessing'!indexOfSubstring: aStringOrStringNode	^ self string		findString: aStringOrStringNode asString		startingAt: 1! !!XMLString methodsFor: 'private'!isCoalescingStringNode	^ true! !!XMLString methodsFor: 'testing'!isContentNode	^ true! !!XMLString methodsFor: 'testing'!isEmpty	^ self string isEmpty! !!XMLString methodsFor: 'deprecated'!isString: aStringOrStringNode	"will be deprecated; use #isStringNode: instead"	^ self isStringNode: aStringOrStringNode! !!XMLString methodsFor: 'testing'!isStringNode	^ true! !!XMLString methodsFor: 'testing'!isStringNode: aStringOrStringNode	^ self string = aStringOrStringNode asString! !!XMLString methodsFor: 'testing'!isWhitespace	^ self string isXMLWhitespace! !!XMLString methodsFor: 'splitting/merging'!mergeAdjacent	"merges a string node with adjacent string nodes in parent"	| siblingNodes selfIndex adjacentNode |	self hasParent		ifFalse: [^ self].	siblingNodes := self parent nodes.	selfIndex := siblingNodes indexOf: self.	[(adjacentNode := siblingNodes at: selfIndex + 1) notNil		and: [adjacentNode isStringNode]]		whileTrue: [			self append: adjacentNode.			siblingNodes removeAt: selfIndex + 1].	[(adjacentNode := siblingNodes at: selfIndex - 1) notNil		and: [adjacentNode isStringNode]]		whileTrue: [			self prepend: adjacentNode.			siblingNodes removeAt: selfIndex - 1.			selfIndex := selfIndex - 1].! !!XMLString methodsFor: 'testing'!notEmpty	^ self string notEmpty! !!XMLString methodsFor: 'appending/prepending'!prepend: aStringOrStringNode	string :=		string			ifNil: [aStringOrStringNode asString]			ifNotNil: [aStringOrStringNode asString, string]! !!XMLString methodsFor: 'printing'!printRawContentOn: aStream	aStream nextPutAll: self string! !!XMLString methodsFor: 'replacing'!replaceAll: aSource with: aReplacement	"works like copyReplaceAll:with:"	self string:		(self string			copyReplaceAll: aSource asString			with: aReplacement asString)! !!XMLString methodsFor: 'replacing'!replaceFrom: aStart to: aStop with: aReplacement	"works like copyReplaceFrom:to:with: and	can be used to insert, delete, and replace"	| start stop |	start := (aStart max: 1) min: self size + 1.	stop := (aStop max: start - 1) min: self size.	self string:		(self string			copyReplaceFrom: start			to: stop			with: aReplacement asString)! !!XMLString methodsFor: 'accessing'!size	^ self string size! !!XMLString methodsFor: 'accessing'!sortKey	^ self string! !!XMLString methodsFor: 'splitting/merging'!splitAt: anOffset	| newNode |	newNode := self copy.	self replaceFrom: anOffset to: self size with: ''.	newNode replaceFrom: 1 to: anOffset - 1 with: ''.	self hasParent		ifTrue: [self parent addNode: newNode after: self].	^ newNode.! !!XMLString methodsFor: 'accessing'!string	^ string ifNil: [string := '']! !!XMLString methodsFor: 'accessing'!string: aString	string := aString asString! !!XMLString methodsFor: 'printing'!writeXMLOn: aWriter	aWriter string: self string! !!XMLNodeFactory methodsFor: 'converting'!asPluggableNodeFactory	^ XMLPluggableNodeFactory new! !!XMLNodeFactory methodsFor: 'accessing'!attributeDeclarationClass	^ XMLAttributeDeclaration! !!XMLNodeFactory methodsFor: 'accessing'!attributeListClass	^ XMLCachingAttributeList! !!XMLNodeFactory methodsFor: 'accessing'!cdataClass	"Can be overridden to return a custom XMLCData subclass."	^ XMLCData! !!XMLNodeFactory methodsFor: 'accessing'!classForElement: aQualifiedName	^ self elementClass! !!XMLNodeFactory methodsFor: 'accessing'!classForElement: aQualifiedName attributes: anAssociationCollection	^ self elementClass! !!XMLNodeFactory methodsFor: 'accessing'!classForElement: aQualifiedName namespaceURI: aURI	^ self elementClass! !!XMLNodeFactory methodsFor: 'accessing'!classForElement: aQualifiedName namespaceURI: aURI attributes: anAssociationCollection	^ self elementClass! !!XMLNodeFactory methodsFor: 'accessing'!classForElement: aQualifiedName namespaceURI: aURI localName: aLocalName attributes: anAssociationCollection	^ self elementClass! !!XMLNodeFactory methodsFor: 'accessing'!commentClass	"Can be overridden to return a custom XMLComment subclass."	^ XMLComment! !!XMLNodeFactory methodsFor: 'accessing'!doctypeDeclarationClass	^ XMLDoctypeDeclaration! !!XMLNodeFactory methodsFor: 'accessing'!documentClass	"Can be overridden to return a custom XMLDocument subclass."	^ XMLDocument! !!XMLNodeFactory methodsFor: 'accessing'!elementClass	"Can be overridden to return a custom XMLElement subclass."	^ XMLElement! !!XMLNodeFactory methodsFor: 'accessing'!elementDeclarationClass	^ XMLElementDeclaration! !!XMLNodeFactory methodsFor: 'accessing'!generalEntityDeclarationClass	^ XMLGeneralEntityDeclaration! !!XMLNodeFactory methodsFor: 'instance creation'!newCData: aString	^ self cdataClass string: aString! !!XMLNodeFactory methodsFor: 'instance creation'!newComment: aString	^ self commentClass string: aString! !!XMLNodeFactory methodsFor: 'instance creation'!newDocument	^ self documentClass new! !!XMLNodeFactory methodsFor: 'instance creation'!newElement	^ self elementClass new! !!XMLNodeFactory methodsFor: 'instance creation'!newElementNamed: aName	^ (self classForElement: aName)		named: aName! !!XMLNodeFactory methodsFor: 'instance creation'!newElementNamed: aName attributes: anAssociationCollection	^ (self		classForElement: aName		attributes: anAssociationCollection)			name: aName			attributes: anAssociationCollection! !!XMLNodeFactory methodsFor: 'instance creation'!newElementNamed: aName namespaceURI: aURI	^ (self		classForElement: aName		namespaceURI: aURI)			name: aName			namespaceURI: aURI! !!XMLNodeFactory methodsFor: 'instance creation'!newElementNamed: aName namespaceURI: aURI attributes: anAssociationCollection	^ (self		classForElement: aName		namespaceURI: aURI		attributes: anAssociationCollection)			name: aName			namespaceURI: aURI			attributes: anAssociationCollection! !!XMLNodeFactory methodsFor: 'instance creation'!newPI	^ self piClass new! !!XMLNodeFactory methodsFor: 'instance creation'!newPITarget: aTargetString data: aDataString	^ self newPI		target: aTargetString;		data: aDataString! !!XMLNodeFactory methodsFor: 'deprecated'!newString: aString	"will be deprecated; use #newStringNode: instead"	^ self newStringNode: aString! !!XMLNodeFactory methodsFor: 'instance creation'!newStringNode: aString	^ self stringNodeClass new string: aString! !!XMLNodeFactory methodsFor: 'accessing'!nodeListClass	^ XMLNodeList! !!XMLNodeFactory methodsFor: 'accessing'!notationDeclarationClass	^ XMLNotationDeclaration! !!XMLNodeFactory methodsFor: 'accessing'!parameterEntityDeclarationClass	^ XMLParameterEntityDeclaration! !!XMLNodeFactory methodsFor: 'accessing'!piClass	"Can be overridden to return a custom XMLPI subclass."	^ XMLPI! !!XMLNodeFactory methodsFor: 'deprecated'!stringClass	"will be deprecated; use #stringNodeClass instead"	^ XMLString! !!XMLNodeFactory methodsFor: 'accessing'!stringNodeClass	"Can be overridden to return a custom XMLString subclass."	"for now this delegates to the soft-deprecated #stringClass to not	break custom subclasses that override it expecting it to be sent"	^ self stringClass! !!XMLPluggableElementFactory methodsFor: 'accessing'!classForElement: aQualifiedName	^ elementClassMapper		classForElement: aQualifiedName		ifNone: [self elementClass]! !!XMLPluggableElementFactory methodsFor: 'accessing'!classForElement: aQualifiedName attributes: anAssociationCollection	^ elementClassMapper		classForElement: aQualifiedName		attributes: anAssociationCollection		ifNone: [self elementClass]! !!XMLPluggableElementFactory methodsFor: 'accessing'!classForElement: aQualifiedName namespaceURI: aURI	^ elementClassMapper		classForElement: aQualifiedName		namespaceURI: aURI		ifNone: [self elementClass]! !!XMLPluggableElementFactory methodsFor: 'accessing'!classForElement: aQualifiedName namespaceURI: aURI attributes: anAssociationCollection	^ elementClassMapper		classForElement: aQualifiedName		namespaceURI: aURI		attributes: anAssociationCollection		ifNone: [self elementClass]! !!XMLPluggableElementFactory methodsFor: 'accessing'!classForElement: aQualifiedName namespaceURI: aURI localName: aLocalName attributes: anAssociationCollection	^ elementClassMapper		classForElement: aQualifiedName		namespaceURI: aURI		localName: aLocalName		attributes: anAssociationCollection		ifNone: [self elementClass]! !!XMLPluggableElementFactory methodsFor: 'private'!elementClassMapper	^ elementClassMapper! !!XMLPluggableElementFactory methodsFor: 'private'!elementClassMapper: anElementClassMapper	elementClassMapper := anElementClassMapper! !!XMLPluggableElementFactory methodsFor: 'defaults'!elementClassMapperClass	^ XMLBasicElementClassMapper! !!XMLPluggableElementFactory methodsFor: 'handling'!handleElement: anElementName attributes: aCollectionOrAttributeSpec withClass: aClass	"aCollectionOrAttributeSpec can be some kind of XMLAttributeSpec or a	collection of associations of required attribute names and values, and the	required values can be strings, blocks, or nil meaning the attribute is	required but can take any value"	elementClassMapper		mapElement: anElementName		attributeSpec: aCollectionOrAttributeSpec asXMLAttributeSpec		toClass: aClass! !!XMLPluggableElementFactory methodsFor: 'handling'!handleElement: anElementName namespaceURI: aURI attributes: aCollectionOrAttributeSpec withClass: aClass	"aCollectionOrAttributeSpec can be some kind of XMLAttributeSpec or a	collection of associations of required attribute names and values, and the	required values can be strings, blocks, or nil meaning the attribute is	required but can take any value"	elementClassMapper		mapElement: anElementName		namespaceURI: aURI		attributeSpec: aCollectionOrAttributeSpec asXMLAttributeSpec		toClass: aClass! !!XMLPluggableElementFactory methodsFor: 'handling'!handleElement: anElementName namespaceURI: aURI withClass: aClass	elementClassMapper		mapElement: anElementName		namespaceURI: aURI		toClass: aClass! !!XMLPluggableElementFactory methodsFor: 'handling'!handleElement: anElementName withClass: aClass	elementClassMapper		mapElement: anElementName		toClass: aClass! !!XMLPluggableElementFactory methodsFor: 'handling'!handleElements: anElementNameCollection namespaceURI: aNamespaceURI withClass: aClass	elementClassMapper		mapElements: anElementNameCollection		namespaceURI: aNamespaceURI		toClass: aClass! !!XMLPluggableElementFactory methodsFor: 'handling'!handleElements: anElementNameCollection withClass: aClass	elementClassMapper		mapElements: anElementNameCollection		toClass: aClass! !!XMLPluggableElementFactory methodsFor: 'handling'!handleElementsMatchingClass: aClass	"This will handle all elements matching the name of a class with that	class, but igoring the class's prefix and any 'Element' suffix.	For example, it will match MyUserDefinedElement to:		<UserDefined>		<userDefined>		<user-defined>		<user_defined>"	elementClassMapper		mapAllMatchingElementsToClass: aClass		ignoringSuffixes: self ignorableClassNameSuffixes! !!XMLPluggableElementFactory methodsFor: 'handling'!handleElementsMatchingClasses: aClassCollection	"See the comment in #handleElementsMatchingClass:"	elementClassMapper		mapAllMatchingElementsToClasses: aClassCollection		ignoringSuffixes: self ignorableClassNameSuffixes! !!XMLPluggableElementFactory methodsFor: 'defaults'!ignorableClassNameSuffixes	^ #('Element')! !!XMLPluggableElementFactory methodsFor: 'initialization'!initialize	super initialize.	elementClassMapper := self elementClassMapperClass new.! !!XMLPluggableElementFactory methodsFor: 'copying'!postCopy	super postCopy.	elementClassMapper := elementClassMapper copy.! !!XMLPluggableNodeFactory methodsFor: 'converting'!asPluggableNodeFactory	^ self! !!XMLPluggableNodeFactory methodsFor: 'accessing'!attributeListClass	^ attributeListClass! !!XMLPluggableNodeFactory methodsFor: 'accessing'!attributeListClass: aClass	attributeListClass := aClass! !!XMLPluggableNodeFactory methodsFor: 'accessing'!cdataClass	^ cdataClass! !!XMLPluggableNodeFactory methodsFor: 'accessing'!cdataClass: aClass	cdataClass := aClass! !!XMLPluggableNodeFactory methodsFor: 'accessing'!commentClass	^ commentClass! !!XMLPluggableNodeFactory methodsFor: 'accessing'!commentClass: aClass	commentClass := aClass! !!XMLPluggableNodeFactory methodsFor: 'accessing'!documentClass	^ documentClass! !!XMLPluggableNodeFactory methodsFor: 'accessing'!documentClass: aClass	documentClass := aClass! !!XMLPluggableNodeFactory methodsFor: 'accessing'!elementClass	^ elementClass! !!XMLPluggableNodeFactory methodsFor: 'accessing'!elementClass: aClass	elementClass := aClass! !!XMLPluggableNodeFactory methodsFor: 'initialization'!initialize	super initialize.	documentClass := XMLDocument.	elementClass := XMLElement.	stringNodeClass := XMLString.	cdataClass := XMLCData.	commentClass := XMLComment.	piClass := XMLPI.	nodeListClass := XMLNodeList.	attributeListClass := XMLCachingAttributeList.! !!XMLPluggableNodeFactory methodsFor: 'accessing'!nodeListClass	^ nodeListClass! !!XMLPluggableNodeFactory methodsFor: 'accessing'!nodeListClass: aClass	nodeListClass := aClass! !!XMLPluggableNodeFactory methodsFor: 'accessing'!piClass	^ piClass! !!XMLPluggableNodeFactory methodsFor: 'accessing'!piClass: aClass	piClass := aClass! !!XMLPluggableNodeFactory methodsFor: 'deprecated'!stringClass	"will be deprecated; use #stringNodeClass instead"	^ stringNodeClass! !!XMLPluggableNodeFactory methodsFor: 'deprecated'!stringClass: aClass	"will be deprecated; use #stringNodeClass: instead"	stringNodeClass := aClass! !!XMLPluggableNodeFactory methodsFor: 'accessing'!stringNodeClass	^ stringNodeClass! !!XMLPluggableNodeFactory methodsFor: 'accessing'!stringNodeClass: aClass	stringNodeClass := aClass! !!XMLMutatingNodeVisitor methodsFor: 'visiting'!visitNodeWithElements: aNodeWithElements	aNodeWithElements hasChildren		ifTrue: [| oldNodes nodeIndexesToRemove |			oldNodes := aNodeWithElements nodes.			1 to: oldNodes size do: [:i | | oldNode newNode |				oldNode := oldNodes at: i.				(newNode := oldNode acceptNodeVisitor: self) = oldNode					ifFalse: [						newNode							ifNil: [								"only initialize if needed"								(nodeIndexesToRemove									ifNil: [nodeIndexesToRemove := OrderedCollection new])									addLast: i]							ifNotNil: [								"replace it"								oldNodes									at: i									put: newNode]]].			nodeIndexesToRemove				ifNotNil: [					nodeIndexesToRemove reverseDo: [:i |						oldNodes removeAt: i]]].	^ aNodeWithElements.! !!XMLNodeVisitor methodsFor: 'visiting'!visitCData: aCData	^ self visitStringNode: aCData! !!XMLNodeVisitor methodsFor: 'visiting'!visitComment: aComment	^ aComment! !!XMLNodeVisitor methodsFor: 'visiting'!visitDocument: aDocument	^ self visitNodeWithElements: aDocument! !!XMLNodeVisitor methodsFor: 'visiting'!visitElement: anElement	^ self visitNodeWithElements: anElement! !!XMLNodeVisitor methodsFor: 'visiting'!visitNode: aNode	^ aNode acceptNodeVisitor: self! !!XMLNodeVisitor methodsFor: 'visiting'!visitNodeWithElements: aNodeWithElements	aNodeWithElements hasChildren		ifTrue: [			aNodeWithElements nodesDo: [:each |				each acceptNodeVisitor: self]].	^ aNodeWithElements.! !!XMLNodeVisitor methodsFor: 'visiting'!visitPI: aPI	^ aPI! !!XMLNodeVisitor methodsFor: 'visiting'!visitStringNode: aStringNode	^ aStringNode! !!XMLValidatingNodeVisitor class methodsFor: 'instance creation'!validator: aValidator	^ self new validator: aValidator! !!XMLValidatingNodeVisitor methodsFor: 'accessing'!validator	^ validator! !!XMLValidatingNodeVisitor methodsFor: 'accessing'!validator: aValidator	validator := aValidator! !!XMLValidatingNodeVisitor methodsFor: 'visiting'!visitComment: aComment	self validator validateComment: aComment.	^ aComment.! !!XMLValidatingNodeVisitor methodsFor: 'visiting'!visitDocument: aDocument	aDocument root		ifNotNil: [:rootElement |			self validator validateRootElement: rootElement name].	super visitDocument: aDocument.	self validator validateEndDocument.	^ aDocument.! !!XMLValidatingNodeVisitor methodsFor: 'visiting'!visitElement: anElement	| attributeDictionary |	attributeDictionary := 		anElement hasAttributes			ifTrue: [anElement attributeNodes asDictionary]			ifFalse: [Dictionary new].	self validator		validateStartTag: anElement name		attributes: attributeDictionary.	"validation can change/add attribute values"	anElement setAttributes: attributeDictionary.	super visitElement: anElement.	self validator validateEndTag: anElement name.	^ anElement.! !!XMLValidatingNodeVisitor methodsFor: 'visiting'!visitPI: aPI	self validator		validatePI: aPI target		data: aPI data.	^ aPI.! !!XMLValidatingNodeVisitor methodsFor: 'visiting'!visitStringNode: aStringNode	self validator validatePCData: aStringNode string.	^ aStringNode.! !!XMLParser class methodsFor: 'instance creation'!driver: aDriver on: aStringOrStream	^ self new		setDriver: aDriver		tokenizer: (aDriver newTokenizerOn: aStringOrStream)! !!XMLParser methodsFor: 'testing'!atEnd	^ self tokenizer atEnd! !!XMLParser methodsFor: 'accessing'!baseURI	^ self driver baseURI! !!XMLParser methodsFor: 'accessing'!currentColumnNumber	^ self tokenizer currentColumnNumber! !!XMLParser methodsFor: 'accessing'!currentLineNumber	^ self tokenizer currentLineNumber! !!XMLParser methodsFor: 'accessing'!currentPosition	^ self tokenizer currentPosition! !!XMLParser methodsFor: 'accessing'!driver	^ driver! !!XMLParser methodsFor: 'private'!handleParserError: anError	self tokenizer closeStreams.	anError isXMLParserException		ifFalse: [anError pass].	(anError hasLineNumber		or: [self currentLineNumber isNil])		ifFalse: [anError lineNumber: self currentLineNumber].	(anError hasColumnNumber		or: [self currentColumnNumber isNil])		ifFalse: [anError columnNumber: self currentColumnNumber].	(anError hasBaseURI		or: [self baseURI isEmpty])		ifFalse: [anError baseURI: self baseURI].	anError shouldPassOnWhenCaught		ifTrue: [anError pass].! !!XMLParser methodsFor: 'parsing'!parseDocument	[[self tokenizer atEnd]		whileFalse: [self tokenizer nextToken]]		on: Error		do: [:error | self handleParserError: error]! !!XMLParser methodsFor: 'parsing'!parseDocumentUntil: aBlock	[[self tokenizer atEnd or: [aBlock value]]		whileFalse: [self tokenizer nextToken]]		on: Error		do: [:error | self handleParserError: error]! !!XMLParser methodsFor: 'parsing'!parseDocumentWhile: aBlock	[[self tokenizer atEnd not and: [aBlock value]]		whileTrue: [self tokenizer nextToken]]		on: Error		do: [:error | self handleParserError: error]! !!XMLParser methodsFor: 'parsing'!parseToken	^ [self tokenizer nextToken]		on: Error		do: [:error | self handleParserError: error]! !!XMLParser methodsFor: 'initialization'!setDriver: aDriver tokenizer: aTokenizer	driver := aDriver.	tokenizer := aTokenizer.! !!XMLParser methodsFor: 'accessing'!state	^ self tokenizer state! !!XMLParser methodsFor: 'accessing'!state: aTokenState	self tokenizer state: aTokenState! !!XMLParser methodsFor: 'accessing'!tokenizer	^ tokenizer! !!DTDExternalSubsetParserDriver class methodsFor: 'instance creation'!saxDriver: aSAXDriver documentURI: anExternalSubsetURIString	^ self new		setSAXDriver: aSAXDriver		documentURI: anExternalSubsetURIString! !!DTDExternalSubsetParserDriver methodsFor: 'testing'!decodesCharacters	^ self saxDriver decodesCharacters! !!DTDExternalSubsetParserDriver methodsFor: 'accessing'!documentURI	^ documentURI! !!DTDExternalSubsetParserDriver methodsFor: 'accessing'!externalEntityResolver	^ self saxDriver externalEntityResolver! !!DTDExternalSubsetParserDriver methodsFor: 'testing'!hasExternalSubset	^ true! !!DTDExternalSubsetParserDriver methodsFor: 'testing'!hasParameterEntityReferences	^ self saxDriver hasParameterEntityReferences! !!DTDExternalSubsetParserDriver methodsFor: 'testing'!hasSkippedParameterEntityReferences	^ self saxDriver hasSkippedParameterEntityReferences! !!DTDExternalSubsetParserDriver methodsFor: 'accessing'!haveParameterEntityReferences	self saxDriver haveParameterEntityReferences! !!DTDExternalSubsetParserDriver methodsFor: 'accessing'!haveSkippedParameterEntityReferences	self saxDriver haveSkippedParameterEntityReferences! !!DTDExternalSubsetParserDriver methodsFor: 'defaults'!initialStateClass	^ XMLExternalSubsetTextDeclarationState! !!DTDExternalSubsetParserDriver methodsFor: 'testing'!isExternal	"Definition: An external markup declaration is defined as a markup	declaration occurring in the external subset or in a parameter entity	(external or internal, the latter being included because non-validating	processors are not required to read them)"	^ true! !!DTDExternalSubsetParserDriver methodsFor: 'testing'!isStandalone	^ self saxDriver isStandalone! !!DTDExternalSubsetParserDriver methodsFor: 'testing'!isValidating	^ self saxDriver isValidating! !!DTDExternalSubsetParserDriver methodsFor: 'accessing'!maxEntityReplacementDepth	^ self saxDriver maxEntityReplacementDepth! !!DTDExternalSubsetParserDriver methodsFor: 'testing'!preservesUndeclaredEntityReferences	^ self saxDriver preservesUndeclaredEntityReferences! !!DTDExternalSubsetParserDriver methodsFor: 'accessing'!readLimit	^ self externalEntityResolver externalSubsetReadLimit! !!DTDExternalSubsetParserDriver methodsFor: 'testing'!replacesContentEntityReferences	^ self saxDriver replacesContentEntityReferences! !!DTDExternalSubsetParserDriver methodsFor: 'testing'!resolvesExternalEntities	^ true! !!DTDExternalSubsetParserDriver methodsFor: 'accessing'!saxDriver	^ saxDriver! !!DTDExternalSubsetParserDriver methodsFor: 'initialization'!setSAXDriver: aSAXDriver documentURI: anExternalSubsetURIString	saxDriver := aSAXDriver.	documentURI := anExternalSubsetURIString.	doctypeDefinition := aSAXDriver doctypeDefinition.! !!DTDSubsetParserDriver methodsFor: 'accessing'!doctypeDefinition	^ doctypeDefinition! !!DTDSubsetParserDriver methodsFor: 'private'!errorImproperParameterEntityNesting	XMLValidationException signal:		'Improper nesting of parameter entity replacement within DTD subset'! !!DTDSubsetParserDriver methodsFor: 'private'!errorInvalidUndeclaredGeneralEntityReference: aName	XMLValidationException		formatSignal: 'Undeclared general entity reference &{1};'		with: aName! !!DTDSubsetParserDriver methodsFor: 'private'!errorInvalidUndeclaredParameterEntityReference: aName	XMLValidationException		formatSignal: 'Undeclared parameter entity reference %{1};'		with: aName! !!DTDSubsetParserDriver methodsFor: 'private'!errorMultipleDeclarationsForElement: aName	XMLValidationException		formatSignal: 'Multiple declarations for <{1}> element'		with: aName! !!DTDSubsetParserDriver methodsFor: 'private'!errorMultipleDeclarationsForNotation: aName	"Unlike redundant entity declarations which are just ignored,	redundant notation declarations are invalid"	XMLValidationException		formatSignal: 'Multiple declarations for notation "{1}"'		with: aName! !!DTDSubsetParserDriver methodsFor: 'private'!errorReferenceToStandaloneExternalEntity: anEntity	XMLValidationException		formatSignal:			'Internal reference to externally defined ',			'entity {1} in standalone="yes" document'		with: anEntity asReference! !!DTDSubsetParserDriver methodsFor: 'private'!errorUndeclaredGeneralEntityReference: aName	XMLWellFormednessException		formatSignal: 'Undeclared general entity reference &{1};'		with: aName! !!DTDSubsetParserDriver methodsFor: 'accessing'!externalEntityResolver	self subclassResponsibility! !!DTDSubsetParserDriver methodsFor: 'handling - dtd'!handleAttributeDeclaration: anElement name: anAttribute type: aType defaultPragma: aDefaultPragma defaultValue: aDefaultValue	| newAttributeValidator |	self mustSkipEntityAndAttributeDeclarations		ifTrue: [^ self].	newAttributeValidator :=		self isStandaloneExternal			ifTrue: [				self doctypeDefinition					addStandaloneExternalValidatorForAttributeIn: anElement					named: anAttribute					type: aType					defaultPragma: aDefaultPragma					defaultValue: aDefaultValue]			ifFalse: [				self doctypeDefinition					addValidatorForAttributeIn: anElement					named: anAttribute					type: aType					defaultPragma: aDefaultPragma					defaultValue: aDefaultValue].	(self isValidating		and: [newAttributeValidator notNil])		ifTrue: [newAttributeValidator validateAttributeDeclaration].! !!DTDSubsetParserDriver methodsFor: 'handling - dtd'!handleElementDeclaration: aName contentModel: aContentModel	| newElementValidator |	newElementValidator :=		self isStandaloneExternal			ifTrue: [				self doctypeDefinition					addStandaloneExternalValidatorForElement: aName					contentModel: aContentModel]			ifFalse: [				self doctypeDefinition					addValidatorForElement: aName					contentModel: aContentModel].	self isValidating		ifTrue: [			newElementValidator				ifNil: [self errorMultipleDeclarationsForElement: aName].			newElementValidator validateElementDeclaration].! !!DTDSubsetParserDriver methodsFor: 'handling - dtd'!handleGeneralEntityDeclaration: aName publicID: aPublicID systemID: aSystemID ndata: aNotation	self mustSkipEntityAndAttributeDeclarations		ifTrue: [^ self].	aNotation isEmpty		ifTrue: [			self resolvesExternalEntities				ifTrue: [					self isStandaloneExternal						ifTrue: [							self doctypeDefinition								addStandaloneExternalExternalGeneralEntity: aName								resolver: self externalEntityResolver								publicID: aPublicID								systemID: aSystemID								baseURI: self baseURI]						ifFalse: [							self doctypeDefinition								addExternalGeneralEntity: aName								resolver: self externalEntityResolver								publicID: aPublicID								systemID: aSystemID								baseURI: self baseURI]]				ifFalse: [					self isValidating						ifTrue: [							self doctypeDefinition								addUnresolvableExternalGeneralEntity: aName]]]		ifFalse: [			self doctypeDefinition				addUnparsedEntity: aName				publicID: aPublicID				systemID: aSystemID				ndata: aNotation].! !!DTDSubsetParserDriver methodsFor: 'handling - dtd'!handleGeneralEntityDeclaration: aName replacement: aReplacement	self mustSkipEntityAndAttributeDeclarations		ifTrue: [^ self].	self isStandaloneExternal		ifTrue: [			self doctypeDefinition				addStandaloneExternalInternalGeneralEntity: aName				replacement: aReplacement				baseURI: self baseURI]		ifFalse: [			self doctypeDefinition				addInternalGeneralEntity: aName				replacement: aReplacement				baseURI: self baseURI].! !!DTDSubsetParserDriver methodsFor: 'handling'!handleGeneralEntityReference: aName	| entity |	entity :=		self doctypeDefinition			generalEntityAt: aName			ifAbsent: [				"WFC: In a document without any DTD, a document with only an				internal DTD subset which contains no parameter entity references,				or a document with ''standalone='yes''', for an entity reference				(general) that does not occur within the external subset or a				parameter entity (meaning DTD 'external')"				self isExternal					ifFalse: [						((self hasExternalSubset not							and: [self hasParameterEntityReferences not])								or: [self isStandalone])							ifTrue: [self errorUndeclaredGeneralEntityReference: aName]].				"all general entity refs must be declared when validating"				self isValidating					ifTrue: [self errorInvalidUndeclaredGeneralEntityReference: aName].				^ nil].	"'VC: Standalone Document Declaration		The standalone document declaration MUST have the value 'no' if any		external markup declarations contain declarations of:			...		entities ... if references to those entities appear in the document'	LibXML2 doesn't flag these at all, and Xerces only does for references	in the content, but the specification says in the 'document', so we	consider all non-external references, even inside the DTD internal subset"	(entity isStandaloneExternal		and: [self isValidating			and: [self isExternal not]])		ifTrue: [self errorReferenceToStandaloneExternalEntity: entity].	^ entity.! !!DTDSubsetParserDriver methodsFor: 'handling - dtd'!handleImproperParameterEntityNesting	"this is a validity constraint and is only checked when validating"	self isValidating		ifTrue: [self errorImproperParameterEntityNesting]! !!DTDSubsetParserDriver methodsFor: 'handling - dtd'!handleNotationDeclaration: aName publicID: aPublicID systemID: aSystemID	(self doctypeDefinition		addNotation: aName		publicID: aPublicID		systemID: aSystemID)		ifNil: [			self isValidating				ifTrue: [self errorMultipleDeclarationsForNotation: aName]]! !!DTDSubsetParserDriver methodsFor: 'handling - dtd'!handleParameterEntityDeclaration: aName publicID: aPublicID systemID: aSystemID	self mustSkipEntityAndAttributeDeclarations		ifFalse: [			self resolvesExternalEntities				ifTrue: [					self doctypeDefinition						addExternalParameterEntity: aName						resolver: self externalEntityResolver						publicID: aPublicID						systemID: aSystemID						baseURI: self baseURI]				ifFalse: [					self isValidating						ifTrue: [							self doctypeDefinition								addUnresolvableExternalParameterEntity: aName]]]! !!DTDSubsetParserDriver methodsFor: 'handling - dtd'!handleParameterEntityDeclaration: aName replacement: aReplacement	self mustSkipEntityAndAttributeDeclarations		ifFalse: [			self doctypeDefinition				addInternalParameterEntity: aName				replacement:aReplacement				baseURI: self baseURI]! !!DTDSubsetParserDriver methodsFor: 'handling - dtd'!handleParameterEntityReference: aName	self haveParameterEntityReferences.	^ self doctypeDefinition		parameterEntityAt: aName		ifAbsent: [			self isValidating				ifTrue: [self errorInvalidUndeclaredParameterEntityReference: aName].			self haveSkippedParameterEntityReferences.			nil]! !!DTDSubsetParserDriver methodsFor: 'handling'!handleParseError: aString	XMLWellFormednessException signal: aString! !!DTDSubsetParserDriver methodsFor: 'testing'!hasExternalSubset	self subclassResponsibility! !!DTDSubsetParserDriver methodsFor: 'testing'!hasParameterEntityReferences	self subclassResponsibility! !!DTDSubsetParserDriver methodsFor: 'testing'!hasSkippedParameterEntityReferences	self subclassResponsibility! !!DTDSubsetParserDriver methodsFor: 'accessing'!haveParameterEntityReferences	self subclassResponsibility! !!DTDSubsetParserDriver methodsFor: 'accessing'!haveSkippedParameterEntityReferences	self subclassResponsibility! !!DTDSubsetParserDriver methodsFor: 'testing'!isExternal	"Definition: An external markup declaration is defined as a markup	declaration occurring in the external subset or in a parameter entity	(external or internal, the latter being included because non-validating	processors are not required to read them)"	self subclassResponsibility! !!DTDSubsetParserDriver methodsFor: 'testing'!isStandalone	self subclassResponsibility! !!DTDSubsetParserDriver methodsFor: 'testing'!isStandaloneExternal	^ self isStandalone		and: [self isExternal]! !!DTDSubsetParserDriver methodsFor: 'testing'!isValidating	self subclassResponsibility! !!DTDSubsetParserDriver methodsFor: 'accessing'!maxEntityReplacementDepth	self subclassResponsibility! !!DTDSubsetParserDriver methodsFor: 'testing'!mustSkipEntityAndAttributeDeclarations	"'Except when standalone=''yes'', they (non-validating parsers) MUST NOT	process entity declarations or attribute-list declarations encountered	after a reference to a parameter entity that is not read...'"	^ self isValidating not		and: [self isStandalone not			and: [self hasSkippedParameterEntityReferences]]! !!DTDSubsetParserDriver methodsFor: 'testing'!preservesUndeclaredEntityReferences	self subclassResponsibility! !!DTDSubsetParserDriver methodsFor: 'testing'!replacesContentEntityReferences	self subclassResponsibility! !!DTDSubsetParserDriver methodsFor: 'testing'!resolvesExternalEntities	self subclassResponsibility! !!SAXParserDriver class methodsFor: 'instance creation'!saxHandler: aSAXHandler	^ self new setSAXHandler: aSAXHandler! !!SAXParserDriver methodsFor: 'accessing'!baseURI	"returns a string with the current base URI at this stage of parsing"	self elementNester hasScopedAttributes		ifTrue: [			^ self elementNester				scopedAttributeAt: 'xml:base'				ifAbsent: [super baseURI]]		ifFalse: [^ super baseURI]! !!SAXParserDriver methodsFor: 'private'!checkForReservedAttributesIn: anOrderPreservingDictionary afterIndex: anIndex	"validation may add attributes, so this is used to check if reserved	attributes were added that need handling when there weren't any before"	self hasUnhandledReservedAttributes		ifTrue: [^ self].	anIndex + 1		to: anOrderPreservingDictionary size		do: [:i |			(anOrderPreservingDictionary keyAtIndex: i) isXMLReservedAttributeName				ifTrue: [^ self haveUnhandledReservedAttributes]].! !!SAXParserDriver methodsFor: 'accessing'!currentElement	^ self elementNester currentElement! !!SAXParserDriver methodsFor: 'accessing'!currentElement: anElement	self elementNester currentElement: anElement! !!SAXParserDriver methodsFor: 'accessing'!currentScope	^ self scopeAllocator currentScope! !!SAXParserDriver methodsFor: 'accessing'!currentScope: aNamespaceScope	self scopeAllocator currentScope: aNamespaceScope! !!SAXParserDriver methodsFor: 'private'!declareNamespaces: aSequenceableCollection inScope: aScope	1 to: aSequenceableCollection size do: [:i | | association |		association := aSequenceableCollection at: i.		(aScope resolvePrefix: association key) = association value			ifFalse: [				self saxHandler					startPrefixMapping: association key					uri: association value]].	aScope mapPrefixesAndURIs: aSequenceableCollection.! !!SAXParserDriver methodsFor: 'testing'!decodesCharacters	^ self saxHandler decodesCharacters! !!SAXParserDriver methodsFor: 'defaults'!doctypeDefinitionClass	^ DTDDoctypeDefinition! !!SAXParserDriver methodsFor: 'accessing'!documentReadLimit	^ self saxHandler documentReadLimit! !!SAXParserDriver methodsFor: 'accessing'!documentURI	^ self saxHandler documentURI! !!SAXParserDriver methodsFor: 'accessing'!elementNester	^ elementNester! !!SAXParserDriver methodsFor: 'private'!errorDocumentConstraintsRequired	XMLValidationException signal: 'Document validation constraints required'! !!SAXParserDriver methodsFor: 'accessing'!externalEntityResolver	^ externalEntityResolver		ifNil: [			externalEntityResolver :=				self saxHandler externalEntityResolver					asLimitingExternalEntityResolver]! !!SAXParserDriver methodsFor: 'private'!externalSubsetParserOn: aStringOrStream documentURI: aURIString	^ self saxHandler parserClass		driver:			(DTDExternalSubsetParserDriver				saxDriver: self				documentURI: aURIString)		on: aStringOrStream! !!SAXParserDriver methodsFor: 'accessing'!externalSubsetPublicID	^ externalSubsetPublicID! !!SAXParserDriver methodsFor: 'accessing'!externalSubsetSystemID	^ externalSubsetSystemID! !!SAXParserDriver methodsFor: 'private'!extractNamespacesFromAttributes: anOrderPreservingDictionary	"returns an ordered collection of namespace prefix/uri associations	removed from the attribute dictionary or nil if there aren't any"	| namespaces keysToRemove |	self haveNoUnhandledReservedAttributes.	anOrderPreservingDictionary keysDo: [:name |		"optimized comparison ordering"		(name at: 1) == $x			ifTrue: [				name isXMLNSAttributeName					ifTrue: [						"only initialize when needed"						(namespaces ifNil: [namespaces := OrderedCollection new: 5])							addLast:								(name size > 6 "'xmlns:' size"									ifTrue: [name copyFrom: 7 to: name size]									ifFalse: ['']) ->										(anOrderPreservingDictionary at: name).						"only initialize when needed"						(keysToRemove ifNil: [keysToRemove := OrderedCollection new: 5])							addLast: name]					ifFalse: [						name isXMLReservedAttributeName							ifTrue: [								"at least one xml attr is not an xmlns attr, so there								will still be reserved attrs to handle after extracting								the namespaces"								self haveUnhandledReservedAttributes]]]].	keysToRemove		ifNotNil: [			"use removeKeys: for speed"			anOrderPreservingDictionary removeKeys: keysToRemove].	^ namespaces.! !!SAXParserDriver methodsFor: 'handling - dtd'!handleAttributeDeclaration: anElement name: anAttribute type: aType defaultPragma: aDefaultPragma defaultValue: aDefaultValue	super		handleAttributeDeclaration: anElement		name: anAttribute		type: aType		defaultPragma: aDefaultPragma		defaultValue: aDefaultValue.	self saxHandler		attributeDeclaration: anElement		name: anAttribute		type: aType		defaultPragma: aDefaultPragma		defaultValue: aDefaultValue.! !!SAXParserDriver methodsFor: 'handling'!handleCData: aString	self isValidating		ifTrue: [self validator validatePCData: aString].	self saxHandler		isInCDataSection: true;		startCData;		characters: aString;		endCData;		isInCDataSection: false.! !!SAXParserDriver methodsFor: 'handling'!handleComment: aString	(self elementNester isInElement		and: [self isValidating])		ifTrue: [self validator validateComment: aString].	self saxHandler comment: aString.! !!SAXParserDriver methodsFor: 'handling - dtd'!handleElementDeclaration: aName contentModel: aContentModel	super		handleElementDeclaration: aName		contentModel: aContentModel.	self saxHandler		elementDeclaration: aName		contentModel: aContentModel.! !!SAXParserDriver methodsFor: 'handling'!handleEndContentEntityReplacement: aName	self saxHandler endEntity: aName! !!SAXParserDriver methodsFor: 'handling - dtd'!handleEndDTD	(self resolvesExternalEntities		and: [self hasExternalSubset			and: [self isValidating				or: [self isStandalone not]]])		ifTrue: [self parseExternalSubset].	self isValidating		ifTrue: [self doctypeDefinition validateCompletedDefinition].	self saxHandler		doctypeDefinition: self doctypeDefinition;		endDTD.! !!SAXParserDriver methodsFor: 'handling'!handleEndDocument	self isValidating		ifTrue: [self validator validateEndDocument].	self saxHandler endDocument.! !!SAXParserDriver methodsFor: 'handling'!handleEndTag: anElement	"performance critical method"	| prefix currentScope |	prefix := anElement xmlPrefixBeforeLocalName.	self saxHandler 		endElement: anElement		prefix: prefix		uri:			(self usesNamespaces				ifTrue: [					(currentScope := self scopeAllocator exitScope)						resolvePrefix: prefix]				ifFalse: [''])		localName: (anElement xmlLocalNameAfterPrefix: prefix).	self usesNamespaces		ifTrue: [			currentScope hasNamespaces				ifTrue: [self undeclareNamespacesInScope: currentScope]].	self isValidating		ifTrue: [self validator validateEndTag: anElement].! !!SAXParserDriver methodsFor: 'handling - dtd'!handleGeneralEntityDeclaration: aName publicID: aPublicID systemID: aSystemID ndata: aNotation	super		handleGeneralEntityDeclaration: aName		publicID: aPublicID		systemID: aSystemID		ndata: aNotation.	self saxHandler		generalEntityDeclaration: aName		publicID: aPublicID		systemID: aSystemID		ndata: aNotation.! !!SAXParserDriver methodsFor: 'handling - dtd'!handleGeneralEntityDeclaration: aName replacement: aReplacement	super		handleGeneralEntityDeclaration: aName		replacement: aReplacement.	self saxHandler		generalEntityDeclaration: aName		replacement: aReplacement.! !!SAXParserDriver methodsFor: 'handling - dtd'!handleNotationDeclaration: aName publicID: aPublicID systemID: aSystemID	super		handleNotationDeclaration: aName		publicID: aPublicID		systemID: aSystemID.	self saxHandler		notationDeclaration: aName		publicID: aPublicID		systemID: aSystemID.! !!SAXParserDriver methodsFor: 'handling'!handlePCData: aString	self isValidating		ifTrue: [self validator validatePCData: aString].	self saxHandler characters: aString.! !!SAXParserDriver methodsFor: 'handling'!handlePI: aTargetString data: aDataString	(self elementNester isInElement		and: [self isValidating])		ifTrue: [			self validator				validatePI: aTargetString				data: aDataString].	self saxHandler 		processingInstruction: aTargetString		data: aDataString.! !!SAXParserDriver methodsFor: 'handling - dtd'!handleParameterEntityDeclaration: aName publicID: aPublicID systemID: aSystemID	super		handleParameterEntityDeclaration: aName		publicID: aPublicID		systemID: aSystemID.	self saxHandler		parameterEntityDeclaration: aName		publicID: aPublicID		systemID: aSystemID.! !!SAXParserDriver methodsFor: 'handling - dtd'!handleParameterEntityDeclaration: aName replacement: aReplacement	super		handleParameterEntityDeclaration: aName		replacement: aReplacement.	self saxHandler		parameterEntityDeclaration: aName		replacement: aReplacement.! !!SAXParserDriver methodsFor: 'private'!handleReservedAttributes: aDictionary	aDictionary		at: 'xml:base'		ifPresent: [:uri |			"expand the new base URI using the current"			aDictionary				at: 'xml:base'				put: (self baseURI asXMLURI / uri) asString].	self isValidating		ifTrue: [self validator validateXMLIDAttributeIn: aDictionary].	self elementNester		setScopedAttributesNamed: self scopedAttributeNames		from: aDictionary.	self haveNoUnhandledReservedAttributes.! !!SAXParserDriver methodsFor: 'handling'!handleStartContent	self saxHandler startContent! !!SAXParserDriver methodsFor: 'handling'!handleStartContentEntityReplacement: aName	self saxHandler startEntity: aName! !!SAXParserDriver methodsFor: 'handling - dtd'!handleStartDTD: aRoot publicID: aPublicID systemID: aSystemID	externalSubsetPublicID := aPublicID.	externalSubsetSystemID := aSystemID.	self doctypeDefinition root: aRoot.	self saxHandler		startDTD: aRoot		publicID: aPublicID		systemID: aSystemID.! !!SAXParserDriver methodsFor: 'handling'!handleStartDocument	self saxHandler startDocument! !!SAXParserDriver methodsFor: 'handling'!handleStartTag: anElement attributes: anAttributeDictionary	"performance critical method"	| prefix totalAttributes namespaceURI currentScope |	prefix := anElement xmlPrefixBeforeLocalName.	totalAttributes := anAttributeDictionary size.	self isValidating		ifTrue: [			self elementNester totalOpenElements > 1				ifFalse: [self validateRootElement: anElement].			self validator				validateStartTag: anElement				attributes: anAttributeDictionary]		ifFalse: [			self doctypeDefinition				processStartTag: anElement				attributes: anAttributeDictionary].	"validation and processing can add attributes"	anAttributeDictionary size > totalAttributes		ifTrue: [			self				checkForReservedAttributesIn: anAttributeDictionary				afterIndex: totalAttributes.			totalAttributes := anAttributeDictionary size].	self usesNamespaces		ifTrue: [			anAttributeDictionary setNamespaceScope:				(currentScope := self scopeAllocator enterScope).			self hasUnhandledReservedAttributes				ifTrue: [					(self extractNamespacesFromAttributes: anAttributeDictionary)						ifNotNil: [:namespaces |							self								declareNamespaces: namespaces								inScope: currentScope.							totalAttributes := anAttributeDictionary size]].			self saxHandler startScope: currentScope.			namespaceURI :=				currentScope					validateAndResolvePrefix: prefix					ofElement: anElement.			totalAttributes > 0				ifTrue: [					"anAttributeDictionary is an XMLAttributeDictionary, which					is an OrderPreservingStringDictionary, so use its internal					#orderedKeys over #keys for speed"					currentScope						validatePrefixesOfAttributes: anAttributeDictionary orderedKeys						from: 1						to: totalAttributes]].	self hasUnhandledReservedAttributes		ifTrue: [self handleReservedAttributes: anAttributeDictionary].	self saxHandler		startElement: anElement		prefix: prefix		uri: (namespaceURI ifNil: [''])		localName: (anElement xmlLocalNameAfterPrefix: prefix)		attributes: anAttributeDictionary.! !!SAXParserDriver methodsFor: 'handling'!handleUnreplacedGeneralEntityReference: aName	self saxHandler skippedEntity: aName! !!SAXParserDriver methodsFor: 'handling'!handleWhitespace: aString	self isValidating		ifTrue: [			self validator isCurrentElementWhitespaceIgnorable				ifTrue: [					(self elementNester hasScopedAttributes						and: [							(self elementNester scopedAttributeAt: 'xml:space') =								'preserve'])						ifTrue: [self saxHandler characters: aString]						ifFalse: [self saxHandler ignorableWhitespace: aString].					^ self]				ifFalse: [					"only validate if it's not ignorable"					self validator validatePCData: aString]].	self saxHandler characters: aString.! !!SAXParserDriver methodsFor: 'handling'!handleXMLVersion: aVersion encoding: anEncoding standalone: aYesOrNo	isStandalone := aYesOrNo = 'yes'.	self saxHandler		xmlVersion: (self versionFloatFromString: aVersion)		encoding: anEncoding		standalone: isStandalone.! !!SAXParserDriver methodsFor: 'testing'!hasExternalSubset	^ self externalSubsetPublicID notEmpty		or: [self externalSubsetSystemID notEmpty]! !!SAXParserDriver methodsFor: 'testing'!hasParameterEntityReferences	^ hasParameterEntityReferences! !!SAXParserDriver methodsFor: 'testing'!hasSkippedParameterEntityReferences	^ hasSkippedParameterEntityReferences! !!SAXParserDriver methodsFor: 'testing'!hasUnhandledReservedAttributes	^ hasUnhandledReservedAttributes! !!SAXParserDriver methodsFor: 'accessing'!haveNoUnhandledReservedAttributes	hasUnhandledReservedAttributes := false! !!SAXParserDriver methodsFor: 'accessing'!haveParameterEntityReferences	hasParameterEntityReferences := true! !!SAXParserDriver methodsFor: 'accessing'!haveSkippedParameterEntityReferences	hasSkippedParameterEntityReferences := true! !!SAXParserDriver methodsFor: 'accessing'!haveUnhandledReservedAttributes	hasUnhandledReservedAttributes := true! !!SAXParserDriver methodsFor: 'testing'!isExternal	"Definition: An external markup declaration is defined as a markup	declaration occurring in the external subset or in a parameter entity	(external or internal, the latter being included because non-validating	processors are not required to read them)"	"returning #isParameter instead of 'self currentEntity notNil'	ensures the correct result when parsing content"	^ self currentEntity		ifNil: [false]		ifNotNil: [:entity | entity isParameter]! !!SAXParserDriver methodsFor: 'testing'!isStandalone	^ isStandalone! !!SAXParserDriver methodsFor: 'accessing'!isStandalone: aBoolean	isStandalone := aBoolean! !!SAXParserDriver methodsFor: 'testing'!isValidating	^ isValidating! !!SAXParserDriver methodsFor: 'accessing'!maxEntityReplacementDepth	^ self saxHandler maxEntityReplacementDepth! !!SAXParserDriver methodsFor: 'instance creation'!newAttributeDictionary	^ (self usesNamespaces		ifTrue: [XMLNamespacedAttributeDictionary]		ifFalse: [XMLAttributeDictionary]) new! !!SAXParserDriver methodsFor: 'instance creation'!newEmptyAttributeDictionary	^ (self usesNamespaces		ifTrue: [XMLLazyNamespacedAttributeDictionary]		ifFalse: [XMLLazyAttributeDictionary]) new! !!SAXParserDriver methodsFor: 'private'!parseExternalSubset	| externalSubsetURI |	externalSubsetURI :=		self externalEntityResolver			externalEntityURIFromPublicID: self externalSubsetPublicID			systemID: self externalSubsetSystemID			baseURI: self baseURI.	"External subsets are stream-resolved so if they are local (stored on disk),	they aren't kept entirely in memory during parsing. HTTP entities will be	kept in memory regardless and this will just return a read stream on them."	(self		externalSubsetParserOn:			(self externalEntityResolver streamResolveExternalEntityURI:				externalSubsetURI)		documentURI: externalSubsetURI asString)		parseDocument.! !!SAXParserDriver methodsFor: 'testing'!preservesUndeclaredEntityReferences	^ self saxHandler preservesUndeclaredEntityReferences! !!SAXParserDriver methodsFor: 'accessing'!readLimit	^ self documentReadLimit! !!SAXParserDriver methodsFor: 'testing'!replacesContentEntityReferences	^ self saxHandler replacesContentEntityReferences! !!SAXParserDriver methodsFor: 'testing'!resolvesExternalEntities	^ self saxHandler resolvesExternalEntities! !!SAXParserDriver methodsFor: 'accessing'!saxHandler	^ saxHandler! !!SAXParserDriver methodsFor: 'accessing'!scopeAllocator	^ scopeAllocator ifNil: [scopeAllocator := XMLNamespaceScopeAllocator new]! !!SAXParserDriver methodsFor: 'private'!scopedAttributeNames	"the scoped attributes tracked by this driver"	^ #('xml:space' 'xml:base')! !!SAXParserDriver methodsFor: 'initialization'!setSAXHandler: aSAXHandler	saxHandler := aSAXHandler.	doctypeDefinition := self doctypeDefinitionClass new.	validator := (aSAXHandler schema ifNil: [doctypeDefinition]) newValidator.	elementNester := self newElementNester.	externalSubsetPublicID := ''.	externalSubsetSystemID := ''.	"these are copied to inst vars for faster access"	isValidating := aSAXHandler isValidating.	usesNamespaces := aSAXHandler usesNamespaces.	isStandalone := false.	hasParameterEntityReferences := false.	hasSkippedParameterEntityReferences := false.	hasUnhandledReservedAttributes := false.! !!SAXParserDriver methodsFor: 'private'!undeclareNamespacesInScope: anExitedScope	| currentScope |	currentScope := self scopeAllocator currentScope.	anExitedScope prefixesAndURIsDo: [:prefix :uri |		(currentScope resolvePrefix: prefix) = uri			ifFalse: [self saxHandler endPrefixMapping: prefix]].! !!SAXParserDriver methodsFor: 'testing'!usesNamespaces	^ usesNamespaces! !!SAXParserDriver methodsFor: 'private'!validateRootElement: anElement	self saxHandler requiresSchema		ifTrue: [			(self validator hasElementValidators				or: [self validator hasAttributeValidators])				ifFalse: [self errorDocumentConstraintsRequired]].	self validator validateRootElement: anElement.! !!SAXParserDriver methodsFor: 'accessing'!validator	^ validator! !!SAXParserDriver methodsFor: 'private'!versionFloatFromString: aString	aString size = 3		ifTrue: [			aString = '1.0'				ifTrue: [^ 1.0].			aString = '1.1'				ifTrue: [^ 1.1]].	^ Float readFrom: aString readStream.! !!XMLParserDriver methodsFor: 'accessing'!baseURI	"returns a string with the current base URI at this stage of parsing"	^ baseURI ifNil: [baseURI := self documentURI]! !!XMLParserDriver methodsFor: 'accessing'!baseURI: aURI	baseURI := aURI! !!XMLParserDriver methodsFor: 'accessing'!currentEntity	^ currentEntity! !!XMLParserDriver methodsFor: 'accessing'!currentEntity: anEntity	currentEntity := anEntity! !!XMLParserDriver methodsFor: 'testing'!decodesCharacters	^ true! !!XMLParserDriver methodsFor: 'accessing'!documentURI	^ nil! !!XMLParserDriver methodsFor: 'accessing'!elementNester	^ self newElementNester! !!XMLParserDriver methodsFor: 'defaults'!elementNesterClass	^ XMLElementNester! !!XMLParserDriver methodsFor: 'handling - dtd'!handleAttributeDeclaration: anElement name: anAttribute type: aType defaultPragma: aDefaultPragma defaultValue: aDefaultValue! !!XMLParserDriver methodsFor: 'handling'!handleCData: aString! !!XMLParserDriver methodsFor: 'handling'!handleComment: aString! !!XMLParserDriver methodsFor: 'handling - dtd'!handleElementDeclaration: aName contentModel: aContentModel! !!XMLParserDriver methodsFor: 'handling'!handleEndContentEntityReplacement: aName! !!XMLParserDriver methodsFor: 'handling - dtd'!handleEndDTD! !!XMLParserDriver methodsFor: 'handling'!handleEndDocument! !!XMLParserDriver methodsFor: 'handling'!handleEndTag: anElement! !!XMLParserDriver methodsFor: 'handling - dtd'!handleGeneralEntityDeclaration: aName publicID: aPublicID systemID: aSystemID ndata: aNotation! !!XMLParserDriver methodsFor: 'handling - dtd'!handleGeneralEntityDeclaration: aName replacement: aReplacement! !!XMLParserDriver methodsFor: 'handling'!handleGeneralEntityReference: aName	^ nil! !!XMLParserDriver methodsFor: 'handling - dtd'!handleNotationDeclaration: aName publicID: aPublicID systemID: aSystemID! !!XMLParserDriver methodsFor: 'handling'!handlePCData: aString! !!XMLParserDriver methodsFor: 'handling'!handlePI: aTargetString data: aDataString! !!XMLParserDriver methodsFor: 'handling - dtd'!handleParameterEntityDeclaration: aName publicID: aPublicID systemID: aSystemID! !!XMLParserDriver methodsFor: 'handling - dtd'!handleParameterEntityDeclaration: aName replacement: aReplacement! !!XMLParserDriver methodsFor: 'handling - dtd'!handleParameterEntityReference: aName	^ nil! !!XMLParserDriver methodsFor: 'handling'!handleParseError: aString! !!XMLParserDriver methodsFor: 'handling'!handleStartContent! !!XMLParserDriver methodsFor: 'handling'!handleStartContentEntityReplacement: aName! !!XMLParserDriver methodsFor: 'handling - dtd'!handleStartDTD: aRoot publicID: aPublicID systemID: aSystemID! !!XMLParserDriver methodsFor: 'handling'!handleStartDocument! !!XMLParserDriver methodsFor: 'handling'!handleStartTag: anElement attributes: anAttributeDictionary! !!XMLParserDriver methodsFor: 'handling'!handleUnreplacedGeneralEntityReference: aName! !!XMLParserDriver methodsFor: 'handling'!handleWhitespace: aString! !!XMLParserDriver methodsFor: 'handling'!handleXMLVersion: aVersion encoding: anEncoding standalone: aYesOrNo! !!XMLParserDriver methodsFor: 'defaults'!initialStateClass	^ XMLXMLDeclarationState! !!XMLParserDriver methodsFor: 'instance creation'!newElementNester	^ self elementNesterClass new! !!XMLParserDriver methodsFor: 'instance creation'!newInitialState	^ self initialStateClass new! !!XMLParserDriver methodsFor: 'instance creation'!newTokenizerOn: aStringOrStream	^ self tokenizerClass		driver: self		on: aStringOrStream		readLimit: self readLimit! !!XMLParserDriver methodsFor: 'accessing'!readLimit	^ nil! !!XMLParserDriver methodsFor: 'defaults'!tokenizerClass	^ XMLWellFormedParserTokenizer! !!XMLParserLimits class methodsFor: 'defaults'!defaultDocumentReadLimit	^ self defaultReadLimit! !!XMLParserLimits class methodsFor: 'defaults'!defaultMaxEntityReplacementDepth	^ 10! !!XMLParserLimits class methodsFor: 'accessing'!defaultReadLimit	^ DefaultReadLimit		ifNil: [DefaultReadLimit := 10000000]! !!XMLParserLimits class methodsFor: 'accessing'!defaultReadLimit: aDefaultLimit	"can be used to change the default read limit instances start with"	DefaultReadLimit := aDefaultLimit! !!XMLParserLimits methodsFor: 'accessing'!documentReadLimit	^ documentReadLimit! !!XMLParserLimits methodsFor: 'accessing'!documentReadLimit: anInteger	documentReadLimit := anInteger! !!XMLParserLimits methodsFor: 'initialization'!initialize	super initialize.	documentReadLimit := self class defaultDocumentReadLimit.	maxEntityReplacementDepth := self class defaultMaxEntityReplacementDepth.! !!XMLParserLimits methodsFor: 'accessing'!maxEntityReplacementDepth	^ maxEntityReplacementDepth! !!XMLParserLimits methodsFor: 'accessing'!maxEntityReplacementDepth: anInteger	maxEntityReplacementDepth := anInteger! !!XMLParserLimits methodsFor: 'removing'!removeAll	documentReadLimit := nil.	maxEntityReplacementDepth := nil.! !!XMLParserTokenizer class methodsFor: 'instance creation'!driver: aDriver on: aStringOrStream	^self		driver: aDriver		on: aStringOrStream		readLimit: nil! !!XMLParserTokenizer class methodsFor: 'instance creation'!driver: aDriver on: aStringOrStream readLimit: anInteger	^self new		setDriver: aDriver		stream:			(aStringOrStream isStream				ifTrue: [aStringOrStream]				ifFalse: [aStringOrStream readStream])		readLimit: anInteger! !!XMLParserTokenizer class methodsFor: 'class initialization'!initialize	"self initialize"	"assign after with #yourself to avoid possible race	conditions when reinitializing the class"	PredefinedEntities :=		Dictionary new			at: 'lt' put: $<;			at: 'gt' put: $>;			at: 'amp' put: $&;			at: 'apos' put: $';			at: 'quot' put: $";			yourself! !!XMLParserTokenizer class methodsFor: 'accessing'!predefinedEntities	^ PredefinedEntities! !!XMLParserTokenizer methodsFor: 'testing'!atEnd	^ state isTerminatedState! !!XMLParserTokenizer methodsFor: 'decoding'!characterFromCodePoint: aCodePoint	(aCodePoint notNil		and: [aCodePoint > 0			and: [aCodePoint <= 16r10FFFF]])		ifTrue: [			^ [Character value: aCodePoint]				on: Error				do: [:error | nil]]		ifFalse: [^ nil]! !!XMLParserTokenizer methodsFor: 'closing'!closeStreams	streamReader closeStreams! !!XMLParserTokenizer methodsFor: 'decoding'!convertFromEncoding: anEncodingName	driver decodesCharacters		ifTrue: [streamReader convertFromEncoding: anEncodingName]! !!XMLParserTokenizer methodsFor: 'accessing'!currentColumnNumber	^ streamReader currentColumnNumber! !!XMLParserTokenizer methodsFor: 'accessing'!currentLineNumber	^ streamReader currentLineNumber! !!XMLParserTokenizer methodsFor: 'accessing'!currentPosition	^ streamReader currentPosition! !!XMLParserTokenizer methodsFor: 'accessing'!driver	^ driver! !!XMLParserTokenizer methodsFor: 'accessing'!elementNester	^ elementNester! !!XMLParserTokenizer methodsFor: 'errors'!errorExpected: aDescription	self parseError: 'Expected ', aDescription! !!XMLParserTokenizer methodsFor: 'errors'!errorExpected: aDescription butGot: aCharacterOrString	self		formatParseError: 'Expected {1} but got "{2}" instead'		with: aDescription		with: aCharacterOrString! !!XMLParserTokenizer methodsFor: 'errors'!errorExpectedLiteral: aCharacterOrString	self		errorExpectedLiteral: aCharacterOrString		butGot: nil! !!XMLParserTokenizer methodsFor: 'errors'!errorExpectedLiteral: anExpectedCharacterOrString butGot: aReceivedCharacterOrString	self		formatParseError: 'Expected "{1}" but got "{2}" instead' 		with: anExpectedCharacterOrString		with: aReceivedCharacterOrString! !!XMLParserTokenizer methodsFor: 'tokenizing - expecting'!expectNext: aCharacter	self subclassResponsibility! !!XMLParserTokenizer methodsFor: 'tokenizing - expecting'!expectNextAll: aString	self subclassResponsibility! !!XMLParserTokenizer methodsFor: 'errors'!formatParseError: aString with: aFirstValue	self		formatParseError: aString		withArguments: (Array with: aFirstValue)! !!XMLParserTokenizer methodsFor: 'errors'!formatParseError: aString with: aFirstValue with: aSecondValue	self		formatParseError: aString		withArguments:			(Array				with: aFirstValue				with: aSecondValue)! !!XMLParserTokenizer methodsFor: 'errors'!formatParseError: aString with: aFirstValue with: aSecondValue with: aThirdValue	self		formatParseError: aString		withArguments:			(Array				with: aFirstValue				with: aSecondValue				with: aThirdValue)! !!XMLParserTokenizer methodsFor: 'errors'!formatParseError: aString with: aFirstValue with: aSecondValue with: aThirdValue with: aFourthValue	self		formatParseError: aString		withArguments:			(Array				with: aFirstValue				with: aSecondValue				with: aThirdValue				with: aFourthValue)! !!XMLParserTokenizer methodsFor: 'errors'!formatParseError: aString withArguments: aValueCollection	self parseError:		(aString format:			"convert nils to empty strings, so nil values are			not printed as 'nil' in error messsages"			(aValueCollection collect: [:each |				each ifNil: ['']]))! !!XMLParserTokenizer methodsFor: 'defaults'!hexCharacterValueLiteralPrefixes	^ 'x'! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextCDataSection	self subclassResponsibility! !!XMLParserTokenizer methodsFor: 'decoding'!nextCharacterValueLiteral	^ self nextCharacterValueLiteralPrintedOn: nil! !!XMLParserTokenizer methodsFor: 'decoding'!nextCharacterValueLiteralPrintedOn: aStream	"do not limit the number of chars read, because char values can	have an arbitrary number of leading zeros"	^ (XMLSmallIntegerReader on: streamReader)		printStream: aStream;		nextIntegerWithBase: 16			andPrefixes: self hexCharacterValueLiteralPrefixes			orBase: 10! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextContentMarkupToken	self subclassResponsibility! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextContentToken	streamReader peek == $<		ifTrue: [			streamReader next.			^ self nextContentMarkupToken].	elementNester isInElement		ifTrue: [^ self nextPCDataToken].	self nextNonElementWhitespace.! !!XMLParserTokenizer methodsFor: 'tokenizing - dtd'!nextDoctypeDeclaration	| root publicID systemID |	state := state doctypeDeclarationState.	self		expectNextAll: 'DOCTYPE';		nextSeparators.	root := self nextElementName.	(streamReader peek == $[		or: [streamReader peek == $>])		ifFalse: [			self nextSeparators.			streamReader peek == $P				ifTrue: [					publicID := self nextPublicID.					self nextSeparators.					systemID := self nextSystemIDLiteral]				ifFalse: [					streamReader peek == $S						ifTrue: [systemID := self nextSystemID]]].	driver		handleStartDTD: root		publicID: (publicID ifNil: [''])		systemID: (systemID ifNil: ['']).	streamReader skipSeparators.	streamReader peek == $[		ifTrue: [self nextStartInternalSubset]		ifFalse: [self nextEndDoctypeDeclaration].! !!XMLParserTokenizer methodsFor: 'tokenizing - dtd'!nextDoctypeDeclarationTerminator	self expectNext: $>! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextElementName	self subclassResponsibility! !!XMLParserTokenizer methodsFor: 'tokenizing - dtd'!nextEndDoctypeDeclaration	self nextDoctypeDeclarationTerminator.	state := state postDoctypeDeclarationState.	driver handleEndDTD.! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextEndDocument	state isTerminatedState		ifFalse: [			self closeStreams.			state := state terminatedState.			driver handleEndDocument]! !!XMLParserTokenizer methodsFor: 'tokenizing - dtd'!nextEndInternalSubset	"skip ]"	streamReader		next;		skipSeparators.	self nextEndDoctypeDeclaration.! !!XMLParserTokenizer methodsFor: 'tokenizing - dtd'!nextInternalSubsetToken	streamReader skipSeparators.	streamReader peek == $%		ifTrue: [			streamReader next.			^ self nextParameterEntityReference].	streamReader peek == $]		ifTrue: [^ self nextEndInternalSubset].	self nextSubsetMarkupToken.! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextNonElementWhitespace	self subclassResponsibility! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextNonPIPrologOrContentMarkupToken	self subclassResponsibility! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextPCDataToken	self subclassResponsibility! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextPI	"skip ?"	streamReader next.	self nextPIWithTarget: self nextPITarget.! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextPIData	self subclassResponsibility! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextPITarget	"should return a PI target string or nil if it's the start of	an '<?xml ...?>' declaration"	self subclassResponsibility! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextPITerminator	self expectNext: $>! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextPIWithTarget: aTarget	streamReader peek == $?		ifTrue: [			streamReader next.			self nextPITerminator.			driver				handlePI: aTarget				data: '']		ifFalse: [			self nextSeparators.			driver				handlePI: aTarget				data: self nextPIData].! !!XMLParserTokenizer methodsFor: 'tokenizing - dtd'!nextParameterEntityReference	self subclassResponsibility! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextPrologToken	self subclassResponsibility! !!XMLParserTokenizer methodsFor: 'tokenizing - dtd'!nextPublicID	^ self		expectNextAll: 'PUBLIC';		nextSeparators;		nextPublicIDLiteral! !!XMLParserTokenizer methodsFor: 'tokenizing - dtd'!nextPublicIDLiteral	self subclassResponsibility! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextSeparators	self subclassResponsibility! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextStartContent	state := state contentState.	elementNester := driver elementNester.	driver handleStartContent.! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextStartDocument	self state: driver newInitialState.	driver handleStartDocument.! !!XMLParserTokenizer methodsFor: 'tokenizing - dtd'!nextStartInternalSubset	"skip ["	streamReader next.	state := state internalSubsetState.! !!XMLParserTokenizer methodsFor: 'tokenizing - dtd'!nextSubsetMarkupToken	self subclassResponsibility! !!XMLParserTokenizer methodsFor: 'tokenizing - dtd'!nextSystemID	^ self		expectNextAll: 'SYSTEM';		nextSeparators;		nextSystemIDLiteral! !!XMLParserTokenizer methodsFor: 'tokenizing - dtd'!nextSystemIDLiteral	self subclassResponsibility! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextToken	streamReader atEnd		ifTrue: [			state isInitializedState				ifTrue: [^ self nextEndDocument]].	^ state nextTokenFrom: self.! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextXMLAttributeEqualsSeparator	streamReader skipSeparators.	self expectNext: $=.	streamReader skipSeparators.! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextXMLAttributeName: aName	self expectNextAll: aName! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextXMLDeclaration	| version encoding |	self nextSeparators.	version := self nextXMLVersionAttributeRequired: true.	streamReader peek == $?		ifFalse: [self nextSeparators].	(encoding := self nextXMLEncodingAttributeRequired: false) isEmpty		ifFalse: [			self convertFromEncoding: encoding.			streamReader peek == $?				ifFalse: [self nextSeparators]].	driver		handleXMLVersion: version		encoding: encoding		standalone: self nextXMLStandaloneAttribute.	streamReader skipSeparators.	self nextXMLDeclarationTerminator.	state := state prologState.! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextXMLDeclarationOrPrologToken	streamReader peek == $<		ifTrue: [			streamReader next.			streamReader peek == $?				ifTrue: [					streamReader next.					self nextPITarget						ifNil: [^ self nextXMLDeclaration]						ifNotNil: [:target |							state := state prologState.							^ self nextPIWithTarget: target]].			state := state prologState.			^ self nextNonPIPrologOrContentMarkupToken].	"other prolog tokens can have whitespace before them, so the doc	does not need to start with an '<' for them"	state := state prologState.	self nextPrologToken.! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextXMLDeclarationTerminator	self expectNextAll: '?>'! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextXMLEncodingAttributeRequired: aBoolean	(aBoolean		or: [streamReader peek == $e])		ifTrue: [				^ self				nextXMLAttributeName: 'encoding';				nextXMLAttributeEqualsSeparator;				nextXMLEncodingAttributeValue]		ifFalse: [^ '']! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextXMLEncodingAttributeValue	self subclassResponsibility! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextXMLStandaloneAttribute	"always optional"	(streamReader peek == $s)		ifTrue: [			^ self				nextXMLAttributeName: 'standalone';				nextXMLAttributeEqualsSeparator;				nextXMLStandaloneAttributeValue]		ifFalse: [^ '']! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextXMLStandaloneAttributeValue	self subclassResponsibility! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextXMLVersionAttributeRequired: aBoolean	(aBoolean		or: [streamReader peek == $v])		ifTrue: [			^ self				nextXMLAttributeName: 'version';				nextXMLAttributeEqualsSeparator;				nextXMLVersionAttributeValue]		ifFalse: [^ '']! !!XMLParserTokenizer methodsFor: 'tokenizing'!nextXMLVersionAttributeValue	self subclassResponsibility! !!XMLParserTokenizer methodsFor: 'accessing'!normalizedLineEndingChar	^ streamReader normalizedLineEndingChar! !!XMLParserTokenizer methodsFor: 'accessing'!normalizedLineEndingChar: aCharacter	streamReader normalizedLineEndingChar: aCharacter! !!XMLParserTokenizer methodsFor: 'errors'!parseError: aString	driver handleParseError: aString! !!XMLParserTokenizer methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		print: state;		nextPutAll: '; ';		print: streamReader;		nextPut: $).! !!XMLParserTokenizer methodsFor: 'initialization'!setDriver: aDriver stream: aStream readLimit: anInteger	state := XMLUninitializedState new.	driver := aDriver.	streamReader :=		self streamReaderClass			on: aStream			readLimit: anInteger.	"must use #writeStream instead of 'WriteStream on:' to get 0-based	streams on Gemstone"	nameStream := (String new: 16) writeStream.	"this separate stream is needed because XML text delcarations can occur	in the replacement of external general entity references in PCDATA and	external parameter entity references within declarations in the external	subset or external entities, and characterStream would already be in use	in both cases"	xmlDeclarationStream := (String new: 8) writeStream.	characterStream := (String new: 128) writeStream.! !!XMLParserTokenizer methodsFor: 'accessing'!state	^ state! !!XMLParserTokenizer methodsFor: 'accessing'!state: aTokenState	(state := aTokenState) isContentState		ifTrue: [elementNester := driver elementNester].	(driver decodesCharacters		and: [state supportsEncodingDetection])		ifTrue: [streamReader detectEncoding].! !!XMLParserTokenizer methodsFor: 'accessing'!streamReader	^ streamReader! !!XMLParserTokenizer methodsFor: 'defaults'!streamReaderClass	^ XMLNestedStreamReader! !!XMLWellFormedParserTokenizer class methodsFor: 'class initialization'!initialize	"self initialize"	self		initializeNormalizedSpace;		initializePublicIDChars;		initializeEncodingNameStartChars;		initializeEncodingNameChars;		initializeVersionNumChars! !!XMLWellFormedParserTokenizer class methodsFor: 'class initialization'!initializeEncodingNameChars	"EncName ::= [A-Za-z] ([A-Za-z0-9._] | '-')*"	"assign the fully initialized object with #yourself to avoid	possible race conditions when reinitialization the class"	EncodingNameChars :=		BitmapCharacterSet new			addRangeFrom: $a to: $z;			addRangeFrom: $A to: $Z;			addRangeFrom: $0 to: $9;			addAll: '-_.';			yourself! !!XMLWellFormedParserTokenizer class methodsFor: 'class initialization'!initializeEncodingNameStartChars	"Character>>isLetter is not used because it may return true for non-ASCII	letters depending on the locale.		EncName ::= [A-Za-z] ([A-Za-z0-9._] | '-')*"	"assign the fully initialized object with #yourself to avoid	possible race conditions when reinitialization the class"	EncodingNameStartChars :=		BitmapCharacterSet new			addRangeFrom: $a to: $z;			addRangeFrom: $A to: $Z;			yourself! !!XMLWellFormedParserTokenizer class methodsFor: 'class initialization'!initializeNormalizedSpace	"stored in a class var for faster access"	NormalizedSpace := Character space! !!XMLWellFormedParserTokenizer class methodsFor: 'class initialization'!initializePublicIDChars	"PubidChar ::= #x20 | #xD | #xA | [a-zA-Z0-9] | [-'()+,./:=?;!!*#@$_%]"	"assign the fully initialized object with #yourself to avoid	possible race conditions when reinitialization the class"	PublicIDChars :=		BitmapCharacterSet new			add: 16r20 asCharacter;			add: 16rD asCharacter;			add: 16rA asCharacter;			addRangeFrom: $a to: $z;			addRangeFrom: $A to: $Z;			addRangeFrom: $0 to: $9;			addAll: '-''()+,./:=?;!!*#@$_%';			yourself! !!XMLWellFormedParserTokenizer class methodsFor: 'class initialization'!initializeVersionNumChars	"VersionNum ::= '1.' [0-9]+"	"assign the fully initialized object with #yourself to avoid	possible race conditions when reinitialization the class"	VersionNumChars :=		BitmapCharacterSet new			addRangeFrom: $0 to: $9;			add: $.;			yourself! !!XMLWellFormedParserTokenizer methodsFor: 'entity replacing'!addPushedBackEntity: aPushedBackEntity	(self hasPushedBackEntity: aPushedBackEntity)		ifTrue: [self errorSelfReferentialEntity: aPushedBackEntity].	self maxEntityReplacementDepth		ifNotNil: [:maxDepth |			self pushedBackEntities size >= maxDepth				ifTrue: [self errorEntityDepthLimitExceeded]].		self pushedBackEntities addLast: aPushedBackEntity.	driver currentEntity: aPushedBackEntity entity.	aPushedBackEntity isExternal		ifTrue: [driver baseURI: aPushedBackEntity uri].	^ aPushedBackEntity.! !!XMLWellFormedParserTokenizer methodsFor: 'decoding'!characterFromCodePoint: aCodePoint	| character |	"nil understands isXMLChar so it does not need to be tested for"	(character := super characterFromCodePoint: aCodePoint) isXMLChar		ifTrue: [^ character]		ifFalse: [^ nil].! !!XMLWellFormedParserTokenizer methodsFor: 'entity replacing'!constructLiteralReplacementForEntity: anEntity	| wasIgnoringLiteralValueTerminator |	wasIgnoringLiteralValueTerminator := isIgnoringLiteralValueTerminator.	isIgnoringLiteralValueTerminator := true.	self		pushBackEntity: anEntity		whenPoppedDo: [			isIgnoringLiteralValueTerminator := wasIgnoringLiteralValueTerminator].! !!XMLWellFormedParserTokenizer methodsFor: 'entity replacing'!constructReplacementForGeneralEntity: anEntity	isInLiteralValue		ifTrue: [			anEntity isExternal				ifTrue: [self errorLiteralReferenceToExternalGeneralEntity: anEntity].			self constructLiteralReplacementForEntity: anEntity]		ifFalse: [			driver handleStartContentEntityReplacement: anEntity name.			self				pushBackEntity: anEntity				whenPoppedDo: [driver handleEndContentEntityReplacement: anEntity name]]! !!XMLWellFormedParserTokenizer methodsFor: 'entity replacing'!constructReplacementForParameterEntity: anEntity	isInLiteralValue		ifTrue: [self constructLiteralReplacementForEntity: anEntity]		ifFalse: [			"the trailing space"			streamReader pushBackCharacter: NormalizedSpace.			self				pushBackEntity: anEntity				whenPoppedDo: nil.			"the leading space"			streamReader pushBackCharacter: NormalizedSpace]! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorDuplicateAttribute: anAttribute	self		formatParseError: 'Duplicate attribute "{1}" in start tag'		with: anAttribute! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorEntityDepthLimitExceeded	XMLLimitException signal: 		'Cannot further nest entity replacements; ',		'use #maxEntityReplacementDepth: to change or disable'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedAttributeEqualsSeparatorFor: anAttributeType butGot: aCharacter	self		formatParseError:			'Expected {1} attribute name-value "=" separator but got "{2}" instead'		with: anAttributeType		with: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedAttributeName	self errorExpected: 'attribute name'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedAttributeValueEnd: aQuote butGot: aCharacter	aCharacter == $<		ifTrue: [self parseError: 'Attribute value contains illegal "<" character']		ifFalse: [			self				errorExpectedQuote: aQuote				ending: 'attribute value'				butGot: aCharacter]! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedAttributeValueStartButGot: aCharacter	self		errorExpectedQuoteStarting: 'attribute value'		butGot: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedCDataSectionTerminator	self errorExpected: 'end of CDATA section "]]>" terminator'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedCharacterReferenceTerminatorButGot: aCharacter	self		errorExpectedReferenceTerminatorFor: 'character'		butGot: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedCommentStartButGot: aCharacter	self		formatParseError:			'Expected comment starting "<--" sequence but got "<-{1}" instead'		with: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedCommentTerminator	self errorExpected: 'comment "-->" terminator'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedCommentTerminatorButGot: aCharacter	self		formatParseError:			'Comments cannot contain "--" sequences',			(aCharacter				ifNil: ['']				ifNotNil: [', like "--{1}",']),			' and any "--" must be followed by ">" to terminate the comment'		with: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedDeclarationTerminatorButGot: aCharacter	self		errorExpectedMarkupTerminatorFor: 'declaration'		butGot: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedDoctypeDeclarationTerminatorButGot: aCharacter	self		errorExpectedMarkupTerminatorFor: 'doctype declaration'		butGot: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedElementAttributeEqualsSeparatorButGot: aCharacter	self		errorExpectedAttributeEqualsSeparatorFor: 'element'		butGot: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedElementName	self errorExpected: 'element name'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedEncodingName	self errorExpected: 'encoding name in <?xml ...?> encoding attribute'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedEndTag: anExpectedEndTag butGot: aCharacter at: aCharacterPosition	| receivedEndTag |	"try to get the entire unexpected name"	nameStream reset.	1 to: aCharacterPosition - 1 do: [:i |		nameStream nextPut: (anExpectedEndTag at: i)].	"nil understands isXMLNameChar so it is not tested for"	aCharacter isXMLNameChar		ifTrue: [			nameStream nextPut: aCharacter.			[streamReader peek isXMLNameChar]				whileTrue: [nameStream nextPut: streamReader next]].	(receivedEndTag := nameStream contents) size > 0		ifTrue: [			(elementNester hasOpenElement: receivedEndTag)				ifTrue: [self errorUnterminatedElementsInElement: receivedEndTag]				ifFalse: [self errorTerminatingUnstartedElement: receivedEndTag]]		ifFalse: [self errorExpectedElementName].! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedEntityName	self errorExpected: 'entity name'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedEntityReferenceTerminatorButGot: aCharacter	self		errorExpectedReferenceTerminatorFor: 'entity'		butGot: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedEntityValueEnd: aQuote butGot: aCharacter	self		errorExpectedQuote: aQuote		ending: 'entity value'		butGot: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedIncludeSectionTerminatorButGot: aFirstCharacter followedBy: aSecondCharacter	self		formatParseError:			'Expected include section "]]>" terminator ',			'but got "]{1}{2}" instead'		with: aFirstCharacter		with: aSecondCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedIntegerCharacterReference	self errorExpected:		'decimal or hex integer after "&#" character reference start'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedLiteral: aString butGot: aCharacter at: aStringPosition	| receivedString |	receivedString :=		(aString			copyReplaceFrom: aStringPosition			to: aString size			with:				(aCharacter ifNil: ['']) asString,				(streamReader next: aString size - aStringPosition)).	self		errorExpectedLiteral: aString		butGot: receivedString.! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedMarkupTerminatorFor: aDescription butGot: aCharacter	self		formatParseError:			'Expected ">" {1} terminator but got "{2}" instead'		with: aDescription		with: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedNmtoken	self errorExpected: 'an XML Nmtoken name'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedNotationName	self errorExpected: 'notation name'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedPITarget	self errorExpected:		(state isXMLDeclarationState			ifTrue: [				'"xml" to start an <?xml ...?> declaration or a ',				'processing instruction target']			ifFalse: ['processing instruction target'])! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedPITerminatorButGot: aCharacter	self		errorExpectedMarkupTerminatorFor: 'processing instruction'		butGot: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedPublicIDLiteralEnd: aQuote butGot: aCharacter	self		errorExpectedQuote: aQuote		ending: 'public ID literal'		butGot: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedPublicIDLiteralStartButGot: aCharacter	self		errorExpectedQuoteStarting: 'public ID literal'		butGot: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedQuote: aQuote ending: aDescription butGot: aCharacter	self		formatParseError:			'Expected end of {1} ({2}) quoted {3} but got "{4}" instead'		with:			(aQuote == $'				ifTrue: ['single']				ifFalse: ['double'])		with: aQuote		with: aDescription		with: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedQuoteStarting: aDescription butGot: aCharacter	self		formatParseError:			'Expected start of double (") or single ('') ',			'quoted {1} but got "{2}" instead'		with: aDescription		with: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedReferenceTerminatorFor: aDescription butGot: aCharacter	self		formatParseError:			'Expected {1} reference ";" terminator but got "{2}" instead'		with: aDescription		with: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedSeparators	self errorExpected: 'one or more whitespace characters'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedStartMarkupTokenButGot: aCharacter	self		errorExpected: '"<" start of markup'		butGot: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedSubsetDeclaration	self errorExpected:		'DTD subset ELEMENT, ATTLIST, ENTITY, or NOTATION declaration'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedSystemIDLiteralEnd: aQuote butGot: aCharacter	self		errorExpectedQuote: aQuote		ending: 'system ID literal'		butGot: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedSystemIDLiteralStartButGot: aCharacter	self		errorExpectedQuoteStarting: 'system ID literal'		butGot: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedTagTerminatorButGot: aCharacter	self		errorExpectedMarkupTerminatorFor: 'tag'		butGot: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedXMLAttributeEqualsSeparatorButGot: aCharacter	self		errorExpectedAttributeEqualsSeparatorFor: '<?xml ...?>'		butGot: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedXMLDeclarationTerminatorButGot: aFirstCharacter followedBy: aSecondCharacter	self		formatParseError:			'Expected "<?xml ...?>" declaration "?>" terminator ',			'but got "{1}{2}" instead'		with: aFirstCharacter		with: aSecondCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedXMLEncodingValueEnd: aQuote butGot: aCharacter	self		errorExpectedQuote: aQuote		ending: '<?xml ...?> encoding value'		butGot: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedXMLEncodingValueStartButGot: aCharacter	self		errorExpectedQuoteStarting: '<?xml ...?> encoding value'		butGot: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedXMLStandaloneValueEnd: aQuote butGot: aCharacter	self		errorExpectedQuote: aQuote		ending: '<?xml ...?> standalone value'		butGot: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedXMLStandaloneValueStartButGot: aCharacter	self		errorExpectedQuoteStarting: '<?xml ...?> standalone value'		butGot: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedXMLVersionNumberButGot: aString	self		errorExpected:			'<?xml ...?> version number "1.x" (where "x" is one or more digits)'		butGot: aString! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedXMLVersionValueEnd: aQuote butGot: aCharacter	self		errorExpectedQuote: aQuote		ending: '<?xml ...?> version value'		butGot: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorExpectedXMLVersionValueStartButGot: aCharacter	self		errorExpectedQuoteStarting: '<?xml ...?> version value'		butGot: aCharacter! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorImproperGeneralEntityNesting	self parseError:		'Markup tokens must start and end in the same general entity replacement'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorInputTerminatedPrematurely	self parseError: 'Input terminated prematurely'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorInternalDeclarationParameterEntityReference	self parseError: 'Parameter entity reference within internal subset declaration'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorInternalSubsetConditionalSection	self parseError:		'Cannot have <!![INCLUDE[...]> or <!![IGNORE[...]> sections in internal subset'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorInvalidCharacterReferenceCodePoint: aCodePoint	self		formatParseError: 'Invalid character reference to U+{1} code point'		with: aCodePoint printStringHex! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorLiteralReferenceToExternalGeneralEntity: anEntity	self		formatParseError:			'External general entity reference {1} in attribute value'		with: anEntity asReference! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorMultipleDoctypeDeclarations	self parseError: 'Multiple <!!DOCTYPE ...> declarations'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorMultipleDocumentRootElements	self parseError: 'Document cannot have multiple root elements'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorNonChar: aCharacter in: aDescription	self		formatParseError: 'Invalid character U+{1} in {2}'		with: aCharacter asciiValue printStringHex		with: aDescription! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorNonCharInAttributeValue: aCharacter	self		errorNonChar: aCharacter		in: 'attribute value'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorNonCharInCDataSection: aCharacter	self		errorNonChar: aCharacter		in: '<!![CDATA[...]]> section'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorNonCharInComment: aCharacter	self		errorNonChar: aCharacter		in: 'comment'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorNonCharInEntityValue: aCharacter	self		errorNonChar: aCharacter		in: 'entity value'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorNonCharInPCData: aCharacter	self		errorNonChar: aCharacter		in: 'PCDATA'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorNonCharInPIValue: aCharacter	self		errorNonChar: aCharacter		in: 'processing instruction value'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorNonCharInSystemID: aCharacter	self		errorNonChar: aCharacter		in: 'system ID'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorNonElementGeneralEntityOrCharacterReference	self parseError:		'Unexpected "&" starting general entity or character reference after content'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorNonElementPCDataCharacter: aCharacter	aCharacter == $&		ifTrue: [self errorNonElementGeneralEntityOrCharacterReference]		ifFalse: [			self				formatParseError: 'Character data "{1}" outside of element'				with: aCharacter]! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorParameterEntityTerminatingSubset	self parseError:		'Parameter entity replacement cannot terminate internal subset'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorReferenceToUnparsedGeneralEntity: anEntity	self		formatParseError: 'Illegal unparsed general entity reference {1}'		with: anEntity asReference! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorReservedPITarget: aTarget	self		formatParseError: 'Processing instruction target "{1}" is reserved'		with: aTarget! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorSelfReferentialEntity: anEntity	self		formatParseError: 'Illegal self-referential {1} entity'		with: anEntity asReference! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorTerminatingUnstartedElement: anElement	self		formatParseError: 'End tag </{1}> with no corresponding <{1}> start tag'		with: anElement! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorURIFragmentInSystemID	self parseError: 'Illegal "#" URI fragment in system ID'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorUnexpectedCDataTerminator	self parseError: 'Unexpected CDATA "]]>" terminator in PCDATA'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorUnexpectedEndConditionalSection	self parseError: 'Unexpected "]" end of conditional section in external entity'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorUnexpectedEndTag: anElement	self		formatParseError: 'Unexpected end tag </{1}> before any start tag'		with: anElement! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorUnexpectedMarkupDeclarationInContent	self parseError: 'Unexpected "<!!" markup declaration in content'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorUnterminatedElements	self		formatParseError: 'Unterminated elements: {1}'		with: elementNester printedElements! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorUnterminatedElementsInElement: anElement	self		formatParseError: '<{1}> element ended before enclosed element(s) {2}'		with: anElement		with: (elementNester printedElementsEnclosedBy: anElement)! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorUnterminatedIgnoreSections	self parseError: 'Unterminated <!![IGNORE[...]]> section(s) in external entity'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorUnterminatedIncludeSections	self parseError: 'Unterminated <!![INCLUDE[...]]> section(s) in external entity'! !!XMLWellFormedParserTokenizer methodsFor: 'errors'!errorXMLDeclarationNotAtStart	self parseError: 'XML declaration can only occur at the start of a document'! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - expecting'!expectNext: aCharacter	| nextChar |	"use #= for pre-SpurVM compatibility where wide chars aren't #=="	(nextChar := streamReader next) = aCharacter		ifFalse: [			self				errorExpectedLiteral: aCharacter				butGot: nextChar].	^ nextChar.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - expecting'!expectNextAll: aString	"uses to:do: and not implemented in terms of #expectNextAll:startingAt:	for speed"	1 to: aString size do: [:i | | nextChar |		"use #= for pre-SpurVM compatibility where wide chars aren't #=="		(nextChar := streamReader next) = (aString at: i)			ifFalse: [				self					errorExpectedLiteral: aString					butGot: nextChar					at: i]].	^ aString.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - expecting'!expectNextAll: aString startingAt: aPosition	"to:do: for speed"	aPosition to: aString size do: [:i | | nextChar |		"use #= for pre-SpurVM compatibility where wide chars aren't #=="		(nextChar := streamReader next) = (aString at: i)			ifFalse: [				self					errorExpectedLiteral: aString					butGot: nextChar					at: i]].	^ aString.! !!XMLWellFormedParserTokenizer methodsFor: 'testing'!hasOpenIncludeSections	totalOpenIncludeSections == nil		ifTrue: [^ false].	^ totalOpenIncludeSections > 0.! !!XMLWellFormedParserTokenizer methodsFor: 'testing'!hasPushedBackEntities	pushedBackEntities == nil		ifTrue: [^ false].	^ pushedBackEntities size > 0.! !!XMLWellFormedParserTokenizer methodsFor: 'testing'!hasPushedBackEntity: aPushedBackEntity	self hasPushedBackEntities		ifFalse: [^ false].	self pushedBackEntities do: [:each |		each entity = aPushedBackEntity entity			ifTrue: [^ true]].	^ false.! !!XMLWellFormedParserTokenizer methodsFor: 'testing'!isInExternalSubsetOrExternalEntity	"This is used to check for conditional sections and parameter entity	refs within declarations in the internal subset, which is disallowed.		The way the spec is written and the way Xerces behaves, internal	entities defined in external entities DO NOT count as 'external'	for this purpose, even though they were defined externally to	the document."	^ state isExternalSubsetState		or: [self topPushedBackExternalEntity notNil]! !!XMLWellFormedParserTokenizer methodsFor: 'accessing'!maxEntityReplacementDepth	^ driver maxEntityReplacementDepth! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextAttlistDeclaration	| element defaultPragma |	self		expectNextAll: 'ATTLIST';		nextSeparatorsInDeclaration.	element := self nextElementName.	[streamReader peek == $>		or: [			self nextSeparatorsInDeclaration.			streamReader peek == $>]]		whileFalse: [			driver				handleAttributeDeclaration: element				name: self nextAttributeName				type: self nextAttributeType				defaultPragma:					(defaultPragma := self nextAttributeDefaultPragma)				defaultValue:					(self nextAttributeDefaultValueForPragma: defaultPragma)].	self nextDeclarationTerminator.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextAttributeDefaultPragma	self nextSeparatorsInDeclaration.	streamReader peek == $#		ifFalse: [^ ''].	streamReader next.	streamReader peek == $R		ifTrue: [^ self expectNextAll: 'REQUIRED'].	streamReader peek == $I		ifTrue: [^ self expectNextAll: 'IMPLIED'].	^ self expectNextAll: 'FIXED'.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextAttributeDefaultValueForPragma: aPragma	| previousState attributeValue |	aPragma isEmpty		ifFalse: [			(aPragma first == $F) "FIXED"				ifFalse: [^ ''].			self nextSeparatorsInDeclaration].	previousState := state.	state := state contentState.	attributeValue := self nextAttributeValue.	state := previousState.	^ attributeValue.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextAttributeEntityType	self expectNextAll: 'ENTIT'.	streamReader peek == $Y		ifFalse: [			^ self				expectNextAll: 'ENTITIES'				startingAt: 6 "'ENTIT' size + 1"].	streamReader next.	^ 'ENTITY'.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextAttributeEnumerationType	characterStream		reset;		nextPut: (self expectNext: $().	"must have at least one value in the enumeration"	self		skipSeparatorsInDeclaration;		nextNmtokenOnCharacterStream.	[self skipSeparatorsInDeclaration.		streamReader peek == $)]		whileFalse: [			characterStream nextPut: (self expectNext: $|).			self				skipSeparatorsInDeclaration;				nextNmtokenOnCharacterStream].	^ characterStream		nextPut: streamReader next;		contents.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextAttributeIDOrIDRefType	self expectNextAll: 'ID'.	streamReader peek == $R		ifFalse: [^ 'ID'].		self		expectNextAll: 'IDREF'		startingAt: 3.	streamReader peek == $S		ifFalse: [^ 'IDREF'].	streamReader next.	^ 'IDREFS'.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextAttributeName	| nextChar |	"nil understands #isXMLNameStartChar so it does not need to be tested for"	(nextChar := streamReader next) isXMLNameStartChar		ifFalse: [self errorExpectedAttributeName].	nameStream		reset;		nextPut: nextChar.	"nil understands #isXMLNameChar so it does not need to be tested for"	[streamReader peek isXMLNameChar]		whileTrue: [nameStream nextPut: streamReader next].	^ nameStream contents.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextAttributeNotationEnumerationOrNmtokenType	"skip the N"	streamReader next.	streamReader peek == $O		ifTrue: [^ self nextAttributeNotationEnumerationType].	self		expectNextAll: 'NMTOKEN'		startingAt: 2.	streamReader peek == $S		ifFalse: [^ 'NMTOKEN'].	streamReader next.	^ 'NMTOKENS'.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextAttributeNotationEnumerationType	characterStream		reset;		nextPutAll:			(self				expectNextAll: 'NOTATION'				startingAt: 2). "the 'N' was already read"	self		nextSeparatorsInDeclaration;		expectNext: $(.	characterStream nextPutAll: ' ('.	"must have at least one declaration name in the enumeration"	self		skipSeparatorsInDeclaration;		nextNotationNameOnCharacterStream.	[self skipSeparatorsInDeclaration.		streamReader peek == $)]		whileFalse: [			characterStream nextPut: (self expectNext: $|).			self				skipSeparatorsInDeclaration;				nextNotationNameOnCharacterStream].		^ characterStream		nextPut: streamReader next;		contents.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextAttributeType	| nextChar |	self nextSeparatorsInDeclaration.	(nextChar := streamReader peek) == $C		ifTrue: [^ self expectNextAll: 'CDATA'].	nextChar == $I		ifTrue: [^ self nextAttributeIDOrIDRefType].	nextChar == $E		ifTrue: [^ self nextAttributeEntityType].	nextChar == $N		ifTrue: [^ self nextAttributeNotationEnumerationOrNmtokenType].	^ self nextAttributeEnumerationType.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextAttributeValue	| quote nextChar |	((quote := streamReader next) == $"		or: [quote == $'])		ifFalse: [self errorExpectedAttributeValueStartButGot: quote].		isInLiteralValue := true.	characterStream reset.	[((nextChar := streamReader next) == quote		and: [isIgnoringLiteralValueTerminator not])			or: [nextChar == $<				or: [nextChar == nil]]]		whileFalse: [			nextChar == $&				ifTrue: [					"char refs should be ignored by whitespace normalization"					self nextGeneralEntityOrCharacterReferenceOnCharacterStream]				ifFalse: [					nextChar isXMLSeparator						ifTrue: [nextChar := NormalizedSpace]						ifFalse: [							nextChar isXMLChar								ifFalse: [self errorNonCharInAttributeValue: nextChar]].					characterStream nextPut: nextChar]].	isInLiteralValue := false.	nextChar == quote		ifFalse: [			self				errorExpectedAttributeValueEnd: quote				butGot: nextChar].	^ characterStream contents.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextCDataSection	| closingBracketsRead nextChar |	self expectNextAll: '[CDATA['.	characterStream reset.	closingBracketsRead := 0.	[(nextChar := streamReader next) == nil		or: [closingBracketsRead == 2			and: [nextChar == $>]]]		whileFalse: [			nextChar == $]				ifTrue: [					closingBracketsRead == 2						ifTrue: [characterStream nextPut: $]]						ifFalse: [closingBracketsRead := closingBracketsRead + 1]]				ifFalse: [					closingBracketsRead == 0						ifFalse: [							characterStream nextPut: $].							closingBracketsRead == 2								ifTrue: [characterStream nextPut: $]].							closingBracketsRead := 0].					nextChar isXMLChar						ifFalse: [self errorNonCharInCDataSection: nextChar].					characterStream nextPut: nextChar]].	nextChar		ifNil: [self errorExpectedCDataSectionTerminator].	driver handleCData: characterStream contents.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextCharacterReferenceOnCharacterStream	"returns the character written to 'characterStream' or $& if	it wasn't replaced"	| codePoint |	"skip #"	streamReader next.	(state isContentState		and: [driver replacesContentEntityReferences not])		ifTrue: [			nameStream reset.			(codePoint := self nextCharacterValueLiteralPrintedOn: nameStream)				ifNil: [self errorExpectedIntegerCharacterReference].			(self characterFromCodePoint: codePoint)				ifNil: [self errorInvalidCharacterReferenceCodePoint: codePoint].			self nextCharacterReferenceTerminator.			characterStream				nextPutAll: '&#';				nextPutAll: nameStream contents;				nextPut: $;.			^ $&]		ifFalse: [| character |			(codePoint := self nextCharacterValueLiteral)				ifNil: [self errorExpectedIntegerCharacterReference].			(character := self characterFromCodePoint: codePoint)				ifNil: [self errorInvalidCharacterReferenceCodePoint: codePoint].			self nextCharacterReferenceTerminator.			characterStream nextPut: character.			^ character].! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextCharacterReferenceTerminator	| nextChar |	(nextChar := streamReader next) == $;		ifFalse: [self errorExpectedCharacterReferenceTerminatorButGot: nextChar]! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextComment	| nextChar |	"Skip first -"	streamReader next.	(nextChar := streamReader next) == $-		ifFalse: [self errorExpectedCommentStartButGot: nextChar].	"xml comments can't have '--' in them; any '--' must be followed	by the terminating '>'"	characterStream reset.	[(nextChar := streamReader next) == nil		or: [nextChar == $-			and: [streamReader peek == $-]]]		whileFalse: [			nextChar isXMLChar				ifFalse: [self errorNonCharInComment: nextChar].			characterStream nextPut: nextChar].	nextChar		ifNil: [self errorExpectedCommentTerminator]		ifNotNil: [			streamReader next. "skip second $-"			(nextChar := streamReader next) == $>				ifFalse: [self errorExpectedCommentTerminatorButGot: nextChar]].	driver handleComment: characterStream contents.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextConditionalSectionFromEntity: aPushedBackParameterEntity	"skip ["	streamReader next.	self		skipSeparatorsInDeclaration;		expectNext: $I.	streamReader peek == $N		ifTrue: [self nextStartIncludeSectionFromEntity: aPushedBackParameterEntity]		ifFalse: [self nextIgnoreSectionFromEntity: aPushedBackParameterEntity].! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextContentMarkupToken	self topPushedBackEntity		ifNil: [			streamReader peek == $?				ifTrue: [^ self nextPI].			streamReader peek == $!!				ifTrue: [					streamReader next.					streamReader peek == $-						ifTrue: [^ self nextComment].					elementNester isInElement						ifTrue: [^ self nextCDataSection].					self errorUnexpectedMarkupDeclarationInContent].			self nextTag]		ifNotNil: [:pushedBackGeneralEntity |			self nextContentMarkupTokenFromEntity: pushedBackGeneralEntity]! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextContentMarkupTokenFromEntity: aPushedBackGeneralEntity	streamReader peek == $?		ifTrue: [self nextPI]		ifFalse: [			streamReader peek == $!!				ifTrue: [					streamReader next.					streamReader peek == $-						ifTrue: [self nextComment]						ifFalse: [							elementNester isInElement								ifTrue: [self nextCDataSection]								ifFalse: [									self errorUnexpectedMarkupDeclarationInContent]]]				ifFalse: [| oldTotalOpenElements newTotalOpenElements |					oldTotalOpenElements := elementNester totalOpenElements.					self nextTag.					newTotalOpenElements := elementNester totalOpenElements.					newTotalOpenElements < oldTotalOpenElements						ifTrue: [							aPushedBackGeneralEntity endElement.							aPushedBackGeneralEntity totalOpenElements >= 0								ifFalse: [self errorImproperGeneralEntityNesting]]						ifFalse: [							newTotalOpenElements > oldTotalOpenElements								ifTrue: [aPushedBackGeneralEntity startElement]]]].	self topPushedBackEntity == aPushedBackGeneralEntity		ifFalse: [self errorImproperGeneralEntityNesting].! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextContentModel	| pushedBackParameterEntity |	self nextSeparatorsInDeclaration.	streamReader peek == $A		ifTrue: [^ self expectNextAll: 'ANY'].	streamReader peek == $E		ifTrue: [^ self expectNextAll: 'EMPTY'].		characterStream		reset;		nextPut: (self expectNext: $().	pushedBackParameterEntity := self topPushedBackEntity.	self skipSeparatorsInDeclaration.	streamReader peek == $#		ifTrue: [			self nextMixedContentListOnCharacterStreamFromEntity:				pushedBackParameterEntity]		ifFalse: [			self nextContentModelChoiceOrSequenceOnCharacterStreamFromEntity:				pushedBackParameterEntity].	^ characterStream contents.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextContentModelChoiceOrSequenceOnCharacterStreamFromEntity: aPushedBackParameterEntity	self		nextContentModelParticleOnCharacterStream;		skipSeparatorsInDeclaration.	streamReader peek == $|		ifTrue: [			characterStream nextPut: streamReader next.			self nextContentModelParticleOnCharacterStream.			[self skipSeparatorsInDeclaration.				streamReader peek == $)]				whileFalse: [					characterStream nextPut: (self expectNext: $|).					self nextContentModelParticleOnCharacterStream].			characterStream nextPut: streamReader next]		ifFalse: [			streamReader peek == $,				ifTrue: [					characterStream nextPut: streamReader next.					self nextContentModelParticleOnCharacterStream.					[self skipSeparatorsInDeclaration.						streamReader peek == $)]						whileFalse: [							characterStream nextPut: (self expectNext: $,).							self nextContentModelParticleOnCharacterStream].					characterStream nextPut: streamReader next]				ifFalse: [characterStream nextPut: (self expectNext: $))]].	self topPushedBackEntity == aPushedBackParameterEntity		ifFalse: [driver handleImproperParameterEntityNesting].	self nextContentModelUnaryOperatorOnCharacterStream.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextContentModelParticleOnCharacterStream	self skipSeparatorsInDeclaration.	streamReader peek == $(		ifTrue: [			characterStream nextPut: streamReader next.			self nextContentModelChoiceOrSequenceOnCharacterStreamFromEntity:				self topPushedBackEntity]		ifFalse: [			self				nextElementNameOnCharacterStream;				nextContentModelUnaryOperatorOnCharacterStream]! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextContentModelUnaryOperatorOnCharacterStream	| nextChar |	((nextChar := streamReader peek) == $?		or: [nextChar == $*			or: [nextChar == $+]])		ifTrue: [characterStream nextPut: streamReader next]! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextDeclarationTerminator	| nextChar |	(nextChar := streamReader next) == $>		ifFalse: [self errorExpectedDeclarationTerminatorButGot: nextChar]! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextDoctypeDeclarationOrComment	"skip !!"	streamReader next.	streamReader peek == $-		ifTrue: [^ self nextComment].	state isPostDoctypeDeclarationState		ifTrue: [self errorMultipleDoctypeDeclarations].	self nextDoctypeDeclaration.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextDoctypeDeclarationTerminator	| nextChar |	(nextChar := streamReader next) == $>		ifFalse: [self errorExpectedDoctypeDeclarationTerminatorButGot: nextChar]! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextElementDeclaration	self		expectNextAll: 'ELEMENT'		startingAt: 2. "the 'E' was already read"	self nextSeparatorsInDeclaration.	driver		handleElementDeclaration: self nextElementName		contentModel: self nextContentModel.	self		skipSeparatorsInDeclaration;		nextDeclarationTerminator.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextElementName	| nextChar |	"nil understands #isXMLNameStartChar so it does not need to be tested for"	(nextChar := streamReader next) isXMLNameStartChar		ifFalse: [self errorExpectedElementName].	nameStream		reset;		nextPut: nextChar.	"nil understands #isXMLNameChar so it does not need to be tested for"	[streamReader peek isXMLNameChar]		whileTrue: [nameStream nextPut: streamReader next].	^ nameStream contents.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextElementNameOnCharacterStream	| nextChar |	"nil understands #isXMLNameStartChar so it does not need to be tested for"	(nextChar := streamReader next) isXMLNameStartChar		ifFalse: [self errorExpectedElementName].	characterStream nextPut: nextChar.	"nil understands #isXMLNameChar so it does not need to be tested for"	[streamReader peek isXMLNameChar]		whileTrue: [characterStream nextPut: streamReader next].! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextEndDocument	state canTerminateInput		ifFalse: [self errorInputTerminatedPrematurely].	state isContentState		ifTrue: [			elementNester hasOpenElements				ifTrue: [self errorUnterminatedElements]]		ifFalse: [			self hasOpenIncludeSections				ifTrue: [self errorUnterminatedIncludeSections]].	super nextEndDocument.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextEndIncludeSection	| secondChar thirdChar |	"skip ]"	streamReader next.	secondChar := streamReader next.	thirdChar := streamReader next. 	(secondChar == $]		and: [thirdChar == $>])		ifFalse: [			self				errorExpectedIncludeSectionTerminatorButGot: secondChar				followedBy: thirdChar].	totalOpenIncludeSections := self totalOpenIncludeSections - 1.	self topPushedBackEntity		ifNotNil: [:pushedBackParameterEntity |			pushedBackParameterEntity endIncludeSection.			pushedBackParameterEntity totalOpenIncludeSections >= 0				ifFalse: [driver handleImproperParameterEntityNesting]].! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextEndInternalSubset	self hasOpenIncludeSections		ifTrue: [^ self nextEndIncludeSection].	"skip ]"	streamReader next.	self hasPushedBackEntities		ifTrue: [self errorParameterEntityTerminatingSubset].	streamReader skipSeparators.	self nextEndDoctypeDeclaration.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextEndTag	| tagName nextChar |	"Skip /"	streamReader next.	(tagName := elementNester currentElement)		ifNil: [self errorUnexpectedEndTag: self nextElementName].	1 to: tagName size do: [:i |		"can't use #== here because wide chars aren't an immediate type		in pre-Spur VMs"		(nextChar := streamReader next) = (tagName at: i)			ifFalse: [				self					errorExpectedEndTag: tagName					butGot: nextChar					at: i]].	elementNester endCurrentElement.	driver handleEndTag: tagName.	streamReader skipSeparators.	(nextChar := streamReader next) == $>		ifFalse: [self errorExpectedTagTerminatorButGot: nextChar].! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextEntityDeclaration	| isParameterEntity name |	self		expectNextAll: 'ENTITY'		startingAt: 2. "the 'E' was already read"	self isInExternalSubsetOrExternalEntity		ifTrue: [			"this is to distinguish a parameter reference from declaration"			[isParameterEntity isNil]				whileTrue: [					streamReader skipSeparators.					streamReader peek == $%						ifTrue: [							streamReader next.							"nil understands isXMLSeparator so no nil test is needed"							streamReader peek isXMLSeparator								ifTrue: [									isParameterEntity := true.									self nextSeparatorsInDeclaration]								ifFalse: [self nextParameterEntityReference]]						ifFalse: [isParameterEntity := false]]]		ifFalse: [			self nextSeparators.			(isParameterEntity := (streamReader peek == $%))				ifTrue: [					streamReader next.					self nextSeparators]].	name := self nextEntityName.	self nextSeparatorsInDeclaration.	streamReader atQuote		ifTrue: [			self				nextInternalEntityDeclaration: name				isParameterEntity: isParameterEntity]		ifFalse: [			self				nextExternalEntityDeclaration: name				isParameterEntity: isParameterEntity].! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextEntityName	| nextChar |	"nil understands #isXMLNameStartChar so it does not need to be tested for"	(nextChar := streamReader next) isXMLNameStartChar		ifFalse: [self errorExpectedEntityName].	nameStream		reset;		nextPut: nextChar.	"nil understands #isXMLNameChar so it does not need to be tested for"	[streamReader peek isXMLNameChar]		whileTrue: [nameStream nextPut: streamReader next].	^ nameStream contents.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextEntityNameOnCharacterStream	| nextChar |	"nil understands #isXMLNameStartChar so it does not need to be tested for"	(nextChar := streamReader next) isXMLNameStartChar		ifFalse: [self errorExpectedEntityName].	characterStream nextPut: nextChar.	"nil understands #isXMLNameChar so it does not need to be tested for"	[streamReader peek isXMLNameChar]		whileTrue: [characterStream nextPut: streamReader next].! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextEntityReferenceTerminator	| nextChar |	(nextChar := streamReader next) == $;		ifFalse: [self errorExpectedEntityReferenceTerminatorButGot: nextChar]! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextEntityValue	| quote nextChar |	quote := streamReader next.	isInLiteralValue := true.	characterStream reset.	[((nextChar := streamReader next) == quote		and: [isIgnoringLiteralValueTerminator not])			or: [nextChar == nil]]		whileFalse: [			nextChar == $&				ifTrue: [					streamReader peek == $#						ifTrue: [							"character refs are replaced in entity values"							self nextCharacterReferenceOnCharacterStream]						ifFalse: [							"general entity refs aren't replaced but must be complete"							characterStream nextPut: $&.							self								nextEntityNameOnCharacterStream;								nextEntityReferenceTerminator.							characterStream nextPut: $;]]				ifFalse: [					nextChar == $%						ifTrue: [							self isInExternalSubsetOrExternalEntity								ifFalse: [									self										errorInternalDeclarationParameterEntityReference].							self nextParameterEntityReferenceOnCharacterStream]						ifFalse: [							nextChar isXMLChar								ifFalse: [self errorNonCharInEntityValue: nextChar].							characterStream nextPut: nextChar]]].	isInLiteralValue := false.	nextChar == quote		ifFalse: [			self				errorExpectedEntityValueEnd: quote				butGot: nextChar].	^ characterStream contents.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextExternalEntityDeclaration: aName isParameterEntity: aBoolean	| publicID systemID notation |	streamReader peek == $P		ifTrue: [			publicID := self nextPublicIDInDeclaration.			self nextSeparatorsInDeclaration.			systemID := self nextSystemIDLiteralWithoutURIFragment]		ifFalse: [			publicID := ''.			systemID := self nextSystemIDInDeclarationWithoutURIFragment].	aBoolean		ifTrue: [			self				skipSeparatorsInDeclaration;				nextDeclarationTerminator.			driver				handleParameterEntityDeclaration: aName				publicID: publicID				systemID: systemID]		ifFalse: [			(streamReader peek == $>				or: [					self nextSeparatorsInDeclaration.					streamReader peek == $>])				ifTrue: [						streamReader next.					notation := '']				ifFalse: [					self						expectNextAll: 'NDATA';						nextSeparatorsInDeclaration.					notation := self nextNotationName.					self						skipSeparatorsInDeclaration;						nextDeclarationTerminator].			driver				handleGeneralEntityDeclaration: aName				publicID: publicID				systemID: systemID				ndata: notation].! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextExternalSubsetToken	streamReader skipSeparators.	streamReader atEnd		ifTrue: [^ self].	streamReader peek == $%		ifTrue: [			streamReader next.			^ self nextParameterEntityReference].	streamReader peek == $]		ifTrue: [			self hasOpenIncludeSections				ifFalse: [self errorUnexpectedEndConditionalSection].			^ self nextEndIncludeSection].	self nextSubsetMarkupToken.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextGeneralEntityOrCharacterReferenceOnCharacterStream	"returns the character written to 'characterStream' if any, nil otherwise"	| pushedBackGeneralEntity result |	pushedBackGeneralEntity := self topPushedBackEntity.	result :=		streamReader peek == $#			ifTrue: [self nextCharacterReferenceOnCharacterStream]			ifFalse: [self nextGeneralEntityReferenceOnCharacterStream].	pushedBackGeneralEntity		ifNotNil: [			(self pushedBackEntities includes: pushedBackGeneralEntity)				ifFalse: [self errorImproperGeneralEntityNesting]].	^ result.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextGeneralEntityReferenceOnCharacterStream	"returns the (first) character written to 'characterStream' if any,	nil otherwise"	| name |	name := self nextEntityName.	self nextEntityReferenceTerminator.	PredefinedEntities		at: name		ifPresent: [:character |			driver replacesContentEntityReferences				ifFalse: [					^ self nextUnreplacedGeneralEntityOnCharacterStreamNamed: name].			characterStream nextPut: character.			^ character].	(driver handleGeneralEntityReference: name)		ifNil: [			(driver replacesContentEntityReferences not				or: [driver preservesUndeclaredEntityReferences])				ifTrue: [					^ self nextUnreplacedGeneralEntityOnCharacterStreamNamed: name].			driver handleUnreplacedGeneralEntityReference: name]		ifNotNil: [:entity |			entity isUnparsed				ifTrue: [self errorReferenceToUnparsedGeneralEntity: entity].			driver replacesContentEntityReferences				ifFalse: [					^ self nextUnreplacedGeneralEntityOnCharacterStreamNamed: name].			self constructReplacementForGeneralEntity: entity].	^ nil.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextIgnoreSectionFromEntity: aPushedBackParameterEntity	| openSections firstChar secondChar nextChar |	self		expectNextAll: 'IGNORE'		startingAt: 2. "the 'I' was already read"	streamReader skipSeparators.	self expectNext: $[.	"the 'IGNORE' can be in the replacement of an entity, like	in '<!![%entity[...]]>', but after it the entity that started	the declaration must be current"	self topPushedBackEntity == aPushedBackParameterEntity		ifFalse: [driver handleImproperParameterEntityNesting].	"From the spec:	The contents of an ignored conditional section MUST be parsed by	ignoring all characters after the '[' following the keyword, except	conditional section starts '<!![' and ends ']]>', until the matching	conditional section end is found. Parameter entity references MUST	NOT be recognized in this process."	openSections := 1.	[openSections == 0		or: [(nextChar := streamReader next) == nil]]		whileFalse: [			nextChar == $>				ifTrue: [					(secondChar == $]						and: [firstChar == $]])						ifTrue: [openSections := openSections - 1]]				ifFalse: [					nextChar == $[						ifTrue: [							(secondChar == $!!								and: [firstChar == $<])								ifTrue: [openSections := openSections + 1]]].			firstChar := secondChar.			secondChar := nextChar].	openSections == 0		ifFalse: [self errorUnterminatedIgnoreSections].! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextInternalEntityDeclaration: aName isParameterEntity: aBoolean	| value |	value := self nextEntityValue.	self		skipSeparatorsInDeclaration;		nextDeclarationTerminator.	aBoolean		ifTrue: [			driver				handleParameterEntityDeclaration: aName				replacement: value]		ifFalse: [			driver				handleGeneralEntityDeclaration: aName				replacement: value].! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextMixedContentListOnCharacterStreamFromEntity: aPushedBackParameterEntity	| hasElements |	hasElements := false.	characterStream nextPutAll: (self expectNextAll: '#PCDATA').	[self skipSeparatorsInDeclaration.		streamReader peek == $)]		whileFalse: [			characterStream nextPut: (self expectNext: $|).			hasElements := true.			self				skipSeparatorsInDeclaration;				nextElementNameOnCharacterStream].	characterStream nextPut: streamReader next.	self topPushedBackEntity == aPushedBackParameterEntity		ifFalse: [driver handleImproperParameterEntityNesting].	streamReader peek == $*		ifTrue: [characterStream nextPut: streamReader next]		ifFalse: [			hasElements				ifTrue: [self errorExpectedLiteral: $*]].! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextNmtokenOnCharacterStream	"matches the Nmtoken production"	| nextChar |	"nil understands #isXMLNameChar so it does not need to be tested for"	(nextChar := streamReader next) isXMLNameChar		ifFalse: [self errorExpectedNmtoken].	characterStream nextPut: nextChar.	"nil understands #isXMLNameChar so it does not need to be tested for"	[streamReader peek isXMLNameChar]		whileTrue: [characterStream nextPut: streamReader next].! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextNonElementWhitespace	| nextChar |	"nil understands isXMLSeparator so it is not tested for first"	[(nextChar := streamReader peek) isXMLSeparator]		whileTrue: [streamReader next].	(nextChar == $<		or: [nextChar == nil])		ifFalse: [self errorNonElementPCDataCharacter: streamReader next].! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextNonPIPrologOrContentMarkupToken	streamReader peek == $!!		ifTrue: [^ self nextDoctypeDeclarationOrComment].	self		nextStartContent;		nextTag.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextNotationDeclaration	| name publicID systemID |	self		expectNextAll: 'NOTATION';		nextSeparatorsInDeclaration.	name := self nextNotationName.	self nextSeparatorsInDeclaration.	streamReader peek == $P		ifTrue: [			publicID := self nextPublicIDInDeclaration.			(streamReader peek == $>				or: [					self nextSeparatorsInDeclaration.					streamReader peek == $>])				ifFalse: [systemID := self nextSystemIDLiteral]]		ifFalse: [systemID := self nextSystemIDInDeclaration].	self		skipSeparatorsInDeclaration;		nextDeclarationTerminator.	driver		handleNotationDeclaration: name		publicID: (publicID ifNil: [''])		systemID: (systemID ifNil: ['']).! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextNotationName	| nextChar |	"nil understands #isXMLNameStartChar so it does not need to be tested for"	(nextChar := streamReader next) isXMLNameStartChar		ifFalse: [self errorExpectedNotationName].	nameStream		reset;		nextPut: nextChar.	"nil understands #isXMLNameChar so it does not need to be tested for"	[streamReader peek isXMLNameChar]		whileTrue: [nameStream nextPut: streamReader next].	^ nameStream contents.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextNotationNameOnCharacterStream	| nextChar |	"nil understands #isXMLNameStartChar so it does not need to be tested for"	(nextChar := streamReader next) isXMLNameStartChar		ifFalse: [self errorExpectedNotationName].	characterStream nextPut: nextChar.	"nil understands #isXMLNameChar so it does not need to be tested for"	[streamReader peek isXMLNameChar]		whileTrue: [characterStream nextPut: streamReader next].! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextPCDataToken	| isWhitespace nextChar closingBracketsRead |	isWhitespace := true.	characterStream reset.	closingBracketsRead := 0.	[(nextChar := streamReader peek) == $<		or: [nextChar == nil]]		whileFalse: [			streamReader next == $&				ifTrue: [					self nextGeneralEntityOrCharacterReferenceOnCharacterStream						ifNotNil: [:writtenChar |							isWhitespace								ifTrue: [isWhitespace := writtenChar isXMLSeparator]]]				ifFalse: [					(isWhitespace						and: [isWhitespace := nextChar isXMLSeparator])						ifFalse: [							nextChar == $]								ifTrue: [									isWhitespace := false.									closingBracketsRead := closingBracketsRead + 1]								ifFalse: [									closingBracketsRead == 0										ifFalse: [											(closingBracketsRead >= 2												and: [nextChar == $>])												ifTrue: [													self errorUnexpectedCDataTerminator].											closingBracketsRead := 0].									nextChar isXMLChar										ifFalse: [self errorNonCharInPCData: nextChar]]].					characterStream nextPut: nextChar]].	isWhitespace		ifTrue: [			characterStream position == 0				ifFalse: [driver handleWhitespace: characterStream contents]]		ifFalse: [driver handlePCData: characterStream contents].! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextPIData	| nextChar |	characterStream reset.	[(nextChar := streamReader next) == nil		or: [nextChar == $?			and: [streamReader peek == $>]]]		whileFalse: [			nextChar isXMLChar				ifFalse: [self errorNonCharInPIValue: nextChar].			characterStream nextPut: nextChar].	self nextPITerminator.	^ characterStream contents.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextPITarget	"PITarget	   ::=   	Name - (('X' | 'x') ('M' | 'm') ('L' | 'l'))"	| nextChar isReservedTarget isLowercaseReservedTarget length |	nameStream reset.	(nextChar := streamReader next) == $x		ifTrue: [			isReservedTarget := true.			isLowercaseReservedTarget := true]		ifFalse:[			nextChar == $X				ifTrue: [isReservedTarget := true]				ifFalse: [					"nil understands #isXMLNameStartChar so it does					not need to be tested for"					nextChar isXMLNameStartChar						ifFalse: [self errorExpectedPITarget].					isReservedTarget := false].			isLowercaseReservedTarget := false].	nameStream nextPut: nextChar.	length := 1.	"nil understands #isXMLNameChar so it does not need to be tested for"	[streamReader peek isXMLNameChar]		whileTrue: [			nextChar := streamReader next.			length := length + 1.			isReservedTarget				ifTrue: [					(length <= 3						and: [							nextChar == ('xml' at: length)								or: [									isLowercaseReservedTarget := false.									nextChar == ('XML' at: length)]])						ifFalse: [							isReservedTarget := false.							isLowercaseReservedTarget := false]].			nameStream nextPut: nextChar].		(isReservedTarget		and: [length = 3])		ifTrue: [			isLowercaseReservedTarget				ifTrue: [					state isXMLDeclarationState						ifFalse: [self errorXMLDeclarationNotAtStart].					"return nil to indicate it's an XML declaration, not a PI"					^ nil].			"a reserved target other than lowercase 'xml' for XML declarations			is never allowed"			self errorReservedPITarget: nameStream contents].	^ nameStream contents.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextPITerminator	| nextChar |	(nextChar := streamReader next) == $>		ifFalse: [self errorExpectedPITerminatorButGot: nextChar]! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextParameterEntityReference	| pushedBackParameterEntity name |	pushedBackParameterEntity := self topPushedBackEntity.	name := self nextEntityName.	self nextEntityReferenceTerminator.	self topPushedBackEntity == pushedBackParameterEntity		ifFalse: [driver handleImproperParameterEntityNesting].	(driver handleParameterEntityReference: name)		ifNotNil: [:entity | self constructReplacementForParameterEntity: entity].! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextParameterEntityReferenceInDeclaration	self isInExternalSubsetOrExternalEntity		ifFalse: [self errorInternalDeclarationParameterEntityReference].	self nextParameterEntityReference.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextParameterEntityReferenceOnCharacterStream	| pushedBackParameterEntity name |	pushedBackParameterEntity := self topPushedBackEntity.	name := self nextEntityName.	self nextEntityReferenceTerminator.	self topPushedBackEntity == pushedBackParameterEntity		ifFalse: [driver handleImproperParameterEntityNesting].		(driver handleParameterEntityReference: name)		ifNil: [			driver preservesUndeclaredEntityReferences				ifTrue: [					characterStream						nextPut: $%;						nextPutAll: name;						nextPut: $;.					^ $%]]		ifNotNil: [:entity |			self constructReplacementForParameterEntity: entity].	^ nil.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextPrologToken	streamReader skipSeparators.	self nextStartMarkupToken.	streamReader peek == $?		ifTrue: [^ self nextPI].	self nextNonPIPrologOrContentMarkupToken.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextPublicIDInDeclaration	^ self		expectNextAll: 'PUBLIC';		nextSeparatorsInDeclaration;		nextPublicIDLiteral! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextPublicIDLiteral	"this returns the pubid with leading and trailing whitespace removed	and all other whitespace sequences converted to single spaces"	| quote isInWhitespace nextChar |	((quote := streamReader next) == $"		or: [quote == $'])		ifFalse: [self errorExpectedPublicIDLiteralStartButGot: quote].	characterStream reset.	isInWhitespace := false.	"it's not enough to test for nil and PublicIDChars inclusion because	(PublicIDChars includes: $') = true (double quoted pubids can contain	single quotes), so the terminating quote must be tested for first to	handle single quoted pubids correctly"	[(nextChar := streamReader next) == nil		or: [nextChar == quote			or: [(PublicIDChars includes: nextChar) not]]]		whileFalse: [			nextChar isXMLSeparator				ifTrue: [					isInWhitespace						ifFalse: [isInWhitespace := true]]				ifFalse: [					isInWhitespace						ifTrue: [							characterStream position > 0								ifTrue: [characterStream nextPut: NormalizedSpace].							isInWhitespace := false].					characterStream nextPut: nextChar]].	nextChar == quote		ifFalse: [			self				errorExpectedPublicIDLiteralEnd: quote				butGot: nextChar].	^ characterStream contents.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextSeparators	"nil understands isXMLSeparator so no nil test is needed"	streamReader next isXMLSeparator		ifTrue: [streamReader skipSeparators]		ifFalse: [self errorExpectedSeparators]! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextSeparatorsInDeclaration	"this can be used to replace entity references within declarations"	[streamReader peek == $%]		whileTrue: [			streamReader next.			self nextParameterEntityReferenceInDeclaration].	self nextSeparators.	[streamReader peek == $%]		whileTrue: [			streamReader next.			self nextParameterEntityReferenceInDeclaration.			streamReader skipSeparators].! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextStartExternalEntity	driver decodesCharacters		ifTrue: [streamReader detectEncoding].	self nextXMLTextDeclaration.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextStartExternalSubset	self nextXMLTextDeclaration.	state := state externalSubsetState.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextStartIncludeSectionFromEntity: aPushedBackParameterEntity	self		expectNextAll: 'INCLUDE'		startingAt: 2. "the 'I' was already read"	streamReader skipSeparators.	self expectNext: $[.	"the 'INCLUDE' can be in the replacement of an entity, like	in '<!![%entity[...]]>', but after it the entity that started	the declaration must be current"	self topPushedBackEntity == aPushedBackParameterEntity		ifFalse: [driver handleImproperParameterEntityNesting].	totalOpenIncludeSections := self totalOpenIncludeSections + 1.	aPushedBackParameterEntity		ifNotNil: [aPushedBackParameterEntity startIncludeSection].! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextStartMarkupToken	| nextChar |	(nextChar := streamReader next) == $<		ifFalse: [self errorExpectedStartMarkupTokenButGot: nextChar]! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextSubsetDeclaration	streamReader peek == $E		ifTrue: [			streamReader next.			streamReader peek == $N				ifTrue: [^ self nextEntityDeclaration]				ifFalse: [^ self nextElementDeclaration]].	streamReader peek == $A		ifTrue: [^ self nextAttlistDeclaration].	streamReader peek == $N		ifTrue: [^ self nextNotationDeclaration].	self errorExpectedSubsetDeclaration.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextSubsetMarkupToken	| pushedBackParameterEntity |	self nextStartMarkupToken.	pushedBackParameterEntity := self topPushedBackEntity.	streamReader peek == $?		ifTrue: [self nextPI]		ifFalse: [			self expectNext: $!!.			streamReader peek == $-				ifTrue: [self nextComment]				ifFalse: [					streamReader peek == $[						ifTrue: [							self isInExternalSubsetOrExternalEntity								ifFalse: [self errorInternalSubsetConditionalSection].							self nextConditionalSectionFromEntity:								pushedBackParameterEntity]						ifFalse: [self nextSubsetDeclaration]]].	self topPushedBackEntity == pushedBackParameterEntity		ifFalse: [driver handleImproperParameterEntityNesting].! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextSystemIDInDeclaration	^ self		expectNextAll: 'SYSTEM';		nextSeparatorsInDeclaration;		nextSystemIDLiteral! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextSystemIDInDeclarationWithoutURIFragment	^ self		expectNextAll: 'SYSTEM';		nextSeparatorsInDeclaration;		nextSystemIDLiteralWithoutURIFragment! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextSystemIDLiteral	^ self nextSystemIDLiteralWithoutURIFragment: false! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextSystemIDLiteralWithoutURIFragment	^ self nextSystemIDLiteralWithoutURIFragment: true! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!nextSystemIDLiteralWithoutURIFragment: aBoolean	"Returns the system ID literal.	If aBoolean is true, it disallows '#' URI fragments."	| quote nextChar |	((quote := streamReader next) == $"		or: [quote == $'])		ifFalse: [self errorExpectedSystemIDLiteralStartButGot: quote].	characterStream reset.	[(nextChar := streamReader next) == nil		or: [nextChar == quote]]		whileFalse: [			nextChar isXMLChar				ifFalse: [self errorNonCharInSystemID: nextChar].			aBoolean				ifTrue: [					nextChar == $#						ifTrue: [self errorURIFragmentInSystemID]].			characterStream nextPut: nextChar].	nextChar == quote		ifFalse: [			self				errorExpectedSystemIDLiteralEnd: quote				butGot: nextChar].	^ characterStream contents.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextTag	"performance critical method"	| tagName attributes nextChar |	(streamReader peek == $/)		ifTrue: [^ self nextEndTag].	tagName := self nextElementName.	"nil understands isXMLSeparator so is not tested for"	[(nextChar := streamReader peek) isXMLSeparator		and: [			streamReader				next;				skipSeparators.			((nextChar := streamReader peek) == $>				or: [nextChar == $/]) not]]		whileTrue: [| attributeName |			attributeName := self nextAttributeName.			streamReader skipSeparators.			(nextChar := streamReader next) == $=				ifFalse: [					self errorExpectedElementAttributeEqualsSeparatorButGot: nextChar].			streamReader skipSeparators.			"delay initializing 'attributes' until now to know for sure if it			needs a non-zero capacity, otherwise use the lazy version"			((attributes				ifNil: [attributes := driver newAttributeDictionary])				at: attributeName				newPut: self nextAttributeValue)				ifFalse: [self errorDuplicateAttribute: attributeName].			"the ordering of these tests is optimized"			(attributeName at: 1) == $x				ifTrue: [					driver hasUnhandledReservedAttributes						ifFalse: [							attributeName isXMLReservedAttributeName								ifTrue: [driver haveUnhandledReservedAttributes]]]].	elementNester wasRootElementEnded		ifTrue: [self errorMultipleDocumentRootElements].	elementNester startElement: tagName.	driver		handleStartTag: tagName		attributes:			(attributes				ifNil: [driver newEmptyAttributeDictionary]).	nextChar == $/		ifTrue: [			streamReader next.			elementNester endCurrentElement.			driver handleEndTag: tagName].	(nextChar := streamReader next) == $>		ifFalse: [self errorExpectedTagTerminatorButGot: nextChar].! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextUnreplacedGeneralEntityOnCharacterStreamNamed: aName	driver handleUnreplacedGeneralEntityReference: aName.	characterStream		nextPut: $&;		nextPutAll: aName;		nextPut: $;.	^ $&.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextXMLAttributeEqualsSeparator	| nextChar |	streamReader skipSeparators.	(nextChar := streamReader next) == $=		ifFalse: [self errorExpectedXMLAttributeEqualsSeparatorButGot: nextChar].	streamReader skipSeparators.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextXMLDeclarationTerminator	| firstChar secondChar |	firstChar := streamReader next.	secondChar := streamReader next.	(firstChar == $?		and: [secondChar == $>])		ifFalse: [			self				errorExpectedXMLDeclarationTerminatorButGot: firstChar				followedBy: secondChar].! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextXMLEncodingAttributeValue	| quote nextChar |	((quote := streamReader next) == $"		or: [quote == $'])		ifFalse: [self errorExpectedXMLEncodingValueStartButGot: quote].	((nextChar := streamReader next) notNil		and: [EncodingNameStartChars includes: nextChar])		ifFalse: [self errorExpectedEncodingName].	xmlDeclarationStream		reset;		nextPut: nextChar.	[(nextChar := streamReader next) == nil		or: [(EncodingNameChars includes: nextChar) not]]		whileFalse: [xmlDeclarationStream nextPut: nextChar].	nextChar == quote		ifFalse: [			self				errorExpectedXMLEncodingValueEnd: quote				butGot: nextChar].	^ xmlDeclarationStream contents.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextXMLStandaloneAttributeValue	| quote yesOrNo nextChar |	((quote := streamReader next) == $"		or: [quote == $'])		ifFalse: [self errorExpectedXMLStandaloneValueStartButGot: quote].	yesOrNo := 		streamReader peek == $y			ifTrue: [self expectNextAll: 'yes']			ifFalse: [self expectNextAll: 'no'].	(nextChar := streamReader next) == quote		ifFalse: [			self				errorExpectedXMLStandaloneValueEnd: quote				butGot: nextChar].	^ yesOrNo.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextXMLTextDeclaration	| encoding |		1 to: 5 "'<?xml' size" do: [:i |		streamReader peek == ('<?xml' at: i)			ifFalse: [				i > 1					ifTrue: [						streamReader pushBack:							('<?xml'								copyFrom: 1								to: i - 1)].				^ self].		streamReader next].	self nextSeparators.	(self nextXMLVersionAttributeRequired: false) isEmpty		ifFalse: [self nextSeparators].	(encoding := self nextXMLEncodingAttributeRequired: true) isEmpty		ifFalse: [self convertFromEncoding: encoding].	streamReader skipSeparators.	self nextXMLDeclarationTerminator.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing'!nextXMLVersionAttributeValue	| quote nextChar length isValid |	((quote := streamReader next) == $"		or: [quote == $'])		ifFalse: [self errorExpectedXMLVersionValueStartButGot: quote].	length := 0.	isValid := true.	xmlDeclarationStream reset.	[(nextChar := streamReader next) == nil		or: [(VersionNumChars includes: nextChar) not]]		whileFalse: [			xmlDeclarationStream nextPut: nextChar.			length := length + 1.			isValid				ifTrue: [isValid := (length == 2) == (nextChar == $.)]].	(isValid		and: [length >= 3])		ifFalse: [			self errorExpectedXMLVersionNumberButGot:				xmlDeclarationStream contents].	nextChar == quote		ifFalse: [			self				errorExpectedXMLVersionValueEnd: quote				butGot: nextChar].	^ xmlDeclarationStream contents.! !!XMLWellFormedParserTokenizer methodsFor: 'entity replacing'!pushBackEntity: anEntity whenPoppedDo: aBlock	anEntity hasReplacement		ifTrue: [| pushedBackEntity |			pushedBackEntity :=				self addPushedBackEntity: anEntity asPushedBackEntity.			streamReader				pushBackStream: pushedBackEntity replacementStream				whenPoppedDo: [					self removePushedBackEntity: pushedBackEntity.					aBlock						ifNotNil: [aBlock value]]				isExternal: pushedBackEntity isExternal.			pushedBackEntity isExternal				ifTrue: [self nextStartExternalEntity]]		ifFalse: [			aBlock				ifNotNil: [aBlock value]]! !!XMLWellFormedParserTokenizer methodsFor: 'accessing'!pushedBackEntities	^ pushedBackEntities		ifNil: [pushedBackEntities := OrderedCollection new: 5]! !!XMLWellFormedParserTokenizer methodsFor: 'entity replacing'!removePushedBackEntity: aPushedBackEntity	self pushedBackEntities remove: aPushedBackEntity.	driver currentEntity: self topPushedBackEntity.	aPushedBackEntity isExternal		ifTrue: [			self topPushedBackExternalEntity				ifNil: [					driver baseURI: nil]				ifNotNil: [:pushedBackExternalEntity |					driver baseURI: pushedBackExternalEntity uri]].	^ aPushedBackEntity poppedByTokenizer: self.! !!XMLWellFormedParserTokenizer methodsFor: 'initialization'!setDriver: aDriver stream: aStream readLimit: anInteger	super		setDriver: aDriver		stream: aStream		readLimit: anInteger.	isInLiteralValue := false.	isIgnoringLiteralValueTerminator := false.! !!XMLWellFormedParserTokenizer methodsFor: 'tokenizing - dtd'!skipSeparatorsInDeclaration	"this can be used to replace references within declarations"	streamReader skipSeparators.	[streamReader peek == $%]		whileTrue: [			streamReader next.			self nextParameterEntityReferenceInDeclaration.			streamReader skipSeparators].! !!XMLWellFormedParserTokenizer methodsFor: 'accessing'!topPushedBackEntity	"heavily optimized"	pushedBackEntities == nil		ifTrue: [^ nil].	pushedBackEntities size > 0		ifFalse: [^ nil].	^ pushedBackEntities at: pushedBackEntities size.! !!XMLWellFormedParserTokenizer methodsFor: 'accessing'!topPushedBackExternalEntity	self pushedBackEntities reverseDo: [:each |		each isExternal			ifTrue: [^ each]].	^ nil.! !!XMLWellFormedParserTokenizer methodsFor: 'accessing'!totalOpenIncludeSections	^ totalOpenIncludeSections ifNil: [totalOpenIncludeSections := 0]! !!XMLPushedBackEntity class methodsFor: 'instance creation'!entity: anEntity	^ self new entity: anEntity! !!XMLPushedBackEntity methodsFor: 'converting'!asPushedBackEntity	^ self! !!XMLPushedBackEntity methodsFor: 'converting'!asReference	^ entity asReference! !!XMLPushedBackEntity methodsFor: 'accessing'!entity	^ entity! !!XMLPushedBackEntity methodsFor: 'accessing'!entity: anEntity	entity := anEntity! !!XMLPushedBackEntity methodsFor: 'testing'!hasReplacement	^ entity hasReplacement! !!XMLPushedBackEntity methodsFor: 'testing'!isExternal	^ entity isExternal! !!XMLPushedBackEntity methodsFor: 'testing'!isParameter	^ entity isParameter! !!XMLPushedBackEntity methodsFor: 'testing'!isStandaloneExternal	^ entity isStandaloneExternal! !!XMLPushedBackEntity methodsFor: 'testing'!isUnparsed	^ entity isUnparsed! !!XMLPushedBackEntity methodsFor: 'accessing'!name	^ entity name! !!XMLPushedBackEntity methodsFor: 'nesting'!poppedByTokenizer: aTokenizer	self subclassResponsibility! !!XMLPushedBackEntity methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		print: entity;		nextPut: $).! !!XMLPushedBackEntity methodsFor: 'accessing'!replacement	^ entity replacement! !!XMLPushedBackEntity methodsFor: 'accessing'!replacementStream	^ entity replacementStream! !!XMLPushedBackEntity methodsFor: 'accessing'!uri	^ entity uri! !!XMLPushedBackGeneralEntity methodsFor: 'nesting'!endElement	totalOpenElements := self totalOpenElements - 1! !!XMLPushedBackGeneralEntity methodsFor: 'nesting'!poppedByTokenizer: aTokenizer	totalOpenElements		ifNotNil: [			totalOpenElements = 0				ifFalse: [aTokenizer errorImproperGeneralEntityNesting]]! !!XMLPushedBackGeneralEntity methodsFor: 'nesting'!startElement	totalOpenElements := self totalOpenElements + 1! !!XMLPushedBackGeneralEntity methodsFor: 'accessing'!totalOpenElements	^ totalOpenElements ifNil: [totalOpenElements := 0]! !!XMLPushedBackParameterEntity methodsFor: 'nesting'!endIncludeSection	totalOpenIncludeSections := self totalOpenIncludeSections - 1! !!XMLPushedBackParameterEntity methodsFor: 'nesting'!poppedByTokenizer: aTokenizer	totalOpenIncludeSections		ifNotNil: [			totalOpenIncludeSections = 0				ifFalse: [aTokenizer driver handleImproperParameterEntityNesting]]! !!XMLPushedBackParameterEntity methodsFor: 'nesting'!startIncludeSection	totalOpenIncludeSections := self totalOpenIncludeSections + 1! !!XMLPushedBackParameterEntity methodsFor: 'accessing'!totalOpenIncludeSections	^ totalOpenIncludeSections ifNil: [totalOpenIncludeSections := 0]! !!XMLPushedBackExternalStream methodsFor: 'testing'!isExternal	^ true! !!XMLPushedBackStream class methodsFor: 'instance creation'!stream: aStream whenPoppedDo: aBlock currentPosition: aPosition currentLineNumber: aLineNumber currentLineStartPosition: aStartPosition	^ self new		setStream: aStream		whenPoppedDo: aBlock		currentPosition: aPosition		currentLineNumber: aLineNumber		currentLineStartPosition: aStartPosition! !!XMLPushedBackStream methodsFor: 'accessing'!currentLineNumber	^ currentLineNumber! !!XMLPushedBackStream methodsFor: 'accessing'!currentLineStartPosition	^ currentLineStartPosition! !!XMLPushedBackStream methodsFor: 'accessing'!currentPosition	^ currentPosition! !!XMLPushedBackStream methodsFor: 'testing'!isExternal	^ false! !!XMLPushedBackStream methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		print: stream;		nextPut: $).! !!XMLPushedBackStream methodsFor: 'initialization'!setStream: aStream whenPoppedDo: aBlock currentPosition: aPosition currentLineNumber: aLineNumber currentLineStartPosition: aStartPosition	stream := aStream.	whenPoppedDo := aBlock.	currentPosition := aPosition.	currentLineNumber := aLineNumber.	currentLineStartPosition := aStartPosition.! !!XMLPushedBackStream methodsFor: 'accessing'!stream	^ stream! !!XMLPushedBackStream methodsFor: 'accessing'!whenPoppedDo	^ whenPoppedDo! !!XMLDecodingReadStreamAdapter class methodsFor: 'instance creation'!nonDecodingOn: aStream	^ self		on: aStream		streamConverter: XMLStreamConverter null! !!XMLDecodingReadStreamAdapter class methodsFor: 'instance creation'!nonDecodingOnIfBinaryOrExternal: aStream	^ aStream isXMLBinaryOrExternalStream		ifTrue: [			self				on: aStream				streamConverter: XMLStreamConverter null]		ifFalse: [nil]! !!XMLDecodingReadStreamAdapter class methodsFor: 'instance creation'!on: aStream	^ self		on: aStream		streamConverter: XMLStreamConverter default! !!XMLDecodingReadStreamAdapter class methodsFor: 'instance creation'!on: aStream streamConverter: aStreamConverter	^ (self basicOn: aStream)		streamConverter: aStreamConverter! !!XMLDecodingReadStreamAdapter methodsFor: 'testing'!atEnd	^ peekChar == nil		and: [stream atEnd]! !!XMLDecodingReadStreamAdapter methodsFor: 'decoding'!detectEncoding	prePeekStreamPosition := nil.	peekChar := nil.	stream reset.	(((self hasNullStreamConverter		or: [self hasImplicitStreamConverter])		ifTrue: [XMLImplicitEncodingDetector]		ifFalse: [XMLEncodingDetector])			on: stream) streamConverterForEncoding				ifNotNil: [:converter |					self streamConverter: converter].! !!XMLDecodingReadStreamAdapter methodsFor: 'testing'!hasDefaultStreamConverter	^ streamConverter isDefault! !!XMLDecodingReadStreamAdapter methodsFor: 'testing'!hasImplicitStreamConverter	^ streamConverter isImplicit! !!XMLDecodingReadStreamAdapter methodsFor: 'testing'!hasNullStreamConverter	^ streamConverter isNull! !!XMLDecodingReadStreamAdapter methodsFor: 'testing'!isXMLConvertingStreamAdapter	^ true! !!XMLDecodingReadStreamAdapter methodsFor: 'accessing'!next	peekChar		ifNil: [^ streamConverter nextFromStream: stream]		ifNotNil: [:nextChar |			prePeekStreamPosition := nil.			peekChar := nil.			^ nextChar]! !!XMLDecodingReadStreamAdapter methodsFor: 'accessing'!peek	^ peekChar		ifNil: [			prePeekStreamPosition := stream position.			peekChar := streamConverter nextFromStream: stream]! !!XMLDecodingReadStreamAdapter methodsFor: 'positioning'!position	^ prePeekStreamPosition ifNil: [stream position]! !!XMLDecodingReadStreamAdapter methodsFor: 'positioning'!position: anInteger	prePeekStreamPosition := nil.	peekChar := nil.	stream position: anInteger.! !!XMLDecodingReadStreamAdapter methodsFor: 'printing'!printStreamOn: aStream	streamConverter		printWithConvertableStream: stream		on: aStream! !!XMLDecodingReadStreamAdapter methodsFor: 'positioning'!reset	prePeekStreamPosition := nil.	peekChar := nil.	stream reset.! !!XMLDecodingReadStreamAdapter methodsFor: 'accessing'!streamConverter	^ streamConverter! !!XMLDecodingReadStreamAdapter methodsFor: 'accessing'!streamConverter: aStreamConverter	streamConverter :=		aStreamConverter ifNil: [XMLStreamConverter null].	peekChar		ifNotNil: [			stream position: prePeekStreamPosition.			prePeekStreamPosition := nil.			peekChar := nil].! !!XMLLimitedReadStreamAdapter class methodsFor: 'accessing'!defaultLimit	^ 1014! !!XMLLimitedReadStreamAdapter class methodsFor: 'instance creation'!on: aStream	^ self		on: aStream		limit: self defaultLimit! !!XMLLimitedReadStreamAdapter class methodsFor: 'instance creation'!on: aStream limit: aLimit	^ (self basicOn: aStream)		limit: aLimit! !!XMLLimitedReadStreamAdapter methodsFor: 'testing'!atEnd	^ stream atEnd		or: [limit <= 0]! !!XMLLimitedReadStreamAdapter methodsFor: 'testing'!atLimitedEnd	^ limit <= 0		and: [stream atEnd not]! !!XMLLimitedReadStreamAdapter methodsFor: 'accessing'!limit	^ limit! !!XMLLimitedReadStreamAdapter methodsFor: 'accessing'!limit: anInteger	limit := anInteger! !!XMLLimitedReadStreamAdapter methodsFor: 'accessing'!next	(stream atEnd		or: [limit <= 0])		ifTrue: [^ nil]		ifFalse: [			limit := limit - 1.			^ stream next]! !!XMLLimitedReadStreamAdapter methodsFor: 'accessing'!peek	(stream atEnd		or: [limit <= 0])		ifTrue: [^ nil]		ifFalse: [^ stream peek]! !!XMLLimitedReadStreamAdapter methodsFor: 'positioning'!position: anInteger	| netPosition |	(netPosition := anInteger - stream position) > limit		ifTrue: [			"skip as far ahead as allowed"			self skip: limit]		ifFalse: [			limit := (limit - netPosition) max: 0.			stream position: anInteger]! !!XMLLimitedReadStreamAdapter methodsFor: 'positioning'!reset	| oldPosition |	oldPosition := stream position.	stream reset.	limit := limit + (oldPosition - stream position).! !!XMLPercentDecodingReadStreamAdapter methodsFor: 'testing'!atEnd	^ stream atEnd		or: [stream peek ~~ $%]! !!XMLPercentDecodingReadStreamAdapter methodsFor: 'testing'!isBinary	"this stream is binary, because it reads percent-encoded octets	character sequences like '%HH' and returns the octet values as	SmallIntegers"	^ true! !!XMLPercentDecodingReadStreamAdapter methodsFor: 'accessing'!next	| byte |	(stream atEnd not		and: [stream peek == $%])		ifTrue: [			stream next.			byte :=				(XMLSmallIntegerReader					readFrom: stream					withBase: 16					upToLimit: 2)						ifNil: [37] "$% asciiValue"].	^ byte.! !!XMLPercentDecodingReadStreamAdapter methodsFor: 'accessing'!peek	| byte |	stream atEnd		ifFalse: [| oldPosition |			oldPosition := stream position.			byte := self next.			stream position: oldPosition].	^ byte.! !!XMLReadStreamAdapter class methodsFor: 'instance creation'!onIfBinaryOrExternal: aStream	^ aStream isXMLBinaryOrExternalStream		ifTrue: [self on: aStream]		ifFalse: [nil]! !!XMLReadStreamAdapter methodsFor: 'testing'!atEnd	^ stream atEnd! !!XMLReadStreamAdapter methodsFor: 'accessing'!contents	| oldPosition contents |	oldPosition := self position.	self reset.	contents := self upToEnd.	self position: oldPosition.	^ contents.! !!XMLReadStreamAdapter methodsFor: 'private'!newWriteStream	^ (self writeStreamCollectionClass new: 128) writeStream! !!XMLReadStreamAdapter methodsFor: 'accessing'!next	stream atEnd		ifTrue: [^ nil]		ifFalse: [^ stream next]! !!XMLReadStreamAdapter methodsFor: 'accessing'!next: anInteger	| writeStream i |	writeStream := self newWriteStream.	i := 0.	[self atEnd		or: [i >= anInteger]]		whileFalse: [			writeStream nextPut: self next.			i := i + 1].	^ writeStream contents.! !!XMLReadStreamAdapter methodsFor: 'accessing'!peek	stream atEnd		ifTrue: [^ nil]		ifFalse: [^ stream peek]! !!XMLReadStreamAdapter methodsFor: 'accessing'!peekFor: anObject	(self atEnd not		and: [self peek = anObject])		ifTrue: [			self next.			^ true]		ifFalse: [^ false]! !!XMLReadStreamAdapter methodsFor: 'positioning'!position	^ stream position! !!XMLReadStreamAdapter methodsFor: 'positioning'!position: anInteger	stream position: anInteger! !!XMLReadStreamAdapter methodsFor: 'positioning'!reset	stream reset! !!XMLReadStreamAdapter methodsFor: 'positioning'!skip: anInteger	"only supports skipping forwards"	1 to: anInteger do: [:i |		self atEnd			ifTrue: [^ self].		self next]! !!XMLReadStreamAdapter methodsFor: 'positioning'!skipSeparators	"we use #isXMLWhitespace instead of the narrower, XML-specific	#isXMLSeparator, because this class supports non-XML input too"	[self atEnd not		and: [self peek isXMLWhitespace]]		whileTrue: [self next]! !!XMLReadStreamAdapter methodsFor: 'positioning'!skipTo: anObject	[self atEnd]		whileFalse: [			self next = anObject				ifTrue: [^ true]].	^ false.! !!XMLReadStreamAdapter methodsFor: 'accessing'!upTo: anObject	| writeStream next |	writeStream := self newWriteStream.	[self atEnd		or: [(next := self next) = anObject]]		whileFalse: [writeStream nextPut: next].	^ writeStream contents.! !!XMLReadStreamAdapter methodsFor: 'accessing'!upToEnd	| writeStream |	writeStream := self newWriteStream.	[self atEnd]		whileFalse: [writeStream nextPut: self next].	^ writeStream contents.! !!XMLReadStreamAdapter methodsFor: 'defaults'!writeStreamCollectionClass	self isBinary		ifTrue: [^ ByteArray]		ifFalse: [^ String]! !!XMLStringReadStreamAdapter methodsFor: 'testing'!isBinary	"this stream is binary, because it converts characters to integers"	^ true! !!XMLStringReadStreamAdapter methodsFor: 'accessing'!next	stream atEnd		ifTrue: [^ nil]		ifFalse: [^ stream next asInteger]! !!XMLStringReadStreamAdapter methodsFor: 'accessing'!peek	stream atEnd		ifTrue: [^ nil]		ifFalse: [^ stream peek asInteger]! !!XMLStreamAdapter class methodsFor: 'basic'!basicOn: aStream	^ self basicNew initialize on: aStream! !!XMLStreamAdapter class methodsFor: 'instance creation'!new	self shouldNotImplement! !!XMLStreamAdapter class methodsFor: 'instance creation'!on: aStream	^ self basicOn: aStream! !!XMLStreamAdapter methodsFor: 'closing'!close	"must use respondsTo: to support streams only implementing the basic protocol"	(stream respondsTo: #close)		ifTrue: [stream close]! !!XMLStreamAdapter methodsFor: 'accessing'!contents	self subclassResponsibility! !!XMLStreamAdapter methodsFor: 'testing'!isBinary	^ false! !!XMLStreamAdapter methodsFor: 'testing'!isStream	^ true! !!XMLStreamAdapter methodsFor: 'testing'!isXMLBinaryOrExternalStream	^ self isBinary! !!XMLStreamAdapter methodsFor: 'initialization'!on: aStream	stream := aStream! !!XMLStreamAdapter methodsFor: 'positioning'!position	self subclassResponsibility! !!XMLStreamAdapter methodsFor: 'positioning'!position: anInteger	self subclassResponsibility! !!XMLStreamAdapter methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	self printStreamOn: aStream.	aStream nextPut: $).! !!XMLStreamAdapter methodsFor: 'printing'!printStreamOn: aStream	aStream print: stream! !!XMLStreamAdapter methodsFor: 'positioning'!reset	self subclassResponsibility! !!XMLStreamAdapter methodsFor: 'accessing'!stream	^ stream! !!XMLEncodingWriteStreamAdapter class methodsFor: 'instance creation'!on: aStream	^ self		on: aStream		streamConverter: XMLStreamConverter default! !!XMLEncodingWriteStreamAdapter class methodsFor: 'instance creation'!on: aStream streamConverter: aStreamConverter	^ (self basicOn:		(aStream isXMLBinaryOrExternalStream			ifTrue: [aStream]			ifFalse: [XMLStringWriteStreamAdapter on: aStream]))		streamConverter: aStreamConverter! !!XMLEncodingWriteStreamAdapter methodsFor: 'testing'!hasDefaultStreamConverter	^ streamConverter isDefault! !!XMLEncodingWriteStreamAdapter methodsFor: 'testing'!hasImplicitStreamConverter	^ streamConverter isImplicit! !!XMLEncodingWriteStreamAdapter methodsFor: 'testing'!hasNullStreamConverter	^ streamConverter isNull! !!XMLEncodingWriteStreamAdapter methodsFor: 'testing'!isXMLConvertingStreamAdapter	^ true! !!XMLEncodingWriteStreamAdapter methodsFor: 'accessing'!nextPut: aCharacter	streamConverter		nextPut: aCharacter		toStream: stream.	^ aCharacter.! !!XMLEncodingWriteStreamAdapter methodsFor: 'accessing'!nextPutAll: aCollection	"can't use #to:do: here because other #nextPutAll: implementations	support non-sequenceable collection arguments wtih #do:"	aCollection do: [:each |		streamConverter			nextPut: each			toStream: stream].	^ aCollection.! !!XMLEncodingWriteStreamAdapter methodsFor: 'accessing'!nextPutByteOrderMark	streamConverter nextPutByteOrderMarkToStream: stream! !!XMLEncodingWriteStreamAdapter methodsFor: 'printing'!printStreamOn: aStream	streamConverter		printWithConvertableStream: stream		on: aStream! !!XMLEncodingWriteStreamAdapter methodsFor: 'accessing'!streamConverter	^ streamConverter! !!XMLEncodingWriteStreamAdapter methodsFor: 'accessing'!streamConverter: aStreamConverter	streamConverter :=		aStreamConverter ifNil: [XMLStreamConverter null]! !!XMLNodeContentWriteStreamAdapter methodsFor: 'private'!insertSpaceBefore: aCharacter	(lastChar == nil		or: [lastChar isXMLWhitespace			or: [aCharacter isXMLWhitespace]])		ifFalse: [stream nextPut: SpaceCharacter]! !!XMLNodeContentWriteStreamAdapter methodsFor: 'accessing'!nextPut: aCharacter	self insertSpaceBefore: aCharacter.	stream nextPut: aCharacter.	^ lastChar := aCharacter.! !!XMLNodeContentWriteStreamAdapter methodsFor: 'accessing'!nextPutAll: aString	aString size > 0 "optimization"		ifTrue: [			self insertSpaceBefore: aString first.			stream nextPutAll: aString.			lastChar := aString last].	^ aString.! !!XMLPercentEncodingWriteStreamAdapter methodsFor: 'testing'!isBinary	"this stream is binary, because it accepts binary octet values	and percent-encodes them as '%HH' character sequences"	^ true! !!XMLPercentEncodingWriteStreamAdapter methodsFor: 'accessing'!nextPut: anObject	| byte |	stream nextPut: $%.	"pad it if needed"	(byte := anObject asInteger) < 16r10		ifTrue: [stream nextPut: $0].	"On GS, #printOn:base: shows the radix, so #printOn:base:showRadix:	is used instead"	byte		printOn: stream		base: 16		showRadix: false.	^ anObject.! !!XMLPercentEncodingWriteStreamAdapter methodsFor: 'accessing'!nextPutAll: aCollection	"can't use #to:do: here because other #nextPutAll: implementations	support non-sequenceable collection arguments wtih #do:"	aCollection do: [:each |		self nextPut: each].	^ aCollection.! !!XMLStringWriteStreamAdapter methodsFor: 'accessing'!nextPut: anObject	stream nextPut: anObject asCharacter! !!XMLStringWriteStreamAdapter methodsFor: 'accessing'!nextPutAll: aCollection	"can't use #to:do: here because other #nextPutAll: implementations	support non-sequenceable collection arguments wtih #do:"	aCollection do: [:each |		stream nextPut: each asCharacter].	^ aCollection.! !!XMLWriteStreamAdapter class methodsFor: 'class initialization'!initialize	"self initialize"	"stored in class vars for faster access"	SpaceCharacter := Character space.	TabCharacter := Character tab.	CRCharacter := Character cr.	LFCharacter := Character lf.! !!XMLWriteStreamAdapter methodsFor: 'basic'!basicNextPut: anObject 	^ self nextPut: anObject! !!XMLWriteStreamAdapter methodsFor: 'accessing'!contents	^ stream contents! !!XMLWriteStreamAdapter methodsFor: 'character writing'!cr	^ self nextPut: CRCharacter! !!XMLWriteStreamAdapter methodsFor: 'character writing'!lf	^ self nextPut: LFCharacter! !!XMLWriteStreamAdapter methodsFor: 'accessing'!nextPut: anObject	stream nextPut: anObject.	^ anObject.! !!XMLWriteStreamAdapter methodsFor: 'accessing'!nextPutAll: aCollection	stream nextPutAll: aCollection.	^ aCollection.! !!XMLWriteStreamAdapter methodsFor: 'positioning'!position	^ stream position! !!XMLWriteStreamAdapter methodsFor: 'positioning'!position: anInteger	stream position: anInteger! !!XMLWriteStreamAdapter methodsFor: 'positioning'!reset	stream reset! !!XMLWriteStreamAdapter methodsFor: 'character writing'!space	^ self nextPut: SpaceCharacter! !!XMLWriteStreamAdapter methodsFor: 'character writing'!tab	^ self nextPut: TabCharacter! !!XMLASCIIStreamConverter class methodsFor: 'basic'!basicEncodingNames	^ #('ASCII' 'US-ASCII' 'USASCII')! !!XMLASCIIStreamConverter methodsFor: 'decoding'!nextFromStream: aStream	| byte |	aStream atEnd		ifTrue: [^ nil].	(byte := aStream next asInteger) > 127		ifTrue: [self errorBadCharacterValue: byte].	^ byte asCharacter.! !!XMLASCIIStreamConverter methodsFor: 'encoding'!nextPut: aCharacter toStream: aStream	| codePoint |	(codePoint := aCharacter asInteger) > 127		ifTrue: [self errorBadCharacterValue: codePoint].	aStream nextPut: codePoint.! !!XMLLatin1StreamConverter class methodsFor: 'basic'!basicEncodingNames	^ #('Latin-1' 'Latin1'			'CP-819' 'CP819'			'IBM-819' 'IBM819'			'ISO-8859-1' 'ISO8859-1' 'ISO-88591' 'ISO88591'			'ISO-IR-100' 'ISOIR-100' 'ISO-IR100' 'ISOIR100'			'L1'			'csISOLatin1')! !!XMLLatin1StreamConverter methodsFor: 'decoding'!nextFromStream: aStream	| byte |	aStream atEnd		ifTrue: [^ nil].	(byte := aStream next asInteger) > 255		ifTrue: [self errorBadCharacterValue: byte].	^ byte asCharacter.! !!XMLLatin1StreamConverter methodsFor: 'encoding'!nextPut: aCharacter toStream: aStream	| codePoint |	(codePoint := aCharacter asInteger) > 255		ifTrue: [self errorBadCharacterValue: codePoint].	aStream nextPut: codePoint.! !!XMLNullStreamConverter methodsFor: 'testing'!isNull	^ true! !!XMLNullStreamConverter methodsFor: 'decoding'!nextFromStream: aStream	aStream atEnd		ifTrue: [^ nil]		ifFalse: [^ aStream next asCharacter]! !!XMLNullStreamConverter methodsFor: 'encoding'!nextPut: aCharacter toStream: aStream	aStream nextPut: aCharacter asInteger! !!XMLStatelessStreamConverter class methodsFor: 'defaults'!abstractClass	^ XMLStatelessStreamConverter! !!XMLStatelessStreamConverter class methodsFor: 'accessing'!instance	^ instance ifNil: [instance := self basicNew initialize]! !!XMLStatelessStreamConverter class methodsFor: 'instance creation'!new	"all subclasses are stateless and have a single, immutable, shared instance"	^ self instance! !!XMLImplicitUTF16BigEndianStreamConverter class methodsFor: 'testing'!isImplicit	^ true! !!XMLUTF16BigEndianStreamConverter class methodsFor: 'basic'!basicByteOrderMarkBytes	^ #[16rFE 16rFF]! !!XMLUTF16BigEndianStreamConverter class methodsFor: 'basic'!basicEncodingNames	^ #('UTF-16' 'UTF16'			'UTF-16-BE' 'UTF16-BE' 'UTF-16BE' 'UTF16BE')! !!XMLUTF16BigEndianStreamConverter methodsFor: 'testing'!isBigEndian	^ true! !!XMLUTF16BigEndianStreamConverter methodsFor: 'basic'!nextPutTwoBytes: anInteger toStream: aStream	aStream		nextPut: ((anInteger bitShift: -8) bitAnd: 16rFF);		nextPut: (anInteger bitAnd: 16rFF)! !!XMLUTF16BigEndianStreamConverter methodsFor: 'basic'!nextTwoBytesFromStream: aStream	| firstByte |	firstByte := aStream next asInteger bitShift: 8.	aStream atEnd		ifTrue: [self errorBadCharacterEncoding].	^ firstByte + aStream next asInteger.! !!XMLImplicitUTF16LittleEndianStreamConverter class methodsFor: 'testing'!isImplicit	^ true! !!XMLUTF16LittleEndianStreamConverter class methodsFor: 'basic'!basicByteOrderMarkBytes	^ #[16rFF 16rFE]! !!XMLUTF16LittleEndianStreamConverter class methodsFor: 'basic'!basicEncodingNames	^ #('UTF-16-LE' 'UTF16-LE' 'UTF-16LE' 'UTF16LE')! !!XMLUTF16LittleEndianStreamConverter methodsFor: 'testing'!isBigEndian	^ false! !!XMLUTF16LittleEndianStreamConverter methodsFor: 'basic'!nextPutTwoBytes: anInteger toStream: aStream	aStream		nextPut: (anInteger bitAnd: 16rFF);		nextPut: ((anInteger bitShift: -8) bitAnd: 16rFF)! !!XMLUTF16LittleEndianStreamConverter methodsFor: 'basic'!nextTwoBytesFromStream: aStream	| firstByte |	firstByte := aStream next asInteger.	aStream atEnd		ifTrue: [self errorBadCharacterEncoding].	^ firstByte + (aStream next asInteger bitShift: 8).! !!XMLUTF16StreamConverter class methodsFor: 'defaults'!abstractClass	^ XMLUTF16StreamConverter! !!XMLUTF16StreamConverter methodsFor: 'testing'!isBigEndian	self subclassResponsibility! !!XMLUTF16StreamConverter methodsFor: 'basic'!nextCodePointFromStream: aStream	| codePoint lowSurrogate |	aStream atEnd		ifTrue: [^ nil].	"code points U+10000 to U+10FFFF are encoded with surrogate pairs,	while those < U+10000 are encoded directly"	((codePoint := self nextTwoBytesFromStream: aStream) < 16rD800		or: [codePoint > 16rDFFF])		ifTrue: [			codePoint > 16r10FFFF				ifTrue: [self errorBadCharacterValue: codePoint].			^ codePoint].	codePoint > 16rDBFF "max high surrogate"		ifTrue: [self errorBadCharacterEncoding].	aStream atEnd		ifTrue: [self errorBadCharacterEncoding].	(lowSurrogate := self nextTwoBytesFromStream: aStream)		ifNil: [self errorBadCharacterEncoding].	(lowSurrogate < 16rDC00 "min low surrogate"		or: [lowSurrogate > 16rDFFF]) "max low surrogate"		ifTrue: [self errorBadCharacterEncoding].	"A code point > U+10FFFF isn't checked for here because it can't	be encoded with UTF-16. The maximum surrogate pairs can encode is:		(16r10000 + (16r3FF bitShift: 10) + 16r3FF) = 16r10FFFF"	^ ((codePoint bitAnd: 16r3FF) bitShift: 10) +		(lowSurrogate bitAnd: 16r3FF) +		16r10000.! !!XMLUTF16StreamConverter methodsFor: 'encoding'!nextPut: aCharacter toStream: aStream	| codePoint |	(codePoint := aCharacter asInteger) < 16r10000		ifTrue: [			"check for the reserved surrogate pair code points"			(codePoint >= 16rD800				and: [codePoint <= 16rDFFF])				ifTrue: [self errorBadCharacterValue: codePoint].			self				nextPutTwoBytes: codePoint				toStream: aStream]		ifFalse: [			codePoint > 16r10FFFF "max code point"				ifTrue: [self errorBadCharacterValue: codePoint].			codePoint := codePoint - 16r10000.			"the 10 high-order bits"			self				nextPutTwoBytes: 16rD800 + ((codePoint bitShift: -10) bitAnd: 16r3FF)				toStream: aStream.			"the 10 low-order bits"			self				nextPutTwoBytes: 16rDC00 + (codePoint bitAnd: 16r3FF)				toStream: aStream]! !!XMLUTF16StreamConverter methodsFor: 'basic'!nextPutTwoBytes: anInteger toStream: aStream	self subclassResponsibility! !!XMLUTF16StreamConverter methodsFor: 'basic'!nextTwoBytesFromStream: aStream	self subclassResponsibility! !!XMLImplicitUTF32BigEndianStreamConverter class methodsFor: 'testing'!isImplicit	^ true! !!XMLUTF32BigEndianStreamConverter class methodsFor: 'basic'!basicByteOrderMarkBytes	^ #[16r00 16r00 16rFE 16rFF]! !!XMLUTF32BigEndianStreamConverter class methodsFor: 'basic'!basicEncodingNames	^ #('UTF-32' 'UTF32'			'UTF-32-BE' 'UTF32-BE' 'UTF-32BE' 'UTF32BE')! !!XMLUTF32BigEndianStreamConverter methodsFor: 'testing'!isBigEndian	^ true! !!XMLUTF32BigEndianStreamConverter methodsFor: 'basic'!nextFourBytesFromStream: aStream	| firstByte secondByte thirdByte |	firstByte := aStream next asInteger bitShift: 24.	aStream atEnd		ifTrue: [self errorBadCharacterEncoding].	secondByte := aStream next asInteger bitShift: 16.	aStream atEnd		ifTrue: [self errorBadCharacterEncoding].	thirdByte := aStream next asInteger bitShift: 8.	aStream atEnd		ifTrue: [self errorBadCharacterEncoding].	^ firstByte + secondByte + thirdByte + aStream next asInteger.! !!XMLUTF32BigEndianStreamConverter methodsFor: 'basic'!nextPutFourBytes: anInteger toStream: aStream	aStream		nextPut: ((anInteger bitShift: -24) bitAnd: 16rFF);		nextPut: ((anInteger bitShift: -16) bitAnd: 16rFF);		nextPut: ((anInteger bitShift: -8) bitAnd: 16rFF);		nextPut: (anInteger bitAnd: 16rFF)! !!XMLImplicitUTF32LittleEndianStreamConverter class methodsFor: 'testing'!isImplicit	^ true! !!XMLUTF32LittleEndianStreamConverter class methodsFor: 'basic'!basicByteOrderMarkBytes	^ #[16rFF 16rFE 16r00 16r00]! !!XMLUTF32LittleEndianStreamConverter class methodsFor: 'basic'!basicEncodingNames	^ #('UTF-32-LE' 'UTF32-LE' 'UTF-32LE' 'UTF32LE')! !!XMLUTF32LittleEndianStreamConverter methodsFor: 'testing'!isBigEndian	^ false! !!XMLUTF32LittleEndianStreamConverter methodsFor: 'basic'!nextFourBytesFromStream: aStream	| firstByte secondByte thirdByte |	firstByte := aStream next asInteger.	aStream atEnd		ifTrue: [self errorBadCharacterEncoding].	secondByte := aStream next asInteger bitShift: 8.	aStream atEnd		ifTrue: [self errorBadCharacterEncoding].	thirdByte := aStream next asInteger bitShift: 16.	aStream atEnd		ifTrue: [self errorBadCharacterEncoding].	^ firstByte + secondByte + thirdByte + (aStream next asInteger bitShift: 24).! !!XMLUTF32LittleEndianStreamConverter methodsFor: 'basic'!nextPutFourBytes: anInteger toStream: aStream	aStream		nextPut: (anInteger bitAnd: 16rFF);		nextPut: ((anInteger bitShift: -8) bitAnd: 16rFF);		nextPut: ((anInteger bitShift: -16) bitAnd: 16rFF);		nextPut: ((anInteger bitShift: -24) bitAnd: 16rFF)! !!XMLUTF32StreamConverter class methodsFor: 'defaults'!abstractClass	^ XMLUTF32StreamConverter! !!XMLUTF32StreamConverter methodsFor: 'testing'!isBigEndian	self subclassResponsibility! !!XMLUTF32StreamConverter methodsFor: 'basic'!nextCodePointFromStream: aStream	| codePoint |	aStream atEnd		ifTrue: [^ nil].	"check for the reserved surrogate pair code points and code points	greater than the max code point"	(codePoint := self nextFourBytesFromStream: aStream) >= 16rD800		ifTrue: [			(codePoint <= 16rDFFF				or: [codePoint > 16r10FFFF])				ifTrue: [self errorBadCharacterValue: codePoint]].	^ codePoint.! !!XMLUTF32StreamConverter methodsFor: 'basic'!nextFourBytesFromStream: aStream	self subclassResponsibility! !!XMLUTF32StreamConverter methodsFor: 'encoding'!nextPut: aCharacter toStream: aStream	| codePoint |	codePoint := aCharacter asInteger.	"check for the reserved surrogate pair code points and code points	greater than the max code point"	(codePoint >= 16rD800		and: [codePoint <= 16rDFFF			or: [codePoint > 16r10FFFF]])		ifTrue: [self errorBadCharacterValue: codePoint].	self		nextPutFourBytes: codePoint		toStream: aStream.! !!XMLUTF32StreamConverter methodsFor: 'basic'!nextPutFourBytes: anInteger toStream: aStream	self subclassResponsibility! !!XMLImplicitUTF8StreamConverter class methodsFor: 'testing'!isImplicit	^ true! !!XMLUTF8StreamConverter class methodsFor: 'basic'!basicByteOrderMarkBytes	^ #[16rEF 16rBB 16rBF]! !!XMLUTF8StreamConverter class methodsFor: 'basic'!basicEncodingNames	^ #('UTF-8' 'UTF8')! !!XMLUTF8StreamConverter methodsFor: 'private'!errorOverlongCodePoint: aCodePoint	XMLEncodingException		formatSignal: 'Illegal overlong UTF-8 encoding for U+{1} code point'		with: aCodePoint printStringHex! !!XMLUTF8StreamConverter methodsFor: 'basic'!nextCodePointFromStream: aStream	self shouldNotImplement! !!XMLUTF8StreamConverter methodsFor: 'decoding'!nextFromStream: aStream	"an attempt was made at porting Bjoern Hoehrmann's DFA-based decoder	(with transitions pre-multiplied by 16), but it was slightly slower	than this implementation and needed significant modification to report	errors the same way, so it was scrapped"	| firstByte codePoint |	aStream atEnd		ifTrue: [^ nil].	(firstByte := aStream next asInteger) < 16r80 "single byte character"		ifTrue: [^ firstByte asCharacter].	codePoint :=		self			nextMultiByteCodePointStartingWith: firstByte			fromStream: aStream.	[codePoint == 16rFEFF] "the BOM code point"		whileTrue: [			aStream atEnd				ifTrue: [^ nil].			(firstByte := aStream next asInteger) < 16r80 "single byte character"				ifTrue: [^ firstByte asCharacter].			codePoint :=				self					nextMultiByteCodePointStartingWith: firstByte					fromStream: aStream].	^ codePoint asCharacter.! !!XMLUTF8StreamConverter methodsFor: 'basic'!nextMultiByteCodePointStartingWith: aFirstByte fromStream: aStream	| secondByte thirdByte codePoint |	aStream atEnd		ifTrue: [self errorBadCharacterEncoding].	secondByte := aStream next asInteger.	(secondByte bitAnd: 16rC0) == 16r80		ifFalse: [self errorBadCharacterEncoding].	(aFirstByte bitAnd: 16rE0) == 16rC0 "two bytes"		ifTrue: [			codePoint :=				((aFirstByte bitAnd: 16r1F) bitShift: 6) +				(secondByte bitAnd: 16r3F).			codePoint >= 16r80				ifFalse: [self errorOverlongCodePoint: codePoint].			^ codePoint].	aStream atEnd		ifTrue: [self errorBadCharacterEncoding].	thirdByte := aStream next asInteger.	(thirdByte bitAnd: 16rC0) == 16r80		ifFalse: [self errorBadCharacterEncoding].	(aFirstByte bitAnd: 16rF0) == 16rE0 "three bytes"		ifTrue: [			codePoint :=				((aFirstByte bitAnd: 16r0F) bitShift: 12) +				((secondByte bitAnd: 16r3F) bitShift: 6) +				(thirdByte bitAnd: 16r3F).			"check for the reserved surrogate pair code points"			codePoint >= 16rD800				ifTrue: [					codePoint <= 16rDFFF						ifTrue: [self errorBadCharacterValue: codePoint]]				ifFalse: [					codePoint >= 16r800						ifFalse: [self errorOverlongCodePoint: codePoint]].			^ codePoint].	(aFirstByte bitAnd: 16rF8) == 16rF0		ifTrue: [| fourthByte |			aStream atEnd				ifTrue: [self errorBadCharacterEncoding].			fourthByte := aStream next asInteger.			(fourthByte bitAnd: 16rC0) == 16r80				ifFalse: [self errorBadCharacterEncoding].			codePoint :=				((aFirstByte bitAnd: 16r07) bitShift: 18) +				((secondByte bitAnd: 16r3F) bitShift: 12) +				((thirdByte bitAnd: 16r3F) bitShift: 6) +				(fourthByte bitAnd: 16r3F).			codePoint > 16r10FFFF "max code point"				ifTrue: [self errorBadCharacterValue: codePoint].			codePoint >= 16r10000				ifFalse: [self errorOverlongCodePoint: codePoint].			^ codePoint].	"the first byte is malformed"	self errorBadCharacterEncoding.! !!XMLUTF8StreamConverter methodsFor: 'encoding'!nextPut: aCharacter toStream: aStream	| codePoint |	(codePoint := aCharacter asInteger) < 16r80		ifTrue: [			aStream nextPut: codePoint.			^ self].	codePoint < 16r800		ifTrue: [			aStream				nextPut: 16rC0 + (codePoint bitShift: -6);				nextPut: 16r80 + (codePoint bitAnd: 16r003F).			^ self].	codePoint < 16r10000		ifTrue: [			"check for the reserved surrogate pair code points"			(codePoint >= 16rD800				and: [codePoint <= 16rDFFF])				ifTrue: [self errorBadCharacterValue: codePoint].			aStream				nextPut: 16rE0 + (codePoint bitShift: -12);				nextPut: 16r80 + ((codePoint bitShift: -6) bitAnd: 16r3F);				nextPut: 16r80 + (codePoint bitAnd: 16r3F).			^ self].	codePoint <= 16r10FFFF  "max code point"		ifTrue: [			aStream				nextPut: 16rF0 + (codePoint bitShift: -18);				nextPut: 16r80 + ((codePoint bitShift: -12) bitAnd: 16r3F);				nextPut: 16r80 + ((codePoint bitShift: -6) bitAnd: 16r3F);				nextPut: 16r80 + (codePoint bitAnd: 16r3F).			^ self].	self errorBadCharacterValue: codePoint.! !!XMLUTFStreamConverter class methodsFor: 'defaults'!abstractClass	^ XMLUTFStreamConverter! !!XMLUTFStreamConverter methodsFor: 'private'!errorBadCharacterValue: aValue	XMLEncodingException		formatSignal: 'Invalid {1} code point U+{1}'		with: self encoding		with: aValue printStringHex! !!XMLUTFStreamConverter methodsFor: 'basic'!nextCodePointFromStream: aStream	self subclassResponsibility! !!XMLUTFStreamConverter methodsFor: 'decoding'!nextFromStream: aStream	| codePoint |	codePoint := self nextCodePointFromStream: aStream.	[codePoint == 16rFEFF] "the BOM code point"		whileTrue: [			aStream atEnd				ifTrue: [^ nil].			codePoint := self nextCodePointFromStream: aStream].	^ codePoint		ifNotNil: [codePoint asCharacter].! !!XMLStreamConverter class methodsFor: 'defaults'!abstractClass	^ XMLStreamConverter! !!XMLStreamConverter class methodsFor: 'basic'!basicByteOrderMarkBytes	^ #[]! !!XMLStreamConverter class methodsFor: 'basic'!basicCanConvertEncoding: anEncodingName	^ self encodingNames includes: anEncodingName! !!XMLStreamConverter class methodsFor: 'basic'!basicEncodingNames	"encodingNames will have these names + upper/lowercase versions"	^ #()! !!XMLStreamConverter class methodsFor: 'accessing'!byteOrderMark	"avoid #asString and #newFrom: for GS portability"	^ String streamContents: [:stream |		self byteOrderMarkBytes do: [:each |			stream nextPut: each asCharacter]]! !!XMLStreamConverter class methodsFor: 'accessing'!byteOrderMarkBytes	^ self basicByteOrderMarkBytes asByteArray! !!XMLStreamConverter class methodsFor: 'testing'!canConvertEncoding: anEncodingName	"Returns true if the receiver can decode the encoding anEncodingName.	Lookup is case-insensitive."	"we could remove whitespace from anEncodingName too, but the	production rule for <?xml ...?> 'encoding' attributes disallows	whitespace, and the HTML parser removes it from <meta> charset	attributes before converting, so we just convert it to lowercase"	^ self isAbstractClass not		and: [self basicCanConvertEncoding: anEncodingName asLowercase]! !!XMLStreamConverter class methodsFor: 'accessing'!classForEncoding: anEncodingName	"avoid #at:ifAbsent: and #at:ifAbsentPut: so the cache isn't locked	during the class lookup, which could stall other processes"	self encodingNamesAndClassesCache		at: anEncodingName		ifPresent: [:classForEncoding | ^ classForEncoding].	"this will store the class as nil if it wasn't found to prevent future lookup"	^ self encodingNamesAndClassesCache		at: anEncodingName		put: (self findClassForEncoding: anEncodingName).! !!XMLStreamConverter class methodsFor: 'convenience'!decode: aStringOrByteArray	^ self new decode: aStringOrByteArray! !!XMLStreamConverter class methodsFor: 'convenience'!decodingOn: aReadStream	^ self new decodingOn: aReadStream! !!XMLStreamConverter class methodsFor: 'instance creation'!default	^ self defaultClass new! !!XMLStreamConverter class methodsFor: 'defaults'!defaultClass	^ XMLImplicitUTF8StreamConverter! !!XMLStreamConverter class methodsFor: 'defaults'!defaultEncoding	^ self defaultClass primaryEncodingName! !!XMLStreamConverter class methodsFor: 'convenience'!encode: aString	^ self new encode: aString! !!XMLStreamConverter class methodsFor: 'accessing'!encodingNames	^ encodingNames		ifNil: [			"assign the fully initialized object with #yourself to avoid			possible race conditions when reinitialization the class"			encodingNames :=				Set new					addAll: self basicEncodingNames;					addAll:						(self basicEncodingNames collect: [:each | each asLowercase]);					addAll:						(self basicEncodingNames collect: [:each | each asUppercase]);					yourself]! !!XMLStreamConverter class methodsFor: 'accessing'!encodingNames: aCollectionOrNil	encodingNames :=		aCollectionOrNil			ifNotNil: [aCollectionOrNil asSet]! !!XMLStreamConverter class methodsFor: 'private'!encodingNamesAndClassesCache	"a class variable so it's shared by all subclasses, but lazy initialized	so it isn't initialized unless needed"	^ EncodingNamesAndClassesCache		ifNil: [EncodingNamesAndClassesCache := XMLKeyValueCache maxSize: 128]! !!XMLStreamConverter class methodsFor: 'convenience'!encodingOn: aReadStream	^ self new encodingOn: aReadStream! !!XMLStreamConverter class methodsFor: 'private'!findClassForEncoding: anEncodingName	"check preferred classes first"	self preferredClasses do: [:each |		(each canConvertEncoding: anEncodingName)			ifTrue: [^ each]].	"avoid #withAllSubclassesDo: because it does not enumerate the receiver first"	(self isNonPreferredClassForEncoding: anEncodingName)		ifTrue: [^ self].	self allSubclassesDo: [:each |		(each isNonPreferredClassForEncoding: anEncodingName)			ifTrue: [^ each]].	^ nil.! !!XMLStreamConverter class methodsFor: 'class initialization'!initialize	"self initialize"	PreferredClasses := nil.	"reset to nil instead of just clearing to get full reinitialization"	EncodingNamesAndClassesCache := nil.! !!XMLStreamConverter class methodsFor: 'testing'!isAbstractClass	^ self == self abstractClass! !!XMLStreamConverter class methodsFor: 'testing'!isDefaultClass	^ self == self defaultClass! !!XMLStreamConverter class methodsFor: 'testing'!isImplicit	^ false! !!XMLStreamConverter class methodsFor: 'testing'!isNonPreferredClassForEncoding: anEncoding	^ self isPreferredClass not		and: [self canConvertEncoding: anEncoding]! !!XMLStreamConverter class methodsFor: 'testing'!isPreferredClass	^ self preferredClasses includes: self! !!XMLStreamConverter class methodsFor: 'instance creation'!newForEncoding: anEncodingName	(self classForEncoding: anEncodingName)		ifNil: [^ self null]		ifNotNil: [:converterClass |			^ converterClass new initializeForEncoding: anEncodingName]! !!XMLStreamConverter class methodsFor: 'instance creation'!null	^ self nullClass new! !!XMLStreamConverter class methodsFor: 'defaults'!nullClass	^ XMLNullStreamConverter! !!XMLStreamConverter class methodsFor: 'accessing'!preferredClasses	"A class var because it should be shared by all subclasses.	Assign the fully initialized object with #yourself to avoid	possible race conditions when reinitialization the class."	^ PreferredClasses		ifNil: [			PreferredClasses :=				IdentitySet new					addAll:						(XMLUTFStreamConverter allSubclasses reject: [:each |							each isAbstractClass								or: [each isImplicit]]);					add: XMLLatin1StreamConverter;					add: XMLASCIIStreamConverter;					yourself]! !!XMLStreamConverter class methodsFor: 'accessing'!preferredClasses: aCollectionOrNil	PreferredClasses :=		aCollectionOrNil			ifNotNil: [aCollectionOrNil asSet]! !!XMLStreamConverter class methodsFor: 'accessing'!primaryEncodingName	^ self basicEncodingNames		at: 1		ifAbsent: ['']! !!XMLStreamConverter methodsFor: 'converting'!asXMLStreamConverter	^ self! !!XMLStreamConverter methodsFor: 'convenience'!decode: aStringOrByteArray	^ (XMLDecodingReadStreamAdapter		on: aStringOrByteArray readStream		streamConverter: self)			contents! !!XMLStreamConverter methodsFor: 'convenience'!decodingOn: aReadStream	^ XMLDecodingReadStreamAdapter		on: aReadStream		streamConverter: self! !!XMLStreamConverter methodsFor: 'convenience'!encode: aString	^ (self encodingOn: (ByteArray new: aString size) writeStream)		nextPutAll: aString;		contents! !!XMLStreamConverter methodsFor: 'accessing'!encoding	^ self class primaryEncodingName! !!XMLStreamConverter methodsFor: 'convenience'!encodingOn: aWriteStream	^ (XMLEncodingWriteStreamAdapter		on: aWriteStream		streamConverter: self)			nextPutByteOrderMark;			yourself! !!XMLStreamConverter methodsFor: 'private'!errorBadCharacterEncoding	XMLEncodingException		formatSignal: 'Invalid {1} encoding for character'		with: self encoding! !!XMLStreamConverter methodsFor: 'private'!errorBadCharacterValue: aValue	XMLEncodingException		formatSignal: 'Invalid character 0x{1} for {2} encoding'		with: aValue printStringHex		with: self encoding! !!XMLStreamConverter methodsFor: 'initialization'!initializeForEncoding: anEncodingName! !!XMLStreamConverter methodsFor: 'testing'!isDefault	^ self class isDefaultClass! !!XMLStreamConverter methodsFor: 'testing'!isImplicit	^ self class isImplicit! !!XMLStreamConverter methodsFor: 'testing'!isNull	^ false! !!XMLStreamConverter methodsFor: 'decoding'!nextFromStream: aStream	self subclassResponsibility! !!XMLStreamConverter methodsFor: 'encoding'!nextPut: aCharacter toStream: aStream	self subclassResponsibility! !!XMLStreamConverter methodsFor: 'encoding'!nextPutByteOrderMarkToStream: aStream	self class byteOrderMarkBytes do: [:each |		aStream nextPut: each]! !!XMLStreamConverter methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		nextPutAll: self encoding;		nextPut: $).! !!XMLStreamConverter methodsFor: 'printing'!printWithConvertableStream: aConvertableStream on: aPrintStream	aPrintStream		print: self;		nextPut: $(;		print: aConvertableStream;		nextPut: $)! !!XMLZincByteEncoderStreamConverter class methodsFor: 'basic'!basicCanConvertEncoding: anEncodingName	^ XMLClassFinder		classNamed: #ZnByteEncoder		ifPresent: [:zincByteEncoderClass |			zincByteEncoderClass handlesEncoding: anEncodingName]		ifAbsent: [false]! !!XMLZincByteEncoderStreamConverter class methodsFor: 'class initialization'!initialize	"self initialize"	NullReadStream := XMLNullReadStream new! !!XMLZincByteEncoderStreamConverter methodsFor: 'initialization'!initializeForEncoding: anEncodingName	zincByteEncoder :=		(XMLClassFinder classNamed: #ZnByteEncoder) newForEncoding: anEncodingName.	"we use an XMLStringReadStreamAdapter to transparently handle non-binary	character streams for ZnByteEncoder, which exepcts binary streams, and	since it's only ever set to a non-null stream during #nextFromStream:,	instances can still be shared by multiple streams, just not re-entrently,	which is OK since this class is explicitly stateful and so not	automatically thread-safe."	stringReadStreamAdapter :=		XMLStringReadStreamAdapter on: NullReadStream.! !!XMLZincByteEncoderStreamConverter methodsFor: 'decoding'!nextFromStream: aStream	"ZnByteEncoder does not check for #atEnd before sending #next"	aStream atEnd		ifTrue: [^ nil]		ifFalse: [| nextChar |			nextChar :=				zincByteEncoder nextFromStream:					(stringReadStreamAdapter on: aStream).			stringReadStreamAdapter on: NullReadStream.			^ nextChar]! !!XMLZincByteEncoderStreamConverter methodsFor: 'encoding'!nextPut: aCharacter toStream: aStream	zincByteEncoder		nextPut: aCharacter		toStream: aStream! !!XMLContentState methodsFor: 'testing'!isContentState	^ true! !!XMLContentState methodsFor: 'tokenizing'!nextTokenFrom: aTokenizer	^ aTokenizer nextContentToken! !!XMLExternalSubsetState methodsFor: 'testing'!isExternalSubsetState	^ true! !!XMLExternalSubsetState methodsFor: 'tokenizing'!nextTokenFrom: aTokenizer	^ aTokenizer nextExternalSubsetToken! !!XMLExternalSubsetTextDeclarationState methodsFor: 'tokenizing'!nextTokenFrom: aTokenizer	^ aTokenizer nextStartExternalSubset! !!XMLExternalSubsetTextDeclarationState methodsFor: 'testing'!supportsEncodingDetection	^ true! !!XMLDoctypeDeclarationState methodsFor: 'testing'!isDoctypeDeclarationState	^ true! !!XMLInternalSubsetState methodsFor: 'testing'!isInternalSubsetState	^ true! !!XMLInternalSubsetState methodsFor: 'tokenizing'!nextTokenFrom: aTokenizer	^ aTokenizer nextInternalSubsetToken! !!XMLPostDoctypeDeclarationState methodsFor: 'testing'!isPostDoctypeDeclarationState	^ true! !!XMLPrologState methodsFor: 'testing'!canTerminateInput	^ false! !!XMLPrologState methodsFor: 'testing'!isPrologState	^ true! !!XMLPrologState methodsFor: 'tokenizing'!nextTokenFrom: aTokenizer	^ aTokenizer nextPrologToken! !!XMLXMLDeclarationState methodsFor: 'testing'!isXMLDeclarationState	^ true! !!XMLXMLDeclarationState methodsFor: 'tokenizing'!nextTokenFrom: aTokenizer	^ aTokenizer nextXMLDeclarationOrPrologToken! !!XMLXMLDeclarationState methodsFor: 'testing'!supportsEncodingDetection	^ true! !!XMLTerminatedState methodsFor: 'testing'!isTerminatedState	^ true! !!XMLTerminatedState methodsFor: 'tokenizing'!nextTokenFrom: aTokenizer	^ aTokenizer nextEndDocument! !!XMLTokenizerState class methodsFor: 'accessing'!instance	^ instance		ifNil: [instance := self basicNew initialize]! !!XMLTokenizerState class methodsFor: 'instance creation'!new	"all subclasses are stateless and have a single, immutable, shared instance"	^ self instance! !!XMLTokenizerState methodsFor: 'testing'!canTerminateInput	^ true! !!XMLTokenizerState methodsFor: 'changing'!contentState	^ XMLContentState new! !!XMLTokenizerState methodsFor: 'changing'!doctypeDeclarationState	^ XMLDoctypeDeclarationState new! !!XMLTokenizerState methodsFor: 'changing'!externalSubsetState	^ XMLExternalSubsetState new! !!XMLTokenizerState methodsFor: 'changing'!internalSubsetState	^ XMLInternalSubsetState new! !!XMLTokenizerState methodsFor: 'testing'!isContentState	^ false! !!XMLTokenizerState methodsFor: 'testing'!isDoctypeDeclarationState	^ false! !!XMLTokenizerState methodsFor: 'testing'!isExternalSubsetState	^ false! !!XMLTokenizerState methodsFor: 'testing'!isInitializedState	^ true! !!XMLTokenizerState methodsFor: 'testing'!isInternalSubsetState	^ false! !!XMLTokenizerState methodsFor: 'testing'!isPostDoctypeDeclarationState	^ false! !!XMLTokenizerState methodsFor: 'testing'!isPrologState	^ false! !!XMLTokenizerState methodsFor: 'testing'!isTerminatedState	^ false! !!XMLTokenizerState methodsFor: 'testing'!isXMLDeclarationState	^ false! !!XMLTokenizerState methodsFor: 'tokenizing'!nextTokenFrom: aTokenizer	self subclassResponsibility! !!XMLTokenizerState methodsFor: 'changing'!postDoctypeDeclarationState	^ XMLPostDoctypeDeclarationState new! !!XMLTokenizerState methodsFor: 'changing'!prologState	^ XMLPrologState new! !!XMLTokenizerState methodsFor: 'testing'!supportsEncodingDetection	^ false! !!XMLTokenizerState methodsFor: 'changing'!terminatedState	^ XMLTerminatedState new! !!XMLUninitializedState methodsFor: 'testing'!isInitializedState	^ false! !!XMLUninitializedState methodsFor: 'tokenizing'!nextTokenFrom: aTokenizer	^ aTokenizer nextStartDocument! !!XMLURI class methodsFor: 'instance creation'!fromStream: aStream	"streams must be parsed eagerly (because the stream might be read from	or closed after), unlike strings"	^ self basicNew initialize parseURIStream: aStream! !!XMLURI class methodsFor: 'instance creation'!fromString: aString	^ self basicNew initialize uriString: aString! !!XMLURI class methodsFor: 'class initialization'!initialize	"self initialize"	"Assign the fully initialized object with #yourself to avoid	possible race conditions when reinitialization the class."	UnreservedCharacters :=		BitmapCharacterSet new			addRangeFrom: $a to: $z;			addRangeFrom: $A to: $Z;			addRangeFrom: $0 to: $9;			addAll: '-._~';			yourself! !!XMLURI class methodsFor: 'instance creation'!new	^ self fromString: ''! !!XMLURI class methodsFor: 'instance creation'!readFrom: aStringOrStream	aStringOrStream isStream		ifTrue: [^ self fromStream: aStringOrStream]		ifFalse: [^ self fromString: aStringOrStream]! !!XMLURI methodsFor: 'combining'!/ aURIOrURIString	"Returns the argument URI if it is absolute or the argument resolved in the	context of the receiver if it is relative, to do relative path resolution	or replace hosts, query strings, and other components."	^ self combinedWith: aURIOrURIString! !!XMLURI methodsFor: 'comparing'!= anObject	self == anObject		ifTrue: [^ true].	self species == anObject species		ifFalse: [^ false].	self scheme = anObject scheme		ifFalse: [^ false].	"#has* tests are used as an optimization to skip direclty comparing	components unless needed when doing so would require additional	decoding of the raw components"	self hasUserInfo		ifTrue: [			(anObject hasUserInfo				and: [self userInfo = anObject userInfo])				ifFalse: [^ false]]		ifFalse: [			anObject hasUserInfo				ifTrue: [^ false]].	self hasHost		ifTrue: [			(anObject hasHost				and: [self host = anObject host])				ifFalse: [^ false]]		ifFalse: [			anObject hasHost				ifTrue: [^ false]].	self port = anObject port		ifFalse: [^ false].	self hasPath		ifTrue: [			(anObject hasPath				and: [self pathSegments = anObject pathSegments])				ifFalse: [^ false]]		ifFalse: [			anObject hasPath				ifTrue: [^ false]].	self hasQuery		ifTrue: [			(anObject hasQuery				and: [self query = anObject query])				ifFalse: [^ false]]		ifFalse: [			anObject hasQuery				ifTrue: [^ false]].	self hasFragment		ifTrue: [			(anObject hasFragment				and: [self fragment = anObject fragment])				ifFalse: [^ false]]		ifFalse: [			anObject hasFragment				ifTrue: [^ false]].	^ true.! !!XMLURI methodsFor: 'private'!addRawDotPathSegment	self hasNonDirectoryPath		ifTrue: [self haveDirectoryPath]! !!XMLURI methodsFor: 'private'!addRawDoubleDotPathSegment	self hasPath		ifFalse: [^ self].	self hasRootPath		ifTrue: [self removeRawPathSegments]		ifFalse: [| hadAbsolutePath |			hadAbsolutePath := self hasAbsolutePath.			self hasDirectoryPath				ifTrue: [self removeLastRawPathSegment].			self hasPath				ifTrue: [					self removeLastRawPathSegment.					(self hasPath						or: [hadAbsolutePath])						ifTrue: [self haveDirectoryPath]]].! !!XMLURI methodsFor: 'private'!addRawPathSegment: aString	aString = '.'		ifTrue: [^ self addRawDotPathSegment].	aString = '..'		ifTrue: [^ self addRawDoubleDotPathSegment].	self hasPath		ifTrue: [			(self hasDirectoryPath				and: [self rawPathSegments size > 1])				ifTrue: [self removeLastRawPathSegment]]		ifFalse: [			self hasHost				ifTrue: [self rawPathSegments addLast: '']].	self rawPathSegments addLast: aString.! !!XMLURI methodsFor: 'private'!addRawPathSegmentsFrom: aURI	"copy before modifying"	self rawPathSegments: self rawPathSegments copy.	aURI hasAbsolutePath		ifTrue: [self removeRawPathSegments]		ifFalse: [			self hasNonDirectoryPath				ifTrue: [					self removeLastRawPathSegment.					self hasPath						ifTrue: [self haveDirectoryPath]]].	aURI rawPathSegments do: [:each | self addRawPathSegment: each].! !!XMLURI methodsFor: 'converting'!asRetrievableResource	^ self isLocal		ifTrue: [self asXMLFileHandle]		ifFalse: [self asXMLHTTPRequest]! !!XMLURI methodsFor: 'converting'!asString	"Returns the full, untruncated URI string, unlike #printString, which	may truncate"	^ self uriString		ifNil: [| writeStream |			writeStream := (String new: 64) writeStream.			self				printSchemeOn: writeStream;				printAuthorityPrefixOn: writeStream;				printAuthorityOn: writeStream;				printPathPrefixOn: writeStream;				printPathOn: writeStream;				printQueryOn: writeStream;				printFragmentOn: writeStream;				uriString: writeStream contents;				uriString]! !!XMLURI methodsFor: 'converting'!asXMLFileHandle	self isLocal		ifFalse: [self errorCannotConvertURIToFileHandle].	^ self path asXMLFileHandle.! !!XMLURI methodsFor: 'converting'!asXMLHTTPRequest	(self isHTTP		or: [self isHTTPS			or: [self isRelative]])		ifFalse: [self errorCannotConvertURIToHTTPRequest].	^ self asString asXMLHTTPRequest.! !!XMLURI methodsFor: 'converting'!asXMLURI	^ self! !!XMLURI methodsFor: 'combining'!combinedWith: aURIOrURIString	"Returns the argument URI if it is absolute or the argument resolved in the	context of the receiver if it is relative, to do relative path resolution	or replace hosts, query strings, and other components."	| uriToCombineWith |	(uriToCombineWith := aURIOrURIString asXMLURI) isEmpty		ifFalse: [			(uriToCombineWith isRelative)				ifTrue: [^ self combinedWithRelativeURI: uriToCombineWith]				ifFalse: [^ uriToCombineWith]]! !!XMLURI methodsFor: 'private'!combinedWithRelativeURI: aRelativeURI	| copy |	copy := self copy.	aRelativeURI hasUserInfo		ifTrue: [			^ copy				rawUserInfo: aRelativeURI rawUserInfo;				rawHost: aRelativeURI rawHost;				port: aRelativeURI port;				rawPathSegments: aRelativeURI rawPathSegments;				rawQuery: aRelativeURI rawQuery;				rawFragment: aRelativeURI rawFragment].	aRelativeURI hasHost		ifTrue: [			^ copy				rawHost: aRelativeURI rawHost;				port: aRelativeURI port;				rawPathSegments: aRelativeURI rawPathSegments;				rawQuery: aRelativeURI rawQuery;				rawFragment: aRelativeURI rawFragment].	aRelativeURI hasPort		ifTrue: [			^ copy				port: aRelativeURI port;				rawPathSegments: aRelativeURI rawPathSegments;				rawQuery: aRelativeURI rawQuery;				rawFragment: aRelativeURI rawFragment].	aRelativeURI hasPath		ifTrue: [			^ copy				addRawPathSegmentsFrom: aRelativeURI;				rawQuery: aRelativeURI rawQuery;				rawFragment: aRelativeURI rawFragment].	aRelativeURI hasQuery		ifTrue: [			^ copy				rawQuery: aRelativeURI rawQuery;				rawFragment: aRelativeURI rawFragment].	aRelativeURI hasFragment		ifTrue: [^ copy rawFragment: aRelativeURI rawFragment].! !!XMLURI methodsFor: 'copying'!copyWithFragment: aString	^ self copy rawFragment: (self percentEncode: aString)! !!XMLURI methodsFor: 'copying'!copyWithHost: aString	| copy |	copy := self copy.	(aString size > 0		and: [aString first == $[			and: [aString last == $]]])		ifTrue: [copy rawHost: aString]		ifFalse: [copy rawHost: (self percentEncode: aString)].	^ copy.! !!XMLURI methodsFor: 'copying'!copyWithPath: aString	| newRawPathSegments |	newRawPathSegments := self rawPathSegments copyEmpty.	$/		xmlSplit: aString		do: [:each |			newRawPathSegments addLast: (self percentEncode: each)].	^ self copy rawPathSegments: newRawPathSegments.! !!XMLURI methodsFor: 'copying'!copyWithPathSegments: aCollection	| newRawPathSegments |	newRawPathSegments := self rawPathSegments copyEmpty.	aCollection do: [:each |		newRawPathSegments addLast: (self percentEncode: each)].	^ self copy rawPathSegments: newRawPathSegments.! !!XMLURI methodsFor: 'copying'!copyWithPort: anInteger	^ self copy port: anInteger! !!XMLURI methodsFor: 'copying'!copyWithQuery: anAssociationCollection	| newRawQuery |	newRawQuery := OrderedCollection new: anAssociationCollection size.	anAssociationCollection associationsDo: [:each |		newRawQuery addLast:			(self percentAndPlusEncode: each key) ->				(self percentAndPlusEncode: each value)].	^ self copy rawQuery: newRawQuery.! !!XMLURI methodsFor: 'copying'!copyWithScheme: aString	^ self copy		scheme: aString;		hasAuthorityPrefix:			(self hasAuthorityPrefix				or: [self hasScheme not])! !!XMLURI methodsFor: 'copying'!copyWithUserInfo: aString	^ self copy rawUserInfo: (self percentEncode: aString)! !!XMLURI methodsFor: 'private'!errorCannotConvertURIToFileHandle	XMLFileException		formatSignal: 'Cannot convert non-local URI to file handle: {1}'		with: self asString! !!XMLURI methodsFor: 'private'!errorCannotConvertURIToHTTPRequest	XMLHTTPException		formatSignal: 'Cannot convert URI to HTTP request: {1}'		with: self asString! !!XMLURI methodsFor: 'accessing'!fragment	"Returns the percent-decoded URI fragment (everything after the '#') or	an empty string if there isn't one"	^ self percentDecode: self rawFragment! !!XMLURI methodsFor: 'resolving'!get	^ self asRetrievableResource get! !!XMLURI methodsFor: 'resolving'!getUpToLimit: aMaxSize decoding: aBoolean	^ self asRetrievableResource		getUpToLimit: aMaxSize		decoding: aBoolean! !!XMLURI methodsFor: 'testing'!hasAbsolutePath	^ self hasPath		and: [self rawPathSegments first isEmpty]! !!XMLURI methodsFor: 'testing'!hasAuthority	^ self hasUserInfo		or: [self hasHost			or: [self hasPort]]! !!XMLURI methodsFor: 'testing'!hasAuthorityPrefix	self parseURIStringIfUnparsed.	^ hasAuthorityPrefix.! !!XMLURI methodsFor: 'private'!hasAuthorityPrefix: aBoolean	hasAuthorityPrefix := aBoolean! !!XMLURI methodsFor: 'testing'!hasDirectoryPath	^ self hasPath		and: [self rawPathSegments last isEmpty]! !!XMLURI methodsFor: 'testing'!hasFragment	^ self rawFragment notEmpty! !!XMLURI methodsFor: 'testing'!hasHost	^ self rawHost notEmpty! !!XMLURI methodsFor: 'testing'!hasIPv6Host	^ self hasHost		and: [self rawHost first == $[			and: [self rawHost last == $]]]! !!XMLURI methodsFor: 'testing'!hasNonDirectoryPath	^ self hasPath		and: [self hasDirectoryPath not]! !!XMLURI methodsFor: 'testing'!hasPath	^ self rawPathSegments notEmpty! !!XMLURI methodsFor: 'testing'!hasPort	^ self port notNil! !!XMLURI methodsFor: 'testing'!hasQuery	^ self rawQuery notEmpty! !!XMLURI methodsFor: 'testing'!hasRootPath	^ self rawPathSegments size = 2		and: [self rawPathSegments allSatisfy: [:each | each isEmpty]]! !!XMLURI methodsFor: 'testing'!hasScheme	^ self scheme notEmpty! !!XMLURI methodsFor: 'testing'!hasUserInfo	^ self rawUserInfo notEmpty! !!XMLURI methodsFor: 'comparing'!hash	"ignores user-info and ports"	^ ((((self species hash bitXor:		self scheme hash) bitXor:			self host hash) bitXor:				self pathSegments hash) bitXor:					self query hash) bitXor:						self fragment hash! !!XMLURI methodsFor: 'private'!haveDirectoryPath	self hasPath		ifFalse: [self rawPathSegments addLast: ''].	self rawPathSegments addLast: ''.! !!XMLURI methodsFor: 'accessing'!host	"Returns the percent-decoded host or IPv6-style host or an empty string	if there isn't one"	self hasIPv6Host		ifTrue: [^ self rawHost]		ifFalse: [^ (self percentDecode: self rawHost) asLowercase]! !!XMLURI methodsFor: 'testing'!isEmpty	self hasScheme		ifTrue: [^ false].	self hasAuthority		ifTrue: [^ false].	self hasPath		ifTrue: [^ false].	self hasQuery		ifTrue: [^ false].	self hasFragment		ifTrue: [^ false].	^ true.! !!XMLURI methodsFor: 'testing'!isFile	^ self scheme = 'file'! !!XMLURI methodsFor: 'deprecated'!isFileURI	self deprecated: 'use #isFile instead'.	^ self isFile.! !!XMLURI methodsFor: 'testing'!isHTTP	^ self scheme = 'http'! !!XMLURI methodsFor: 'testing'!isHTTPS	^ self scheme = 'https'! !!XMLURI methodsFor: 'testing'!isLocal	^ self isFile		or: [self isRelative			and: [self hasHost not]]! !!XMLURI methodsFor: 'deprecated'!isLocalURI	self deprecated: 'use #isLocal instead'.	^ self isLocal.! !!XMLURI methodsFor: 'testing'!isRelative	^ self hasScheme not! !!XMLURI methodsFor: 'testing'!notEmpty	^ self isEmpty not! !!XMLURI methodsFor: 'private'!parseURIStream: aStream	| parser |	parser := XMLURIParser on: aStream.	self		scheme: parser parseScheme;		hasAuthorityPrefix: parser parseAuthorityPrefix.	(self hasScheme		or: [self hasAuthorityPrefix])		ifTrue: [			self				rawUserInfo: parser parseUserInfo;				rawHost: parser parseHost;				port: parser parsePort]		ifFalse: [			self				rawUserInfo: '';				rawHost: ''].	self		rawPathSegments: parser parsePathSegments;		rawQuery: parser parseQuery;		rawFragment: parser parseFragment.! !!XMLURI methodsFor: 'private'!parseURIStringIfUnparsed	scheme		ifNil: [self parseURIStream: self uriString readStream]! !!XMLURI methodsFor: 'accessing'!path	"Returns the percent-decoded path as a string"	self hasPath		ifTrue: [| writeStream |			writeStream := (String new: self rawPathSegments size * 10) writeStream.			self rawPathSegments				do: [:each | writeStream nextPutAll: (self percentDecode: each)]				separatedBy: [writeStream nextPut: $/].			^ writeStream contents]		ifFalse: [^ '']! !!XMLURI methodsFor: 'accessing'!pathSegments	"Returns a temporary OrderedCollection of percent-decoded path segments"	^ self rawPathSegments collect: [:each | self percentDecode: each]! !!XMLURI methodsFor: 'enumerating'!pathSegmentsDo: aBlock	self rawPathSegments do: [:each |		aBlock value: (self percentDecode: each)]! !!XMLURI methodsFor: 'private'!percentAndPlusDecode: aString	| readStream writeStream |	((aString includes: $%)		or: [aString includes: $+])		ifFalse: [^ aString].	readStream := aString readStream.	writeStream := (String new: aString size) writeStream.	[readStream atEnd]		whileFalse: [			readStream peek == $%				ifTrue: [					self						percentDecodeNextFrom: readStream						on: writeStream]				ifFalse: [| nextChar |					(nextChar := readStream next) == $+						ifTrue: [writeStream nextPut: Character space]						ifFalse: [writeStream nextPut: nextChar]]].	^ writeStream contents.! !!XMLURI methodsFor: 'private'!percentAndPlusEncode: aString	| writeStream |	writeStream := (String new: aString size) writeStream.	"use #to:do: for speed"	1 to: aString size do: [:i | | nextChar |		(UnreservedCharacters includes: (nextChar := aString at: i))			ifTrue: [					nextChar asciiValue = 32 "Character space asciiValue"					ifTrue: [writeStream nextPut: $+]					ifFalse: [writeStream nextPut: nextChar]]			ifFalse: [				(XMLEncodingWriteStreamAdapter on:					(XMLPercentEncodingWriteStreamAdapter on: writeStream))						nextPut: nextChar]].	^ writeStream contents.! !!XMLURI methodsFor: 'private'!percentDecode: aString	| readStream writeStream |	(aString includes: $%)		ifFalse: [^ aString].	readStream := aString readStream.	writeStream := (String new: aString size) writeStream.	[readStream atEnd]		whileFalse: [			readStream peek == $%				ifTrue: [					self						percentDecodeNextFrom: readStream						on: writeStream]				ifFalse: [writeStream nextPut: readStream next]].	^ writeStream contents.! !!XMLURI methodsFor: 'private'!percentDecodeNextFrom: aReadStream on: aWriteStream	| readStreamAdapter |	readStreamAdapter :=		XMLDecodingReadStreamAdapter			on: (XMLPercentDecodingReadStreamAdapter on: aReadStream).	[readStreamAdapter atEnd]		whileFalse: [aWriteStream nextPut: readStreamAdapter next].! !!XMLURI methodsFor: 'private'!percentEncode: aString	| writeStream |	writeStream := (String new: aString size) writeStream.	"use #to:do: for speed"	1 to: aString size do: [:i | | nextChar |		(UnreservedCharacters includes: (nextChar := aString at: i))			ifTrue: [writeStream nextPut: nextChar]			ifFalse: [				(XMLEncodingWriteStreamAdapter on:					(XMLPercentEncodingWriteStreamAdapter on: writeStream))					nextPut: nextChar]].	^ writeStream contents.! !!XMLURI methodsFor: 'accessing'!port	"Returns the integer port or nil if there isn't one"	self parseURIStringIfUnparsed.	^ port.! !!XMLURI methodsFor: 'private'!port: anInteger	port := anInteger! !!XMLURI methodsFor: 'copying'!postCopy	"the copyWith* methods modify copies, so any URI string of a copy must be parsed	if it hasn't been already and then cleared because it will be obsolete after a	URI component is changed"	self		parseURIStringIfUnparsed;		uriString: nil! !!XMLURI methodsFor: 'printing'!printAuthorityOn: aStream	self hasAuthority		ifTrue: [			self				printUserInfoOn: aStream;				printHostOn: aStream;				printPortOn: aStream]! !!XMLURI methodsFor: 'printing'!printAuthorityPrefixOn: aStream	(self hasAuthorityPrefix		or: [self hasScheme not and: [self hasAuthority]])		ifTrue: [aStream nextPutAll: '//']! !!XMLURI methodsFor: 'printing'!printFragmentOn: aStream	self hasFragment		ifTrue: [			aStream				nextPut: $#;				nextPutAll: self rawFragment]! !!XMLURI methodsFor: 'printing'!printHostOn: aStream	self hasHost		ifTrue: [aStream nextPutAll: self rawHost]! !!XMLURI methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: self asString! !!XMLURI methodsFor: 'printing'!printPathOn: aStream	self rawPathSegments		do: [:each | aStream nextPutAll: each]		separatedBy: [aStream nextPut: $/]! !!XMLURI methodsFor: 'printing'!printPathPrefixOn: aStream	(self hasPath		and: [self hasAbsolutePath not			and: [self hasScheme or: [self hasAuthority]]])		ifTrue: [aStream nextPut: $/]! !!XMLURI methodsFor: 'printing'!printPortOn: aStream	self hasPort		ifTrue: [			aStream nextPut: $:.			port printOn: aStream]! !!XMLURI methodsFor: 'printing'!printQueryOn: aStream	| atBeginning |	self hasQuery		ifFalse: [^ self].		aStream nextPut: $?.	atBeginning := true.	self rawQuery do: [:each |		atBeginning			ifTrue: [atBeginning := false]			ifFalse: [aStream nextPut: $&].		aStream			nextPutAll: each key;			nextPut: $=;			nextPutAll: each value].! !!XMLURI methodsFor: 'printing'!printSchemeOn: aStream	self hasScheme		ifTrue: [			aStream				nextPutAll: self scheme;				nextPut: $:]! !!XMLURI methodsFor: 'printing'!printUserInfoOn: aStream	self hasUserInfo		ifTrue: [			aStream				nextPutAll: self rawUserInfo;				nextPut: $@]! !!XMLURI methodsFor: 'accessing'!query	"Returns a temporary OrderedCollection of percent/plus-decoded	query string key=value pairs"	^ self rawQuery collect: [:each |		(self percentAndPlusDecode: each key) ->			(self percentAndPlusDecode: each value)]! !!XMLURI methodsFor: 'accessing'!queryAt: aKey	"Returns the last percent/plus-decoded value of the query string	parameter aKey or an empty string if there isn't one"	^ self		queryAt: aKey		ifAbsent: ['']! !!XMLURI methodsFor: 'accessing'!queryAt: aKey ifAbsent: aBlock	"Returns the first percent/plus-decoded value of the query string	parameter aKey or the value of aBlock if there isn't one"	self rawQuery do: [:each |		(self percentAndPlusDecode: each key) = aKey			ifTrue: [^ self percentAndPlusDecode: each value]].	^ aBlock value.! !!XMLURI methodsFor: 'testing'!queryIncludesKey: aKey	self		queryAt: aKey		ifAbsent: [^ false].	^ true.! !!XMLURI methodsFor: 'accessing'!queryKeys	"Returns a SequenceableCollection of the unique percent/plus-decoded	query string parameter keys"	| keys |	keys := OrderedCollection new: self rawQuery size.	self queryKeysDo: [:each |		keys addLast: each].	^ keys.! !!XMLURI methodsFor: 'enumerating'!queryKeysAndValuesDo: aTwoArgumentBlock	self rawQuery do: [:each |		aTwoArgumentBlock			value: (self percentAndPlusDecode: each key)			value: (self percentAndPlusDecode: each value)]! !!XMLURI methodsFor: 'enumerating'!queryKeysDo: aBlock	self rawQuery do: [:each |		aBlock value: (self percentAndPlusDecode: each key)]! !!XMLURI methodsFor: 'accessing'!queryValuesAt: aKey	"Returns the percent/plus-decoded values of the query string parameter	aKey or an empty collection if there aren't any"	^ self		queryValuesAt: aKey		ifAbsent: [OrderedCollection new]! !!XMLURI methodsFor: 'enumerating'!queryValuesAt: aKey do: aBlock	self queryKeysAndValuesDo: [:key :value |		key = aKey			ifTrue: [aBlock value: value]]! !!XMLURI methodsFor: 'accessing'!queryValuesAt: aKey ifAbsent: aBlock	"Returns the percent/plus-decoded values of the query string parameter	aKey or the value of aBlock if there aren't any"	| values |	self		queryValuesAt: aKey		do: [:each |			"only initialize if needed"			(values ifNil: [values := OrderedCollection new])				addLast: each].	^ values ifNil: [aBlock value].! !!XMLURI methodsFor: 'accessing'!rawFragment	"Returns the raw URI fragment (everything after the '#') without	percent-decoding or an empty string if there isn't one"	self parseURIStringIfUnparsed.	^ rawFragment.! !!XMLURI methodsFor: 'private'!rawFragment: aString	rawFragment := aString! !!XMLURI methodsFor: 'accessing'!rawHost	"Returns the raw host without percent-decoding or the IPv6-style host	or an empty string if there isn't one"	self parseURIStringIfUnparsed.	^ rawHost.! !!XMLURI methodsFor: 'private'!rawHost: aString	rawHost := aString! !!XMLURI methodsFor: 'accessing'!rawPathSegments	"Returns an OrderedCollection of raw path segments without	percent-decoding"	self parseURIStringIfUnparsed.	^ rawPathSegments.! !!XMLURI methodsFor: 'private'!rawPathSegments: aPathSegmentCollection	rawPathSegments := aPathSegmentCollection! !!XMLURI methodsFor: 'accessing'!rawQuery	"Returns an OrderedCollection of raw query string key=value pairs	without percent/plus-decoding"	self parseURIStringIfUnparsed.	^ rawQuery.! !!XMLURI methodsFor: 'private'!rawQuery: anOrderedCollection	rawQuery := anOrderedCollection! !!XMLURI methodsFor: 'accessing'!rawUserInfo	self parseURIStringIfUnparsed.	^ rawUserInfo.! !!XMLURI methodsFor: 'private'!rawUserInfo: aString	rawUserInfo := aString! !!XMLURI methodsFor: 'private'!removeLastRawPathSegment	^ self rawPathSegments removeLast! !!XMLURI methodsFor: 'private'!removeRawPathSegments	self rawPathSegments removeAll! !!XMLURI methodsFor: 'accessing'!scheme	"Returns the URI scheme or an empty string if there isn't one"	self parseURIStringIfUnparsed.	^ scheme.! !!XMLURI methodsFor: 'private'!scheme: aString	scheme := aString! !!XMLURI methodsFor: 'resolving'!streamGet	^ self asRetrievableResource streamGet! !!XMLURI methodsFor: 'resolving'!streamGetUpToLimit: aMaxSize decoding: aBoolean	^ self asRetrievableResource		streamGetUpToLimit: aMaxSize		decoding: aBoolean! !!XMLURI methodsFor: 'private'!uriString	^ uriString! !!XMLURI methodsFor: 'private'!uriString: aString	uriString := aString! !!XMLURI methodsFor: 'accessing'!userInfo	^ self percentDecode: self rawUserInfo! !!XMLUnparsedEntityValidator class methodsFor: 'instance creation'!unparsedEntities: anUnparsedEntityDictionary notations: aNotationDictionary	^ self new		setUnparsedEntities: anUnparsedEntityDictionary		notations: aNotationDictionary! !!XMLUnparsedEntityValidator methodsFor: 'private'!errorMultipleDeclarationsForNotation: aNotation	XMLValidationException		formatSignal: 'Multiple declarations for notation "{1}"'		with: aNotation! !!XMLUnparsedEntityValidator methodsFor: 'private'!errorMultipleNotationAttributesForElement: anElement	XMLValidationException		formatSignal: 'Element <{1}> has multiple NOTATION list attributes'		with: anElement! !!XMLUnparsedEntityValidator methodsFor: 'private'!errorUndeclaredNotation: aNotation inAttribute: anAttribute	XMLValidationException		formatSignal: 'Undeclared notation "{1}" in NOTATION (...) attribute "{2}"'		with: aNotation		with: anAttribute! !!XMLUnparsedEntityValidator methodsFor: 'private'!errorUndeclaredNotation: aNotation inEntity: anEntity	XMLValidationException		formatSignal: 'Undeclared notation "{1}" referenced by <!!ENTITY {2} ...> declaration'		with: aNotation		with: anEntity! !!XMLUnparsedEntityValidator methodsFor: 'private'!errorUndeclaredUnparsedEntityReference: anEntity inAttribute: anAttriubute	XMLValidationException		formatSignal: 'Undeclared unparsed entity "{1}" in "{2}" attribute'		with: anEntity		with: anAttriubute! !!XMLUnparsedEntityValidator methodsFor: 'testing'!hasNotationAttributeValidators	"direct access to avoid lazy initialization"	^ notationAttributeValidators notNil		and: [notationAttributeValidators notEmpty]! !!XMLUnparsedEntityValidator methodsFor: 'accessing'!notationAttributeValidators	^ notationAttributeValidators ifNil: [notationAttributeValidators := Dictionary new]! !!XMLUnparsedEntityValidator methodsFor: 'accessing'!notations	^ notations ifNil: [notations := Dictionary new]! !!XMLUnparsedEntityValidator methodsFor: 'initialization'!setUnparsedEntities: anUnparsedEntityDictionary notations: aNotationDictionary	unparsedEntities := anUnparsedEntityDictionary.	notations := aNotationDictionary.! !!XMLUnparsedEntityValidator methodsFor: 'accessing'!unparsedEntities	^ unparsedEntities ifNil: [unparsedEntities := Dictionary new]! !!XMLUnparsedEntityValidator methodsFor: 'validating'!validateEntityReference: anEntity inAttribute: anAttribute	(self unparsedEntities includesKey: anEntity)		ifFalse: [			self				errorUndeclaredUnparsedEntityReference: anEntity				inAttribute: anAttribute]! !!XMLUnparsedEntityValidator methodsFor: 'validating'!validateNotationAttributeDeclaration: aNotationAttributeValidator	| oldSize |	"checking size after is faster than includes:"	oldSize := self notationAttributeValidators size.	(self notationAttributeValidators		at: aNotationAttributeValidator element		put: aNotationAttributeValidator;		size) > oldSize		ifFalse: [			self errorMultipleNotationAttributesForElement:				aNotationAttributeValidator element].! !!XMLUnparsedEntityValidator methodsFor: 'validating'!validateNotationAttributeDeclarationDefaults	"this validation has to be delayed until the entire DTD	is processed so notation attributes can be declared before	the notations referenced in their enumeration list are"	self notationAttributeValidators valuesDo: [:validator |		validator allowedValues do: [:each |			(self notations includesKey: each)				ifFalse: [					self						errorUndeclaredNotation: each						inAttribute: validator attribute]]]! !!XMLUnparsedEntityValidator methodsFor: 'validating'!validateUnparsedEntityDeclarations	"this validation has to be delayed until the entire DTD	is processed so unparsed entities can be declared before	the notation they reference are"	self unparsedEntities valuesDo: [:each |		(self notations includesKey: each ndata)			ifFalse: [				self					errorUndeclaredNotation: each ndata					inEntity: each name]]! !!XMLAttributeDictionary methodsFor: 'converting'!asXMLAttributeDictionary	^ self! !!XMLAttributeDictionary methodsFor: 'accessing'!associationAtName: aQualifiedOrLocalName	^ self		associationAtName: aQualifiedOrLocalName		ifAbsent: [nil]! !!XMLAttributeDictionary methodsFor: 'accessing'!associationAtName: aQualifiedOrLocalName ifAbsent: aBlock	^ self		associationAt: aQualifiedOrLocalName		ifAbsent: [			aQualifiedOrLocalName xmlPrefixBeforeLocalName isEmpty				ifTrue: [					self keysDo: [:each |						(each isXMLQualifiedOrLocalName: aQualifiedOrLocalName)							ifTrue: [^ self associationAt: each]]].			aBlock value]! !!XMLAttributeDictionary methodsFor: 'accessing'!associationAtName: aQualifiedOrLocalName namespaceURI: aURI	^ self		associationAtName: aQualifiedOrLocalName		namespaceURI: aURI		ifAbsent: [nil]! !!XMLAttributeDictionary methodsFor: 'accessing'!associationAtName: aQualifiedOrLocalName namespaceURI: aURI ifAbsent: aBlock	| namePrefix |	(namePrefix := aQualifiedOrLocalName xmlPrefixBeforeLocalName) isEmpty		ifTrue: [			"aQualifiedOrLocalName has no prefix, so check for an			attribute with a matching local name and namespace URI"			self keysDo: [:each |				(each isXMLQualifiedOrLocalName: aQualifiedOrLocalName)					ifTrue: [| keyPrefix |						(keyPrefix := each xmlPrefixBeforeLocalName) isEmpty							ifTrue: [								"unprefixed attribute have no namespace URI"								aURI isEmpty									ifTrue: [^ self associationAt: each]]							ifFalse: [								(self resolvePrefix: keyPrefix) = aURI									ifTrue: [^ self associationAt: each]]]]]		ifFalse: [			"aQualifiedOrLocalName is a qualified name, look it up exactly"			(self resolvePrefix: namePrefix) = aURI				ifTrue: [					^ self						associationAt: aQualifiedOrLocalName						ifAbsent: aBlock]].	^ aBlock value.! !!XMLAttributeDictionary methodsFor: 'private'!at: aKey newPut: aValue	"should be identical to StandardOrderedDictionary>>#at:put: except	it returns a boolean to tell if the key is new"	| oldSize |	oldSize := dictionary size.	dictionary		at: aKey		put: aValue.	dictionary size > oldSize		ifTrue: [			orderedKeys size > oldSize				ifFalse: [self growOrderedKeys].			orderedKeys at: oldSize + 1 put: aKey.			^ true].	^ false.! !!XMLAttributeDictionary methodsFor: 'accessing'!atName: aQualifiedOrLocalName	^ self		atName: aQualifiedOrLocalName		ifAbsent: ['']! !!XMLAttributeDictionary methodsFor: 'accessing'!atName: aQualifiedOrLocalName ifAbsent: aBlock	^ (self		associationAtName: aQualifiedOrLocalName		ifAbsent: [^ aBlock value])		ifNil: [aBlock value]		ifNotNil: [:association | association value]! !!XMLAttributeDictionary methodsFor: 'accessing'!atName: aQualifiedOrLocalName namespaceURI: aURI	^ self		atName: aQualifiedOrLocalName		namespaceURI: aURI		ifAbsent: ['']! !!XMLAttributeDictionary methodsFor: 'accessing'!atName: aQualifiedOrLocalName namespaceURI: aURI ifAbsent: aBlock	^ (self		associationAtName: aQualifiedOrLocalName		namespaceURI: aURI)		ifNil: [aBlock value]		ifNotNil: [:association | association value]! !!XMLAttributeDictionary methodsFor: 'private'!namespaceScope	^ nil! !!XMLAttributeDictionary methodsFor: 'accessing'!namespaceURIOf: aKey	"Returns the namespace URI of the attribute name aKey"	| prefix |	^ (self usesNamespaces		and: [(prefix := aKey xmlPrefixBeforeLocalName) notEmpty])		ifTrue: [self resolvePrefix: prefix]		ifFalse: ['']! !!XMLAttributeDictionary methodsFor: 'private'!resolvePrefix: aPrefix	^ self		resolvePrefix: aPrefix		ifUnresolvable: ''! !!XMLAttributeDictionary methodsFor: 'private'!resolvePrefix: aPrefix ifUnresolvable: aBlock	^ aBlock value! !!XMLAttributeDictionary methodsFor: 'initialization'!setNamespaceScope: aNamespaceScope! !!XMLAttributeDictionary methodsFor: 'testing'!usesNamespaces	^ false! !!XMLNamespacedAttributeDictionary methodsFor: 'private'!namespaceScope	^ namespaceScope ifNil: [namespaceScope := XMLNamespaceScope new]! !!XMLNamespacedAttributeDictionary methodsFor: 'private'!resolvePrefix: aPrefix ifUnresolvable: aBlock	^ self namespaceScope		resolvePrefix: aPrefix		ifUnresolvable: aBlock! !!XMLNamespacedAttributeDictionary methodsFor: 'initialization'!setNamespaceScope: aNamespaceScope	namespaceScope := aNamespaceScope! !!XMLNamespacedAttributeDictionary methodsFor: 'testing'!usesNamespaces	^ true! !!String methodsFor: '*XML-Parser'!asXMLEscapedString	"returns a copy of self with &, <, and > escaped with &amp;, &lt;, and &gt;"	| stream |	stream := (self class new: self size) writeStream.	"to:do: for performance"	1 to: self size do: [:i | | nextChar |		(nextChar := self at: i) == $<			ifTrue: [stream nextPutAll: '&lt;']			ifFalse: [				nextChar == $> "needed to escape ]]> in PCDATA"					ifTrue: [stream nextPutAll: '&gt;']					ifFalse: [						nextChar == $&							ifTrue: [stream nextPutAll: '&amp;']							ifFalse: [stream nextPut: nextChar]]]].	^ stream contents.! !!String methodsFor: '*XML-Parser'!asXMLFileHandle	^ XMLFileHandle path: self! !!String methodsFor: '*XML-Parser'!asXMLHTTPRequest	^ XMLHTTPRequest url: self! !!String methodsFor: '*XML-Parser'!asXMLStreamConverter	^ XMLStreamConverter newForEncoding: self! !!String methodsFor: '*XML-Parser'!asXMLString	"will be deprecated; use #asXMLStringNode instead"	^ self asXMLStringNode! !!String methodsFor: '*XML-Parser'!asXMLStringNode	^ XMLString string: self! !!String methodsFor: '*XML-Parser'!asXMLURI	^ XMLURI fromString: self! !!String methodsFor: '*XML-Parser'!expandWithXMLNamespaceURI: aURI	"optimized"	aURI size == 0		ifTrue: [^ self]		ifFalse: [^ 'Q{', aURI, '}', self]! !!String methodsFor: '*XML-Parser'!isXMLNCName	"optimized"	self size == 0		ifTrue: [^ false].	(self at: 1) isXMLNCNameStartChar		ifFalse: [^ false].	2 to: self size do: [:i |		(self at: i) isXMLNCNameChar			ifFalse: [^ false]].	^ true.! !!String methodsFor: '*XML-Parser'!isXMLNSAttributeName	"optimized"	self size >= 5		ifFalse: [^ false].	(self at: 1) == $x		ifFalse: [^ false].	(self at: 2) == $m		ifFalse: [^ false].	(self at: 3) == $l		ifFalse: [^ false].	(self at: 4) == $n		ifFalse: [^ false].	(self at: 5) == $s		ifFalse: [^ false].	self size == 5		ifTrue: [^ true].	^ (self at: 6) == $:.! !!String methodsFor: '*XML-Parser'!isXMLName	"optimized"	self size == 0		ifTrue: [^ false].	(self at: 1) isXMLNameStartChar		ifFalse: [^ false].	2 to: self size do: [:i |		(self at: i) isXMLNameChar			ifFalse: [^ false]].	^ true.! !!String methodsFor: '*XML-Parser'!isXMLNmtoken	"optimized"	self size == 0		ifTrue: [^ false].	1 to: self size do: [:i |		(self at: i) isXMLNameChar			ifFalse: [^ false]].	^ true.! !!String methodsFor: '*XML-Parser'!isXMLQualifiedOrLocalName: aQualifiedOrLocalName	"returns true if self and aQualifiedOrLocalName are the	same QName or if self is a QName and aQualifiedOrLocalName	is the local part, or if they are the same NCName."	| i |	i := aQualifiedOrLocalName size.	self size to: 1 by: -1 do: [:j |		i == 0			ifTrue: [^ (self at: j) == $:].		"avoid #== for compatibility with pre-Spur VMs where wide chars		aren't an immediate type"		(aQualifiedOrLocalName at: i) = (self at: j)			ifFalse: [^ false].		i := i - 1].	^ i == 0.! !!String methodsFor: '*XML-Parser'!isXMLReservedAttributeName	"optimized"	self size > 3		ifFalse: [^ false].	(self at: 1) == $x		ifFalse: [^ false].	(self at: 2) == $m		ifFalse: [^ false].	^ (self at: 3) == $l.! !!String methodsFor: '*XML-Parser'!isXMLWhitespace	"optimized"	self size == 0		ifTrue: [^ false].	1 to: self size do: [:i |		(self at: i) isXMLWhitespace			ifFalse: [^ false]].	^ true.! !!String methodsFor: '*XML-Parser'!parseXML	^ XMLDOMParser parse: self! !!String methodsFor: '*XML-Parser'!qualifyWithXMLPrefix: aPrefix	"optimized"	aPrefix size == 0		ifTrue: [^ self]		ifFalse: [^ (aPrefix copyWith: $:), self]! !!String methodsFor: '*XML-Parser'!xmlCopyWithoutWhitespace	^ self reject: [:each | each isXMLWhitespace]! !!String methodsFor: '*XML-Parser'!xmlLocalNameAfterPrefix	^ self xmlLocalNameAfterPrefix: self xmlPrefixBeforeLocalName! !!String methodsFor: '*XML-Parser'!xmlLocalNameAfterPrefix: aPrefix	"optimized"	| prefixSize |	(prefixSize := aPrefix size) == 0		ifTrue: [^ self]		ifFalse: [^ self copyFrom: prefixSize + 2 to: self size]! !!String methodsFor: '*XML-Parser'!xmlPrefixBeforeLocalName	"optimized"	| i |	i := self size.	[i == 0]		whileFalse: [			((self at: i) == $:)				ifTrue: [^ (self copyFrom: 1 to: i - 1)].			i := i - 1].	^ ''.! !!String methodsFor: '*XML-Parser'!xmlPrefixBeforeLocalName: aLocalName	"optimized"	| prefixSize |	(prefixSize := self size - aLocalName size - 1) > 0		ifTrue: [^ self copyFrom: 1 to: prefixSize]		ifFalse: [^ '']! !!UndefinedObject methodsFor: '*XML-Parser'!isXMLChar	"hack optimization to avoid testing for nil before sending	this to objects from streams in XMLParser"	^ false! !!UndefinedObject methodsFor: '*XML-Parser'!isXMLNCNameChar	"hack optimization to avoid testing for nil before sending	this to objects from streams in XMLParser"	^ false! !!UndefinedObject methodsFor: '*XML-Parser'!isXMLNCNameStartChar	"hack optimization to avoid testing for nil before sending	this to objects from streams in XMLParser"	^ false! !!UndefinedObject methodsFor: '*XML-Parser'!isXMLNameChar	"hack optimization to avoid testing for nil before sending	this to objects from streams in XMLParser"	^ false! !!UndefinedObject methodsFor: '*XML-Parser'!isXMLNameStartChar	"hack optimization to avoid testing for nil before sending	this to objects from streams in XMLParser"	^ false! !!UndefinedObject methodsFor: '*XML-Parser'!isXMLSeparator	"hack optimization to avoid testing for nil before sending	this to objects from streams in XMLParser"	^ false! !!UndefinedObject methodsFor: '*XML-Parser'!isXMLWhitespace	"hack optimization to avoid testing for nil before sending	this to objects from streams in XMLParser"	^ false! !!Character class methodsFor: '*XML-Parser'!xmlSeparators	^ String		with: 32 asCharacter "space"		with: 10 asCharacter "lf"		with: 9 asCharacter "tab"		with: 13 asCharacter "cr"! !!Character class methodsFor: '*XML-Parser'!xmlWhitespace	^ self xmlSeparators copyWith: 12 asCharacter "form feed"! !!Character methodsFor: '*XML-Parser'!isXMLChar	"Range tests are faster and use less memory than a BitmapCharacterSet, and	a temp is used because Character in newer SpurVM images has no 'value'	inst var.		Char ::=		#x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]"	| tempValue |	(tempValue := self asciiValue) >= 16r20		ifTrue: [			"most chars should be in the range 16r20-16rD7FF"			tempValue <= 16rD7FF				ifTrue: [^ true].				tempValue <= 16rFFFD				ifTrue: [^ tempValue >= 16rE000].			tempValue >= 16r10000				ifFalse: [^ false].			^ tempValue <= 16r10FFFF].	tempValue == 16r9		ifTrue: [^ true].	tempValue == 16rA		ifTrue: [^ true].	^ tempValue == 16rD.! !!Character methodsFor: '*XML-Parser'!isXMLNCNameChar	"should be the same as isXMLNameChar except without a test for $:"	| tempValue |	(tempValue := self asciiValue) <= 16r7A "$z asciiValue hex"		ifTrue: [			tempValue >= 16r61 "$a asciiValue hex"				ifTrue: [^ true].			tempValue >= 16r41 "$A asciiValue hex"				ifTrue: [					tempValue <= 16r5A "$Z asciiValue hex"						ifTrue: [^ true].					^ tempValue == 16r5F]. "$_ asciiValue hex"			tempValue >= 16r30 "$0 asciiValue hex"				ifTrue: [^ tempValue <= 16r39]. "$9 asciiValue hex; no $: test"			tempValue == 16r2D "$- asciiValue hex"				ifTrue: [^ true].			^ tempValue == 16r2E]. "$. asciiValue hex"	tempValue <= 16r2040		ifTrue: [			tempValue <= 16r36F				ifTrue: [						tempValue <= 16rF6						ifTrue: [							tempValue <= 16rD6								ifFalse: [^ tempValue >= 16rD8].							tempValue >= 16rC0								ifTrue: [^ true].							^ tempValue == 16rB7]						ifFalse: [							tempValue <= 16r2FF								ifTrue: [^ tempValue >= 16rF8].							^ tempValue >= 16r300]]				ifFalse: [					tempValue <= 16r1FFF						ifTrue: [								tempValue <= 16r37D								ifFalse: [^ tempValue >= 16r37F].							^ tempValue >= 16r370]						ifFalse: [							tempValue <= 16r200D								ifTrue: [^ tempValue >= 16r200C].							^ tempValue >= 16r203F]]]	ifFalse: [		tempValue <= 16rD7FF			ifTrue: [				tempValue >= 16r2C00					ifTrue: [						tempValue >= 16r3001							ifTrue: [^ true].						^ tempValue <= 16r2FEF]					ifFalse: [						tempValue <= 16r218F							ifFalse: [^ false].						^ tempValue >= 16r2070]]			ifFalse: [				tempValue <= 16rFFFD					ifTrue: [						tempValue <= 16rFDCF							ifTrue: [^ tempValue >= 16rF900].						^ tempValue >= 16rFDF0]					ifFalse: [						tempValue >= 16r10000							ifFalse: [^ false].						^ tempValue <= 16rEFFFF]]].! !!Character methodsFor: '*XML-Parser'!isXMLNCNameStartChar	"should be the same as isXMLNameStartChar except without a test for $:"	| tempValue |	(tempValue := self asciiValue) <= 16r7A "$z asciiValue hex"		ifTrue: [			tempValue >= 16r61 "$a asciiValue hex"				ifTrue: [^ true].			tempValue <= 16r5A "$Z asciiValue hex"				ifTrue: [^ tempValue >= 16r41]. "$A asciiValue hex"			^ tempValue == 16r5F]. "$_ asciiValue hex; no $: test"	tempValue <= 16r200D		ifTrue: [			tempValue <= 16r2FF				ifTrue: [					tempValue >= 16rD8						ifTrue: [							tempValue >= 16rF8								ifTrue: [^ true].							^ tempValue <= 16rF6]						ifFalse: [							tempValue >= 16rC0								ifFalse: [^ false].							^ tempValue <= 16rD6]]				ifFalse: [					tempValue >= 16r37F						ifTrue: [							tempValue >= 16r200C								ifTrue: [^ true].							^ tempValue <= 16r1FFF]						ifFalse: [							tempValue <= 16r37D								ifFalse: [^ false].							^ tempValue >= 16r370]]]	ifFalse: [		tempValue <= 16rD7FF			ifTrue: [				tempValue >= 16r2C00					ifTrue: [						tempValue >= 16r3001							ifTrue: [^ true].						^ tempValue <= 16r2FEF]					ifFalse: [						tempValue <= 16r218F							ifFalse: [^ false].						^ tempValue >= 16r2070]]			ifFalse: [				tempValue >= 16rFDF0					ifTrue: [						tempValue >= 16r10000							ifTrue: [^ tempValue <= 16rEFFFF].						^ tempValue <= 16rFFFD]					ifFalse: [						tempValue <= 16rFDCF							ifFalse: [^ false].						^ tempValue >= 16rF900]]].! !!Character methodsFor: '*XML-Parser'!isXMLNameChar	"Range tests are faster and use less memory than a BitmapCharacterSet, and	a temp is used because Character in newer SpurVM images has no 'value'	inst var.		NameStartChar ::=		':' | [A-Z] | '_' | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] |		[#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] |		[#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] |		[#x10000-#xEFFFF]	NameChar ::=		NameStartChar | '-' | '.' | [0-9] | #xB7 | [#x0300-#x036F] |		[#x203F-#x2040]"	| tempValue |	(tempValue := self asciiValue) <= 16r7A "$z asciiValue hex"		ifTrue: [			tempValue >= 16r61 "$a asciiValue hex"				ifTrue: [^ true].			tempValue >= 16r41 "$A asciiValue hex"				ifTrue: [					tempValue <= 16r5A "$Z asciiValue hex"						ifTrue: [^ true].					^ tempValue == 16r5F]. "$_ asciiValue hex"			tempValue >= 16r30 "$0 asciiValue hex"				ifTrue: [					tempValue <= 16r39 "$9 asciiValue hex"						ifTrue: [^ true].					^ tempValue == 16r3A]. "$: asciiValue hex"			tempValue == 16r2D "$- asciiValue hex"				ifTrue: [^ true].			^ tempValue == 16r2E]. "$. asciiValue hex"	tempValue <= 16r2040		ifTrue: [			tempValue <= 16r36F				ifTrue: [						tempValue <= 16rF6						ifTrue: [							tempValue <= 16rD6								ifFalse: [^ tempValue >= 16rD8].							tempValue >= 16rC0								ifTrue: [^ true].							^ tempValue == 16rB7]						ifFalse: [							tempValue <= 16r2FF								ifTrue: [^ tempValue >= 16rF8].							^ tempValue >= 16r300]]				ifFalse: [					tempValue <= 16r1FFF						ifTrue: [								tempValue <= 16r37D								ifFalse: [^ tempValue >= 16r37F].							^ tempValue >= 16r370]						ifFalse: [							tempValue <= 16r200D								ifTrue: [^ tempValue >= 16r200C].							^ tempValue >= 16r203F]]]	ifFalse: [		tempValue <= 16rD7FF			ifTrue: [				tempValue >= 16r2C00					ifTrue: [						tempValue >= 16r3001							ifTrue: [^ true].						^ tempValue <= 16r2FEF]					ifFalse: [						tempValue <= 16r218F							ifFalse: [^ false].						^ tempValue >= 16r2070]]			ifFalse: [				tempValue <= 16rFFFD					ifTrue: [						tempValue <= 16rFDCF							ifTrue: [^ tempValue >= 16rF900].						^ tempValue >= 16rFDF0]					ifFalse: [						tempValue >= 16r10000							ifFalse: [^ false].						^ tempValue <= 16rEFFFF]]].! !!Character methodsFor: '*XML-Parser'!isXMLNameStartChar	"Range tests are faster and use less memory than a BitmapCharacterSet, and	a temp is used because Character in newer SpurVM images has no 'value'	inst var.		NameStartChar ::=		':' | [A-Z] | '_' | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] |		[#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] |		[#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] |		[#x10000-#xEFFFF]"	| tempValue |	(tempValue := self asciiValue) <= 16r7A "$z asciiValue hex"		ifTrue: [			tempValue >= 16r61 "$a asciiValue hex"				ifTrue: [^ true].			tempValue >= 16r41 "$A asciiValue hex"				ifTrue: [					tempValue <= 16r5A "$Z asciiValue hex"						ifTrue: [^ true].					^ tempValue == 16r5F]. "$_ asciiValue hex"				^ tempValue == 16r3A]. "$: asciiValue hex"	tempValue <= 16r200D		ifTrue: [			tempValue <= 16r2FF				ifTrue: [					tempValue >= 16rD8						ifTrue: [							tempValue >= 16rF8								ifTrue: [^ true].							^ tempValue <= 16rF6]						ifFalse: [							tempValue >= 16rC0								ifFalse: [^ false].							^ tempValue <= 16rD6]]				ifFalse: [					tempValue >= 16r37F						ifTrue: [							tempValue >= 16r200C								ifTrue: [^ true].							^ tempValue <= 16r1FFF]						ifFalse: [							tempValue <= 16r37D								ifFalse: [^ false].							^ tempValue >= 16r370]]]	ifFalse: [		tempValue <= 16rD7FF			ifTrue: [				tempValue >= 16r2C00					ifTrue: [						tempValue >= 16r3001							ifTrue: [^ true].						^ tempValue <= 16r2FEF]					ifFalse: [						tempValue <= 16r218F							ifFalse: [^ false].						^ tempValue >= 16r2070]]			ifFalse: [				tempValue >= 16rFDF0					ifTrue: [						tempValue >= 16r10000							ifTrue: [^ tempValue <= 16rEFFFF].						^ tempValue <= 16rFFFD]					ifFalse: [						tempValue <= 16rFDCF							ifFalse: [^ false].						^ tempValue >= 16rF900]]].! !!Character methodsFor: '*XML-Parser'!isXMLSeparator	"a temp is used because Character in newer SpurVM images	has no 'value' inst var"	| tempValue |	(tempValue := self asciiValue) == 32 "space"		ifTrue: [^ true].	tempValue == 10 "line feed"		ifTrue: [^ true].	tempValue == 9 "tab"		ifTrue: [^ true].	^ tempValue == 13. "carriage return; no form feeds"! !!Character methodsFor: '*XML-Parser'!isXMLWhitespace	"a temp is used because Character in newer SpurVM images	has no 'value' inst var"	| tempValue |	(tempValue := self asciiValue) == 32 "space"		ifTrue: [^ true].	tempValue == 10 "line feed"		ifTrue: [^ true].	tempValue == 9 "tab"		ifTrue: [^ true].	tempValue == 13 "carriage return"		ifTrue: [^ true].	^ tempValue == 12. "form feed"! !!Character methodsFor: '*XML-Parser'!xmlSplit: aString	"faster, portable version"	| parts |	parts := OrderedCollection new.	self		xmlSplit: aString		do: [:each | parts addLast: each].	^ parts.! !!Character methodsFor: '*XML-Parser'!xmlSplit: aString do: aBlock	"faster, portable version"	| start |	start := 1.	1 to: aString size do: [:end |		"avoid #== for compatibility with pre-Spur VMs where wide chars		aren't an immediate type"		(aString at: end) = self			ifTrue: [				aBlock value: (aString copyFrom: start to: end - 1).				start := end + 1]].	start > aString size		ifTrue: [			"either aString is empty or it ends with self"			aBlock value: '']		ifFalse: [aBlock value: (aString copyFrom: start to: aString size)].! !!Error methodsFor: '*XML-Parser'!isXMLParserException	^ false! !!XMLException class methodsFor: 'signalling'!formatSignal: aString with: aFirstValue	^ self new		formatSignal: aString		with: aFirstValue! !!XMLException class methodsFor: 'signalling'!formatSignal: aString with: aFirstValue with: aSecondValue	^ self new		formatSignal: aString		with: aFirstValue		with: aSecondValue! !!XMLException class methodsFor: 'signalling'!formatSignal: aString with: aFirstValue with: aSecondValue with: aThirdValue	^ self new		formatSignal: aString		with: aFirstValue		with: aSecondValue		with: aThirdValue! !!XMLException class methodsFor: 'signalling'!formatSignal: aString with: aFirstValue with: aSecondValue with: aThirdValue with: aFourthValue	^ self new		formatSignal: aString		with: aFirstValue		with: aSecondValue		with: aThirdValue		with: aFourthValue! !!XMLException class methodsFor: 'signalling'!formatSignal: aString withArguments: anArray	^ self new		formatSignal: aString		withArguments: anArray! !!XMLException class methodsFor: 'signalling'!signalMessageFrom: anException	^ self new signalMessageFrom: anException! !!XMLException methodsFor: 'accessing'!formatMessage: aString with: aFirstValue	self		formatMessage: aString		withArguments: (Array with: aFirstValue)! !!XMLException methodsFor: 'accessing'!formatMessage: aString with: aFirstValue with: aSecondValue	self		formatMessage: aString		withArguments:			(Array				with: aFirstValue				with: aSecondValue)! !!XMLException methodsFor: 'accessing'!formatMessage: aString with: aFirstValue with: aSecondValue with: aThirdValue	self		formatMessage: aString		withArguments:			(Array				with: aFirstValue				with: aSecondValue				with: aThirdValue)! !!XMLException methodsFor: 'accessing'!formatMessage: aString with: aFirstValue with: aSecondValue with: aThirdValue with: aFourthValue	self		formatMessage: aString		withArguments:			(Array				with: aFirstValue				with: aSecondValue				with: aThirdValue				with: aFourthValue)! !!XMLException methodsFor: 'accessing'!formatMessage: aString withArguments: anArray	self messageText: (aString format: anArray)! !!XMLException methodsFor: 'signaling'!formatSignal: aString with: aFirstValue	self		formatMessage: aString		with: aFirstValue.	^ self signal.! !!XMLException methodsFor: 'signaling'!formatSignal: aString with: aFirstValue with: aSecondValue	self		formatMessage: aString		with: aFirstValue		with: aSecondValue.	^ self signal.! !!XMLException methodsFor: 'signaling'!formatSignal: aString with: aFirstValue with: aSecondValue with: aThirdValue	self		formatMessage: aString		with: aFirstValue		with: aSecondValue		with: aThirdValue.	^ self signal.! !!XMLException methodsFor: 'signaling'!formatSignal: aString with: aFirstValue with: aSecondValue with: aThirdValue with: aFourthValue	self		formatMessage: aString		with: aFirstValue		with: aSecondValue		with: aThirdValue		with: aFourthValue.	^ self signal.! !!XMLException methodsFor: 'signaling'!formatSignal: aString withArguments: anArray	self		formatMessage: aString		withArguments: anArray.	^ self signal.! !!XMLException methodsFor: 'accessing'!inheritMessageFrom: anException	self		formatMessage: '({1}) {2}'		with: anException class name		with: anException messageText! !!XMLException methodsFor: 'signaling'!signalMessageFrom: anException	self inheritMessageFrom: anException.	^  self signal.! !!XMLParserException methodsFor: 'accessing'!baseURI	^ baseURI ifNil: [baseURI := '']! !!XMLParserException methodsFor: 'accessing'!baseURI: aURIString	baseURI := aURIString! !!XMLParserException methodsFor: 'accessing'!columnNumber	^ columnNumber! !!XMLParserException methodsFor: 'accessing'!columnNumber: aColumnNumber	columnNumber := aColumnNumber! !!XMLParserException methodsFor: 'testing'!hasBaseURI	^ self baseURI notEmpty! !!XMLParserException methodsFor: 'testing'!hasColumnNumber	^ self columnNumber notNil! !!XMLParserException methodsFor: 'testing'!hasLineNumber	^ self lineNumber notNil! !!XMLParserException methodsFor: 'testing'!isXMLParserException	^ true! !!XMLParserException methodsFor: 'accessing'!lineNumber	^ lineNumber! !!XMLParserException methodsFor: 'accessing'!lineNumber: aLineNumber	lineNumber := aLineNumber! !!XMLParserException methodsFor: 'accessing'!messageText	| rawMessageText messageTextStream |	rawMessageText := super messageText.	(self hasLineNumber		or: [self hasBaseURI])		ifFalse: [^ rawMessageText].	(messageTextStream := (String new: rawMessageText size * 2) writeStream)		nextPutAll: rawMessageText;		nextPutAll: ' ('.	self hasLineNumber		ifTrue: [			messageTextStream				nextPutAll: 'near line ';				nextPutAll: self lineNumber asString.			self hasColumnNumber				ifTrue: [					messageTextStream						nextPutAll: ', column ';						nextPutAll: self columnNumber asString]].	self hasBaseURI		ifTrue: [			messageTextStream				nextPutAll:					(self hasLineNumber						ifTrue: [' in ']						ifFalse: ['in ']);				nextPutAll: self baseURI].				^ messageTextStream		nextPut: $);		contents.! !!XMLParserException methodsFor: 'testing'!shouldPassOnWhenCaught	^ true! !!XMLParsingInterruptException methodsFor: 'testing'!shouldPassOnWhenCaught	^ false! !!Stream methodsFor: '*XML-Parser'!isXMLBinaryOrExternalStream	^ self isBinary! !!Stream methodsFor: '*XML-Parser'!parseXML	^ XMLDOMParser parse: self! !!Collection methodsFor: '*XML-Parser'!asXMLAttributeDictionary	^ XMLAttributeDictionary newFrom: self! !!Collection methodsFor: '*XML-Parser'!asXMLAttributeSpec	^ XMLBasicAttributeSpec attributes: self! !!Collection methodsFor: '*XML-Parser'!includesXMLName: aName	"optimized with do: instead of anySatisfy:"	self do: [:each |		(aName isXMLQualifiedOrLocalName: each)			ifTrue: [^ true]].	^ false.! !!XMLLazyAttributeDictionary class methodsFor: 'private'!emptyAttributeDictionary	^ emptyAttributeDictionary! !!XMLLazyAttributeDictionary class methodsFor: 'private'!emptyAttributeDictionaryClass	^ XMLAttributeDictionary! !!XMLLazyAttributeDictionary class methodsFor: 'class initialization'!initialize	"self initialize"	self initializeEmptyAttributeDictionary! !!XMLLazyAttributeDictionary class methodsFor: 'class initialization'!initializeEmptyAttributeDictionary	"explictly initialized class inst vars are used for the empty	dictionaries to simplify class initialization (on GS) and to	speed up lazy dictionary instance creation"	emptyAttributeDictionary := self emptyAttributeDictionaryClass new! !!XMLLazyAttributeDictionary class methodsFor: 'instance creation'!new	^ self basicNew setAttributeDictionary: emptyAttributeDictionary! !!XMLLazyAttributeDictionary class methodsFor: 'instance creation'!new: aCapacity	^ self new! !!XMLLazyAttributeDictionary class methodsFor: 'instance creation'!newFrom: anAssociationCollection	^ self basicNew setAttributeDictionary:		(self emptyAttributeDictionaryClass newFrom:			anAssociationCollection)! !!XMLLazyAttributeDictionary class methodsFor: 'instance creation'!newFromPairs: aSequenceableCollection	^ self basicNew setAttributeDictionary:		(self emptyAttributeDictionaryClass newFromPairs:			aSequenceableCollection)! !!XMLLazyAttributeDictionary methodsFor: 'comparing'!= anObject	^ attributeDictionary = anObject! !!XMLLazyAttributeDictionary methodsFor: 'adding'!add: anAssociation	^ self copiedAttributeDictionary add: anAssociation! !!XMLLazyAttributeDictionary methodsFor: 'adding'!addAll: anAssociationCollection	^ self copiedAttributeDictionary addAll: anAssociationCollection! !!XMLLazyAttributeDictionary methodsFor: 'converting'!asXMLAttributeDictionary	^ self! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!associationAt: aKey	^ attributeDictionary associationAt: aKey! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!associationAt: aKey ifAbsent: aBlock	^ attributeDictionary		associationAt: aKey		ifAbsent: aBlock! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!associationAt: aKey ifPresent: aBlock	^ attributeDictionary		associationAt: aKey		ifPresent: aBlock! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!associationAtName: aQualifiedOrLocalName	^ attributeDictionary associationAtName: aQualifiedOrLocalName! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!associationAtName: aKey ifAbsent: aBlock	^ attributeDictionary		associationAtName: aKey		ifAbsent: aBlock! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!associationAtName: aQualifiedOrLocalName namespaceURI: aURI	^ attributeDictionary		associationAtName: aQualifiedOrLocalName		namespaceURI: aURI! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!associationAtName: aKey namespaceURI: aURI ifAbsent: aBlock	^ attributeDictionary		associationAtName: aKey		namespaceURI: aURI		ifAbsent: aBlock! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!associations	^ attributeDictionary associations! !!XMLLazyAttributeDictionary methodsFor: 'enumerating'!associationsDo: aBlock	attributeDictionary associationsDo: aBlock! !!XMLLazyAttributeDictionary methodsFor: 'enumerating'!associationsSelect: aBlock	^ self copyEmpty setAttributeDictionary:		(attributeDictionary associationsSelect: aBlock)! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!at: aKey	^ attributeDictionary at: aKey! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!at: aKey ifAbsent: aBlock	^ attributeDictionary		at: aKey		ifAbsent: aBlock! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!at: aKey ifAbsentPut: aBlock	^ self copiedAttributeDictionary		at: aKey		ifAbsentPut: aBlock! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!at: aKey ifPresent: aBlock	^ attributeDictionary		at: aKey		ifPresent: aBlock! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!at: aKey ifPresent: aPresentBlock ifAbsent: anAbsentBlock	^ attributeDictionary		at: aKey		ifPresent: aPresentBlock		ifAbsent: anAbsentBlock! !!XMLLazyAttributeDictionary methodsFor: 'private'!at: aKey newPut: aValue	"added to be consistent with XMLAttributeDictionary,	but it shouldn't be needed"	^ self copiedAttributeDictionary		at: aKey		newPut: aValue! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!at: aKey put: aValue	^ self copiedAttributeDictionary		at: aKey		put: aValue! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!atName: aQualifiedOrLocalName	^ attributeDictionary atName: aQualifiedOrLocalName! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!atName: aQualifiedOrLocalName ifAbsent: aBlock	^ attributeDictionary		atName: aQualifiedOrLocalName		ifAbsent: aBlock! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!atName: aQualifiedOrLocalName namespaceURI: aURI	^ attributeDictionary		atName: aQualifiedOrLocalName		namespaceURI: aURI! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!atName: aQualifiedOrLocalName namespaceURI: aURI ifAbsent: aBlock	^ attributeDictionary		atName: aQualifiedOrLocalName		namespaceURI: aURI		ifAbsent: aBlock! !!XMLLazyAttributeDictionary methodsFor: 'private'!attributeDictionary	^ attributeDictionary! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!capacity	^ attributeDictionary capacity! !!XMLLazyAttributeDictionary methodsFor: 'enumerating'!collect: aBlock	^ self copyEmpty setAttributeDictionary:		(attributeDictionary collect: aBlock)! !!XMLLazyAttributeDictionary methodsFor: 'private'!copiedAttributeDictionary	"replaces the shared, empty order-preserving dictionary with a new	mutable one ready for modification"	^ attributeDictionary == self emptyAttributeDictionary		ifTrue: [attributeDictionary := self copyEmptyAttributeDictionary]		ifFalse: [attributeDictionary]! !!XMLLazyAttributeDictionary methodsFor: 'copying'!copyEmpty	"Squeak and GS don't have Collection>>#copyEmpty, so it is	reimplemented for portability"	^ self species new! !!XMLLazyAttributeDictionary methodsFor: 'private'!copyEmptyAttributeDictionary	^ attributeDictionary copy! !!XMLLazyAttributeDictionary methodsFor: 'private'!dictionary	^ attributeDictionary dictionary! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!dictionaryClass	^ attributeDictionary dictionaryClass! !!XMLLazyAttributeDictionary methodsFor: 'enumerating'!do: aBlock	attributeDictionary do: aBlock! !!XMLLazyAttributeDictionary methodsFor: 'private'!emptyAttributeDictionary	^ self class emptyAttributeDictionary! !!XMLLazyAttributeDictionary methodsFor: 'comparing'!hash	^ attributeDictionary hash! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!identityIndexOfKey: aKey	^ attributeDictionary identityIndexOfKey: aKey! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!identityIndexOfKey: aKey ifAbsent: aBlock	^ attributeDictionary		identityIndexOfKey: aKey		ifAbsent: aBlock! !!XMLLazyAttributeDictionary methodsFor: 'testing'!includesAssociation: anAssociation	^ attributeDictionary includesAssociation: anAssociation! !!XMLLazyAttributeDictionary methodsFor: 'testing'!includesIdentity: anObject	^ attributeDictionary includesIdentity: anObject! !!XMLLazyAttributeDictionary methodsFor: 'testing'!includesKey: aKey	^ attributeDictionary includesKey: aKey! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!indexOfKey: aKey	^ attributeDictionary indexOfKey: aKey! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!indexOfKey: aKey ifAbsent: aBlock	^ attributeDictionary		indexOfKey: aKey		ifAbsent: aBlock! !!XMLLazyAttributeDictionary methodsFor: 'testing'!isDictionary	^ true! !!XMLLazyAttributeDictionary methodsFor: 'testing'!isEmpty	"Squeak's Collection>>#isEmpty is inefficient"	^ attributeDictionary isEmpty! !!XMLLazyAttributeDictionary methodsFor: 'testing'!isIdentityDictionary	^ attributeDictionary isIdentityDictionary! !!XMLLazyAttributeDictionary methodsFor: 'testing'!isOrderPreservingDictionary	^ true! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!keyAtIdentityValue: aValue	^ attributeDictionary keyAtIdentityValue: aValue! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!keyAtIdentityValue: aValue ifAbsent: aBlock	^ attributeDictionary		keyAtIdentityValue: aValue		ifAbsent: aBlock! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!keyAtIndex: anIndex	^ attributeDictionary keyAtIndex: anIndex! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!keyAtIndex: anIndex ifAbsent: aBlock	^ attributeDictionary		keyAtIndex: anIndex		ifAbsent: aBlock! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!keyAtValue: anObject	^ attributeDictionary keyAtValue: anObject! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!keyAtValue: anObject ifAbsent: aBlock	^ attributeDictionary		keyAtValue: anObject		ifAbsent: aBlock! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!keyForIdentity: anObject	^ attributeDictionary keyForIdentity: anObject! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!keys	^ attributeDictionary keys! !!XMLLazyAttributeDictionary methodsFor: 'enumerating'!keysAndValuesDo: aBlock	attributeDictionary keysAndValuesDo: aBlock! !!XMLLazyAttributeDictionary methodsFor: 'removing'!keysAndValuesRemove: aTwoArgumentBlock	self copiedAttributeDictionary keysAndValuesRemove: aTwoArgumentBlock! !!XMLLazyAttributeDictionary methodsFor: 'enumerating'!keysDo: aBlock	attributeDictionary keysDo: aBlock! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!keysSortedSafely	^ attributeDictionary keysSortedSafely! !!XMLLazyAttributeDictionary methodsFor: 'private'!namespaceScope	^ attributeDictionary namespaceScope! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!namespaceURIOf: aKey	^ attributeDictionary namespaceURIOf: aKey! !!XMLLazyAttributeDictionary methodsFor: 'private'!orderedKeys	^ attributeDictionary orderedKeys! !!XMLLazyAttributeDictionary methodsFor: 'copying'!postCopy	attributeDictionary == self emptyAttributeDictionary		ifFalse: [attributeDictionary := attributeDictionary copy]! !!XMLLazyAttributeDictionary methodsFor: 'printing'!printElementsOn: aStream	attributeDictionary printElementsOn: aStream! !!XMLLazyAttributeDictionary methodsFor: 'removing'!remove: anObject ifAbsent: aBlock	self shouldNotImplement! !!XMLLazyAttributeDictionary methodsFor: 'removing'!removeAll	attributeDictionary := self emptyAttributeDictionary! !!XMLLazyAttributeDictionary methodsFor: 'removing'!removeKey: aKey	^ self copiedAttributeDictionary removeKey: aKey! !!XMLLazyAttributeDictionary methodsFor: 'removing'!removeKey: aKey ifAbsent: aBlock	^ self copiedAttributeDictionary		removeKey: aKey		ifAbsent: aBlock! !!XMLLazyAttributeDictionary methodsFor: 'removing'!removeKeys: aKeyCollection	self copiedAttributeDictionary removeKeys: aKeyCollection! !!XMLLazyAttributeDictionary methodsFor: 'private'!resolvePrefix: aPrefix	^ attributeDictionary resolvePrefix: aPrefix! !!XMLLazyAttributeDictionary methodsFor: 'private'!resolvePrefix: aPrefix ifUnresolvable: aBlock	^ attributeDictionary		resolvePrefix: aPrefix		ifUnresolvable: aBlock! !!XMLLazyAttributeDictionary methodsFor: 'enumerating'!select: aBlock	^ self copyEmpty setAttributeDictionary:		(attributeDictionary select: aBlock)! !!XMLLazyAttributeDictionary methodsFor: 'initialization'!setAttributeDictionary: anAttributeDictionary	attributeDictionary := anAttributeDictionary! !!XMLLazyAttributeDictionary methodsFor: 'initialization'!setNamespaceScope: aNamespaceScope! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!size	^ attributeDictionary size! !!XMLLazyAttributeDictionary methodsFor: 'testing'!usesNamespaces	^ attributeDictionary usesNamespaces! !!XMLLazyAttributeDictionary methodsFor: 'accessing'!values	^ attributeDictionary values! !!XMLLazyAttributeDictionary methodsFor: 'enumerating'!valuesDo: aBlock	attributeDictionary valuesDo: aBlock! !!XMLLazyNamespacedAttributeDictionary class methodsFor: 'private'!emptyAttributeDictionaryClass	^ XMLNamespacedAttributeDictionary! !!XMLLazyNamespacedAttributeDictionary class methodsFor: 'class initialization'!initialize	"self initialize"	self initializeEmptyAttributeDictionary! !!XMLLazyNamespacedAttributeDictionary methodsFor: 'private'!copyEmptyAttributeDictionary	^ super copyEmptyAttributeDictionary setNamespaceScope: self namespaceScope! !!XMLLazyNamespacedAttributeDictionary methodsFor: 'private'!namespaceScope	^ namespaceScope		ifNil: [			namespaceScope :=				attributeDictionary == self emptyAttributeDictionary					ifTrue: [XMLNamespaceScope new]					ifFalse: [attributeDictionary namespaceScope]]! !!XMLLazyNamespacedAttributeDictionary methodsFor: 'initialization'!setNamespaceScope: aNamespaceScope	namespaceScope := aNamespaceScope! !!XMLNFAStateSet class methodsFor: 'instance creation'!new	^ self new: 5! !!XMLNFAStateSet class methodsFor: 'instance creation'!new: aCapacity	^ self basicNew initialize: aCapacity! !!XMLNFAStateSet class methodsFor: 'instance creation'!newFrom: aCollection	"for GS portability"	^ self withAll: aCollection! !!XMLNFAStateSet methodsFor: 'copying'!, aCollection	"GS doesn't define #, for non-Sequenceable collections"	^ self copy		addAll: aCollection;		yourself! !!XMLNFAStateSet methodsFor: 'comparing'!= anObject	self == anObject		ifTrue: [^ true].	(self species == anObject species		and: [self size = anObject size])		ifFalse: [^ false].	"use #do: instead of #allSatisfy: for speed"	self do: [:each |		(anObject includes: each)			ifFalse: [^ false]].	^ true.! !!XMLNFAStateSet methodsFor: 'adding'!add: aState	isAccepting		ifFalse: [isAccepting := aState isAccepting].	^ set add: aState.! !!XMLNFAStateSet methodsFor: 'converting'!asDFAState	^ self asDFAStateWithStateCache: nil! !!XMLNFAStateSet methodsFor: 'converting'!asDFAStateWithStateCache: aDFAStateCache	^ XMLDFAState		nfaStates: self		dfaStateCache: aDFAStateCache! !!XMLNFAStateSet methodsFor: 'accessing'!capacity	^ set capacity! !!XMLNFAStateSet methodsFor: 'enumerating'!do: aBlock	set do: aBlock! !!XMLNFAStateSet methodsFor: 'comparing'!hash	| hash |	hash := self species hash.	self size > 5		ifFalse: [			self do: [:each |				hash := hash bitXor: each hash]].	^ hash bitXor: self size hash.! !!XMLNFAStateSet methodsFor: 'testing'!includes: aState	^ set includes: aState! !!XMLNFAStateSet methodsFor: 'initialization'!initialize: aCapacity	set := IdentitySet new: aCapacity.	isAccepting := false.! !!XMLNFAStateSet methodsFor: 'testing'!isAccepting	^ isAccepting! !!XMLNFAStateSet methodsFor: 'testing'!isEmpty	"Squeak's Collection>>#isEmpty is inefficient"	^ self size = 0! !!XMLNFAStateSet methodsFor: 'copying'!postCopy	set := set copy! !!XMLNFAStateSet methodsFor: 'removing'!remove: aState ifAbsent: aBlock	set		remove: aState		ifAbsent: [^ aBlock value].	isAccepting		ifTrue: [isAccepting := set anySatisfy: [:each | each isAccepting]].	^ aState.! !!XMLNFAStateSet methodsFor: 'removing'!removeAll	"Redefined because Collection>>#removeAll assumes the collection can	be safely modified while iterating it with #do:, and 'set removeAll'	is not used because GS's Set/IdentitySet don't implement it"	self initialize: self capacity! !!XMLNFAStateSet methodsFor: 'private'!set	^ set! !!XMLNFAStateSet methodsFor: 'accessing'!size	^ set size! !!XMLAttributeList class methodsFor: 'instance creation'!new	^ self new: 5! !!XMLAttributeList methodsFor: 'adding'!addAttributeAssociation: anAssociation	^ self		addAttributeName: anAssociation key		value: anAssociation value! !!XMLAttributeList methodsFor: 'adding'!addAttributeName: aName value: aValue	^ self addLast:		(self attributeClass			name: aName			value: aValue)! !!XMLAttributeList methodsFor: 'private'!afterAdding: aNode at: anIndex	(self		removeDuplicateOf: aNode		notAt: anIndex)		ifNotNil: [:duplicate |			duplicate = aNode				ifTrue: [^ self]].	observer		ifNotNil: [observer addedAttribute: aNode].! !!XMLAttributeList methodsFor: 'private'!afterAddingLast: aNode	(self		removeDuplicateOf: aNode		notAt: self size)		ifNotNil: [:duplicate |			duplicate = aNode				ifTrue: [^ self]].	observer		ifNotNil: [observer addedAttribute: aNode].! !!XMLAttributeList methodsFor: 'private'!afterAddingToCopyLast: aNode	observer		ifNotNil: [observer addedAttribute: aNode]! !!XMLAttributeList methodsFor: 'private'!afterRemoving: aNode	observer		ifNotNil: [observer removedAttribute: aNode].! !!XMLAttributeList methodsFor: 'converting'!asDictionary	^ self attributes! !!XMLAttributeList methodsFor: 'accessing'!attributeAssociations	^ self collect: [:each | each name -> each value]! !!XMLAttributeList methodsFor: 'accessing'!attributeAt: aName	^ self attributeValueAt: aName! !!XMLAttributeList methodsFor: 'accessing'!attributeAt: aName ifAbsent: aBlock	^ self		attributeValueAt: aName		ifAbsent: aBlock! !!XMLAttributeList methodsFor: 'accessing'!attributeAt: aName ifAbsentPut: aBlock	^ self		attributeValueAt: aName		ifAbsentPut: aBlock! !!XMLAttributeList methodsFor: 'accessing'!attributeAt: aName put: aValue	^ self		attributeValueAt: aName		put: aValue! !!XMLAttributeList methodsFor: 'defaults'!attributeClass	"Can be overridden in subclasses to use a custom attribute class"	^ XMLAttribute! !!XMLAttributeList methodsFor: 'accessing'!attributeNames	^ self collect: [:each | each name]! !!XMLAttributeList methodsFor: 'enumerating'!attributeNamesAndValuesDo: aTwoArgumentBlock	self do: [:each |		aTwoArgumentBlock			value: each name			value: each value]! !!XMLAttributeList methodsFor: 'enumerating'!attributeNamesDo: aBlock	self do: [:each | aBlock value: each name]! !!XMLAttributeList methodsFor: 'accessing'!attributeNodeAt: aName	^ self		attributeNodeAt: aName		ifAbsent: [self defaultValue]! !!XMLAttributeList methodsFor: 'accessing'!attributeNodeAt: aName ifAbsent: aBlock	self do: [:each |		(each isNamed: aName)			ifTrue: [^ each]].	^ aBlock value.! !!XMLAttributeList methodsFor: 'accessing'!attributeNodeAt: aName namespaceURI: aURI	^ self		attributeNodeAt: aName		namespaceURI: aURI		ifAbsent: [self defaultValue]! !!XMLAttributeList methodsFor: 'accessing'!attributeNodeAt: aName namespaceURI: aURI ifAbsent: aBlock	self do: [:each |		((each isNamed: aName)			and: [each namespaceURI = aURI])			ifTrue: [^ each]].	^ aBlock value.! !!XMLAttributeList methodsFor: 'private'!attributeValueAt: aName	^ self		attributeValueAt: aName		ifAbsent: ['']! !!XMLAttributeList methodsFor: 'private'!attributeValueAt: aName ifAbsent: aBlock	| i |	^ (i := self indexOfAttributeValueAt: aName) > 0		ifTrue: [(self at: i) value]		ifFalse: [aBlock value]! !!XMLAttributeList methodsFor: 'private'!attributeValueAt: aName ifAbsentPut: aBlock	^ self		attributeValueAt: aName		ifAbsent: [			"use #addToCopyLast:, since we know it's not in the collection"			(self addToCopyLast:				(self attributeClass					name: aName					value: aBlock value)) value]! !!XMLAttributeList methodsFor: 'private'!attributeValueAt: aName put: aValue	| i |	(i := self indexOfAttributeValueAt: aName) > 0		ifTrue: [(self at: i) value: aValue]		ifFalse: [			"use #addToCopyLast: since we know it's not already in the collection"			self addToCopyLast:				(self attributeClass					name: aName					value: aValue)].	^ aValue.! !!XMLAttributeList methodsFor: 'accessing'!attributes	| dictionary |	dictionary := self attributesClass new: self size.	self do: [:each |		dictionary			at: each name			put: each value].	^ dictionary.! !!XMLAttributeList methodsFor: 'defaults'!attributesClass	"Can be overridden in subclasses to use a custom collection	class for #attributes to use when returning attribute associations"	^ OrderPreservingStringDictionary! !!XMLAttributeList methodsFor: 'private'!duplicateIndexOf: aNode notAt: anIndex	"like the superclass version, but it considers nodes with	the same name to be duplicates"	1 to: anIndex - 1 do: [:i | | node |		(node := collection at: i) name = aNode name			ifTrue: [^ i]].	anIndex + 1 to: collection size do: [:i | | node |		(node := collection at: i) name = aNode name			ifTrue: [^ i]].	^ 0.! !!XMLAttributeList methodsFor: 'testing'!includesAttribute: aName	^ (self indexOfAttributeValueAt: aName) > 0! !!XMLAttributeList methodsFor: 'testing'!includesAttributeNode: aName	self		attributeNodeAt: aName		ifAbsent: [^ false].	^ true.! !!XMLAttributeList methodsFor: 'testing'!includesAttributeNode: aName namespaceURI: aURI	self		attributeNodeAt: aName		namespaceURI: aURI		ifAbsent: [^ false].	^ true.! !!XMLAttributeList methodsFor: 'private'!indexOfAttributeValueAt: aName	"Returns the index of the attribute value with the exact name of aName"	"this needs to be fast, for #attributeValueAt:... methods, so	use #to:do: for speed"	1 to: collection size do: [:i | | node |		(node := collection at: i) name = aName			ifTrue: [^ i]].	^ 0.! !!XMLAttributeList methodsFor: 'removing'!removeAttribute: aName	^ (self removeAt: (self indexOfAttributeValueAt: aName)) value! !!XMLAttributeList methodsFor: 'removing'!removeAttribute: aName ifAbsent: aBlock	| i |	(i := self indexOfAttributeValueAt: aName) > 0		ifTrue: [^ (self removeAt: i) value]		ifFalse: [^ aBlock value].! !!XMLAttributeList methodsFor: 'notifying'!renamedAttribute: anAttribute from: anOldName to: aNewName	self		removeDuplicateOf: anAttribute		notAt: (self indexOf: anAttribute)! !!XMLAttributeList methodsFor: 'initialization'!setAttributes: anAssociationCollection	self removeAll.	anAssociationCollection associationsDo: [:each |		self addAttributeAssociation: each].! !!XMLAttributeList methodsFor: 'private'!setAttributesFromOrderPreservingDictionary: anOrderPreservingDictionary	"This should only be sent by DOM parsers/builders, not public API users"	| orderedKeys |	"Add the XMLAttributes in order directly to the collection to avoid	sending notifications that would do unneeded, costly namespace prefix	revalidation.	Use the internal #orderedKeys with #to:do: to create an inlined #keysDo:	without block closure overhead."	orderedKeys := anOrderPreservingDictionary orderedKeys.	1 to: anOrderPreservingDictionary size do: [:i | | key |		key := orderedKeys at: i.		collection addLast: 			(self attributeClass new				setName: key				value:					"use dictionary at:ifAbsent: for speed over at:"					(anOrderPreservingDictionary						at: key						ifAbsent: nil)				element: observer)].! !!XMLAttributeList methodsFor: 'sorting'!sort	self sort: [:a :b | a sortKey <= b sortKey]! !!XMLAttributeList methodsFor: 'private'!writeAttributesOn: aWriter	"use #to:do: with direct access for fast writing"	1 to: collection size do: [:i | | attribute |		attribute := collection at: i.		aWriter			writeAttributeName: attribute name			value: attribute value]! !!XMLAttributeList methodsFor: 'private'!writeCanonicalAttributesOn: aWriter	| sortedAttributes |	(sortedAttributes := self asArray) sort: [:a :b | | prefixOfA prefixOfB |		prefixOfA := a prefix.		prefixOfB := b prefix.		prefixOfA = prefixOfB			ifTrue: [				(a name xmlLocalNameAfterPrefix: prefixOfA)					<= (b name xmlLocalNameAfterPrefix: prefixOfB)]			ifFalse: [| uriOfA uriOfB |				"the namespace URI is the primary key and				the local name is the secondary key"				uriOfA := a resolvePrefix: prefixOfA.				uriOfB := b resolvePrefix: prefixOfB.				uriOfA < uriOfB					or: [						uriOfA = uriOfB							and: [								(a name xmlLocalNameAfterPrefix: prefixOfA)									<= (b name xmlLocalNameAfterPrefix: prefixOfB)]]]].	"use #to:do: for fast writing"	1 to: sortedAttributes size do: [:i | | attribute |		attribute := sortedAttributes at: i.		aWriter			writeAttributeName: attribute name			value: attribute value].! !!XMLCachingAttributeList methodsFor: 'private'!afterAdding: aNode at: anIndex	self attributeNodesByName		at: aNode name ifPresent: [:duplicate |			self				removeDuplicateOf: aNode				notAt: anIndex.			duplicate = aNode				ifTrue: [^ self]];		at: aNode name put: aNode.	observer		ifNotNil: [observer addedAttribute: aNode].! !!XMLCachingAttributeList methodsFor: 'private'!afterAddingLast: aNode	self attributeNodesByName		at: aNode name ifPresent: [:duplicate |			self				removeDuplicateOf: aNode				notAt: self size.			duplicate = aNode				ifTrue: [^ self]];		at: aNode name put: aNode.	observer		ifNotNil: [observer addedAttribute: aNode].! !!XMLCachingAttributeList methodsFor: 'private'!afterAddingToCopyLast: aNode	self attributeNodesByName		at: aNode name		put: aNode.	observer		ifNotNil: [observer addedAttribute: aNode].! !!XMLCachingAttributeList methodsFor: 'private'!afterRemoving: aNode	self attributeNodesByName removeKey: aNode name.	observer		ifNotNil: [observer removedAttribute: aNode].! !!XMLCachingAttributeList methodsFor: 'private'!attributeNodesByName	^ attributeNodesByName		ifNil: [attributeNodesByName := Dictionary new: self capacity]! !!XMLCachingAttributeList methodsFor: 'private'!attributeValueAt: aName ifAbsent: aBlock	^ (self attributeNodesByName		at: aName		ifAbsent: [^ aBlock value]) value! !!XMLCachingAttributeList methodsFor: 'private'!attributeValueAt: aName put: aValue	(self attributeNodesByName		at: aName		ifAbsent: [			"use #addToCopyLast: since we know it's not already in the collection"			self addToCopyLast:				(self attributeClass					name: aName					value: aValue).			^ aValue]) value: aValue.	^ aValue.! !!XMLCachingAttributeList methodsFor: 'defaults'!copyClass	"use the non-caching superclass for copies for performance"	^ XMLAttributeList! !!XMLCachingAttributeList methodsFor: 'testing'!includes: aNode	^ aNode isAttribute		and: [			(self attributeNodesByName				at: aNode name				ifAbsent: [^ false]) = aNode]! !!XMLCachingAttributeList methodsFor: 'testing'!includesAttribute: aName	^ self attributeNodesByName includesKey: aName! !!XMLCachingAttributeList methodsFor: 'private'!indexOfAttributeValueAt: aName	^ (self attributeNodesByName includesKey: aName)		ifTrue: [super indexOfAttributeValueAt: aName]		ifFalse: [0]! !!XMLCachingAttributeList methodsFor: 'removing'!removeAttribute: aName	^ (self remove: (self attributeNodesByName at: aName)) value! !!XMLCachingAttributeList methodsFor: 'removing'!removeAttribute: aName ifAbsent: aBlock	^ (self remove:		(self attributeNodesByName			at: aName			ifAbsent: [^ aBlock value])) value! !!XMLCachingAttributeList methodsFor: 'notifying'!renamedAttribute: anAttribute from: anOldName to: aNewName	self attributeNodesByName		removeKey: anOldName;		at: aNewName ifPresent: [:duplicate |			self				removeDuplicateOf: anAttribute				notAt: (self indexOf: anAttribute)];		at: aNewName put: anAttribute! !!XMLCachingAttributeList methodsFor: 'private'!setAttributesFromOrderPreservingDictionary: anOrderPreservingDictionary	"This should only be sent by DOM parsers/builders, not public API users"	| orderedKeys |	"Hack to reuse its internal dictionary for speed, which we will	modify the association values of. This is safe because the DOM	parser/builder will never use it again."	attributeNodesByName := anOrderPreservingDictionary dictionary.	"Add the XMLAttributes in order directly to the collection to avoid	sending notifications that would do unneeded, costly namespace prefix	revalidation and also replace the value in the attributeNodesByName	association with the new XMLAttribute.	Use the internal #orderedKeys with #to:do: to create an inlined #keysDo:	without block closure overhead."	orderedKeys := anOrderPreservingDictionary orderedKeys.	1 to: anOrderPreservingDictionary size do: [:i | | key association |		key := orderedKeys at: i.		"use associationAt:ifAbsent: for speed over associationAt:"		association :=			attributeNodesByName				associationAt: key				ifAbsent: nil.		"replace its string value with the new XMLAttribute"		association value:			(collection addLast: 				(self attributeClass new					setName: key					value: association value					element: observer))].! !!XMLInternalSubsetList methodsFor: 'private'!afterAdding: aNode at: anIndex	(aNode hasParentWithNodeList: self)		ifTrue: [			self				removeDuplicateOf: aNode				notAt: anIndex]		ifFalse: [			observer				ifNotNil: [observer addedNode: aNode]]! !!XMLInternalSubsetList methodsFor: 'private'!afterAddingLast: aNode	(aNode hasParentWithNodeList: self)		ifTrue: [			self				removeDuplicateOf: aNode				notAt: self size]		ifFalse: [			observer				ifNotNil: [observer addedNode: aNode]]! !!XMLInternalSubsetList methodsFor: 'private'!afterAddingToCopyLast: aNode	observer		ifNotNil: [observer addedNode: aNode]! !!XMLInternalSubsetList methodsFor: 'private'!afterRemoving: aNode	observer ifNotNil: [observer removedNode: aNode]! !!XMLInternalSubsetList methodsFor: 'sorting'!sort	self sort: [:a :b | a sortKey <= b sortKey]! !!XMLCachingNodeList methodsFor: 'private'!afterAdding: aNode at: anIndex	(aNode hasParentWithNodeList: self)		ifTrue: [			self				removeDuplicateOf: aNode				notAt: anIndex.			aNode isElement				ifTrue: [self rebuildCachedElements]]		ifFalse: [			aNode isElement				ifTrue: [					self						cacheElement: aNode						addedAt: anIndex].			observer				ifNotNil: [observer addedNode: aNode]]! !!XMLCachingNodeList methodsFor: 'private'!afterAddingLast: aNode	(aNode hasParentWithNodeList: self)		ifTrue: [			self				removeDuplicateOf: aNode				notAt: self size.			aNode isElement				ifTrue: [self rebuildCachedElements]]		ifFalse: [			aNode isElement				ifTrue: [self cacheElementAddedLast: aNode].			observer				ifNotNil: [observer addedNode: aNode]]! !!XMLCachingNodeList methodsFor: 'private'!afterAddingToCopyLast: aNode	aNode isElement		ifTrue: [self cacheElementAddedLast: aNode].	observer		ifNotNil: [observer addedNode: aNode].! !!XMLCachingNodeList methodsFor: 'private'!afterRemoving: aNode	aNode isElement		ifTrue: [self uncacheElement: aNode].	observer		ifNotNil: [observer removedNode: aNode].! !!XMLCachingNodeList methodsFor: 'private'!cacheElement: anElement addedAt: anIndex	anIndex = self size		ifTrue: [^ self cacheElementAddedLast: anElement].	(self findElementAfterIndex: anIndex)		ifNil: [self cachedElements addLast: anElement]		ifNotNil: [:elementAfter |			self cachedElements				add: anElement				before: elementAfter].	self		cachedElementsByNameAt: anElement name		add: anElement		beforeNextAfterIndex: anIndex.	anElement hasPrefix		ifTrue: [			self				cachedElementsByNameAt: anElement localName				add: anElement				beforeNextAfterIndex: anIndex].! !!XMLCachingNodeList methodsFor: 'private'!cacheElementAddedLast: anElement	self cachedElements addLast: anElement.	self		cachedElementsByNameAt: anElement name		addLast: anElement.	anElement hasPrefix		ifTrue: [			self				cachedElementsByNameAt: anElement localName				addLast: anElement].! !!XMLCachingNodeList methodsFor: 'private'!cachedElements	^ cachedElements ifNil: [cachedElements := OrderedCollection new]! !!XMLCachingNodeList methodsFor: 'private'!cachedElementsByName	^ cachedElementsByName ifNil: [cachedElementsByName := Dictionary new]! !!XMLCachingNodeList methodsFor: 'private'!cachedElementsByNameAt: aName add: anElement beforeNextAfterIndex: anIndex	| elementAfter elementsWithName |	(elementAfter :=		self			findElementAfterIndex: anIndex			named: aName)		ifNil: [			^ self				cachedElementsByNameAt: aName				addLast: anElement].	(elementsWithName := self cachedElementsByName at: aName) isCollection		ifTrue: [elementsWithName add: anElement before: elementAfter]		ifFalse: [			self cachedElementsByName				at: aName				put: (OrderedCollection with: anElement with: elementAfter)].! !!XMLCachingNodeList methodsFor: 'private'!cachedElementsByNameAt: aName addLast: anElement	| elementsWithName |	elementsWithName :=		self cachedElementsByName			at: aName			ifAbsent: [				self cachedElementsByName at: aName put: anElement.				^ self].	 elementsWithName isCollection		ifTrue: [elementsWithName addLast: anElement]		ifFalse: [			self cachedElementsByName				at: aName				put: (OrderedCollection with: elementsWithName with: anElement)].! !!XMLCachingNodeList methodsFor: 'private'!cachedElementsByNameAt: aName remove: anElement	| elementsWithName |	(elementsWithName := self cachedElementsByName at: aName) isCollection		ifTrue: [			elementsWithName remove: anElement.			elementsWithName isEmpty				ifTrue: [self cachedElementsByName removeKey: aName]]		ifFalse: [self cachedElementsByName removeKey: aName]! !!XMLCachingNodeList methodsFor: 'defaults'!copyClass	"use the non-caching superclass for copies for performance"	^ XMLNodeList! !!XMLCachingNodeList methodsFor: 'accessing'!elementAt: aName ifAbsent: aBlock	| elementsWithName |	(elementsWithName :=		self cachedElementsByName			at: aName			ifAbsent: [^ aBlock value]) isCollection		ifTrue: [^ elementsWithName first]		ifFalse: [^ elementsWithName]! !!XMLCachingNodeList methodsFor: 'accessing'!elements	^ self copyEmpty		addAll: self cachedElements;		yourself! !!XMLCachingNodeList methodsFor: 'accessing'!elementsAt: aName	| elementsWithName copiedElements |	copiedElements := self copyEmpty.	(elementsWithName :=		self cachedElementsByName			at: aName			ifAbsent: [^ copiedElements]) isCollection		ifTrue: [			elementsWithName do: [:each |				copiedElements addToCopyLast: each]]		ifFalse: [			copiedElements addToCopyLast: elementsWithName].	^ copiedElements.! !!XMLCachingNodeList methodsFor: 'enumerating'!elementsAt: aName do: aBlock	| elementsWithName |	(elementsWithName :=		self cachedElementsByName			at: aName			ifAbsent: [^ self]) isCollection		ifTrue: [elementsWithName do: aBlock]		ifFalse: [aBlock value: elementsWithName]! !!XMLCachingNodeList methodsFor: 'enumerating'!elementsDo: aBlock	self cachedElements do: aBlock! !!XMLCachingNodeList methodsFor: 'private'!findElementAfterIndex: anIndex	anIndex + 1 to: self size do: [:i | | node |		node := self at: i.		node isElement			ifTrue: [^ node]].	^ nil.! !!XMLCachingNodeList methodsFor: 'private'!findElementAfterIndex: anIndex named: aName	anIndex + 1 to: self size do: [:i | | node |		node := self at: i.		(node isElement			and: [node isNamed: aName])			ifTrue: [^ node]].	^ nil.! !!XMLCachingNodeList methodsFor: 'accessing'!firstElement	^ self cachedElements		at: 1		ifAbsent: [self defaultValue]! !!XMLCachingNodeList methodsFor: 'testing'!hasElements	^ cachedElements notNil and: [cachedElements notEmpty]! !!XMLCachingNodeList methodsFor: 'testing'!includesElement: aName	^ self cachedElementsByName includesKey: aName! !!XMLCachingNodeList methodsFor: 'accessing'!lastElement	^ self cachedElements		at: self cachedElements size		ifAbsent: [self defaultValue]! !!XMLCachingNodeList methodsFor: 'private'!rebuildCachedElements	self cachedElements removeAll.	self cachedElementsByName removeAll.	self do: [:each |		each isElement			ifTrue: [self cacheElementAddedLast: each]].! !!XMLCachingNodeList methodsFor: 'notifying'!renamedElement: anElement from: anOldName to: aNewName	| oldPrefix index |	self		cachedElementsByNameAt: anOldName		remove: anElement.	(oldPrefix := anOldName xmlPrefixBeforeLocalName) notEmpty		ifTrue: [			self				cachedElementsByNameAt: (anOldName xmlLocalNameAfterPrefix: oldPrefix)				remove: anElement].	index := self indexOf: anElement.	self		cachedElementsByNameAt: anElement name		add: anElement		beforeNextAfterIndex: index.	anElement hasPrefix		ifTrue: [			self				cachedElementsByNameAt: anElement localName				add: anElement				beforeNextAfterIndex: index].! !!XMLCachingNodeList methodsFor: 'sorting'!sort: aSortBlock	super sort: aSortBlock.	self cachedElements sort: aSortBlock.	self cachedElementsByName valuesDo: [:each |		each isCollection			ifTrue: [each sort: aSortBlock]].! !!XMLCachingNodeList methodsFor: 'accessing'!swap: aFirstIndex with: aSecondIndex	super swap: aFirstIndex with: aSecondIndex.	((self at: aFirstIndex) isElement		or: [(self at: aSecondIndex) isElement])		ifTrue: [self rebuildCachedElements].! !!XMLCachingNodeList methodsFor: 'private'!uncacheElement: anElement	self cachedElements remove: anElement.	self		cachedElementsByNameAt: anElement name		remove: anElement.	anElement hasPrefix		ifTrue: [			self				cachedElementsByNameAt: anElement localName				remove: anElement].! !!XMLNodeList class methodsFor: 'instance creation'!new	^ self new: 5! !!XMLNodeList methodsFor: 'private'!afterAdding: aNode at: anIndex	(aNode hasParentWithNodeList: self)		ifTrue: [			self				removeDuplicateOf: aNode				notAt: anIndex]		ifFalse: [			observer				ifNotNil: [observer addedNode: aNode]]! !!XMLNodeList methodsFor: 'private'!afterAddingLast: aNode	(aNode hasParentWithNodeList: self)		ifTrue: [			self				removeDuplicateOf: aNode				notAt: self size]		ifFalse: [			observer				ifNotNil: [observer addedNode: aNode]]! !!XMLNodeList methodsFor: 'private'!afterAddingToCopyLast: aNode	observer		ifNotNil: [observer addedNode: aNode]! !!XMLNodeList methodsFor: 'private'!afterRemoving: aNode	observer		ifNotNil: [observer removedNode: aNode]! !!XMLNodeList methodsFor: 'accessing'!contentNodes	^ self select: [:each | each isContentNode]! !!XMLNodeList methodsFor: 'enumerating'!contentNodesDo: aBlock	self do: [:each |		each isContentNode			ifTrue: [aBlock value: each]]! !!XMLNodeList methodsFor: 'accessing'!contentStringAt: aName	^ (self		elementAt: aName		ifAbsent: [^ '']) contentString! !!XMLNodeList methodsFor: 'accessing'!elementAfter: anElement	| last |	self elementsDo: [:each |		last = anElement			ifTrue: [^ each].		last := each].	^ self defaultValue.! !!XMLNodeList methodsFor: 'accessing'!elementAt: aName	^ self		elementAt: aName		ifAbsent: [self defaultValue]! !!XMLNodeList methodsFor: 'accessing'!elementAt: aName ifAbsent: aBlock	self elementsDo: [:each |		(each isNamed: aName)			ifTrue: [^ each]].	^ aBlock value.! !!XMLNodeList methodsFor: 'accessing'!elementAt: aName namespaceURI: aURI	^ self		elementAt: aName		namespaceURI: aURI		ifAbsent: [self defaultValue]! !!XMLNodeList methodsFor: 'accessing'!elementAt: aName namespaceURI: aURI ifAbsent: aBlock	self		elementsAt: aName		do: [:each |			each namespaceURI = aURI				ifTrue: [^ each]].	^ aBlock value.! !!XMLNodeList methodsFor: 'accessing'!elementBefore: anElement	| last |	last := self defaultValue.	self elementsDo: [:each |		each = anElement			ifTrue: [^ last].		last := each].	^ self defaultValue.! !!XMLNodeList methodsFor: 'accessing'!elementNames	^ self elementsCollect: [:each | each name]! !!XMLNodeList methodsFor: 'accessing'!elements	^ self select: [:each | each isElement]! !!XMLNodeList methodsFor: 'accessing'!elementsAt: aName	^ self elementsSelect: [:each | each isNamed: aName]! !!XMLNodeList methodsFor: 'enumerating'!elementsAt: aName do: aBlock	self elementsDo: [:each |		(each isNamed: aName)			ifTrue: [aBlock value: each]]! !!XMLNodeList methodsFor: 'accessing'!elementsAt: aName namespaceURI: aURI	^ self elementsSelect: [:each |		(each isNamed: aName)			and: [each namespaceURI = aURI]]! !!XMLNodeList methodsFor: 'enumerating'!elementsCollect: aBlock	| collectedElements |	"implementing with #elementsDo: benefits the caching subclass because	of its fast #elementsDo: implementation"	collectedElements := self copyEmptyForCollect.	self elementsDo: [:each |		collectedElements addLast: (aBlock value: each)].	^ collectedElements.! !!XMLNodeList methodsFor: 'enumerating'!elementsDetect: aBlock	^ self		elementsDetect: aBlock		ifNone: [self defaultValue]! !!XMLNodeList methodsFor: 'enumerating'!elementsDetect: aBlock ifNone: anExceptionBlock	"implementing with #elementsDo: benefits the caching subclass because	of its fast #elementsDo: implementation"	self elementsDo: [:each |		(aBlock value: each)			ifTrue: [^ each]].	^ anExceptionBlock value.! !!XMLNodeList methodsFor: 'enumerating'!elementsDo: aBlock	"use #to:do: for performance, because so many methods rely on this"	1 to: collection size do: [:i | | node |		(node := collection at: i) isElement			ifTrue: [aBlock value: node]]! !!XMLNodeList methodsFor: 'enumerating'!elementsSelect: aBlock	| selectedElements |	"implementing with #elementsDo: benefits the caching subclass because	of its fast #elementsDo: implementation"	selectedElements := self copyEmpty.	self elementsDo: [:each |		(aBlock value: each)			ifTrue: [selectedElements addToCopyLast: each]].	^ selectedElements.! !!XMLNodeList methodsFor: 'accessing'!firstElement	self elementsDo: [:each | ^ each].	^ self defaultValue.! !!XMLNodeList methodsFor: 'testing'!hasContentNodes	^ self anySatisfy: [:each | each isContentNode]! !!XMLNodeList methodsFor: 'testing'!hasElements	^ self anySatisfy: [:each | each isElement]! !!XMLNodeList methodsFor: 'testing'!hasStringNodes	^ self anySatisfy: [:each | each isStringNode]! !!XMLNodeList methodsFor: 'testing'!includesElement: aName	self		elementAt: aName		ifAbsent: [^ false].	^ true.! !!XMLNodeList methodsFor: 'testing'!includesElement: aName namespaceURI: aURI	self		elementAt: aName		namespaceURI: aURI		ifAbsent: [^ false].	^ true.! !!XMLNodeList methodsFor: 'accessing'!lastElement	self reverseDo: [:each |		each isElement			ifTrue: [^ each]].	^ self defaultValue.! !!XMLNodeList methodsFor: 'accessing'!rawContentStringAt: aName	^ (self		elementAt: aName		ifAbsent: [^ '']) rawContentString! !!XMLNodeList methodsFor: 'notifying'!renamedElement: anElement from: anOldName to: aNewName! !!XMLNodeList methodsFor: 'sorting'!sort	self sort: [:a :b | a sortKey <= b sortKey]! !!XMLNodeList methodsFor: 'accessing'!stringNodes	^ self select: [:each | each isStringNode]! !!XMLNodeList methodsFor: 'enumerating'!stringNodesDo: aBlock	self do: [:each |		each isStringNode			ifTrue: [aBlock value: each]]! !!XMLNodeList methodsFor: 'accessing'!strings	^ self		select: [:each | each isStringNode]		thenCollect: [:each | each string]! !!XMLNodeList methodsFor: 'enumerating'!stringsDo: aBlock	self stringNodesDo: [:each | aBlock value: each string]! !!XMLObservableList class methodsFor: 'instance creation'!observer: anObserver	^ self new observer: anObserver! !!XMLObservableList class methodsFor: 'instance creation'!ofSize: aSize	self shouldNotImplement! !!XMLObservableList methodsFor: 'adding'!add: anObject after: aPreviousObject	^ self		add: anObject		afterIndex:			(collection				indexOf: aPreviousObject				ifAbsent: [-1])! !!XMLObservableList methodsFor: 'adding'!add: anObject afterIndex: anIndex	collection		add: anObject		afterIndex: anIndex.	self		afterAdding: anObject		at: anIndex + 1.	^ anObject.! !!XMLObservableList methodsFor: 'adding'!add: anObject before: aNextObject	^ self		add: anObject		beforeIndex:			(collection				indexOf: aNextObject				ifAbsent: [-1])! !!XMLObservableList methodsFor: 'adding'!add: anObject beforeIndex: anIndex	collection		add: anObject		beforeIndex: anIndex.	self		afterAdding: anObject		at: anIndex.	^ anObject.! !!XMLObservableList methodsFor: 'adding'!addFirst: anObject	collection addFirst: anObject.	self afterAdding: anObject at: 1.	^ anObject.! !!XMLObservableList methodsFor: 'adding'!addLast: anObject	collection addLast: anObject.	self afterAddingLast: anObject.	^ anObject.! !!XMLObservableList methodsFor: 'private'!addToCopyLast: anObject	collection addLast: anObject.	self afterAddingToCopyLast: anObject.	^ anObject.! !!XMLObservableList methodsFor: 'private'!afterAdding: anObject at: anIndex	observer		ifNotNil: [			observer				added: anObject				to: self]! !!XMLObservableList methodsFor: 'private'!afterAddingLast: anObject	"can be used to handle appending separately and more efficiently than	insertion"	self		afterAdding: anObject		at: self size! !!XMLObservableList methodsFor: 'private'!afterAddingToCopyLast: anObject	"can be used to handle appending existing elements to a copy separately and	more efficiently than #afterAddingLast: so not as much checking needs to be	done (because no new elements are being added to the copy)"	self afterAddingLast: anObject! !!XMLObservableList methodsFor: 'private'!afterRemoving: anObject	observer		ifNotNil: [			observer				removed: anObject				from: self]! !!XMLObservableList methodsFor: 'accessing'!at: anIndex put: anObject	| oldObject |	"Gemstone's OrderedCollection>>#at:put: allows the index to be	just after the last, treating it like addLast:, so this is needed	for compatbility"	anIndex = (self size + 1)		ifTrue: [^ self addLast: anObject].	"this will raise an error if the index is invalid"	oldObject := collection at: anIndex.	"remove the old object and notify any observer"	collection at: anIndex put: nil.	oldObject		ifNotNil: [self afterRemoving: oldObject].		"now add the new object and notify any observer"	collection at: anIndex put: anObject.	self		afterAdding: anObject		at: anIndex.	^ anObject.! !!XMLObservableList methodsFor: 'private'!duplicateIndexOf: anObject notAt: anIndex	"to:do: for speed because some subclasses need this to be fast"	1 to: anIndex - 1 do: [:i |		(collection at: i) = anObject			ifTrue: [^ i]].	"to:do: for speed because some subclasses need this to be fast"	anIndex + 1 to: collection size do: [:i |		(collection at: i) = anObject			ifTrue: [^ i]].	^ 0.! !!XMLObservableList methodsFor: 'observing'!observer	^ observer! !!XMLObservableList methodsFor: 'observing'!observer: anObserver	observer := anObserver! !!XMLObservableList methodsFor: 'removing'!remove: anObject ifAbsent: aBlock	collection remove: anObject ifAbsent: [^ aBlock value].	self afterRemoving: anObject.	^ anObject.! !!XMLObservableList methodsFor: 'removing'!removeAt: anIndex	| removed |	removed := super removeAt: anIndex.	self afterRemoving: removed.	^ removed.! !!XMLObservableList methodsFor: 'private'!removeDuplicateOf: anObject notAt: anIndex	"Removes a duplicate of anObject at any index besides anIndex and	returns the removed duplicate or nil if there isn't one."	| duplicateIndex |	(duplicateIndex := 		self			duplicateIndexOf: anObject			notAt: anIndex) > 0		ifTrue: [| duplicate |			(duplicate := collection removeAt: duplicateIndex) = anObject				ifFalse: [					"subclasses may implement #duplicateIndexOf:notAt: to test					for duplicates not with #=, so 'duplicate' can be a					distinct object from 'anObject' that's been removed"					self afterRemoving: duplicate].			^ duplicate]		ifFalse: [^ nil]! !!XMLObservableList methodsFor: 'removing'!reset	| removed |	removed := collection copy.	collection reset.	removed reverseDo: [:each |		self afterRemoving: each].! !!XMLOrderedList class methodsFor: 'private'!collection: aCollection	^ self basicNew setCollection: aCollection! !!XMLOrderedList class methodsFor: 'defaults'!collectionClass	^ OrderedCollection! !!XMLOrderedList class methodsFor: 'inspecting'!inspectorClass	"for pre-GTInspector Pharo"	^ self collectionClass inspectorClass! !!XMLOrderedList class methodsFor: 'instance creation'!new	^ self new: 10! !!XMLOrderedList class methodsFor: 'instance creation'!new: aCapacity	^ self basicNew setCollection: (self collectionClass new: aCapacity)! !!XMLOrderedList class methodsFor: 'instance creation'!new: aSize withAll: anObject	| newList |	"reimplement for portability"	newList := self new: aSize.	1 to: aSize do: [:i | newList addLast: anObject].	^ newList.! !!XMLOrderedList class methodsFor: 'instance creation'!newFrom: aCollection	^ (self new: aCollection size)		addAll: aCollection;		yourself! !!XMLOrderedList class methodsFor: 'instance creation'!ofSize: aSize	^ self new: aSize withAll: nil! !!XMLOrderedList methodsFor: 'copying'!, aCollection	"GS doesn't define #, for non-Sequenceable collections"	^ self copy		addAll: aCollection;		yourself! !!XMLOrderedList methodsFor: 'comparing'!= anObject	"Returns true if anObject is any kind of XMLOrderedList (not just the	class of the receiver) and it and the receiver have the same items	in the same order."	self == anObject		ifTrue: [^ true].	(self species == anObject species		and: [collection size = anObject size])		ifFalse: [^ false].	"Test each position with #= using #to:do: for speed instead of	just 'collection = anObject collection' because that would	make equality depend on the internal collection types instead	of just their items."	1 to: collection size do: [:i |		(collection at: i) = (anObject at: i)			ifFalse: [^ false]].	^ true.! !!XMLOrderedList methodsFor: 'adding'!add: anObject	^ self addLast: anObject! !!XMLOrderedList methodsFor: 'adding'!add: anObject after: aPreviousObject	^ collection add: anObject after: aPreviousObject! !!XMLOrderedList methodsFor: 'adding'!add: anObject afterIndex: anIndex	^ collection add: anObject afterIndex: anIndex! !!XMLOrderedList methodsFor: 'adding'!add: anObject before: aNextObject	^ collection add: anObject before: aNextObject! !!XMLOrderedList methodsFor: 'adding'!add: anObject beforeIndex: anIndex	^ collection add: anObject beforeIndex: anIndex! !!XMLOrderedList methodsFor: 'adding'!addAll: aCollection	^ self addAllLast: aCollection! !!XMLOrderedList methodsFor: 'adding'!addAllFirst: aCollection	aCollection reverseDo: [:each | self addFirst: each].	^ aCollection.! !!XMLOrderedList methodsFor: 'adding'!addAllLast: aCollection	aCollection do: [:each | self addLast: each].	^ aCollection.! !!XMLOrderedList methodsFor: 'adding'!addFirst: anObject	^ collection addFirst: anObject! !!XMLOrderedList methodsFor: 'adding'!addLast: anObject	^ collection addLast: anObject! !!XMLOrderedList methodsFor: 'private'!addToCopyLast: anObject	"this is used to efficiently append to copies for methods like #copy,	#copyWithout:, #select:, and #reject: that create copies with no new elements	(only old ones) so duplicate or other constraint checking can be skipped	by subclasses"	^ collection addLast: anObject! !!XMLOrderedList methodsFor: 'accessing'!after: anObject	^ self after: anObject ifAbsent: [self defaultValue]! !!XMLOrderedList methodsFor: 'accessing'!after: anObject ifAbsent: aBlock	^ collection after: anObject ifAbsent: aBlock! !!XMLOrderedList methodsFor: 'accessing'!allButFirst	^ self allButFirst: 1! !!XMLOrderedList methodsFor: 'accessing'!allButFirst: anInteger	^ self copyFrom: anInteger + 1 to: self size! !!XMLOrderedList methodsFor: 'enumerating'!allButFirstDo: aBlock	"reimplemented for portability"	2 to: collection size do: [:i |		aBlock value: (collection at: i)]! !!XMLOrderedList methodsFor: 'accessing'!allButLast	^ self allButLast: 1! !!XMLOrderedList methodsFor: 'accessing'!allButLast: anInteger	^ self copyFrom: 1 to: self size - anInteger! !!XMLOrderedList methodsFor: 'enumerating'!allButLastDo: aBlock	"reimplemented for portability"	1 to: collection size - 1 do: [:i |		aBlock value: (collection at: i)]! !!XMLOrderedList methodsFor: 'accessing'!anyOne	^ self first! !!XMLOrderedList methodsFor: 'converting'!asArray	"use withAll: not newFrom: for portability"	^ Array withAll: collection! !!XMLOrderedList methodsFor: 'converting'!asOrderedCollection	"use withAll: not newFrom: for portability"	^ OrderedCollection withAll: collection! !!XMLOrderedList methodsFor: 'converting'!asString	"don't assume Object>>#asString is defined, for portability"	^ self printString! !!XMLOrderedList methodsFor: 'accessing'!at: anIndex	"optimized"	(anIndex > 0 and: [anIndex <= collection size])		ifTrue: [^ collection at: anIndex]		ifFalse: [^ self defaultValue]! !!XMLOrderedList methodsFor: 'accessing'!at: anIndex ifAbsent: aBlock	^ collection at: anIndex ifAbsent: aBlock! !!XMLOrderedList methodsFor: 'accessing'!at: anIndex put: aValue	"treats index = size + 1 as addLast: gemstone compatibility"	anIndex = (collection size + 1)		ifTrue: [^ collection addLast: aValue]		ifFalse: [^ collection at: anIndex put: aValue]! !!XMLOrderedList methodsFor: 'accessing'!atLast: anIndexFromEnd	^ self atLast: anIndexFromEnd ifAbsent: [self defaultValue]! !!XMLOrderedList methodsFor: 'accessing'!atLast: anIndexFromEnd ifAbsent: aBlock	^ collection atLast: anIndexFromEnd ifAbsent: aBlock! !!XMLOrderedList methodsFor: 'accessing'!before: anObject	^ self before: anObject ifAbsent: [self defaultValue]! !!XMLOrderedList methodsFor: 'accessing'!before: anObject ifAbsent: aBlock	 ^ collection before: anObject ifAbsent: aBlock! !!XMLOrderedList methodsFor: 'testing'!beginsWith: aCollection	^ collection beginsWith: aCollection! !!XMLOrderedList methodsFor: 'accessing'!capacity	^ collection capacity! !!XMLOrderedList methodsFor: 'enumerating'!collect: aBlock	| collected |	collected := self copyEmptyForCollect.	"use #to:do: for speed"	1 to: collection size do: [:i |		collected addLast: (aBlock value: (collection at: i))].	^ collected.! !!XMLOrderedList methodsFor: 'enumerating'!collect: aCollectBlock thenSelect: aSelectBlock	| selected |	selected := self copyEmpty.	"use #to:do: for speed"	1 to: collection size do: [:i | | item |		item := aCollectBlock value: (collection at: i).		(aSelectBlock value: item)			ifTrue: [selected addLast: item]].	^ selected.! !!XMLOrderedList methodsFor: 'private'!collection	^ collection! !!XMLOrderedList methodsFor: 'copying'!copy	| copy |	copy := self copyEmpty.	"use #to:do: for speed with direct access"	1 to: collection size do: [:i |		copy addToCopyLast: (collection at: i)].	^ copy.! !!XMLOrderedList methodsFor: 'copying'!copyAfter: anObject	| copy |	copy := self copyEmpty.	(self		indexOf: anObject		ifAbsent: [^ copy]) + 1			to: self size			do: [:i | copy addToCopyLast: (self at: i)].	^ copy.! !!XMLOrderedList methodsFor: 'copying'!copyAfterLast: anObject	| copy |	copy := self copyEmpty.	(self		lastIndexOf: anObject		ifAbsent: [^ copy]) + 1			to: self size			do: [:i | copy addToCopyLast: (self at: i)].	^ copy.! !!XMLOrderedList methodsFor: 'defaults'!copyClass	"the class to use for copies"	^ self class! !!XMLOrderedList methodsFor: 'copying'!copyEmpty	^ self copyClass collection: collection copyEmpty! !!XMLOrderedList methodsFor: 'private'!copyEmptyForCollect	"collect: methods return instances of the generic ordered list species class	because a collect block can return any value, which may not be appropiate to	store in copies of particular subclasses (like XMLNodeList)"	^ self species new: self size! !!XMLOrderedList methodsFor: 'copying'!copyFrom: aStart to: anEnd	| copy |	copy := self copyEmpty.	(aStart max: 1)		to: (anEnd min: self size)		do: [:i | copy addToCopyLast: (self at: i)].	^ copy.! !!XMLOrderedList methodsFor: 'copying'!copyReplaceAll: aSearchCollection with: aReplacementCollection	| copy index size searchCollectionSize |	"this implementation always returns a copy, even if it doesn't replace"	(searchCollectionSize := aSearchCollection size) > 0		ifFalse: [^ self copy].	copy := self copyEmpty.	index := 1.	size := self size.	[index <= size]		whileTrue: [			(self at: index) = (aSearchCollection at: 1)				ifTrue: [| searchCollectionIndex |					searchCollectionIndex := 2.					[searchCollectionIndex <= searchCollectionSize						and: [							(self at: index + searchCollectionIndex - 1) =								(aSearchCollection at: searchCollectionIndex)]]						whileTrue: [searchCollectionIndex := searchCollectionIndex + 1].					searchCollectionIndex > searchCollectionSize						ifTrue: [							"found a match, add the replacement and skip the replaced"							copy addAll: aReplacementCollection.							index := index + searchCollectionSize]						ifFalse: [							copy addLast: (self at: index).							index := index + 1]]				ifFalse: [ 					copy addLast: (self at: index).					index := index + 1]].	^ copy.! !!XMLOrderedList methodsFor: 'copying'!copyReplaceFrom: aStart to: aStop with: aReplacementCollection	| copy start stop |	(self size < 1		or: [self size < aStart])		ifTrue: [			^ self copy				addAll: aReplacementCollection;				yourself].	copy := self copyEmpty.	start := aStart max: 1.	stop := aStop min: self size.	1 to: self size do: [:i |		(i = start)			ifTrue: [				copy addAll: aReplacementCollection.				start > stop					ifTrue: [copy addLast: (self at: i)]]			ifFalse: [				(i > start and: [i <= stop])					ifFalse: [copy addLast: (self at: i)]]].	^ copy.! !!XMLOrderedList methodsFor: 'copying'!copyUpTo: anObject	| copy |	copy := self copyEmpty.	1		to:			(self				indexOf: anObject				ifAbsent: [self size + 1]) - 1		do: [:i | copy addToCopyLast: (self at: i)].	^ copy.! !!XMLOrderedList methodsFor: 'copying'!copyUpToLast: anObject	| copy |	copy := self copyEmpty.	1		to:			(self				lastIndexOf: anObject				ifAbsent: [collection size + 1]) - 1		do: [:i | copy addToCopyLast: (self at: i)].	^ copy.! !!XMLOrderedList methodsFor: 'copying'!copyWith: anObject	^ self copy		addLast: anObject;		yourself! !!XMLOrderedList methodsFor: 'copying'!copyWithFirst: anObject	^ self copyEmpty		addLast: anObject;		addAll: self;		yourself! !!XMLOrderedList methodsFor: 'copying'!copyWithout: anObject	^ self reject: [:each | each = anObject]! !!XMLOrderedList methodsFor: 'copying'!copyWithoutAll: aCollection	| rejected |	rejected :=		aCollection size > 5			ifTrue: [aCollection asSet]			ifFalse: [aCollection].	^ self reject: [:each | rejected includes: each].! !!XMLOrderedList methodsFor: 'defaults'!defaultValue	^ nil! !!XMLOrderedList methodsFor: 'enumerating'!detect: aBlock	^ self detect: aBlock ifNone: [self defaultValue]! !!XMLOrderedList methodsFor: 'enumerating'!detect: aBlock ifNone: anExceptionBlock	^ collection detect: aBlock ifNone: anExceptionBlock! !!XMLOrderedList methodsFor: 'enumerating'!do: aBlock	collection do: aBlock! !!XMLOrderedList methodsFor: 'enumerating'!doWithIndex: aBlock	^ self withIndexDo: aBlock! !!XMLOrderedList methodsFor: 'accessing'!eighth	^ self at: 8! !!XMLOrderedList methodsFor: 'testing'!endsWith: aCollection	^ collection endsWith: aCollection! !!XMLOrderedList methodsFor: 'accessing'!fifth	^ self at: 5! !!XMLOrderedList methodsFor: 'accessing'!first	"optimized implementation"	^ collection size > 0		ifTrue: [collection at: 1]		ifFalse: [self defaultValue]! !!XMLOrderedList methodsFor: 'accessing'!first: anInteger	^ self copyFrom: 1 to: anInteger! !!XMLOrderedList methodsFor: 'accessing'!fourth	^ self at: 4! !!XMLOrderedList methodsFor: 'comparing'!hash	| hash |	hash := self species hash.	self size > 10		ifFalse: [			self do: [:each |				hash := hash bitXor: each hash]].	^ hash bitXor: self size hash.! !!XMLOrderedList methodsFor: 'accessing'!identityIndexOf: anObject	^ self identityIndexOf: anObject ifAbsent: [0]! !!XMLOrderedList methodsFor: 'accessing'!identityIndexOf: anObject ifAbsent: aBlock	^ collection identityIndexOf: anObject ifAbsent: aBlock! !!XMLOrderedList methodsFor: 'accessing'!indexOf: anObject	^ self indexOf: anObject ifAbsent: [0]! !!XMLOrderedList methodsFor: 'accessing'!indexOf: anObject ifAbsent: aBlock	^ collection		indexOf: anObject		ifAbsent: aBlock! !!XMLOrderedList methodsFor: 'accessing'!indexOf: anObject startingAt: anIndex 	^ self		indexOf: anObject		startingAt: anIndex		ifAbsent: [0]! !!XMLOrderedList methodsFor: 'accessing'!indexOf: anObject startingAt: anIndex ifAbsent: aBlock	^ collection		indexOf: anObject		startingAt: (anIndex max: 1)		ifAbsent: aBlock! !!XMLOrderedList methodsFor: 'accessing'!indexOfSubCollection: aSubCollection startingAt: anIndex	^ self		indexOfSubCollection: aSubCollection		startingAt: anIndex		ifAbsent: [0]! !!XMLOrderedList methodsFor: 'accessing'!indexOfSubCollection: aSubCollection startingAt: anIndex ifAbsent: aBlock	^ collection		indexOfSubCollection: aSubCollection		startingAt: anIndex		ifAbsent: aBlock! !!XMLOrderedList methodsFor: 'inspecting'!inspectorClass	"for Squeak"	^ collection inspectorClass! !!XMLOrderedList methodsFor: 'testing'!isEmpty	"Squeak's Collection>>#isEmpty is inefficient"	^ self size = 0! !!XMLOrderedList methodsFor: 'testing'!isSequenceable	^ true! !!XMLOrderedList methodsFor: 'accessing'!last	| lastIndex |	"optimized implementation"	^ (lastIndex := collection size) > 0		ifTrue: [collection at: lastIndex]		ifFalse: [self defaultValue]! !!XMLOrderedList methodsFor: 'accessing'!last: anInteger	^ self copyFrom: self size - anInteger + 1 to: self size! !!XMLOrderedList methodsFor: 'accessing'!lastIndexOf: anObject	^ self lastIndexOf: anObject ifAbsent: [0]! !!XMLOrderedList methodsFor: 'accessing'!lastIndexOf: anObject ifAbsent: aBlock	^ collection lastIndexOf: anObject ifAbsent: aBlock! !!XMLOrderedList methodsFor: 'accessing'!ninth	^ self at: 9! !!XMLOrderedList methodsFor: 'enumerating'!pairsDo: aBlock	collection pairsDo: aBlock! !!XMLOrderedList methodsFor: 'converting'!readStream	"use #readStream to get a 0-based position stream on GS"	^ collection readStream! !!XMLOrderedList methodsFor: 'enumerating'!reject: aBlock	| selected |	selected := self copyEmpty.	"use #to:do: for speed"	1 to: collection size do: [:i | | item |		item := collection at: i.		(aBlock value: item)			ifFalse: [selected addToCopyLast: item]].	^ selected.! !!XMLOrderedList methodsFor: 'enumerating'!reject: aRejectBlock thenCollect: aCollectBlock	| collected |	collected := self copyEmptyForCollect.	"use #to:do: for speed"	1 to: collection size do: [:i | | item |		item := collection at: i.		(aRejectBlock value: item)			ifFalse: [collected addLast: (aCollectBlock value: item)]].	^ collected.! !!XMLOrderedList methodsFor: 'removing'!remove: anObject ifAbsent: aBlock	^ collection remove: anObject ifAbsent: aBlock! !!XMLOrderedList methodsFor: 'removing'!removeAll	"Redefined because Collection>>#removeAll assumes the collection can	be safely modified while iterating it with #do:"	self size timesRepeat: [self removeLast]! !!XMLOrderedList methodsFor: 'removing'!removeAt: anIndex	^ collection removeAt: anIndex! !!XMLOrderedList methodsFor: 'removing'!removeFirst	^ self removeAt: 1! !!XMLOrderedList methodsFor: 'removing'!removeFirst: aNumber	| removed |	removed := self copyFrom: 1 to: aNumber.	aNumber timesRepeat: [self removeFirst].	^ removed.! !!XMLOrderedList methodsFor: 'removing'!removeLast	^ self removeAt: self size! !!XMLOrderedList methodsFor: 'removing'!removeLast: aNumber	| removed |	removed := self copyFrom: self size - (aNumber - 1) to: self size.	aNumber timesRepeat: [self removeLast].	^ removed.! !!XMLOrderedList methodsFor: 'accessing'!replaceFrom: aStart to: aStop with: aReplacementCollection	^ self		replaceFrom: aStart		to: aStop		with: aReplacementCollection		startingAt: 1! !!XMLOrderedList methodsFor: 'accessing'!replaceFrom: aStart to: aStop with: aReplacementCollection startingAt: aReplacementStart	| offset |	offset := 0.	[aStart + offset <= aStop]		whileTrue: [			self				at: aStart + offset				put: (aReplacementCollection at: aReplacementStart + offset).			offset := offset + 1].! !!XMLOrderedList methodsFor: 'removing'!reset	collection reset! !!XMLOrderedList methodsFor: 'converting'!reverse	"returns a copy like #reversed instead of doing in-place reversal to	be compatible with SequenceableCollection>>#reverse"	^ self reversed! !!XMLOrderedList methodsFor: 'enumerating'!reverseDo: aBlock	collection reverseDo: aBlock! !!XMLOrderedList methodsFor: 'converting'!reversed	| reversed |	reversed := self copyEmpty.	self reverseDo: [:each | reversed addToCopyLast: each].	^ reversed.! !!XMLOrderedList methodsFor: 'accessing'!second	^ self at: 2! !!XMLOrderedList methodsFor: 'enumerating'!select: aBlock	| selected |	selected := self copyEmpty.	"use #to:do: for speed"	1 to: collection size do: [:i | | item |		item := collection at: i.		(aBlock value: item)			ifTrue: [selected addToCopyLast: item]].	^ selected.! !!XMLOrderedList methodsFor: 'enumerating'!select: aSelectBlock thenCollect: aCollectBlock	| collected |	collected := self copyEmptyForCollect.	"use #to:do: for speed"	1 to: collection size do: [:i | | item |		item := collection at: i.		(aSelectBlock value: item)			ifTrue: [collected addLast: (aCollectBlock value: item)]].	^ collected.! !!XMLOrderedList methodsFor: 'private'!setCollection: aCollection	collection := aCollection! !!XMLOrderedList methodsFor: 'accessing'!seventh	^ self at: 7! !!XMLOrderedList methodsFor: 'accessing'!sixth	^ self at: 6! !!XMLOrderedList methodsFor: 'accessing'!size	^ collection size! !!XMLOrderedList methodsFor: 'sorting'!sort	self sort: [:a :b | a <= b]! !!XMLOrderedList methodsFor: 'sorting'!sort: aSortBlock	collection sort: aSortBlock! !!XMLOrderedList methodsFor: 'sorting'!sorted	^ self copy sort! !!XMLOrderedList methodsFor: 'sorting'!sorted: aSortBlock	^ self copy sort: aSortBlock! !!XMLOrderedList methodsFor: 'private'!species	"this makes instances of this class and all subclasses with the same	items in the same order be equal"	^ XMLOrderedList! !!XMLOrderedList methodsFor: 'accessing'!swap: aFirstIndex with: aSecondIndex	"swap positions of the objects at aFirstIndex and aSecondIndex,	raising an error if either index is out of bounds"	| temp |	temp := collection at: aFirstIndex.	collection		at: aFirstIndex		put: (collection at: aSecondIndex).	collection		at: aSecondIndex		put: temp.! !!XMLOrderedList methodsFor: 'accessing'!third	^ self at: 3! !!XMLOrderedList methodsFor: 'enumerating'!with: aCollection collect: aBlock	| collected |	collected := self copyEmptyForCollect.	1 to: (collection size min: aCollection size) do: [:i |		collected addLast:			(aBlock				value: (collection at: i)				value: (aCollection at: i))].	^ collected.! !!XMLOrderedList methodsFor: 'enumerating'!with: aCollection do: aBlock	1 to: (collection size min: aCollection size) do: [:i |		aBlock			value: (collection at: i)			value: (aCollection at: i)]! !!XMLOrderedList methodsFor: 'enumerating'!withIndexCollect: aTwoArgumentBlock	| collected |	collected := self copyEmptyForCollect.	1 to: collection size do: [:i |		collected addLast:			(aTwoArgumentBlock				value: (collection at: i)				value: i)].	^ collected.! !!XMLOrderedList methodsFor: 'enumerating'!withIndexDo: aBlock	collection withIndexDo: aBlock! !!XMLOrderedList methodsFor: 'converting'!writeStream	"This is not supported because the collection already supports WriteStream	behavior with #addLast: and the Pharo/Squeak WriteStream works by expanding	its collection with #grownBy:, which should fill the new space with nils,	but some subclasses cannot contain nil"	self shouldNotImplement! !!XMLOrderedList methodsFor: 'accessing'!xmlLastOrNil	^ self last! !!SequenceableCollection methodsFor: '*XML-Parser'!includesXMLName: aName	"optimized with #to:do:"	1 to: self size do: [:i |		(aName isXMLQualifiedOrLocalName: (self at: i))			ifTrue: [^ true]].	^ false.! !!SequenceableCollection methodsFor: '*XML-Parser'!xmlLastOrNil	"for speed to avoid at:ifAbsent: closure"	| lastOrNilOffset |	(lastOrNilOffset := self size) > 0		ifTrue: [^ self at: lastOrNilOffset]		ifFalse: [^ nil]! !"XML-Parser"!!FileLocator methodsFor: '*PharoLauncher-100Compatibility'!asFileLocatorOrReference	^ self! !!String methodsFor: '*PharoLauncher-100Compatibility' prior: 66729715!asFileLocatorOrReference	^ FileLocator fromString: self ifNone: [ self asFileReference ]! !!FTTableMorph methodsFor: '*PharoLauncher-100Compatibility'!alternateRowsColor	self container alternateRowsColor! !!FileReference methodsFor: '*PharoLauncher-100Compatibility' prior: 26106243!asFileLocatorOrReference	filesystem isMemoryFileSystem ifTrue: [ ^ self "no convertion for memory file system" ].		^ self path asFileLocatorOrReference! !!ScrollPane methodsFor: '*PharoLauncher-100Compatibility' prior: 60799926!mouseDown: evt	"Dirty fix for DropList events triggereed twice: see https://github.com/pharo-spec/Spec/issues/1259"	"Should be removed once the bug is solved in Spec / Morphic"! !!StringTest methodsFor: '*PharoLauncher-100Compatibility' prior: 66940501!testAsFileLocatorOrReferenceReturnsALocatorWhenStringRefersToAKnownOrigin	| pathString locator |	pathString := (FileLocator home / 'foo') fullName.		locator := pathString asFileLocatorOrReference.			self		assert: locator origin		equals: #home.	self		assert: locator fullName		equals: pathString.! !!StringTest methodsFor: '*PharoLauncher-100Compatibility' prior: 66982208!testAsFileLocatorOrReferenceReturnsAReferenceWhenStringDoesNotReferToAKnownOrigin	| fileRef result |	fileRef := '/foo' asFileReference.		result := fileRef fullName asFileLocatorOrReference.		self		assert: result		equals: fileRef.! !"PharoLauncher-100Compatibility"!!PhLSettingBrowser commentStamp: '' prior: 0!I'm exactly the same as the standard settings browser except I save to a dedicated pharo launcher setting file.!!PhLSettingTree commentStamp: '' prior: 0!I'm exactly the same as the standard settings browser except I save to a dedicated pharo launcher setting file.!!PhLGeneralCommand commentStamp: '' prior: 0!Abstract superclass for all general-purpose commands. These commands concern the launcher in general, not a particular template or image.!!PhLAboutCommand commentStamp: '' prior: 0!Command to display a box with information related to the Pharo Launcher!!PhLOpenNewImageWindowCommand commentStamp: '' prior: 0!Open the image creation UI.!!PhLOpenSettingsCommand commentStamp: '' prior: 0!Command to open the Settings browser.!!PhLOpenVmManagerCommand commentStamp: '' prior: 0!Open the VM Manager UI!!PhLQuitCommand commentStamp: '' prior: 0!Quit Pharo Launcher.!!PhLRefreshImageRepositoryCommand commentStamp: '' prior: 0!Ask the image repository to update.!!PhLRefreshTemplateRepositoryCommand commentStamp: '' prior: 0!Ask the template repository to update.!!PhLImageCommand commentStamp: '' prior: 0!Superclass of all commands that are applied to one image or multiple images.!!PhLCopyImageCommand commentStamp: '' prior: 0!Copy one image to another name.!!PhLCopyLaunchCommand commentStamp: '' prior: 0!Copy the command used to launch the selected image to the system clipboard.!!PhLCopyPathname commentStamp: '' prior: 0!Copy the selected image pathname to the system clipboard.!!PhLCreateTemplateFromImageCommand commentStamp: '' prior: 0!Create a new local template based on the selected image.!!PhLDeleteImageCommand commentStamp: '' prior: 0!Remove an image from the hard disk. Can be applied to multiple images at the same time.!!PhLImportImageCommand commentStamp: '' prior: 0!I can be used to import an image into Pharo Launcher.I move the image file and its associated changes file to the default location of Pharo Launcher images store.!!PhLInspectCommand commentStamp: '' prior: 0!Command to inspect the current selection!!PhLLaunchImageCommand commentStamp: '' prior: 0!Launch the selected image with the appropriate virtual machine.!!PhLLaunchImageFromDiskCommand commentStamp: '' prior: 0!Launch an image from the filesystem without importing it into Pharo Launcher!!PhLOpenLaunchConfigurationEditorCommand commentStamp: '' prior: 0!Open Launch configuration editor for the selected image.!!PhLRecreateImageCommand commentStamp: '' prior: 0!Refresh the currently selected image.It will first drop the current local image and fetch a fresh version of the template. The name of the local image will not be updated.!!PhLRenameImageCommand commentStamp: '' prior: 0!Rename the currently selected image and move the files accordingly.!!PhLShowImageInFolderCommand commentStamp: '' prior: 0!Open your OS's file browser on the selected image directory.!!PhLTemplateCommand commentStamp: '' prior: 0!Superclass of all commands that are applied to one template or multiple templates.!!PhLCreateImageFromTemplateCommand commentStamp: '' prior: 0!Extract the selected template to a new image.!!PhLRemoveTemplateCommand commentStamp: '' prior: 0!Removes the selected template!!PhLRenameTemplateCommand commentStamp: '' prior: 0!Rename the selected template!!PhLVmCommand commentStamp: '' prior: 0!Superclass of all commands that are applied to one VM or multiple VMs.!!PhLDeleteVmCommand commentStamp: '' prior: 0!Remove a VM from the hard disk. Can be applied to multiple VMs at the same time.!!PhLShowVmInFolderCommand commentStamp: '' prior: 0!Open your OS's file browser on the selected VM directory.!!PhLToggleVmPrivateVmCommand commentStamp: '' prior: 0!Toggle between display of VMs used to launch Pharo images and "private" VMs used to determine Pharo version of an image (one VM per image format)!!PhLUpdateVmCommand commentStamp: '' prior: 0!Will update selected Virtual Machines. Update will download and install the lastest available archive for the selected VM.!!PhLError commentStamp: '' prior: 0!I represent an error as can be signaled by any code of Pharo Launcher.!!PhLCommandError commentStamp: '' prior: 0!This error is thrown each time a command can not do its job.!!PhLCorruptedTemplateError commentStamp: '' prior: 0!Error thrown when a template (zip archive) is corrupted!!PhLDownloadError commentStamp: '' prior: 0!I represent download errors.I can be added as a node to the template tree. That's why I have some methods to say I have no children and I am not a template (polymorphism with PhLAbstractTemplate)!!PhLExecutableNotFoundError commentStamp: '' prior: 0!Error thrown when Pharo Launcher did not succeed to find a Pharo binary or executable inside a given folder.Probably, the folder should be deleted as the VM are only cached!!PhLImageVersionDeterminationError commentStamp: '' prior: 0!Error thrown when Pharo Launcher did not succeed to determine the Pharo version of the image to launch.Probably, the run command failed.I hold the command run to determoine the version so that it can be reused for debugging purposes.!!PhLLaunchError commentStamp: '' prior: 0!Error raised when the launch of an image failed!!!!PhLArchitectureError commentStamp: '' prior: 0!Error raised when trying to run a 32-bit image whereas the underlying Operating System does not support 32-bit applications.!!PhLMissingVirtualMachineError commentStamp: '' prior: 0!Error raised when a virtual machine object describes a VM that cannot be found on disk (i.e. executable not found).!!PhLNameNotAvailableError commentStamp: '' prior: 0!Error raised when the name provided is not available.e.g. trying to create an image with the same name as an existing Pharo image!!PhLProcessTimeOut commentStamp: '' prior: 0!Exception signaled when a Pharo Launcher process launched exceeds the timeout given.!!PhLQuitOnLaunchValueChanged commentStamp: '' prior: 0!Annoucement used to update the UI when QuitOnLaunchValueIsChanged from another part (ex: settings, not widget on main window)!!PhLSourcesFileUpdateAvailable commentStamp: '' prior: 0!Announcement thrown when current templates sources do not match downloaded templates sources.!!PhLCommandCancellation commentStamp: '' prior: 0!Get notified if a user canceled an operation do not run following operations if any!!PhLFileBrowser commentStamp: '' prior: 0!I'm a simple visitor in charge of opening an operating system browser on the provided path string.!!PhLLaunchImageProcessConfigurator commentStamp: '' prior: 0!Visitor used to configure the process to launch image dependending on the target OS platform.!!PhLProcessWrapper commentStamp: '' prior: 0!This class allows to run external (OS) processes for Pharo Launcher.It hides some complexity to the Launcher.OSSubProcess is used on Linux and OS X, while OSWinSubprocess is used on Windows.Use me as a builder to configure the process, then call prepareProcess (will use a visitor pattern to visit code specific to targeted OS) to have a PhLProcess ready to run.I act as a facade to OSSubProcess and OSWinSubprocess.!!PhLProcessWrapperCommandStringGenerator commentStamp: '' prior: 0!I'm a visitor used to generate a command string out of the given PhLProcessWrapper instance.!!PhLArchitectureMismatchWarning commentStamp: '' prior: 0!Warning raised when PharoLauncher architecture (image / VM) does not match the image (and by consequence the VM to run it) architecture.e.g. raised when PharoLauncher 64-bit tries to run a 32-bit image (possibly missing libraries)!!ManifestPharoLauncherCore commentStamp: '' prior: 0!I stores metadata on true and false positive critics. These meta data are used by the SmalllintManifestChecker and the critics Browser !!PhLDownloadManager commentStamp: '' prior: 0!I present a simple interface to an HTTP library.My semaphore takes care of error handling when multiple downloads occur in parallel.!!PhLImageDescriptionUpdater commentStamp: '' prior: 0!I'm used to update and by so, serialize the image description to disk.I implement a mechanism to delay the saving by a few seconds to avoid too much disk i/o.Indeed, If I'm asked to update many times within a short delay, I will abort the current saving and replace it by the new one. It can be used to update the description at each text change in the UI.!!PhLJenkinsArtifact commentStamp: '' prior: 0!Represent a file artifact as built on a Jenkins server.Instance Variables	name:		a String	options:		a dictionary mapping option names to option values. Used by Jenkins matrix jobs	url:		location of job on Jenkins!!PhLLaunchConfiguration commentStamp: '' prior: 0!I am a launch configuration that knows how to launch an image.I have all the required information to run one: - vm - arguments - use settingsAn image stores many of my instances so the user can choose one to launch it.!!PhLLaunchedImagesWatcher commentStamp: '' prior: 0!I'm in charge of watching launched images to detect if a problem occured at the launch.To watch a process:	PhLLaunchedImagesWatcher new		checkProcess: aPhLProcess image: aPhLImage!!PhLNetworkSettings commentStamp: '' prior: 0!I provide NetworkSystemSettings proxy settingfor the PhLSettingsBrowser (pragma pharoLauncherSettings).!!PhLObject commentStamp: '' prior: 0!Super class of everything the user can act on!!PhLAbstractTemplate commentStamp: '' prior: 0!I'm an object that can create new identical images. I have a name to distinguish myself from other templates.Currently, all templates are represented by a zip file locally or on the network.!!PhLLocalTemplate commentStamp: '' prior: 0!I am a template that has already been downloaded in the past and stored somewhere on the disk.!!PhLRemoteTemplate commentStamp: '' prior: 0!I represent a template that is somewhere on the network.!!PhLAbstractTemplateGroup commentStamp: '' prior: 0!I represent a group of templates.The #templateAndGroups method is very important. Calling this method must answer a collection of my subgroups and of templates that I directly contain.Most of my subclasses won't have to do any caching, even the network-intensive ones. This is because PhLCacheTemplateGroup does that for everyone.!!PhLCacheTemplateGroup commentStamp: '' prior: 0!Take care of caching for all subclasses of PhLAbstractTemplateGroup. Instance Variables	delegate:		a PhLAbstractTemplateGroup	simplifiedTemplateAndGroups:			a cached version of what my delegate answered to #simplifiedTemplateAndGroups.!!PhLDownloadedTemplateGroup commentStamp: '' prior: 0!I represent a group of templates already downloaded from the network. I maintain a set of zip files in my baseDirectory and a cache.json which contains meta-data about these files.IMPLEMENTATIONI don't cache anything as variables in the image. For each action, I read the cache.json and update it.!!PhLFixedURLsTemplateGroup commentStamp: '' prior: 0!Represent a list of templates that is defined at construction time. The interesting property of this group is that is does not require the network to be shown. The network is only needed to actually download a template.!!PhLHTTPListingTemplateGroup commentStamp: '' prior: 0!Represent a list of templates as given by an HTML webpage. <a href="*.zip"> are searched in the webpage.!!PhLJenkins2BuildGroup commentStamp: '' prior: 0!I  represent a named group of builds for a Jenkins job.By example, I'm used to offer a group 'All builds' provinding a list of all builds of a particualr job.!!PhLJenkins2Entity commentStamp: '' prior: 0!Abstract superclass for everything that is in a Jenkins server (and is visible from the JSON Jenkins API)!!PhLJenkins2Job commentStamp: '' prior: 0!I'm a job as can be available on a Jenkins platform.!!PhLJenkins2Server commentStamp: '' prior: 0!I represent a group of templates as built by a Jenkins server (url of the server is in my url instance variable). I use Jenkins' JSON API to get the data from the server.!!PhLJenkins2WithArtifactsEntity commentStamp: '' prior: 0!Abstract superclass for everything in a Jenkins server that produces artifacts: currently, only simple jobs (i.e., non-matrix jobs) and runs (i.e., what is executed by a matrix job).!!PhLJenkins2Build commentStamp: '' prior: 0!I represent a Jenkins job. If I'm a simple job, artifacts are available directly. If I'm a matrix job, artefacts are available from runs.!!PhLJenkins2Run commentStamp: '' prior: 0!I represent a run of a job (one configuration) resulting from a matrix job.!!PhLImage commentStamp: '' prior: 0!I represent a Pharo (or other) image. I live in a particular location and have a name. Users can launch me.#VM MatchingI am matched to the appropriate VM to launch me via my "version file", which is in the same folder as me, and whose name is the string returned by #versionFileName. My version file's contents are of the form: `{prefix}{version}`*, where:- {prefix} is empty for standard Pharo images. It is made available and used by custom images/VMs e.g. Gtoolkit uses 'gt-'- {version} is whatever convention is used by the image/VM type. For standard Pharo, it is the Pharo version with dots removed. Examples:  - Pharo 9.0 -> `90`.  - Gtoolkit 0.8.83 -> `gt-0.8.83`.* This pattern is the same as the matching VM root folder minus the architecture. See PhLVirtualMachine comment, "Filesystem Location" section for more info.#Customized Image TypesSubclassing me allows you to customize things like:- Which VM to use (if not using the standard mapping from Pharo image version to Pharo VM). For example, GToolkit or Squeak VMs. See below for more details.- Default image arguments (by overriding #defaultArguments). For example, GToolkit needs this because the image immediately closes after startup unless `'--no-quit'` is supplied.##Custom VM Mappingwith contents `{prefix}{version}` e.g. `gt-0.8.83`. This is the same as the VM root folder minus the architecture. See PhLVirtualMachine comment, "Filesystem Location" section for more info.Let's say you have an image that should be run on a custom VM (i.e. not a standard Pharo one)... subclass me, overriding `#versionPrefix` to match the `#versionPrefix` returned by an appropriate PhLVirtualMachine subclass. N.B. To change the VM of an image that has previously been launched with another VM, you may have to delete the image's metainfo file, which would cache the VM info.##Installing an existing (on the filesystem) image in LauncherCurrently, custom images can't be downloaded via Launcher due to differences in URL and other conventions, although this could probably be implemented if someone was interested enough. To create a template from a custom image, you must do the following:1. Download the image and changes file.2. Create a folder in your Launcher images folder which contains the image and changes file. Both files should have the same basename as the folder. For example, `/path/to/launcher_images/Gtoolkit 0.8.83`, `Gtoolkit 0.8.83.image` and `Gtoolkit 0.8.83.changes`.3. Create a "version file" as described in "Custom VM Mapping" above.4. Open or refresh Launcher. The image should appear.##Template CreationTo create a template from a custom image, prepare an image as described above in "Installing..." and then select the image in Launcher, bring up its context menu, choose "Create Template" and go through the dialogs.The template should now be available to create new images.Instance Variables	file:		a reference to the .image file	description: user description of the image	formatNumber: image format number encoded in the image header	architecture: is the image 32-bit or 64-bit	pharoVersion: the Pharo version number of the image 	originTemplate: template that was used to create this image	My metadata are serialized when setting description, template or before launching the image (implies to compute formatNumber, architecture and pharo version).!!PhLROCheckStartup commentStamp: '' prior: 0!Startup action used to check if the image can write in the working directory.Currently needed for Epicea, logs, etc.!!PhLRepository commentStamp: '' prior: 0!Abstract superclass of the template and image repositories. User interfaces can use my interface to be notified when my instances change.!!PhLDirectoryBasedImageRepository commentStamp: '' prior: 0!I'm a group of images which are stored in subdirectories of a dedicated directory.Each image in the group is stored in its own subdirectory with the same name as the image. E.g., if the group's baseDirectory is ~/.config/pharo/images, one example of an image could be ~/.config/pharo/images/Seaside3.0/Seaside3.0.image.Instance Variables	baseDirectory:		place where the images are stored	images:		collection of PhImage!!PhLTemplateGroupRepository commentStamp: '' prior: 0!I maintain a collection of PhLTemplateGroup. I take care of adding a cache to each group.!!PhLStartupManager commentStamp: '' prior: 0!PhLStartupManager is in charge of running startup actions related to the PharoLauncher.!!PhLTemplateGroupsBuilder commentStamp: '' prior: 0!I'm in charge of building the list of templates groups and its associated templates from a list of template sources.I use as input an instance of PhLTemplateSources.The default input is the serialized ston file 'sources.list' defining templates sources (stored in Launcher directory) + the user ston file 'mysources.list' if exists.I'm used at Launcher creation, see PharoLauncherApplication >>#resetTemplateRepository.To update the list of official sources, please update the sources files hosted at http://files.pharo.org/pharo-launcher/sources.list!!PhLTemplateSource commentStamp: '' prior: 0!I represent a source for templates used by Pharo Launcher to create an image.	type could be a value between: jenkins, URL, http listing, cache, etc.I'm just a state holder easily serializable with Ston !!PhLTemplateSources commentStamp: '' prior: 0!I represent a list of template sources used by Pharo Launcher.You initialize me with a reference to a file (serialized with Ston) and then, you can ask me the list of PhlTemplateSource (you can see them as template groups).ex: 	(self withFile: PhLPharoTemplateSources sourcesFile) sources !!PhLCompositeTemplateSources commentStamp: '' prior: 0!I aggregate different template sources and provide a common API to access sources.!!PhLPharoTemplateSources commentStamp: '' prior: 0!I represent the official template sources used by Pharo Launcher.Preview :	PhLTemplateGroupsBuilder buildFrom: PhLPharoTemplateSources fromFile.	Serialization:	self generateSourcesFile!!PhLUserTemplateSources commentStamp: '' prior: 0!I represent the template sources defined by the user locally and used by Pharo Launcher.Preview :	PhLTemplateGroupsBuilder buildFrom: PhLUserTemplateSources fromUserFile.!!PhLTemplateSourcesUpdateChecker commentStamp: '' prior: 0!Process used to chek regurlarly if there is an update for Launcher template sources.PhLTemplateSourcesUpdateChecker run.PhLTemplateSourcesUpdateChecker terminate !!PhLUIConfirmation commentStamp: '' prior: 0!Abstraction of a yes/no dialog.!!PhLUIInformation commentStamp: '' prior: 0!Abstraction of an information dialog.!!PhLUIRequest commentStamp: '' prior: 0!Abstraction of a string request dialog.!!PhLVirtualMachine commentStamp: '' prior: 0!I represent a Pharo (or other) virtual machine that can be used to run an image.# Filesystem LocationFor standard Pharo VMs, this is handled automatically and users should not have to be concerned about the details. However, the name of my executable's root folder must follow an exact pattern because this is how I am matched to images. My custom subclasses will have to know where and how to install their files. My executable is kept in the Launcher VM folder, in a root folder of the form `{prefix}{version}{architecture}`, where:- {prefix} - Standard Pharo VMs have no prefix, which is available and used to distinguish custom images/VMs. For example, Gtoolkit uses 'gt-'.- {version} - Standard Pharo VMs use the image version without dots e.g. '90' for Pharo 9.0. Custom classes can use any convention they wish, e.g. Gtoolkit keeps the dots e.g. '0.8.83' for Gtoolkit 0.8.83.- {architecture} - one of #('x64', 'x86')Three folder naming examples:- 64-bit: For Pharo 9.0 64-bit, I would be in the `path/to/vms/90-x64` folder- 32-bit: For Pharo 8.0 32-bit, I would be in the `path/to/vms/80-x86` folder- Custom VM: For GToolkit 0.8.83, I would be in the `path/to/vms/gt-0.8.83-x64` folder#Customized VM TypesSubclassing me allows you to use non-standard Pharo VMs, customizing things like the `#executableName`. Also, pick a prefix as described above in 'Filesystem Location'.##SetupCurrently, custom VMs can't be downloaded via Launcher due to differences in URL and other conventions, although this could probably be implemented if someone was interested enough. To install VMs within Launcher1. Download the VM2. Put the VM, including all libraries and other needed resources - like the sources file - into a folder as described above in 'Filesystem Location'executableRef is a reference to the script/binary to actually use to launch images.vmBinaryRef is a reference to the vm binary (not a bash file).!!PhLPrivateVirtualMachine commentStamp: '' prior: 0!I represent a Pharo virtual machine used to determine an image phar version by running it with a VM compatible with its image format.	ex: 6505 6521 68021!!PhLVirtualMachineManager commentStamp: '' prior: 0!I'm in charge of selecting the appropriate Virtual Machine for a given image. If the required virtual machine is not found on disk, I will download it from http://files.pharo.org.I determine the VM to use by reading the image file header.!!PhLVirtualMachinesDataSource commentStamp: '' prior: 0!I provide the list of virtual machines and private virtual machines for PharoLauncher.!!PhLVmProvider commentStamp: '' prior: 0!I'm used to provide the download URL of the Pharo Virtual Machine described as a PhLVirtualMachine object or a PhLVirtualMachineManager (used to determine VM information from an image file).!!PhLVmProviderUntilPharo80 commentStamp: '' prior: 0!I'm used to provide the download URL of the Pharo Virtual Machine for Pharo version up to Pharo 8.0.Pharo versions > 8.0 have a diffrente URL scheme and are managed by PhLVmProvider.!!PharoLauncherModel commentStamp: '' prior: 0!Provide an environment that the commands can query and change. The environment is composed of an image repository, a template repository, and a selection (of either images or templates).Instance Variables	imageRepository:		the list of available images in the system	selection:		a current selection of either images or templates	templateRepository:		the list of templates that can be used to create images.!!String methodsFor: '*PharoLauncher-Core'!asLegalSelector	"'234znak 43 ) 2' asLegalSelector"		| toUse | 	toUse := self select: [:char | char isAlphaNumeric].	(toUse size = 0 or: [ toUse first isLetter not ])		ifTrue: [ toUse := 'v', toUse ].	^ toUse uncapitalized asSymbol.! !!String methodsFor: '*PharoLauncher-Core'!formatTemplateName: aUrlString	"Format the receiver by interpolating elements from url string path segments, as in the following examples:" 	"('{6} ({5})' formatTemplateName: '/pharo-ide/TelePharo/releases/download/v0.4.2/Pharo7.0-32bit-TelePharo.zip') >>> 'Pharo7.0-32bit-TelePharo (v0.4.2)'"	"We always remove the extension of the last segment ('.zip)"	| segments |	segments:= aUrlString asZnUrl segments.	^ self class		new: self size		streamContents: [ :result | 			| stream |			stream := self readStream.			[ stream atEnd ]				whileFalse: [ | currentChar |					(currentChar := stream next) == ${						ifTrue: [ | expression index value |							expression := stream upTo: $}.							index := Integer readFrom: expression ifFail: [ expression ].							value := segments at: index.							result nextPutAll: (index = segments size ifTrue: [ value copyUpToLast: $. ] ifFalse: [ value ]) ]						ifFalse: [ currentChar == $\								ifTrue: [ stream atEnd										ifFalse: [ result nextPut: stream next ] ]								ifFalse: [ result nextPut: currentChar ] ] ] ]! !!PhLSettingBrowser class methodsFor: 'initialization'!initialize	PhLStartupManager addToLauncherStartUpList: self! !!PhLSettingBrowser class methodsFor: 'system startup'!launcherStartUp	PharoLauncherApplication isDeployed ifFalse: [ ^ self ].	self preferencesFile ifNotNil: [ self new loadSettings ].	"Allow to have manual settings in the preferences folder of Pharo Launcher."	self preferencesFolder exists 		ifTrue: [ StartupPreferencesLoader default load: (self preferencesFolder filesMatching: '*.st') ]! !!PhLSettingBrowser class methodsFor: 'system startup'!launcherStartUpPriority	^ 100! !!PhLSettingBrowser class methodsFor: 'accessing'!preferencesFile	^ (self preferencesFolder / 'settings.ston') asFileReference! !!PhLSettingBrowser class methodsFor: 'private'!preferencesFolder	^ FileLocator preferences / 'pharo-launcher'! !!PhLSettingBrowser methodsFor: 'private'!exportSettings: aCollection toFileNamed: filename	aCollection do: [ :startupAction | startupAction runOnce: false ].	StartupPreferencesLoader default addAtStartup: aCollection inDirectory: self class preferencesFolder named: filename! !!PhLSettingBrowser methodsFor: 'loading'!loadSettings	self treeHolder updateSettingNodes.	"do not inform settings are loaded even if not loaded"! !!PhLSettingBrowser methodsFor: 'instance creation'!newTreeHolder	^ PhLSettingTree new 		acceptableKeywords: self settingsKeywords		! !!PlatformResolver methodsFor: '*PharoLauncher-Core'!launcherImagesLocation	<origin>	^ PhLDirectoryBasedImageRepository location resolve! !!PlatformResolver methodsFor: '*PharoLauncher-Core'!launcherUserFilesLocation	"Where to put the user files (images, virtual machines) for the pharo launcher"	<origin>	^ self documents resolve / 'Pharo'! !!PlatformResolver methodsFor: '*PharoLauncher-Core'!launcherVMsLocation	<origin>	^ PhLVirtualMachineManager vmStore resolve! !!PlatformResolver methodsFor: '*PharoLauncher-Core'!vmExecutableName	self subclassResponsibility! !!VirtualMachine methodsFor: '*PharoLauncher-Core' prior: 88268587!fullPath	"Return the full vm path as a string"	"Ex: '/Applications/Squeak/Squeak 4.2.5beta1U.app/Contents/MacOS/Squeak VM Opt'"	"SmalltalkImage current vmFullPath"	^(self getSystemAttribute: 0) asByteArray utf8Decoded! !!MacOSResolver methodsFor: '*PharoLauncher-Core'!vmExecutableName	^ 'Pharo'! !!PhLSettingTree methodsFor: 'accessing'!persistence	^ persistence ifNil: 		[ persistence := SystemSettingsPersistence new 			fileReference: PhLSettingBrowser preferencesFile;			settingTree: self;			yourself ]! !!OSPlatform class methodsFor: '*PharoLauncher-Core'!archX86_64	^ 'x86_64'! !!OSPlatform methodsFor: '*PharoLauncher-Core'!canRun32bitApp	^ true! !!OSPlatform methodsFor: '*PharoLauncher-Core'!hostArchitecture	self subclassResponsibility! !!OSPlatform methodsFor: '*PharoLauncher-Core'!uname	self subclassResponsibility! !!ZnUrl methodsFor: '*pharolauncher-core'!jenkinsOptions	| options |	options := Dictionary new.	(self segments atWrap: -2)		splitOn: $,		do: [ :option | 			| pair |			pair := option splitOn: $=.			pair size ~= 2				ifTrue: [ ^ Dictionary new	"the url is not properly formatted, we can't extract anything." ].			options at: pair first put: pair second ].	^ options! !!Dictionary methodsFor: '*PharoLauncher-Core'!asPhLImage	"old metadata file format"	^ PhLImage new		privOriginTemplate: (self at: #template);		yourself! !!WindowsResolver methodsFor: '*PharoLauncher-Core'!vmExecutableName	^ 'Pharo.exe'! !!PhLAboutCommand class methodsFor: 'versions'!version: aString	LauncherVersion := aString.! !!PhLAboutCommand methodsFor: 'querying'!aboutText	^ String streamContents: [:stream |		stream			<< 'Pharo Launcher version: ';			<< self launcherVersion;			cr; cr;			<< 'Pharo Launcher is a tool that eases the management of Pharo images and their associated Virtual Machines. It can download official Pharo images from the Pharo repository, fetch the right virtual machine to run your image and many other things.';			cr;			<< 'Documentation is available at https://pharo-project.github.io/pharo-launcher.';			cr;			<< 'If you find a bug, please open an issue at https://github.com/pharo-project/pharo-launcher/issues.'. ]	! !!PhLAboutCommand methodsFor: 'converting'!asSpecCommand	^ super asSpecCommand		iconName: #help;		shortcutKey: (KeyboardKey named: 'QUESTION') meta;		yourself! !!PhLAboutCommand methodsFor: 'executing'!execute	| presenter |	presenter := PhLAboutPresenter 		text: self aboutText		iconName: #pharo.	presenter application: self application.		presenter openDialog.	^ presenter! !!PhLAboutCommand methodsFor: 'initialization'!initialize	super initialize.	self		name: 'About';		description: 'Documentation and information about Pharo Launcher'! !!PhLAboutCommand methodsFor: 'querying'!launcherVersion	^ LauncherVersion ifNil: [ 'N/A' ] ! !!PhLGeneralCommand methodsFor: 'accessing'!application	^ self context application! !!PhLOpenNewImageWindowCommand methodsFor: 'converting'!asSpecCommand	^ super asSpecCommand		iconName: #smallNew;		shortcutKey: $n meta;		yourself! !!PhLOpenNewImageWindowCommand methodsFor: 'executing'!execute	^ (PhLTemplatesPresenter		   newApplication: self application		   model: PhLTemplateGroupRepository default)		  open;		  yourself! !!PhLOpenNewImageWindowCommand methodsFor: 'initialization'!initialize	super initialize.	self		name: 'New';		description: self class comment.! !!PhLOpenSettingsCommand methodsFor: 'converting'!asSpecCommand	^ super asSpecCommand		iconName: #configurationIcon;		yourself! !!PhLOpenSettingsCommand methodsFor: 'executing'!execute	^ (PhLSettingBrowser forKeywords: #( #pharoLauncherSettings ))			loadSettings;			open.! !!PhLOpenSettingsCommand methodsFor: 'initialization'!initialize	super initialize.	self		name: 'Open settings';		description: 'Open Pharo Launcher settings'! !!PhLOpenVmManagerCommand methodsFor: 'converting'!asSpecCommand	^ super asSpecCommand		iconProvider: self;		iconName: #configurationIcon;		yourself! !!PhLOpenVmManagerCommand methodsFor: 'executing'!execute	(PhLVMPresenter		 newApplication: self application		 model: PhLVirtualMachinesDataSource default) open! !!PhLOpenVmManagerCommand methodsFor: 'accessing'!icon	"encoded with 		ZnBase64Encoder new encode: 'Cog-icon-grey.png' asFileReference binaryReadStream upToEnd."	^ ImageReadWriter formFromStream: (ZnBase64Encoder new decode: 		'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gkECQkiHlkkLQAAAu1JREFUOMttk09oXFUYxX/33Zs3k8wbhmQaMyUWBy00Jg1Yl1p3igpqwHaSgAs3QjZF60JwZWYVk6wEkSQlGxcuMqM7hUqxRJSIUs0iZqwiE9qq8TExf18yee/d+66bMUyxZ/Wtzvm+c84nAMbGxgAeX1paul0qlc4Aa8ArjuN8DZxPkuSXarVqeAAEQKlUAlgBHgKanuedD4LgLvAP0A0MDw0NBYBTLpeTdgKnbf4ik8k8BjhBEFwF7mQymQvAV5VK5XB5eVkNDg4mlUpFWmvFyQYt9R+llE8aY2ySJGfz+Xwd6NjZ2dmUUuajKLolpXy5Wq3+DWCtBRBCCCvGx8cBilrrN9Pp9NthGC4JIT601o6nUqkrcRx/XigUfk6S5KOurq4/gFFr7crGxsZmtVo17R5cB54HjlKpVFcYhlprvem6blQsFovAmrX212w2OxYEwQszMzNfAkKUy2UAZ319/VXgB6Agpfzedd2rhULhchzHF13XBTgEmkqpU1rrm9bah2dnZ8+pFkECfNq67d7AwMCjSqk/R0ZG3M7OzovHx8erxphnpJSHWusPcrncW7u7uzcBVHsko6OjAM7U1JSo1+sdvu87LVIcx3Huy1+IGED95+ji4uIlpdStMAxPHxwcrCil3nNd93Iul2N/f/9CHMc+cKSUyu/t7d0ATp8UaWFhAeCG4zjPGmOa2Wy2MwiCWErpG2OO6vX6GWttzXGc3z3PGwuC4MXp6enrgJBzc3NYa4tCiEc8z3sqiqLPoih6Awg9z3suDMNvtNaf5HK5d5rN5sdRFN0xxqz29/fv12q1RLTUV13XfSKKImuMOSulrAMdwF/pdPpUFEU/JUny0sTExOb/itR2wrs9PT3vb29v3wauWWsv9fb2Pr21tXWtu7t7ApC1Ws0AanJy0ggh7IkH8/PzAN8JIfLAcV9f37Dv+3eBLaBHaz3caDQe+EyqFRHA68aY34B+3/fXgNestd8Cg41G46itL/fhX0CxZrLKWx8FAAAAAElFTkSuQmCC') readStream! !!PhLOpenVmManagerCommand methodsFor: 'accessing'!iconNamed: aName	^ self icon! !!PhLOpenVmManagerCommand methodsFor: 'initialization'!initialize	super initialize.	self		name: 'Open VM Manager';		description:			'Open a new window allowing to manage Virtual Machines used to launch images'! !!PhLQuitCommand methodsFor: 'converting'!asSpecCommand	^ super asSpecCommand		iconName: #smallQuitIcon;		shortcutKey: $q meta;		yourself! !!PhLQuitCommand methodsFor: 'executing'!execute	PhLDownloadManager reset. "reset error logging"	Smalltalk snapshot: false andQuit: true! !!PhLQuitCommand methodsFor: 'initialization'!initialize	super initialize.	self		name: 'Quit';		description: 'Quit Pharo Launcher'! !!PhLRefreshImageRepositoryCommand methodsFor: 'converting'!asSpecCommand	^ super asSpecCommand		iconName: #smallUpdateIcon;		shortcutKey: $u meta;		yourself! !!PhLRefreshImageRepositoryCommand methodsFor: 'executing'!execute	self context imageRepository contentsChanged.! !!PhLRefreshImageRepositoryCommand methodsFor: 'initialization'!initialize	super initialize.	self		name: 'Refresh';		description: 'Refresh image list'! !!PhLRefreshTemplateRepositoryCommand methodsFor: 'converting'!asSpecCommand	^ super asSpecCommand		iconName: #smallUpdateIcon;		shortcutKey: $u meta;		yourself! !!PhLRefreshTemplateRepositoryCommand methodsFor: 'executing'!execute	self context templateRepository refresh! !!PhLRefreshTemplateRepositoryCommand methodsFor: 'initialization'!initialize 	super initialize.	self		basicName: 'Refresh';		basicDescription: 'Refresh template list'.! !!PhLRelocateImageDirectoryCommand methodsFor: 'executing'!canBeExecuted	self target ensureCreateDirectory.	^ self source ~= self target 		and: [ self source hasChildren 		and: [ self target hasChildren not ] ]! !!PhLRelocateImageDirectoryCommand methodsFor: 'executing'!execute	self canBeExecuted 		ifTrue: [ 			self context application showWaitCursorWhile: [ 				self relocate.				self informMigrationDone ] ]		ifFalse: [ 			self informManualMigrationNeeded ]! !!PhLRelocateImageDirectoryCommand methodsFor: 'user interaction'!informManualMigrationNeeded	self application newInformation		message:				('You need to manually relocate your images from {1} to {2}'						format:							{(self source pathString).							(self target pathString)});		inform! !!PhLRelocateImageDirectoryCommand methodsFor: 'user interaction'!informMigrationDone	self application newInformation		message:				('Migration of your images from {1} to {2} done'						format:							{(self source pathString).							(self target pathString)});		inform! !!PhLRelocateImageDirectoryCommand methodsFor: 'executing'!relocate	self source children do: [ :child | 		child moveTo:			(self target resolvePath: (child relativeTo: self source)) resolve ]! !!PhLRelocateImageDirectoryCommand methodsFor: 'user interaction'!requestTargetLocation	^ self application newRequest		initialAnswer: self source;		title: 'New location for your images';		validateAnswer: [ :answer | answer asFileReference ~= self source ];		request! !!PhLRelocateImageDirectoryCommand methodsFor: 'accessing'!source	^ source ifNil: [ source := PhLDirectoryBasedImageRepository location ]! !!PhLRelocateImageDirectoryCommand methodsFor: 'accessing'!source: aDirectory	source := aDirectory! !!PhLRelocateImageDirectoryCommand methodsFor: 'accessing'!target	^ target ifNil: [ target := self requestTargetLocation asFileReference ]! !!PhLRelocateImageDirectoryCommand methodsFor: 'accessing'!target: aDirectory	target := aDirectory! !!PhLCopyImageCommand methodsFor: 'converting'!asSpecCommand	^ super asSpecCommand		iconName: #smallCopyIcon;		shortcutKey: $c meta;		beDisabledWhenCantBeRun;		yourself! !!PhLCopyImageCommand methodsFor: 'executing'!execute	| name |	name := self newImageName.	name ifNil: [ ^ self ].	self imagesPresenter ensure: (self imageRepository isNewImageNameValid: name).	self context application showWaitCursorWhile: [ 		self imageRepository			copyImage: self imagesPresenter singleImage			to: name ]! !!PhLCopyImageCommand methodsFor: 'executing'!imageRepository	^ self imagesPresenter imageRepository! !!PhLCopyImageCommand methodsFor: 'initialization'!initialize	super initialize.	self		name: 'Copy image';		description: 'Copy the currently selected image to the new name.'! !!PhLCopyImageCommand methodsFor: 'instance creation'!newImageName	^ self newImageName: self imagesPresenter singleImageName! !!PhLCopyImageCommand methodsFor: 'instance creation'!newImageName: aString 	^ self imagesPresenter newRequest 		parentWindow: self context window;		title: 'Image name?';		initialAnswer: aString;		validateAnswer: [ :answer | (self imagesPresenter imageRepository hasImageNamed: answer) not ];		request! !!PhLCopyLaunchCommand methodsFor: 'converting'!asSpecCommand	^ super asSpecCommand		iconName: #smallCopyIcon;		beDisabledWhenCantBeRun;		yourself! !!PhLCopyLaunchCommand methodsFor: 'executing'!execute	Clipboard clipboardText: 		self imagesPresenter selectedLaunchConfiguration commandString! !!PhLCopyLaunchCommand methodsFor: 'initialization'!initialize	super initialize.	self name: 'Copy launch command'! !!PhLCopyPathname methodsFor: 'converting'!asSpecCommand	^ super asSpecCommand		iconName: #smallCopyIcon;		beDisabledWhenCantBeRun;		yourself! !!PhLCopyPathname methodsFor: 'executing'!execute	Clipboard clipboardText: 		self imagesPresenter singleImage file fullName surroundedByDoubleQuotes.! !!PhLCopyPathname methodsFor: 'initialization'!initialize	super initialize.	self name: 'Copy pathname'! !!PhLCreateTemplateFromImageCommand methodsFor: 'converting'!asSpecCommand	^ super asSpecCommand		iconName: #smallNewIcon;		shortcutKey: $t meta;		beDisabledWhenCantBeRun;		yourself! !!PhLCreateTemplateFromImageCommand methodsFor: 'converting'!asSpecCommandWithImageRemoval	self		willRemoveImage;		name: 'Create Template and delete image';		description:			'Create a Template from the selected Pharo image and delete the image just after template creation'.	^ super asSpecCommand		iconName: #smallNewIcon;		beDisabledWhenCantBeRun;		yourself! !!PhLCreateTemplateFromImageCommand methodsFor: 'accessing'!confirmTemplateOverride	^ self imagesPresenter newConfirmation		parentWindow: self context window;		message: 'Do you want to override exisiting template?';		confirm! !!PhLCreateTemplateFromImageCommand methodsFor: 'executing'!execute	| name |	name := self newTemplateName.	name ifNil: [ PhLCommandCancellation signal ].	self imagesPresenter createLocalTemplateFromSelectionNamed: name.	"ensure the template is created before removing the image"	(willRemoveImage and: [self imagesPresenter templateRepository hasLocalTemplateNamed: name])		ifTrue: [ PhLDeleteImageCommand new						context: context;						execute ]! !!PhLCreateTemplateFromImageCommand methodsFor: 'initialization'!initialize	super initialize.	willRemoveImage := false.	self		name: 'Create Template';		description: 'Create a Template from the selected Pharo image'! !!PhLCreateTemplateFromImageCommand methodsFor: 'accessing'!newTemplateName	^ newTemplateName 		ifNil: [ newTemplateName := self requestNewTemplateName: self imagesPresenter singleImageName ]! !!PhLCreateTemplateFromImageCommand methodsFor: 'accessing'!requestNewTemplateName: aString	| templateRepository |		templateRepository := self imagesPresenter templateRepository.	^ self imagesPresenter newRequest		parentWindow: self context window;		title: 'Template name?';		initialAnswer: (templateRepository makeUniqueTemplateName: aString);		validateAnswer: [ :answer | 			(templateRepository hasLocalTemplateNamed: answer)				ifTrue: [ self confirmTemplateOverride ]				ifFalse: [ true ] ];		request! !!PhLCreateTemplateFromImageCommand methodsFor: 'configuring'!willRemoveImage	willRemoveImage := true.! !!PhLDeleteImageCommand methodsFor: 'converting'!asSpecCommand	^ super asSpecCommand		iconName: #smallDeleteIcon;		shortcutKey: $x meta;		beDisabledWhenCantBeRun;		yourself! !!PhLDeleteImageCommand methodsFor: 'accessing'!canBeExecuted 	^ self imagesPresenter selectedImages notEmpty! !!PhLDeleteImageCommand methodsFor: 'accessing'!execute	| images imageNames confirmMessage answer |		images := self imagesPresenter selectedImages.	imageNames := images collect: #name.	confirmMessage := 'Are you sure you want to delete ', (imageNames joinUsing: ', ' last: ' and ').	answer := self imagesPresenter newConfirmation		parentWindow: self context window;		message: (confirmMessage withNoLineLongerThan: 60) , '?';		confirm.	answer ifFalse: [ ^ self ].	self context application showWaitCursorWhile: [ 		self imagesPresenter imageRepository deleteImages: images ]! !!PhLDeleteImageCommand methodsFor: 'initialization'!initialize	super initialize.	self		name: 'Delete';		description: 'Delete the selected Pharo images'! !!PhLImageCommand methodsFor: 'accessing'!canBeExecuted	^ self imagesPresenter hasSingleImageSelected! !!PhLImageCommand methodsFor: 'accessing'!imagesPresenter	^ self context! !!PhLImageCommand methodsFor: 'initialization'!initialize	super initialize.	self description: self class comment! !!PhLImportImageCommand methodsFor: 'converting'!asSpecCommand	^ super asSpecCommand		iconName: #smallLoadProject;		shortcutKey: $y meta;		beDisabledWhenCantBeRun;		yourself! !!PhLImportImageCommand methodsFor: 'accessing'!canBeExecuted	^ true! !!PhLImportImageCommand methodsFor: 'ui interaction'!chooseNewImageNameFor: anImageName	^ self imagesPresenter newRequest		title: 'An image with the name ', anImageName , ' already exists. Please choose a new name:';		initialAnswer: (self imagesPresenter imageRepository makeUniqueImageName: anImageName);		validateAnswer: [ :answer | (self imagesPresenter imageRepository hasImageNamed: answer) not ];		request! !!PhLImportImageCommand methodsFor: 'executing'!execute	| answer |	importSiblings := false.	answer := self imagesPresenter newRequest		title: 'What would you like to do?';		chooseFrom:			{ 'Import an image into Pharo Launcher images store (will move files)' .			'Import the image directory (and all files it contains) into Pharo Launcher images store (will move files)' }.	answer = 0 		ifTrue: [ ^ self "cancel" ].	answer = 2		ifTrue: [ importSiblings := true ].	self importImage.! !!PhLImportImageCommand methodsFor: 'executing'!import: imageFileRef	| infoMessage destFolderName imageRepository |	destFolderName := imageFileRef basenameWithoutExtension.	imageRepository := self imagesPresenter imageRepository.	[ imageRepository ensureNoImageWithName: destFolderName ]		on: PhLNameNotAvailableError		do: [ destFolderName := self chooseNewImageNameFor: destFolderName ].	destFolderName ifNil: [ ^ self "abort" ].		importSiblings		ifTrue: [ 			imageRepository				importImageNamed: imageFileRef				andSiblingFilesto: destFolderName ]		ifFalse:			[ imageRepository importImage: imageFileRef to: destFolderName ].	infoMessage := 'Image ' , imageFileRef fullName , ' imported!!'.	self imagesPresenter newInformation		message: (infoMessage withNoLineLongerThan: 60);		inform! !!PhLImportImageCommand methodsFor: 'executing'!importImage	| imageFile |	imageFile := self imagesPresenter newFileRequest		title: 'Import a Pharo image (will move image, changes file and pharo-local folder)';		extensionsToShow: #('image');		path: FileLocator home;		chooseFile.	imageFile ifNil: [ 		self imagesPresenter newInformation 			message: 'No path selected. Import failed.';			inform.		^ self ].	imageFile asFileReference isDirectory ifTrue: [ 		self imagesPresenter newInformation 			message: 'The file selected is a directory and not a Pharo image. Import failed.';			inform.		^ self ].	self import: imageFile! !!PhLImportImageCommand methodsFor: 'initialization'!initialize	super initialize.	self		name: 'Import';		description:			'Import into Pharo Launcher an existing Pharo image (and possibly its parent folder)'! !!PhLInspectCommand methodsFor: 'converting'!asSpecCommand	^ super asSpecCommand		iconName: #smallInspectIt;		shortcutKey: $i meta;		beDisabledWhenCantBeRun;		yourself! !!PhLInspectCommand methodsFor: 'accessing'!canBeExecuted 	^ self imagesPresenter selectedImages notEmpty! !!PhLInspectCommand methodsFor: 'executing'!execute	self imagesPresenter singleImage inspect! !!PhLInspectCommand methodsFor: 'initialization'!initialize	super initialize.	self		name: 'Inspect';		description: 'Inspect the selected element'! !!PhLLaunchImageCommand class methodsFor: 'settings'!archMismatchSettingDescription	^ 'Get a warning when trying to launch an image with a different architecture than the Launcher (i.e. trying to launch a 32-bit image from Pharo Launcher 64-bit). '! !!PhLLaunchImageCommand class methodsFor: 'settings'!archMismatchSettingLabel	^ 'Warn on image architecture mismatch? ' translated! !!PhLLaunchImageCommand class methodsFor: 'settings'!quitOnLaunch	^ QuitOnLaunch ifNil: [  QuitOnLaunch := false ].! !!PhLLaunchImageCommand class methodsFor: 'settings'!quitOnLaunch: aBoolean	QuitOnLaunch = aBoolean 		ifFalse: [ QuitOnLaunch := aBoolean ]! !!PhLLaunchImageCommand class methodsFor: 'settings'!settingsOn: aBuilder	<systemsettings>	<pharoLauncherSettings>	(aBuilder setting: #quitOnLaunch)		label: 'Quit On Launch' translated;		parent: #pharoLauncher;		target: self;		order: 30;		description:			'When enabled, Launcher quits when an image is launched. ' , String cr				, 'When disabled, Launcher stays alive when an image is launched.'.	(aBuilder setting: #warnOnArchMismatch)		label: self archMismatchSettingLabel;		parent: #pharoLauncher;		target: self;		order: 35;		description: self archMismatchSettingDescription! !!PhLLaunchImageCommand class methodsFor: 'settings'!warnOnArchMismatch	^ WarnOnArchMismatch ifNil: [  WarnOnArchMismatch := true ].! !!PhLLaunchImageCommand class methodsFor: 'settings'!warnOnArchMismatch: aBoolean	WarnOnArchMismatch := aBoolean.! !!PhLLaunchImageCommand methodsFor: 'converting'!asSpecCommand	^ super asSpecCommand		iconName: #smallDoItIcon;		shortcutKey: $l meta;		beDisabledWhenCantBeRun;		yourself! !!PhLLaunchImageCommand methodsFor: 'converting'!asSpecLaunchWithoutSettingsCommand	self		doNotUseSettings;		name: 'Basic lau...';		description: 'Launch the selected Pharo image without settings'.	^ super asSpecCommand		iconProvider: self;		iconName: #smallDoItIcon;		"shortcutKey: $l meta, $b meta ;"		beDisabledWhenCantBeRun;		yourself! !!PhLLaunchImageCommand methodsFor: 'private'!basicIconNamed: aName	"Only used for basic launch command"	^ super iconNamed: aName! !!PhLLaunchImageCommand methodsFor: 'configuring'!doNotUseSettings	useSettings := false.! !!PhLLaunchImageCommand methodsFor: 'executing'!execute	self imagesPresenter hasSingleImageSelected		ifTrue: [ ^ self launchSelectedImage ]		ifFalse: [ ^ nil ]! !!PhLLaunchImageCommand methodsFor: 'private'!iconNamed: aName	"Only used for basic launch command"	^ (self basicIconNamed: aName) asGrayScaleWithAlpha! !!PhLLaunchImageCommand methodsFor: 'initialization'!initialize	super initialize.	useSettings := true.	self name: 'Launch'! !!PhLLaunchImageCommand methodsFor: 'executing'!launchConfigurationOfImage: aPhLImage	^ self imagesPresenter selectedLaunchConfiguration! !!PhLLaunchImageCommand methodsFor: 'executing'!launchImage: aPhLImage	| process launchConfig |		[ 		launchConfig := self launchConfigurationOfImage: aPhLImage.		launchConfig useSettings: useSettings.		process := aPhLImage launchWithConfiguration: launchConfig ]	on: PhLError	do: [ :error | error uiAlert. ^ process ].	"Waiting for https://github.com/pharo-contributions/OSSubprocess/issues/58 to be fixed	(PhLLaunchedImagesWatcher process: process image: aPhLImage) check."	self class quitOnLaunch		ifTrue: [ self quit ].	^ process! !!PhLLaunchImageCommand methodsFor: 'executing'!launchSelectedImage	^ self launchImage: self imagesPresenter singleImage! !!PhLLaunchImageCommand methodsFor: 'private'!quit	(PhLQuitCommand forSpecContext: self imagesPresenter) execute! !!PhLLaunchImageFromDiskCommand methodsFor: 'converting'!asSpecCommand	^ super asSpecCommand		"iconName: #smallLoadProject;		shortcutKey: $d meta;"		beDisabledWhenCantBeRun;		iconName: self;		iconProvider: self;		yourself! !!PhLLaunchImageFromDiskCommand methodsFor: 'accessing'!canBeExecuted	^ true! !!PhLLaunchImageFromDiskCommand methodsFor: 'executing'!execute	| imageFile |	imageFile := self imagesPresenter newFileRequest 		title: 'Open a Pharo image';		extensionsToShow: #('image');		path: FileLocator home;		chooseFile.	imageFile ifNil: [ ^ self ].	imageFile isFile ifFalse: [ ^self ].	^ self launchImage: (PhLImage location: imageFile).! !!PhLLaunchImageFromDiskCommand methodsFor: 'accessing'!iconNamed: anIconName	^ (self basicIconNamed: #open) mergeWith: (self basicIconNamed: #smallDoItIcon) at:0@0! !!PhLLaunchImageFromDiskCommand methodsFor: 'initialization'!initialize	super initialize.	self name: 'From disk'! !!PhLLaunchImageFromDiskCommand methodsFor: 'executing'!launchConfigurationOfImage: aPhLImage	^ aPhLImage defaultLaunchConfiguration! !!PhLOpenLaunchConfigurationEditorCommand methodsFor: 'converting'!asSpecCommand	^ super asSpecCommand		iconName: #edit;		yourself! !!PhLOpenLaunchConfigurationEditorCommand methodsFor: 'executing'!execute	^ (PhLLaunchConfigurationPresenter		   newApplication: self imagesPresenter application		   model: self imagesPresenter singleImage)		  open;		  yourself! !!PhLOpenLaunchConfigurationEditorCommand methodsFor: 'initialization'!initialize	super initialize.	self 		name: '';		description: self class comment.! !!PhLRecreateImageCommand methodsFor: 'converting'!asSpecCommand	^ super asSpecCommand		iconName: #refreshIcon;		shortcutKey: $R meta;		beDisabledWhenCantBeRun;		yourself! !!PhLRecreateImageCommand methodsFor: 'user interaction'!askConfirmation	| confirmMessage |		confirmMessage := 'Are you sure you want to recreate this image?' , Character cr asString, 							'This will overwrite the existing image and you will lose changes.'.		^ self imagesPresenter newConfirmation		parentWindow: self context window;		message: (confirmMessage withNoLineLongerThan: 60) , '?';		confirm.! !!PhLRecreateImageCommand methodsFor: 'executing'!execute	self askConfirmation ifFalse: [ ^ self ].		self context application showWaitCursorWhile: [ 		self imagesPresenter selectedImages do: [ :image |				self imagesPresenter imageRepository recreateImage: image ] ]! !!PhLRecreateImageCommand methodsFor: 'initialization'!initialize	super initialize.	self		name: 'Recreate';		description: self class comment! !!PhLRenameImageCommand methodsFor: 'converting'!asSpecCommand	^ super asSpecCommand		iconName: #workspaceIcon;		shortcutKey: $r meta;		beDisabledWhenCantBeRun;		yourself! !!PhLRenameImageCommand methodsFor: 'executing'!execute	| name |	name := self newImageName.	name ifNil: [ ^ self ].	self imagesPresenter imageRepository 		renameImage: self imagesPresenter singleImage 		to: name! !!PhLRenameImageCommand methodsFor: 'initialization'!initialize	super initialize.	self		name: 'Rename';		description: 'Rename the currently selected image and move the files accordingly.'! !!PhLRenameImageCommand methodsFor: 'private'!newImageName	^ self newImageName: self imagesPresenter singleImageName! !!PhLRenameImageCommand methodsFor: 'private'!newImageName: aString 	^ self imagesPresenter newRequest 		parentWindow: self context window;		title: 'Image name?';		initialAnswer: aString;		validateAnswer: [ :answer | (self imagesPresenter imageRepository hasImageNamed: answer) not ];		request! !!PhLShowImageInFolderCommand methodsFor: 'converting'!asSpecCommand	^ super asSpecCommand		iconName: #openIcon;		shortcutKey: $o meta;		beDisabledWhenCantBeRun;		yourself! !!PhLShowImageInFolderCommand methodsFor: 'executing'!execute	self imagesPresenter singleImage showNativeFolder! !!PhLShowImageInFolderCommand methodsFor: 'initialization'!initialize	super initialize.	self name: 'Show in folder'! !!PhLCreateImageFromTemplateCommand methodsFor: 'executing'!addDescriptionIfAny	| description |	description := self templatesPresenter description.	description isNotEmpty		ifTrue: [ image description: description ].! !!PhLCreateImageFromTemplateCommand methodsFor: 'executing'!addInitializationScriptMetadataIfPresent	| initScript |	initScript := self templatesPresenter initializationScript.	(initScript exists and: [ initScript contents isNotEmpty ])		ifTrue: [ image initializationScript: initScript ].! !!PhLCreateImageFromTemplateCommand methodsFor: 'converting'!asSpecCommand	^ super asSpecCommand		iconName: #smallNewIcon;		shortcutKey: $s meta;		beDisabledWhenCantBeRun;		yourself! !!PhLCreateImageFromTemplateCommand methodsFor: 'executing'!createImage	| name |	name := self templatesPresenter imageName.	name isEmptyOrNil ifTrue: [ ^ self ].		image := self templatesPresenter imageRepository		extractTemplate: self templatesPresenter singleTemplate		to: name.	self addInitializationScriptMetadataIfPresent.	self addDescriptionIfAny.	self templatesPresenter application imageRepositoryChanged: image.	^ image! !!PhLCreateImageFromTemplateCommand methodsFor: 'executing'!execute		[ ^ self createImage ]		on: PhLCorruptedTemplateError		do: [ :error | 			self application showError: error ]! !!PhLCreateImageFromTemplateCommand methodsFor: 'initialization'!initialize	super initialize.	self		name: 'Create image';		description: 'Create a new image from the selected template'! !!PhLRemoveTemplateCommand methodsFor: 'converting'!asSpecCommand	^ super asSpecCommand		iconName: #smallDelete;		shortcutKey: $x meta;		beDisabledWhenCantBeRun;		yourself! !!PhLRemoveTemplateCommand methodsFor: 'testing'!canBeExecuted	^ self templatesPresenter hasLocalTemplatesSelected! !!PhLRemoveTemplateCommand methodsFor: 'executing'!execute 	| templates templateNames confirmMessage answer |	templates := self templatesPresenter selectedTemplates.	templates ifEmpty: [ ^ self ].		templateNames := templates collect: #name.	confirmMessage := 'Are you sure you want to delete ' , (templateNames joinUsing: ', ' last: ' and ').	answer := self templatesPresenter newConfirmation		parentWindow: self context window;		message: (confirmMessage withNoLineLongerThan: 60) , '?';		confirm.	answer ifFalse: [ ^ self "abort" ].			self templatesPresenter templateRepository deleteTemplates: templates.	self templatesPresenter refresh. ! !!PhLRemoveTemplateCommand methodsFor: 'initialization'!initialize	super initialize.	self		name: 'Remove template';		description: 'Remove the selected template from the local cache'! !!PhLRenameTemplateCommand methodsFor: 'converting'!asSpecCommand	^ super asSpecCommand		iconName: #workspace;		beDisabledWhenCantBeRun;		yourself! !!PhLRenameTemplateCommand methodsFor: 'testing'!canBeExecuted	^ self templatesPresenter hasLocalTemplateSelected! !!PhLRenameTemplateCommand methodsFor: 'executing'!execute 	| name template |	template := self templatesPresenter singleTemplate.	name := self newTemplateName.	name ifNil: [ ^ self "cancel" ].		self templatesPresenter templateRepository rename: template to: name.	self templatesPresenter refresh. ! !!PhLRenameTemplateCommand methodsFor: 'initialization'!initialize	super initialize.	self		name: 'Rename template';		description: 'Rename the selected template from the local cache'! !!PhLRenameTemplateCommand methodsFor: 'instance creation'!newTemplateName	^ self newTemplateName: self templatesPresenter singleTemplate name! !!PhLRenameTemplateCommand methodsFor: 'instance creation'!newTemplateName: aString 	^ self templatesPresenter newRequest 		title: 'New name for the template?';		initialAnswer: aString;		validateAnswer: [ :answer | (self templatesPresenter templateRepository hasLocalTemplateNamed: answer) not ];		request! !!PhLTemplateCommand methodsFor: 'accessing'!application	^ self context application! !!PhLTemplateCommand methodsFor: 'accessing'!templatesPresenter	^ self context! !!PhLDeleteVmCommand methodsFor: 'converting'!asSpecCommand	^ super asSpecCommand		iconName: #smallDeleteIcon;		shortcutKey: $x meta;		beDisabledWhenCantBeRun;		yourself! !!PhLDeleteVmCommand methodsFor: 'executing'!execute	| vms vmNames confirmMessage answer |	vms := self vmsPresenter selectedVms.	vmNames := vms collect: #name.	confirmMessage := 'Are you sure you want to delete VM ' , (vmNames joinUsing: ', ' last: ' and ').	answer := self vmsPresenter newConfirmation		parentWindow: self context window;		message: (confirmMessage withNoLineLongerThan: 60) , '?';		confirm.	answer ifFalse: [ ^ self ].		self context application showWaitCursorWhile: [ 		vms do: #removeFromSystem.		self vmsPresenter refresh ]! !!PhLDeleteVmCommand methodsFor: 'initialization'!initialize	super initialize.	self		name: 'Delete';		description: 'Delete the selected Pharo Virtual Machines'! !!PhLShowVmInFolderCommand methodsFor: 'converting'!asSpecCommand	^ super asSpecCommand		iconName: #openIcon;		shortcutKey: $o meta;		yourself! !!PhLShowVmInFolderCommand methodsFor: 'executing'!execute	| vms |	vms := self vmsPresenter selectedVms.	vms size >= 1		ifTrue: [ vms first showInFolder ]! !!PhLShowVmInFolderCommand methodsFor: 'initialization'!initialize	super initialize.	self name: 'Show in Folder'! !!PhLToggleVmPrivateVmCommand methodsFor: 'converting'!asSpecCommand	^ super asSpecCommand		iconName: #remote;		beDisplayedOnRightSide;		configureAsToolBarToggleButton;		yourself! !!PhLToggleVmPrivateVmCommand methodsFor: 'executing'!execute	self vmsPresenter toggleShowVmPrivateVm.! !!PhLToggleVmPrivateVmCommand methodsFor: 'initialization'!initialize	super initialize.	self name: 'public'! !!PhLUpdateVmCommand methodsFor: 'converting'!asSpecCommand	^ super asSpecCommand		iconName: #smallUpdate;		shortcutKey: $u meta;		yourself! !!PhLUpdateVmCommand methodsFor: 'executing'!execute	self vmsPresenter selectedVms do: #updateFromUrl.	self vmsPresenter refresh.! !!PhLUpdateVmCommand methodsFor: 'initialization'!initialize	super initialize.	self name: 'Update'! !!PhLVmCommand methodsFor: 'initialization'!initialize	super initialize.	self description: self class comment! !!PhLVmCommand methodsFor: 'accessing'!vmsPresenter	^ self context! !!PhLCommandError methodsFor: 'accessing'!longDescription	^ 'Pharo Launcher Command Error!!'! !!PhLCommandError methodsFor: 'accessing'!name	^ 'command error'! !!PhLCorruptedTemplateError methodsFor: 'accessing'!name	^ 'This template appears to be corrupted!! Please try again.'! !!PhLDownloadError class methodsFor: 'signalling'!signalUrl: anUrl	^ self new		setUrl: anUrl;		signal! !!PhLDownloadError class methodsFor: 'signalling'!signalUrl: anUrl message: errorMessage	^ self new		setUrl: anUrl;		messageText: errorMessage;		signal! !!PhLDownloadError methodsFor: 'polymorphism'!hasChildren 	^ false! !!PhLDownloadError methodsFor: 'polymorphism'!isTemplate	^ false! !!PhLDownloadError methodsFor: 'accessing'!longDescription	^ String streamContents: [ :stream |		stream 			nextPutAll: 'Error downloading ';			nextPutAll: (url printStringLimitedTo: 100).		messageText ifNotNil: [ stream cr; nextPutAll: messageText ] ]! !!PhLDownloadError methodsFor: 'accessing'!name	^ 'network error'! !!PhLDownloadError methodsFor: 'initialization'!setUrl: anUrl		url := anUrl! !!PhLError methodsFor: 'testing'!isResumable 	^ true! !!PhLError methodsFor: 'accessing'!longDescription	^ self subclassResponsibility! !!PhLError methodsFor: 'accessing'!name	^ self subclassResponsibility! !!PhLError methodsFor: 'ui'!uiAlert	PharoLauncherApplication default showError: self! !!PhLExecutableNotFoundError class methodsFor: 'signalling'!signalKind: aKindOfApp inPath: aString	^ self new		kindOfApplication: aKindOfApp;		path: aString;		signal! !!PhLExecutableNotFoundError methodsFor: 'accessing'!kindOfApplication: string	kindOfApplication := string! !!PhLExecutableNotFoundError methodsFor: 'accessing'!longDescription	^ 'Cannot detect Pharo ', kindOfApplication ,' in ', path, '.', String cr, 'Delete the folder and retry!! It can also due to a corruption of the downloaded file...'! !!PhLExecutableNotFoundError methodsFor: 'accessing'!name	^ 'Pharo Executable Not Found'! !!PhLExecutableNotFoundError methodsFor: 'accessing'!path	^ path! !!PhLExecutableNotFoundError methodsFor: 'accessing'!path: string	path := string! !!PhLImageVersionDeterminationError class methodsFor: 'signalling'!signalCommand: aCommandString	^ self new		setCommand: aCommandString;		signal! !!PhLImageVersionDeterminationError methodsFor: 'accessing'!longDescription	^ PhLImage versionFileName , 	' file was not found for your image, and probably your VMs are not up to date.Please, contact us at http://pharo.org/community'! !!PhLImageVersionDeterminationError methodsFor: 'accessing'!name	^ 'Cannot determine image version'! !!PhLImageVersionDeterminationError methodsFor: 'initialization'!setCommand: aCommandString	command := aCommandString reject: [ :c | c = Character cr ] "easier to run the copy/pasted command in a shell if command has only one line"! !!PhLArchitectureError class methodsFor: 'signalling'!signalImage: anImage	^ self new 		process: nil image: anImage;		signal! !!PhLArchitectureError methodsFor: 'accessing'!longDescription	^ ('Cannot run {1} image!!' format: { image name }), 		String cr, 		'This image requires a 32-bit VM to run and 32-bit applications are not supported on this Operating System!!'! !!PhLArchitectureError methodsFor: 'accessing'!name	^ 'Architecture error'! !!PhLLaunchError class methodsFor: 'signalling'!signalProcess: aProcess image: anImage	^ self new 		process: aProcess image: anImage;		signal! !!PhLLaunchError methodsFor: 'action'!defaultAction 	PhLUIInformation new		message: self longDescription;		alert! !!PhLLaunchError methodsFor: 'accessing'!longDescription	^ ('An error occured while launching {1} image' format: image name), 		String cr, process stderrString! !!PhLLaunchError methodsFor: 'accessing'!name	^ 'Launch error'! !!PhLLaunchError methodsFor: 'initialization'!process: aPhLProcessWrapper image: aPhLImage 	process := aPhLProcessWrapper.	image := aPhLImage.! !!PhLMissingVirtualMachineError class methodsFor: 'signalling'!signalVm: aPhLVirtualMachine	^ self new 		setVm: aPhLVirtualMachine;		signal! !!PhLMissingVirtualMachineError methodsFor: 'private'!isResumable 	^ true! !!PhLMissingVirtualMachineError methodsFor: 'accessing'!longDescription	^ vm id , 	' virtual machine was not found!!'! !!PhLMissingVirtualMachineError methodsFor: 'accessing'!name	^ 'Cannot find VM'! !!PhLMissingVirtualMachineError methodsFor: 'initialization'!setVm: aPhlVirtualMachine	vm := aPhlVirtualMachine! !!PhLNameNotAvailableError class methodsFor: 'signalling'!signalName: aString	^ self new		setProvidedName: aString;		signal! !!PhLNameNotAvailableError methodsFor: 'accessing'!longDescription	^ 'Provided name {1} is not available!!' format: self providedName! !!PhLNameNotAvailableError methodsFor: 'accessing'!name	^ 'Name error'! !!PhLNameNotAvailableError methodsFor: 'initialization'!providedName	^ providedName! !!PhLNameNotAvailableError methodsFor: 'initialization'!setProvidedName: aString	providedName := aString! !!PhLProcessTimeOut methodsFor: 'accessing'!longDescription	^ 'Process took too much time. Aborted!!'! !!PhLProcessTimeOut methodsFor: 'accessing'!name	^ 'Process timeout'! !!MacOSXPlatform class methodsFor: '*PharoLauncher-Core'!armArchitecture	^ 'arm64'! !!MacOSXPlatform class methodsFor: '*PharoLauncher-Core'!intelArchitecture	^ 'x86_64'! !!MacOSXPlatform methodsFor: '*PharoLauncher-Core'!canRun32bitApp	^ self version asInteger < 1015 "OS X Mojave 10.15 drop support of 32-bit application "! !!MacOSXPlatform methodsFor: '*PharoLauncher-Core'!hostArchitecture	| archName |	archName := (LibC resultOfCommand: 'uname -m') trim.		^ archName = self class intelArchitecture 		ifTrue: [ (LibC resultOfCommand: 'sysctl -in sysctl.proc_translated') trim = '1' 			ifTrue: [ "Running on Rosetta 2" self class armArchitecture ]			ifFalse: [ "Running native Intel" archName ] ]		ifFalse: [ archName ]! !!MacOSXPlatform methodsFor: '*PharoLauncher-Core'!uname	^ PhLVmProvider osDarwin ! !!PhLSourcesFileUpdateAvailable class methodsFor: 'instance creation'!sources: aListOfTemplateSources 	^ self new 		sources: aListOfTemplateSources;		yourself! !!PhLSourcesFileUpdateAvailable methodsFor: 'accessing'!sources	^ sources! !!PhLSourcesFileUpdateAvailable methodsFor: 'accessing'!sources: aListOfTemplateSources 	sources := aListOfTemplateSources! !!LGitLibrary class methodsFor: '*PharoLauncher-Core' prior: 30119033!startUp: isImageStarting	"avoid init error with libgit. See https://github.com/pharo-project/pharo/issues/4463"	(isImageStarting and: [ PharoLauncherApplication isDeployed not ])		ifTrue: [ self uniqueInstance initializeLibGit2 ]! !!LGitLibrary methodsFor: '*PharoLauncher-Core' prior: 30114951!unixModuleName	| pluginDir |	pluginDir := Smalltalk vm directory asFileReference.	#('libgit2.so' 'libgit2.so.0')		detect: [ :each | (pluginDir / each) exists ] 		ifFound: [ :libName | ^ libName ].	self error: 'Module not found.'! !!UnixPlatform methodsFor: '*PharoLauncher-Core'!hostArchitecture	^ (LibC resultOfCommand: 'uname -m') trim! !!UnixPlatform methodsFor: '*PharoLauncher-Core'!uname	^ PhLVmProvider osLinux ! !!WinPlatform methodsFor: '*PharoLauncher-Core'!hostArchitecture	| processorArch |	processorArch := OSEnvironment current at: 'PROCESSOR_ARCHITECTURE'.	(#(AMD64 x64) includes: processorArch asSymbol)		ifTrue: [ processorArch :=  self class archX86_64 ].	^ processorArch ! !!WinPlatform methodsFor: '*PharoLauncher-Core'!privShellExecute: lpOperation file: lpFile parameters: lpParameters directory: lpDirectory show: nShowCmd		^self ffiCall: #( 			FFIConstantHandle ShellExecuteA(     				0,     				char* lpOperation,         			char* lpFile,     				char* lpParameters,     				char* lpDirectory,        			int nShowCmd)) module: #shell32	! !!WinPlatform methodsFor: '*PharoLauncher-Core'!privShellExplore: folder	"	self privShellExplore: 'c:\'	"	^self privShellExecute: 'explore' file: folder parameters: '' directory: '' show: 5 "SW_SHOW"! !!WinPlatform methodsFor: '*PharoLauncher-Core'!uname	^ PhLVmProvider osWindows! !!PhLFileBrowser class methodsFor: 'instance creation'!openOn: aFileReferenceOrPathString	^ self new 		path: aFileReferenceOrPathString;		open.! !!PhLFileBrowser methodsFor: 'action'!open 	self visit! !!PhLFileBrowser methodsFor: 'accessing'!path: aFileReferenceOrPathString	"Opens an OS-specific file and directory browser on ==aFileReference==. If aFileReference is a file, opens the browser on its containing directory instead."	| ref |	aFileReferenceOrPathString isNil ifTrue: [ ^ nil ].	ref := aFileReferenceOrPathString asFileReference.	ref exists ifFalse: [ ^ nil ].		ref := ref isFile ifTrue: [ ref parent ] ifFalse: [ ref ].	(ref isNil or: [ ref exists not ])		ifTrue: [ ^ nil ].	path := ref fullName.! !!PhLFileBrowser methodsFor: 'visiting'!visitMacOS: aPlatform	^ PhLProcessWrapper new 		shellCommand;		addArgument: ('open "{1}"' format: {path});		runUnwatch! !!PhLFileBrowser methodsFor: 'visiting'!visitUnix: aPlatform	^  PhLProcessWrapper new 		shellCommand;		addArgument: ('xdg-open "{1}"' format: {path});		runUnwatch! !!PhLFileBrowser methodsFor: 'visiting'!visitWindows: aPlatform	^ aPlatform privShellExplore: path! !!PhLLaunchImageProcessConfigurator methodsFor: 'private - unix'!cleanLDLibraryPath	^ (self currentLDLibraryPaths		reject: [ :path | path = FileLocator vmDirectory pathString ])! !!PhLLaunchImageProcessConfigurator methodsFor: 'private'!configurePotentialInitializationScript	launchConfiguration image shouldRunInitializationScript 		ifFalse: [ ^ self ].			launchConfiguration image initializationScript 		ifNotNil: [ :script | 						process 							addArgument: 'eval';							addArgument: script fullName surroundedByDoubleQuotes ].! !!PhLLaunchImageProcessConfigurator methodsFor: 'visiting'!configureVm	super visit.	"platform specific behavior"	launchConfiguration vm isHeadless		ifTrue: [ process addArgument: launchConfiguration vm class headlessOptionString ].	launchConfiguration vmArguments 		do: [ :arg | process addArgument: arg ].! !!PhLLaunchImageProcessConfigurator methodsFor: 'private - unix'!currentLDLibraryPaths	^ (OSEnvironment current at: 'LD_LIBRARY_PATH' ifAbsent: [ '' ])		substrings: ':'! !!PhLLaunchImageProcessConfigurator methodsFor: 'private - unix'!exportLDLibraryPathCommandWith: vmDirectoryPath	^ 'export LD_LIBRARY_PATH=' ,		($: join: ((self cleanLDLibraryPath copyWithFirst: vmDirectoryPath) collect: #surroundedBySingleQuotes))! !!PhLLaunchImageProcessConfigurator methodsFor: 'accessing'!imageFile	^ launchConfiguration image imageFile! !!PhLLaunchImageProcessConfigurator methodsFor: 'accessing'!launchConfiguration: aPhLLaunchConfiguration	launchConfiguration := aPhLLaunchConfiguration! !!PhLLaunchImageProcessConfigurator methodsFor: 'accessing'!launchInALoginShell: anObject	launchInALoginShell := anObject! !!PhLLaunchImageProcessConfigurator methodsFor: 'accessing'!usePharoSettings	^ launchConfiguration isUsingPharoSettings! !!PhLLaunchImageProcessConfigurator methodsFor: 'visiting'!visit	process := PhLProcessWrapper new.	process workingDirectory: self imageFile parent pathString.	self configureVm.	process		addArgument: self imageFile pathString surroundedByDoubleQuotes.	self usePharoSettings		ifFalse: [ process addArgument: '--no-default-preferences' ].	self configurePotentialInitializationScript.	launchConfiguration imageArguments 		do: [ :arg | process addArgument: arg ].	^ process! !!PhLLaunchImageProcessConfigurator methodsFor: 'visiting'!visitGeneric: aPlatform	launchInALoginShell		ifTrue: [ process loginShellCommand.					process addArgument: self vmPath surroundedByDoubleQuotes ]		ifFalse: [process command: self vmPath "surroundedByDoubleQuotes" ].! !!PhLLaunchImageProcessConfigurator methodsFor: 'visiting'!visitUnix: aPlatform		launchInALoginShell		ifTrue: [ process loginShellCommand ]		ifFalse: [ process shellCommand ].	process 		addArguments: (self exportLDLibraryPathCommandWith: self vmDirectoryPath);		addArguments: '&& export SQUEAK_PLUGINS="" &&';		addArgument: self vmPath.! !!PhLLaunchImageProcessConfigurator methodsFor: 'private'!vmDirectoryPath	^ self vmPath asFileReference parent fullName! !!PhLLaunchImageProcessConfigurator methodsFor: 'private'!vmPath	^ launchConfiguration vm executablePath! !!PhLProcessWrapper class methodsFor: 'testing'!isCommandAvailable: aCommand	| process |		[ process := self new 		shellCommand;		addArgument: aCommand;		runAndWaitTimeOut: 2 seconds.		^ process isSuccess ]	on: Error 	do: [ ^ false ]! !!PhLProcessWrapper methodsFor: 'building'!addArgument: aString	arguments add: aString! !!PhLProcessWrapper methodsFor: 'building'!addArguments: aString	self addArguments: aString separator: Character space! !!PhLProcessWrapper methodsFor: 'building'!addArguments: aString separator: aCharacter	(aCharacter split: aString)		do: [ :arg | self addArgument: arg ]! !!PhLProcessWrapper methodsFor: 'accessing'!arguments	"On Linux and OS X, we give an array of arguments to the process. 	If the command is a shell, then pathes HAVE TO be protected with double quotes.	It the command is pharo-vm, then pathes SHOULD NOT be surrounded by double quotes, else they are interpreted as part of the argument. This is not true on Windows because arguments is a String with all arguments. It means we MUST keep double quotes for windows pathes.	We assume that arguments are already protected (user knows what to protect, we cannot guess)."	(isShellCommand or: [ Smalltalk os isWindows ])		ifTrue: [ ^ arguments asArray ].	^ arguments		collect:	[ :arg | 			(arg first = $" and: [ arg last = $" ])				ifTrue: [ arg allButFirst allButLast ]				ifFalse: [ arg ] ]		as: Array! !!PhLProcessWrapper methodsFor: 'accessing'!command 	^ command! !!PhLProcessWrapper methodsFor: 'building'!command: apathString	command := apathString! !!PhLProcessWrapper methodsFor: 'querying'!commandLineString	^ PhLProcessWrapperCommandStringGenerator new 		processWrapper: self;		visit! !!PhLProcessWrapper methodsFor: 'accessing'!exitCode	^ Smalltalk os isWindows		ifTrue: [ process exitCode ] 		ifFalse: [ process exitStatus ]! !!PhLProcessWrapper methodsFor: 'initialization'!initialize	super initialize.	arguments := OrderedCollection new.	isShellCommand := false.	useLoginShell := false! !!PhLProcessWrapper methodsFor: 'testing'!isRunning	^ Smalltalk os isWindows		ifTrue: [ process isRunning not ] 		ifFalse: [ process isComplete not ]! !!PhLProcessWrapper methodsFor: 'testing'!isShellCommand	^ isShellCommand! !!PhLProcessWrapper methodsFor: 'testing'!isSuccess	^ Smalltalk os isWindows		ifTrue: [ process isRunning not and: [ process exitCode == 0 ] ] 		ifFalse: [ process isSuccess ]! !!PhLProcessWrapper methodsFor: 'building'!loginShellCommand 	self shellCommand.	useLoginShell := true.! !!PhLProcessWrapper methodsFor: 'private'!prepareProcess	"I am an OSPlatform visitor. Running the visit will actually configure thr process dependending on the Operating System"	self visit! !!PhLProcessWrapper methodsFor: 'private'!process: aProcessWrapper 	process := aProcessWrapper! !!PhLProcessWrapper methodsFor: 'running'!runAndWait	self prepareProcess.	process runAndWait.		process isSuccess ifFalse: [		self error: 'command ', self commandLineString ,' failed' ].! !!PhLProcessWrapper methodsFor: 'running'!runAndWaitTimeOut: aDuration	Smalltalk os isWindows		ifTrue: [ self runOnWindowsAndWaitTimeOut: aDuration ]		ifFalse: [ self runOnLinuxAndWaitTimeOut: aDuration ]! !!PhLProcessWrapper methodsFor: 'running'!runOnLinuxAndWaitTimeOut: aDuration	self prepareProcess.	[ process 		run;		waitForExitWithTimeout: aDuration ]	on: OSSTimeout	do: [ PhLProcessTimeOut signal ].! !!PhLProcessWrapper methodsFor: 'running'!runOnWindowsAndWaitTimeOut: aDuration	self prepareProcess.	process runAndWaitTimeOut: aDuration asMilliSeconds.		process hasTimedOut		ifTrue: [ PhLProcessTimeOut signal ].! !!PhLProcessWrapper methodsFor: 'running'!runUnwatch	self prepareProcess.	Smalltalk os isWindows		ifTrue: [ process runUnwatch. ]		ifFalse: [ process run. ]! !!PhLProcessWrapper methodsFor: 'building'!shellCommand 	isShellCommand := true.! !!PhLProcessWrapper methodsFor: 'accessing'!stderrString	^ Smalltalk os isWindows		ifTrue: [ 'Std error not available on Windows' ]		ifFalse: [ (process stderrStream upToEndOfFile ifNil: [ '' ]) trimBoth ]! !!PhLProcessWrapper methodsFor: 'terminating'!terminate 	process terminate! !!PhLProcessWrapper methodsFor: 'private'!visitMacOS: aPlatform	self visitUnix: aPlatform! !!PhLProcessWrapper methodsFor: 'private'!visitUnix: aPlatform	process := OSSUnixSubprocess new		workingDirectory: workingDirectory;		"redirectStderr;" "Waiting for https://github.com/pharo-contributions/OSSubprocess/issues/58 to be fixed"		yourself.	isShellCommand 		ifTrue: [ | commandLine |			commandLine := Character space join: self arguments.			useLoginShell 				ifTrue: [ process loginShellCommand: commandLine ]				ifFalse: [ process shellCommand: commandLine ] ] 		ifFalse: [ process command: command.					process arguments: self arguments. ].! !!PhLProcessWrapper methodsFor: 'private'!visitWindows: aPlatform	process := OSWSWinProcess new		workingDirectory: workingDirectory;		yourself.	isShellCommand 		ifTrue: [ process shellCommand ] 		ifFalse: [ process command: command ].	process arguments: self arguments.! !!PhLProcessWrapper methodsFor: 'accessing'!workingDirectory 	^ workingDirectory ! !!PhLProcessWrapper methodsFor: 'building'!workingDirectory: apathString	workingDirectory := apathString! !!PhLProcessWrapperCommandStringGenerator methodsFor: 'accessing'!processWrapper: aPhLProcessWrapper	processWrapper := aPhLProcessWrapper ! !!PhLProcessWrapperCommandStringGenerator methodsFor: 'visiting'!visitGeneric: aPlatform	| commandLine |	commandLine := processWrapper workingDirectory 		ifNil: [ '' ]		ifNotNil: [ 'cd ' ,  processWrapper workingDirectory surroundedByDoubleQuotes, sequenceSeparator ].	 processWrapper isShellCommand 		ifFalse: [ commandLine := commandLine ,  processWrapper command surroundedByDoubleQuotes, ' ' ].	commandLine := commandLine , (Character space join:  processWrapper arguments).	^  processWrapper isShellCommand 		ifTrue: [ shellCommandBlock value: commandLine ]		ifFalse: [ commandLine ]! !!PhLProcessWrapperCommandStringGenerator methodsFor: 'visiting'!visitMacOS: aPlatform	^ self visitUnix: aPlatform! !!PhLProcessWrapperCommandStringGenerator methodsFor: 'visiting'!visitUnix: aPlatform	sequenceSeparator := ' && '.	shellCommandBlock := [ :commandLine | 'bash -c ''{1}''' format: { commandLine } ].	^ self visitGeneric: aPlatform! !!PhLProcessWrapperCommandStringGenerator methodsFor: 'visiting'!visitWindows: aPlatform	sequenceSeparator := ' & '.	shellCommandBlock := [ :commandLine | 'C:\Windows\System32\cmd.exe /C ', commandLine surroundedByDoubleQuotes ].	^ self visitGeneric: aPlatform! !!PhLArchitectureMismatchWarning class methodsFor: 'signalling'!signalLauncherArch: launcherArchitecture imageArch: imageArchitecure 	^ self new		initializeWith: launcherArchitecture imageArch: imageArchitecure;		signal! !!PhLArchitectureMismatchWarning methodsFor: 'initialization'!initializeWith: launcherArch imageArch: imageArch	launcherArchitecture := launcherArch.	imageArchitecture := imageArch.! !!PhLArchitectureMismatchWarning methodsFor: 'accessing'!longDescription	^ String streamContents: [ :stream |		stream			nextPutAll: 'Warning!! You are trying to launch a ';			nextPutAll: imageArchitecture;			nextPutAll: ' image requiring a ';			nextPutAll: imageArchitecture;			nextPutAll: ' VM.';			nextPut: Character cr;			nextPutAll: 'Your Pharo Launcher architecture is ';			nextPutAll: launcherArchitecture;			nextPutAll: '. You may need to install additional librairies to your system.';			nextPut: Character cr;			nextPutAll: 'See https://pharo.org/gnu-linux-installation for more information.' ]! !!PhLArchitectureMismatchWarning methodsFor: 'accessing'!name	^ 'Architecture Mismatch!! Continue?'! !!PharoCommandLineHandler methodsFor: '*PharoLauncher-Core' prior: 52998662!runPreferences	"When Pharo Launcher is deployed, ignore Pharo preferences. Pharo preferences will only be loaded when Pharo Launcher is in developer mode."	"PhLSettingBrowser startup action is in charge of loading launcher preferences."	PharoLauncherApplication isDeployed ifTrue: [ ^ self ].		Smalltalk at: #SystemSettingsPersistence ifPresent: [:persistence | 		persistence resumeSystemSettings ].	Smalltalk at: #StartupPreferencesLoader ifPresent: [:loader |		loader default loadFromDefaultLocations ].! !!ManifestPharoLauncherCore class methodsFor: 'meta data'!rejectClasses^ #()! !!ManifestPharoLauncherCore class methodsFor: 'meta data'!rejectRules^ #()! !!ManifestPharoLauncherCore class methodsFor: 'meta data'!ruleAbstractClassRuleV1FalsePositive^ #(#(#(#RGClassDefinition #(#PhLError)) #'2013-06-27T15:21:58.6527+02:00') )! !!ManifestPharoLauncherCore class methodsFor: 'meta data'!ruleImplementedNotSentRuleV1FalsePositive^ #(#(#(#RGMethodDefinition #(#'PhLJenkinsServer class' #inriaPharo #true)) #'2013-06-27T17:14:56.694694+02:00') )! !!ManifestPharoLauncherCore class methodsFor: 'meta data'!ruleInconsistentMethodClassificationRuleV1FalsePositive^ #(#(#(#RGMethodDefinition #(#PhLImage #name #false)) #'2013-06-27T17:14:57.998691+02:00') #(#(#RGMethodDefinition #(#PhLAbstractTemplateGroup #name #false)) #'2013-06-27T17:14:57.998691+02:00') #(#(#RGMethodDefinition #(#PhLError #name #false)) #'2013-06-27T17:14:57.998691+02:00') #(#(#RGMethodDefinition #(#PhLAbstractTemplate #name #false)) #'2013-06-27T17:14:57.998691+02:00') #(#(#RGMethodDefinition #(#PhLJenkinsArtifact #name #false)) #'2013-06-27T17:14:57.998691+02:00') )! !!ManifestPharoLauncherCore class methodsFor: 'meta data'!ruleMissingYourselfRuleV1FalsePositive^ #(#(#(#RGMethodDefinition #(#'PhLError class' #signalUrl: #true)) #'2013-06-27T15:21:58.5907+02:00') #(#(#RGMethodDefinition #(#PhLDownloadManager #downloadToPositionableStream:mimeType: #false)) #'2013-06-27T15:21:58.5907+02:00') )! !!Object methodsFor: '*PharoLauncher-Core'!asPhLImage	PhLError signal: 'Unrecognized metadata format'! !!PhLDownloadManager class methodsFor: 'accessing'!default	^ Default ifNil: [ self setDefault: self new ]! !!PhLDownloadManager class methodsFor: 'action'!reset	Default := nil! !!PhLDownloadManager class methodsFor: 'accessing'!setDefault: aDownloadManager	^ Default := aDownloadManager! !!PhLDownloadManager methodsFor: 'action'!basicDownload: url toFile: destinationFile	| tmpFile |	tmpFile := destinationFile , UUIDGenerator  next asString.	self 		displayProgress: ('Downloading {1}...' format: { url })		during: [ (self newHTTPClientForUrl: url) downloadTo: tmpFile ].	destinationFile ensureDelete. 	tmpFile renameTo: destinationFile basename.! !!PhLDownloadManager methodsFor: 'private'!displayProgress: aTitle during: workBlock	"Inform user about download progression"	PharoLauncherApplication default 		pushProgress: aTitle		with: [ :bar |			workBlock				on: HTTPProgress				do: [ :progress |					bar label: progress printString.					progress isEmpty						ifFalse: [ bar progressPercent: progress percentage ].					progress resume ] ]! !!PhLDownloadManager methodsFor: 'private'!displayProgressDuring: workBlock	"Inform user about download progression"	self 		displayProgress: 'Downloading...' 		during: workBlock! !!PhLDownloadManager methodsFor: 'action'!download: url toFile: destinationFile	[ self basicDownload: url toFile: destinationFile ]	on: PhLDownloadError 	do: [ :error |			PhlRetryPresenter new				explanation: error longDescription;				retryBlock: [ self download: url toFile: destinationFile ];				cancelBlock: [ error pass ];				openModal. ]! !!PhLDownloadManager methodsFor: 'private'!downloadFailureForUrl: url message: errorMessage	semaphore critical: [ errors add: url ].	PhLDownloadError signalUrl: url message: errorMessage.! !!PhLDownloadManager methodsFor: 'action'!downloadToPositionableStream: url mimeType: mimeType	"Unfortunately, Zinc (and HTTP in general) doesn't support positionable streams so well. So we have to get the whole content as a collection and stream over it."	| client content |	client := (self newHTTPClientForUrl: url)		beOneShot;		accept: mimeType;		enforceAcceptContentType: true.	self 		displayProgress: ('Downloading {1}...' format: { url }) 		during: [ content := client get ].	^ content readStream! !!PhLDownloadManager methodsFor: 'initialization'!initialize	super initialize.	semaphore := Semaphore forMutualExclusion.	errors := OrderedCollection new asValueHolder.	self reset! !!PhLDownloadManager methodsFor: 'private'!newHTTPClientForUrl: url	^ ZnClient new		signalProgress: true;		url: url;		enforceHttpSuccess: true;		withOptions: [ :options | options at: #queryKeyValueSafeSet put: (ZnOptions queryKeyValueSafeSet \ '/;') ];		ifFail: [ :exception | self downloadFailureForUrl: url message: exception messageText ];		yourself! !!PhLDownloadManager methodsFor: 'accessing'!numberOfErrors	^ errors size! !!PhLDownloadManager methodsFor: 'action'!reset	errors removeAll! !!PhLDownloadManager methodsFor: 'announcements'!whenErrorAddedDo: aBlock	errors whenChangedDo: aBlock ! !!PhLImageDescriptionUpdater class methodsFor: 'accessing'!default 	^ Default ifNil: [ Default := self new ]! !!PhLImageDescriptionUpdater class methodsFor: 'instance creation'!image: aPhLImage description: aString	^ self default 		image: aPhLImage description: aString;		yourself! !!PhLImageDescriptionUpdater class methodsFor: 'initialization'!reset 	Default := nil.! !!PhLImageDescriptionUpdater methodsFor: 'saving'!doSave	"Will trigger the write of metadata on disk"	image description: description! !!PhLImageDescriptionUpdater methodsFor: 'initialization'!image: aPhLImage description: aString	(aPhLImage isNil or: [ aPhLImage location = '' ]) ifTrue: [ ^ self ].		self terminateProcess.	"image changed, no more edition of description, save it without delay"		(image isNotNil and: [ image file path ~= aPhLImage file path ])		ifTrue: [ self doSave ].			image := aPhLImage.	description := aString.	image description = description 		ifFalse: [ self newProcess ].! !!PhLImageDescriptionUpdater methodsFor: 'private'!newProcess	process := 		[ self waitDelay wait. "Avoid to save description at each key stroke"		self doSave ] 			forkNamed: 'Pharo Launcher image description save process'.! !!PhLImageDescriptionUpdater methodsFor: 'private'!terminateProcess 	process ifNotNil: [ process terminate ]! !!PhLImageDescriptionUpdater methodsFor: 'accessing'!waitDelay	^ 3 seconds! !!PhLJenkinsArtifact class methodsFor: 'protected'!jsonFields	^ #('relativePath')! !!PhLJenkinsArtifact class methodsFor: 'protected'!jsonFieldsQuery	^ $, join: self jsonFields! !!PhLJenkinsArtifact class methodsFor: 'protected'!jsonName	^ 'artifacts'! !!PhLJenkinsArtifact class methodsFor: 'instance creation'!newWithProperties: json 	^ self new		setProperties: json;		yourself! !!PhLJenkinsArtifact methodsFor: 'converting'!asTemplate	^ PhLRemoteTemplate name: self fullName url: self url! !!PhLJenkinsArtifact methodsFor: 'accessing'!fileExtension	^ self url lastPathSegment copyAfterLast: $.! !!PhLJenkinsArtifact methodsFor: 'accessing'!fullName	^ self options isEmpty		ifTrue: [ self name ]		ifFalse: [ String		streamContents: [ :s | 			s				<< $(;				<< self url lastPathSegment;				<< $);				space;				<< self name.			self options				keysAndValuesDo: [ :key :value | 					s space						<< key;						<< '=';						<< value ] ] ]! !!PhLJenkinsArtifact methodsFor: 'testing'!isPotentialTemplate	^ self fileExtension = 'zip' "In a better world we would distinguish potential images differently"! !!PhLJenkinsArtifact methodsFor: 'accessing'!name	^ self relativePath! !!PhLJenkinsArtifact methodsFor: 'accessing'!options	"Return a dictionary of the options used to build this artifact (typically the version of the image, the version of the project...)."	"Because Jenkins doesn't store this information properly, we have to parse it from the url"	^ parent url jenkinsOptions! !!PhLJenkinsArtifact methodsFor: 'accessing'!parent: aBuildOrRun	parent := aBuildOrRun! !!PhLJenkinsArtifact methodsFor: 'accessing'!relativePath	^ properties at: 'relativePath'! !!PhLJenkinsArtifact methodsFor: 'initialization'!setProperties: json	properties := json! !!PhLJenkinsArtifact methodsFor: 'accessing'!url	"Jenkins JSON API does not assign urls to artifacts. You have to get the url of build or run that defines the artifact (i.e., the artifact's parent)."	^ parent url / 'artifact' / self relativePath! !!PhLLaunchConfiguration class methodsFor: 'instance creation'!defaultName	^ 'Default'! !!PhLLaunchConfiguration class methodsFor: 'instance creation'!defaultWithImage: anImage	^ (self withImage: anImage)		name: self defaultName;		yourself! !!PhLLaunchConfiguration class methodsFor: 'settings'!launchInALoginShell	^ LaunchInALoginShell ifNil: [ LaunchInALoginShell := true ]! !!PhLLaunchConfiguration class methodsFor: 'settings'!launchInALoginShell: aBoolean	LaunchInALoginShell := aBoolean! !!PhLLaunchConfiguration class methodsFor: 'settings'!settingsOn: aBuilder	<systemsettings>	<pharoLauncherSettings>	(aBuilder setting: #launchInALoginShell)		label: 'Launch image from a login shell' translated;		parent: #pharoLauncher;		target: self;		order: 31;		description: 'When enabled, Pharo Launcher will start a Shell and launch the image from it. ' , String cr , 'It allows to inherit from the Shell environment variables.'! !!PhLLaunchConfiguration class methodsFor: 'serialization'!stonAllInstVarNames	^ super stonAllInstVarNames reject: [ :varName | varName = #usePharoSettings ]! !!PhLLaunchConfiguration class methodsFor: 'instance creation'!withImage: anImage	^ self new		initializeWithImage: anImage;		yourself! !!PhLLaunchConfiguration methodsFor: 'comparing'!= anObject	self == anObject		ifTrue: [ ^ true ].	self class = anObject class		ifFalse: [ ^ false ].	^ self name = anObject name! !!PhLLaunchConfiguration methodsFor: 'querying'!commandString	^ self launchProcess commandLineString! !!PhLLaunchConfiguration methodsFor: 'querying'!defaultVm	self image ensurePharoVersion.	^ self image vmManager virtualMachine! !!PhLLaunchConfiguration methodsFor: 'configuring'!doNotUseSettings	self useSettings: false! !!PhLLaunchConfiguration methodsFor: 'comparing'!hash 	^ self name hash! !!PhLLaunchConfiguration methodsFor: 'accessing'!image	^ image! !!PhLLaunchConfiguration methodsFor: 'accessing'!imageArguments	^ imageArguments ifNil: [ OrderedCollection new ]! !!PhLLaunchConfiguration methodsFor: 'accessing'!imageArguments: aCollection 	imageArguments := aCollection! !!PhLLaunchConfiguration methodsFor: 'initialization'!initializeWithImage: anImage	self initialize.	image := anImage.	name := 'new configuration...'.	usePharoSettings := true.	imageArguments := anImage defaultArguments.! !!PhLLaunchConfiguration methodsFor: 'testing'!isNullConfiguration	^ false! !!PhLLaunchConfiguration methodsFor: 'testing'!isUsingPharoSettings	^ usePharoSettings ifNil: [ usePharoSettings := true ]! !!PhLLaunchConfiguration methodsFor: 'querying'!launchProcess	self vm isValidAfterUpdate		ifFalse: [ PhLMissingVirtualMachineError signalVm: self vm ].	^ PhLLaunchImageProcessConfigurator new 		launchConfiguration: self;		launchInALoginShell: self class launchInALoginShell;		visit.! !!PhLLaunchConfiguration methodsFor: 'accessing'!name	^ name! !!PhLLaunchConfiguration methodsFor: 'accessing'!name: aString 	name := aString! !!PhLLaunchConfiguration methodsFor: 'printing'!printOn: aStream	aStream << self class name << '(' << self name << ')'! !!PhLLaunchConfiguration methodsFor: 'configuring'!useSettings: aBoolean	"Cannot skip Pharo settings before Pharo 3.0"	self image ensurePharoVersion asInteger < 30 ifTrue: [ ^ self ].	usePharoSettings := aBoolean.! !!PhLLaunchConfiguration methodsFor: 'accessing'!vm	^ vm ifNil: [ self vm: self defaultVm. vm ]! !!PhLLaunchConfiguration methodsFor: 'accessing'!vm: aPhLVirtualMachine 	vm := aPhLVirtualMachine.	vm manager: self image vmManager.! !!PhLLaunchConfiguration methodsFor: 'accessing'!vmArguments	^ vmArguments ifNil: [ OrderedCollection new ]! !!PhLLaunchConfiguration methodsFor: 'accessing'!vmArguments: aCollection 	vmArguments := aCollection! !!PhLLaunchedImagesWatcher class methodsFor: 'initialization'!process: aPhLProcess image: aPhLImage	^ self new 		process: aPhLProcess image: aPhLImage;		yourself ! !!PhLLaunchedImagesWatcher methodsFor: 'private'!basicCheckProcess	| timeout pollingDelay failed |	timeout := 5 seconds.	pollingDelay := 500 milliSeconds.	failed := false.	[ timeout isZero or: [ failed ] ]		whileFalse: [			timeout := timeout - pollingDelay.			pollingDelay wait.			failed := self hasProcessFailed ].	failed ifTrue: [ PhLLaunchError signalProcess: process image: image ]! !!PhLLaunchedImagesWatcher methodsFor: 'initialization'!check	"process ifNil: [ ^ self ]."		[ self basicCheckProcess ]		forkAt: self priority named: self name! !!PhLLaunchedImagesWatcher methodsFor: 'testing'!hasProcessFailed	process isRunning ifTrue: [ ^ false ].	^ process isSuccess not! !!PhLLaunchedImagesWatcher methodsFor: 'private'!name	^ 'Pharo Launcher launched images watcher'! !!PhLLaunchedImagesWatcher methodsFor: 'private'!priority	^ 20! !!PhLLaunchedImagesWatcher methodsFor: 'initialization'!process: aPhLProcess image: aPhLImage	process := aPhLProcess.	image := aPhLImage.! !!PhLNetworkSettings class methodsFor: 'settings'!networkSettingsOn: aBuilder	<pharoLauncherSettings>	(aBuilder group: #network)		label: 'Network' ;  		description: 'All settings concerned with the network'.	 (aBuilder setting: #useHTTPProxy)		label: 'Use HTTP proxy';		parent: #network;		target: NetworkSystemSettings;		order: 10;		description:			'If checked then the you will be able to set a port number and a server name. If unchecked, then no http proxy is used.';		with: [ 			(aBuilder setting: #httpProxyPort)				label: 'Port' translated;				target: NetworkSystemSettings;				description: 'The HTTP proxy port'.			(aBuilder setting: #httpProxyServer)				label: 'Server' translated;				target: NetworkSystemSettings;				description: 'The HTTP proxy server (i.e. proxy.univ-brest.fr)'.			(aBuilder setting: #manageHttpProxyExceptions)				label: 'Exceptions' translated;				target: NetworkSystemSettings;				description: 'Domains to avoid to proxy (separated by ;)' ].				(aBuilder setting: #useNetworkAuthentification) 		label: 'Proxy authentication' ;		parent: #network;		order: 20;		target: NetworkSystemSettings;		description: 'If checked then you will be able to enter a user name and a password for network authentification. Store  HTTP 1.0 basic authentication credentials. Note: this is an ugly hack that stores your password in your image.  It''s just enought to get you going if you use a firewall that requires authentication';		with: [			(aBuilder setting: #proxyUser)				label: 'User name' ;				description: 'The proxy user name'.			(aBuilder setting: #proxyPassword)				type: #Password;				label: 'Password' ;				description: 'The user password'].! !!PhLAbstractTemplate methodsFor: 'actions'!extractTo: aDirectory	"Extract myself to aDirectory, making sure to name the resulting image after me"	"In most cases, you probably want to call #extractTo:named: and let the user choose the new name for the image."	self halt. "Not used"	self extractTo: aDirectory named: self name! !!PhLAbstractTemplate methodsFor: 'actions'!extractTo: aDirectory named: aString	"Extract myself to aDirectory. Name the resulting image aString"	| extractionDirectory archive |		archive := self zipArchive.	extractionDirectory := self extractZipArchive: archive to: aDirectory.	self relocateImageFilesFrom: extractionDirectory to: aDirectory withName: aString.	extractionDirectory deleteAll.	"Will serialize image metadata with the template information"	^ (PhLImage location: aDirectory / aString , 'image') 		originTemplate: self.! !!PhLAbstractTemplate methodsFor: 'private'!extractZipArchive: zipFile to: aDirectory	"Unzip zipFile inside a temporary subdirectory of aDirectory. Return a reference to the subdirectory. The subdirectory can and must be deleted by the caller"	| tempDirectory |	PharoLauncherApplication default		pushProgress: ('Extracting {1}' format: { zipFile isStream ifTrue: [ '' ] ifFalse: [ zipFile basename ] }) 		with: [ :bar | | zip |				"We have to go through a temporary directory because we don't know where 			 the interesting files are in the archive (maybe at the root or maybe in 			 a subdirectory)"			tempDirectory := aDirectory / DateAndTime millisecondClockValue asString.			"It will crash if directory already exists. And that's good :-)"			tempDirectory createDirectory. 			[				zip := ZipArchive new.				zip readFrom: zipFile.				bar max: zip numberOfMembers.				zip extractAllTo: tempDirectory informing: bar.			]			on: Error			do: [ :error | 				error messageText = 'can''t find EOCD position'					ifTrue: [ PhLCorruptedTemplateError signal ]					ifFalse: [ error pass ] ] ].	^ tempDirectory! !!PhLAbstractTemplate methodsFor: 'testing'!hasChildren	^ false! !!PhLAbstractTemplate methodsFor: 'testing'!isTemplate	^ true! !!PhLAbstractTemplate methodsFor: 'accessing'!name	^ name! !!PhLAbstractTemplate methodsFor: 'printing'!printOn: aStream	aStream		nextPutAll: 'Image template (';		nextPutAll: name;		nextPutAll: ')'! !!PhLAbstractTemplate methodsFor: 'private'!relocateImageFilesFrom: extractionDirectory to: targetDirectory withName: targetName	"Move the image files from anywhere within extractionDirectory (even subdirectories) to aDirectory and give the image the name aString"	| imageFile changesFile sourcesFile versionFile |	imageFile := extractionDirectory allFiles detect: [ :aFile | '*.image' match: aFile basename ].	"A changes file must have the same name and be in the same directory as the image file:"	changesFile := imageFile parent / imageFile basenameWithoutExtension , 'changes'.	sourcesFile := imageFile parent / imageFile basenameWithoutExtension , 'sources'.	versionFile := imageFile parent / PhLImage versionFileName.	imageFile = (targetDirectory / targetName , 'image')		ifTrue: [ ^ self "no need to relocate" ].	imageFile moveTo: targetDirectory / targetName , 'image'.	changesFile moveTo: targetDirectory / targetName , 'changes'.	sourcesFile exists 		ifTrue: [ sourcesFile moveTo: targetDirectory / sourcesFile basename ]		ifFalse: [ "ugly hack to handle Pharo 7 - 64 bits images not following the naming scheme"			extractionDirectory allFiles 				detect: [ :aFile | '*.sources' match: aFile basename ]				ifFound: [ :aFile | aFile moveTo: targetDirectory / aFile basename ] ].	versionFile exists 		ifTrue: [ versionFile moveTo: targetDirectory / versionFile basename ]! !!PhLAbstractTemplate methodsFor: 'actions'!renameTo: aString	name := aString! !!PhLAbstractTemplate methodsFor: 'testing'!shouldComputeChildrenLazily 	^ false! !!PhLAbstractTemplate methodsFor: 'querying'!suggestedImageName	^ self name! !!PhLAbstractTemplate methodsFor: 'accessing'!zipArchive	"Return a reference to the archive file representing this template"	^ self subclassResponsibility! !!PhLLocalTemplate class methodsFor: 'serialization'!fromSton: stonReader	| template |	template := super fromSton: stonReader.	template setName: template name zipFile: template zipArchive asFileReference.	^ template! !!PhLLocalTemplate class methodsFor: 'instance creation'!name: aString zipFile: aFileReference	^ self new 		setName: aString zipFile: aFileReference;		yourself		! !!PhLLocalTemplate methodsFor: 'comparing'!= anObject	self == anObject ifTrue: [ ^ true ].	self class = anObject class ifFalse: [ ^ false ].	^ name = anObject name 		and: [ zipFile = anObject zipArchive ]! !!PhLLocalTemplate methodsFor: 'comparing'!hash	^ name hash bitXor: zipFile hash! !!PhLLocalTemplate methodsFor: 'testing'!isLocalTemplate	^ true! !!PhLLocalTemplate methodsFor: 'actions'!renameTo: aString 	super renameTo: aString.	zipFile renameTo: aString, '.zip'! !!PhLLocalTemplate methodsFor: 'initialization'!setName: aString zipFile: aFile 	name := aString.	zipFile := aFile! !!PhLLocalTemplate methodsFor: 'accessing'!url	^ ''! !!PhLLocalTemplate methodsFor: 'accessing'!zipArchive	^ zipFile! !!PhLRemoteTemplate class methodsFor: 'example'!example 	^ self name: 'Pharo Mooc' url: 'https://mooc.pharo.org/image/PharoWeb.zip'! !!PhLRemoteTemplate class methodsFor: 'instance creation'!name: aString url: anUrl	^ self new		setName: aString url: anUrl;		yourself! !!PhLRemoteTemplate class methodsFor: 'instance creation'!name: aString url: anUrl username: anotherString password: yetAnotherString	^ (self name: aString url: anUrl)		  username: anotherString;		  password: yetAnotherString;		  yourself! !!PhLRemoteTemplate methodsFor: 'comparing'!= anObject	self == anObject ifTrue: [ ^ true ].	self class = anObject class ifFalse: [ ^ false ].	^ name = anObject name 		and: [ url = anObject url ]! !!PhLRemoteTemplate methodsFor: 'comparing'!hash	^ name hash bitXor: url hash! !!PhLRemoteTemplate methodsFor: 'accessing'!password	^ url password! !!PhLRemoteTemplate methodsFor: 'accessing'!password: aString	url password: aString! !!PhLRemoteTemplate methodsFor: 'initialization'!setName: aName url: anUrl	name := aName.	url := anUrl! !!PhLRemoteTemplate methodsFor: 'querying'!suggestedImageName	| rxMatcher |	rxMatcher := '(\((\w+).zip\)).*' asRegex.	^ (rxMatcher matches: self name)		ifTrue: [ rxMatcher subexpression: 3 "extract zip filename" ]		ifFalse: [ self name ]! !!PhLRemoteTemplate methodsFor: 'accessing'!url	^ url! !!PhLRemoteTemplate methodsFor: 'accessing'!username	^ url username! !!PhLRemoteTemplate methodsFor: 'accessing'!username: aString	url username: aString! !!PhLRemoteTemplate methodsFor: 'accessing'!zipArchive	"The local template group takes care of cashing downloaded templates."	^ PhLDownloadedTemplateGroup default downloadAndStoreFile: url forTemplate: self! !!PhLAbstractTemplateGroup methodsFor: 'accessing'!children	^ self templatesAndGroups! !!PhLAbstractTemplateGroup methodsFor: 'accessing'!icon 	"icon used to display the group"	self subclassResponsibility ! !!PhLAbstractTemplateGroup methodsFor: 'testing'!isHighlighted	^ isHighlighted ifNil: [ isHighlighted := false ]! !!PhLAbstractTemplateGroup methodsFor: 'accessing'!isHighlighted: aBoolean	isHighlighted := aBoolean! !!PhLAbstractTemplateGroup methodsFor: 'testing'!isTemplateGroup	^ true! !!PhLAbstractTemplateGroup methodsFor: 'accessing'!name	^ self subclassResponsibility! !!PhLAbstractTemplateGroup methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: self name; nextPutAll: ' Template group'! !!PhLAbstractTemplateGroup methodsFor: 'actions'!refresh	"Clear any cached data - this is a noop for non caching groups"! !!PhLAbstractTemplateGroup methodsFor: 'testing'!shouldComputeChildrenLazily	^ false! !!PhLAbstractTemplateGroup methodsFor: 'accessing'!templatesAndGroups	"Return a collection of all the templates and subgroups I contain"	^ self subclassResponsibility! !!PhLCacheTemplateGroup class methodsFor: 'instance creation'!group: aTemplateGroup	^ self new		setGroup: aTemplateGroup;		yourself! !!PhLCacheTemplateGroup methodsFor: 'accessing'!icon	^ delegate icon! !!PhLCacheTemplateGroup methodsFor: 'testing'!isHighlighted	^ delegate isHighlighted! !!PhLCacheTemplateGroup methodsFor: 'accessing'!name	^ delegate name! !!PhLCacheTemplateGroup methodsFor: 'actions'!refresh	templatesAndGroups := nil! !!PhLCacheTemplateGroup methodsFor: 'initialization'!setGroup: templateGroup	delegate := templateGroup.! !!PhLCacheTemplateGroup methodsFor: 'accessing'!templatesAndGroups	^ templatesAndGroups		ifNil: [ templatesAndGroups := delegate templatesAndGroups ]		! !!PhLDownloadedTemplateGroup class methodsFor: 'accessing'!default	^ Default ifNil: [ Default := self new ]! !!PhLDownloadedTemplateGroup class methodsFor: 'instance creation'!named: aName	^ Default := self new 			setName: aName;		yourself! !!PhLDownloadedTemplateGroup methodsFor: 'accessing'!baseDirectory	^ baseDirectory! !!PhLDownloadedTemplateGroup methodsFor: 'accessing'!baseDirectory: aDirectory	baseDirectory := aDirectory ensureCreateDirectory! !!PhLDownloadedTemplateGroup methodsFor: 'accessing'!cacheFile		^ (self baseDirectory / 'cache', 'json') ensureCreateFile! !!PhLDownloadedTemplateGroup methodsFor: 'private'!dictionary	^ self cacheFile		readStreamDo: [ :aStream | 			aStream atEnd				ifTrue: [ Dictionary new ]				ifFalse: [ STONJSON fromStream: aStream ] ]! !!PhLDownloadedTemplateGroup methodsFor: 'action'!downloadAndStoreFile: anUrl forTemplate: aRemoteTemplate	"Download the file at anUrl (hopefully a zip archive), put it in my cache, and update the meta-data file (using information from aRemoteTemplate). If everything went well, a reference to the downloaded file is returned"	| destinationFile fileExtension |	"We want to keep the same extension..."	fileExtension := anUrl lastPathSegment copyAfterLast: $..	"...but change the file name to be the one of aRemoteTemplate"	destinationFile := self baseDirectory / aRemoteTemplate name , fileExtension.	destinationFile ensureDelete.	PhLDownloadManager default download: anUrl toFile: destinationFile.	self register: aRemoteTemplate withZip: destinationFile.	^ destinationFile! !!PhLDownloadedTemplateGroup methodsFor: 'accessing'!icon	^ self iconNamed: #home! !!PhLDownloadedTemplateGroup methodsFor: 'initialization'!initialize 	super initialize.	baseDirectory := (FileLocator preferences / 'pharo' / 'templateCache') ensureCreateDirectory! !!PhLDownloadedTemplateGroup methodsFor: 'accessing'!name	^ name! !!PhLDownloadedTemplateGroup methodsFor: 'accessing'!pharoStableImagePath	| img |	img := (self resourcesPath  / 'images' / 'pharo-stable.zip') asFileReference.	^ img exists 		ifTrue: [ img ]		ifFalse: [ nil ]! !!PhLDownloadedTemplateGroup methodsFor: 'private'!register: aRemoteTemplate withZip: aZipFile	"Update my cache file by adding information about a new zip file as described in aRemoteTemplate"	| aDictionary templateDescription |	aDictionary := self dictionary.	templateDescription := aDictionary at: aRemoteTemplate name ifAbsentPut: [ Dictionary new ].	self updateTemplateDescription: templateDescription with: aRemoteTemplate.	self saveToFile: aDictionary! !!PhLDownloadedTemplateGroup methodsFor: 'accessing'!resourcesPath	| vmDirectory |		vmDirectory := Smalltalk vm binary parent.	Smalltalk os isMacOSX ifTrue: [ ^ vmDirectory parent / 'Resources' ].	Smalltalk os isUnix ifTrue: [ ^ vmDirectory parent/ 'shared' ].	Smalltalk os isWindows ifTrue: [ ^ vmDirectory ].! !!PhLDownloadedTemplateGroup methodsFor: 'private'!saveToFile: aDictionary	self cacheFile writeStreamDo: [ :aStream | 	STONJSON put: aDictionary onStream: aStream ] ! !!PhLDownloadedTemplateGroup methodsFor: 'accessing'!setName: aString 	name := aString! !!PhLDownloadedTemplateGroup methodsFor: 'accessing'!templatesAndGroups	"Read the cache file to answer a list of already downloaded templates"	| aDictionary templates |	templates := SortedCollection sortBlock: [ :e1 :e2 | e1 name < e2 name ].	aDictionary := self dictionary.	aDictionary valuesDo: [ :value | 		(self baseDirectory / (value at: #name), 'zip') exists 			ifTrue: [ templates add:			(PhLLocalTemplate 				name: (value at: #name)				zipFile: self baseDirectory / (value at: #name), 'zip')  ]			ifFalse: [ self flag:'TODO remove non existing stuff' ].		].	self pharoStableImagePath ifNotNil: [:image | 		templates add: 			(PhLLocalTemplate 				name: 'Pharo image (stable)'				zipFile: image)		].	^ templates! !!PhLDownloadedTemplateGroup methodsFor: 'private'!updateTemplateDescription: templateDescription with: aRemoteTemplate	templateDescription at: 'url' put: aRemoteTemplate url asString.	templateDescription at: 'name' put: aRemoteTemplate name.	templateDescription at: 'downloadDate' put: DateAndTime now asString! !!PhLFixedURLsTemplateGroup methodsFor: 'adding'!addTemplate: aTemplate	templates add: aTemplate! !!PhLFixedURLsTemplateGroup methodsFor: 'accessing'!icon	^ self iconNamed: #remote! !!PhLFixedURLsTemplateGroup methodsFor: 'accessing'!name	^ name! !!PhLFixedURLsTemplateGroup methodsFor: 'initialization'!setName: aString Templates: aCollection	name := aString.	templates := aCollection! !!PhLFixedURLsTemplateGroup methodsFor: 'accessing'!templatesAndGroups	^ templates! !!PhLHTTPListingTemplateGroup class methodsFor: 'defaults'!defaultFilterPattern	"Returns the default filter pattern (Pharo6). The parenthesis here are important because this is what we want to extract for each match. The #subexpression must correspond to the index of this pair of parenthesis"	^'href="([^"]*.zip)"' ! !!PhLHTTPListingTemplateGroup class methodsFor: 'instance creation'!name: aString url: anUrl	^ self new		setName: aString url: anUrl;		yourself! !!PhLHTTPListingTemplateGroup class methodsFor: 'instance creation'!name: aString url: anUrl filterPattern: aPatternString	^ self new		setName: aString url: anUrl filterPattern: aPatternString;		yourself! !!PhLHTTPListingTemplateGroup class methodsFor: 'instance creation'!name: aString url: anUrl filterPattern: aPatternString templateNameFormat: aNameFormat username: anotherString password: yetAnotherString	^ (self name: aString url: anUrl filterPattern: aPatternString)		  username: anotherString;		  password: yetAnotherString;		  templateNameFormat: aNameFormat;		  yourself! !!PhLHTTPListingTemplateGroup class methodsFor: 'instance creation'!name: aString url: anUrl filterPattern: aPatternString username: anotherString password: yetAnotherString	^ (self name: aString url: anUrl filterPattern: aPatternString)		  username: anotherString;		  password: yetAnotherString;		  yourself! !!PhLHTTPListingTemplateGroup class methodsFor: 'instance creation'!name: aString url: anUrl username: anotherString password: yetAnotherString	^ (self name: aString url: anUrl)		  username: anotherString;		  password: yetAnotherString;		  yourself! !!PhLHTTPListingTemplateGroup class methodsFor: 'accessing'!regexCache	"Cache the regex per version so that we don't recompute it all the time"	^ RegexCache ifNil: [ RegexCache := Dictionary new ]! !!PhLHTTPListingTemplateGroup class methodsFor: 'accessing'!subexpression	"Index of the #regex subexpression (delimited by parenthesis) we are interested in. See 'usage' documentation at RxParser"	^ 2! !!PhLHTTPListingTemplateGroup methodsFor: 'private'!createTemplateFromHref: filename addingTo: templates	| templateName urlFile |	templateNameFormat 		ifNil: [ templateName := filename copyUpToLast: $..			urlFile := url / filename ]		ifNotNil: [ templateName := templateNameFormat formatTemplateName: filename. 			urlFile := url clearPath / filename ].	templates add: (PhLRemoteTemplate name: templateName url: urlFile)! !!PhLHTTPListingTemplateGroup methodsFor: 'accessing'!icon	^ self iconNamed: #remote! !!PhLHTTPListingTemplateGroup methodsFor: 'accessing'!name	^ name! !!PhLHTTPListingTemplateGroup methodsFor: 'accessing'!password	^ url password! !!PhLHTTPListingTemplateGroup methodsFor: 'accessing'!password: aString	^ url password: aString! !!PhLHTTPListingTemplateGroup methodsFor: 'accessing'!regex	^ self class regexCache at: self name asSymbol ! !!PhLHTTPListingTemplateGroup methodsFor: 'initialization'!setName: aName url: anUrl	name := aName.	url := anUrl.	self class regexCache at: aName asSymbol put: (RxParser parse: self class defaultFilterPattern) ! !!PhLHTTPListingTemplateGroup methodsFor: 'initialization'!setName: aName url: anUrl filterPattern: aPatternString	name := aName.	url := anUrl.	self class regexCache at: aName asSymbol put: (RxParser parse: aPatternString)! !!PhLHTTPListingTemplateGroup methodsFor: 'accessing'!subexpression	^ self class subexpression! !!PhLHTTPListingTemplateGroup methodsFor: 'accessing'!templateNameFormat	^ templateNameFormat! !!PhLHTTPListingTemplateGroup methodsFor: 'accessing'!templateNameFormat: anObject	templateNameFormat := anObject! !!PhLHTTPListingTemplateGroup methodsFor: 'accessing'!templatesAndGroups	| content matcher templates |	content := PhLDownloadManager default downloadToPositionableStream: url mimeType: ZnMimeType textHtml. 	matcher := RxMatcher for: self regex.	templates := OrderedCollection new.	[ matcher searchStream: content ] whileTrue: 		[ self createTemplateFromHref: (matcher subexpression: self subexpression)  addingTo: templates ].	^ templates	! !!PhLHTTPListingTemplateGroup methodsFor: 'accessing'!username	^ url username! !!PhLHTTPListingTemplateGroup methodsFor: 'accessing'!username: aString	url username: aString! !!PhLJenkins2BuildGroup class methodsFor: 'instance creation'!name: aString builds: aCollection 	^ self new		setName: aString builds: aCollection;		yourself! !!PhLJenkins2BuildGroup methodsFor: 'accessing'!builds	^ builds! !!PhLJenkins2BuildGroup methodsFor: 'accessing'!name	^ name! !!PhLJenkins2BuildGroup methodsFor: 'initialization'!setName: aString builds: aCollection 	name := aString.	builds := aCollection! !!PhLJenkins2BuildGroup methodsFor: 'accessing'!templatesAndGroups	^ self builds sorted: [ :b1 :b2 | b1 number > b2 number ]! !!PhLJenkins2Entity class methodsFor: 'testing'!isAbstract	^ self = PhLJenkins2Entity! !!PhLJenkins2Entity class methodsFor: 'protected'!jsonFields	^ self subclassResponsibility! !!PhLJenkins2Entity class methodsFor: 'protected'!jsonFieldsQuery	^ $, join: self jsonFields! !!PhLJenkins2Entity class methodsFor: 'protected'!jsonName	^ self subclassResponsibility ! !!PhLJenkins2Entity class methodsFor: 'instance creation'!newWithProperties: json 	^ self new		setProperties: json;		yourself! !!PhLJenkins2Entity methodsFor: 'accessing'!children	"Since we need to request the network to get children, it is better to cache them.	In the current use of the launcher, the jenkins entities are recreated each time we want to create a new image. Thus, we can cache the children, the probability of the jenkins been updated meanwhile."	^ childrenCache ifNil: [ childrenCache := super children ]! !!PhLJenkins2Entity methodsFor: 'accessing'!icon 	"(Base64MimeConverter mimeEncode: 'jenkins.png' asFileReference binaryReadStream) contents"	^ (Form fromBase64String: 'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAACXBIWXMAAAsTAAALEwEAmpwYAAACC2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS40LjAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyI+CiAgICAgICAgIDx0aWZmOlJlc29sdXRpb25Vbml0PjI8L3RpZmY6UmVzb2x1dGlvblVuaXQ+CiAgICAgICAgIDx0aWZmOkNvbXByZXNzaW9uPjE8L3RpZmY6Q29tcHJlc3Npb24+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlBob3RvbWV0cmljSW50ZXJwcmV0YXRpb24+MjwvdGlmZjpQaG90b21ldHJpY0ludGVycHJldGF0aW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KD0UqkwAACPlJREFUWAmVVwtQVOcV/u6+lwVWdmURWJ6u4gMUqA+MImmjURMdNRpfmWTaTDJTk4xJOtXJTKdpptNO0zbTSSedaTOBVtvG6BjHWG2MqAV1iiIkgjyDiLAssLzZ93tvz/+Tiyig9uzce/f+j3O+8/6vIBLhMYgtEwQB0WgUHXfacfFSJbo7u2CIk4/vVmhgMmdg3fr1SDaZ+DqZTPZIzsLjAJCE93TbcK2qCuVfXUJRQSY2r1sNfZwGUQLndbrQ1m7Fmcs12P2j17B0SR6NRyETHg7ikQCYxkyThvp6VF6oQCDow6anC7AwzQjR64Uv4EEwEoFCroRGo4XXH0DpZ19i24sHYLFkP9ISD4UnRkUuvL/PjsNlpXD5AshflIGFqUZ4RsfQ1DkM27APSqWaC3J5nJDLFEhNTcdPDv4M4VCI78dDvDwjAG52mYAAafRJaSkyLfPg8vshhD2IBr2ov2NH7a0WiJEQBOZpEqJQKOElq6zIy8aWlWa03m7nMcBcNBM9FADbZLf3wjfqQDAQxNe1DVDLogiFw9ApQ9i1qQhpJj38AT8UgpLAyBCjVsJsisO64kJ4HaMzyZ0Ynx4AAZaC53zFFXTZrWhpbUF6ymwkmcj3kTAsGWZESXtoDOgeJMvIBVh7++HzhREUtWjssGN4oI8LYtkzE00LIIoomF1PnDiBGy//EPpYLRYvsKCn14ZwlExOrmFWECnC65vuoLyyHsMuF7SxOtQ1d1I23IXLG8HZo4dRefkKT99INDIthikAeNQT46raajh37cL2bc9hw4ankGkywJyaiMEhJ1lHwf0uCCKSDWpsX1+A2BgtzEY9wrIQfB4XtqxfjiJjAk49WYLO7l4KTjlP1wdR3AeABR5LOZfPh6/e/wgbU/UY1aphSTYgOSaEn/94B3JzMuAPBvg6MSIiaXYcUubE8uiXE7eSFflo7Bogtw3AGBbxHEk8+tcyLldGrmAyJtMUAGyyqroGK09+CkXhKgQ+O4umu63Iz8+FWhmkfCcGIjHiP1CqRaGIymAfcOHbHgfqmtqRm21C0O1D+FY7Mn9QArz3Lhra2rjcGQFI2oep8DSdO4esRD2G3A6sXDYXPX86hrd+XYrugRDkChWiFB8CuUkglQOCHI137ahvbsPFyhp0dPejb9CN9o5B6JpqIKgUWESia65e5QAeDMcJC0iG6R8Zge5yJXTZ8+APhQG1ClvVCpiPkEViY8kKSoyOOODxhqAkMH6PG539Dqg0sciaMwtZKQlUhhdj5JtGJBoNcAcjyMgywl59nfixAJ4QyQHde/vONyPDw0igxeEYNVRUCQPRIPwk9Pswoq6uDjKlBjEqLRparQh6g0gx6HlZDofclAUa5C9cgMaGW4j/5DD08xbA73UifnYqFHVVGHU6uVDWIyRSSH+kp9fjAetvUbkCkagfcezpdsOao8ORPx7H6uV5yKbis5hMdvnWHXxvXjJy5s5BdloypZ6DmlEV9v2tCq+sKkbmgB2zdVSoKD2VFdeoT/jHxTBzf+eLKQDYCoZPIJQapRydhPrfYizKi7ZilqDHgXc/xqEDL0JDvu04ew7/sg7C8vQaZM9JRUXNTXjK/o6XN+/BhcQ8fNtyDb8MupGuHRcjleTJcTAFgFqthoMAREQ5yh0ufJxkgTKnEBmiDEGnA40+NU5dbYWeYJqPnYEpOw+uD8/g2rO5yO8dQcyKNXi/thzz1u5EhXkhepurkB4jR2iuBVqViulHdA/CFAAJBgMGF8yHzzmCv+jTMSe3CGJvDwZcY+QWOdLpsPHRzdvYPGpDQ+4inG5qxhuGWAT60vCNTItPb1QgKIuHLuDDstEBZMfr4BmxI7jiCcyKi39QPiYASPU6yWhEqOQpCOePYmeSFsfdXiRS2YVKCbmgQjDkxSqdCk4tWabRhkwxgmPJmSh9/U1YFmUh9fwmdI958Y8rNXiVAthI2tuudyHh1bcRq9XwrinJYmgmskA6bmnITIs3bIC104EiuR9tzmEodXFUcQgEUYQaUIiCyEs1oFUtYP1P38Obv/kzaru6oBJDSMpaRJnDgPqQL0QQF6dHPe0rXLOG75figL/QbQIAG5CQFZcUo2pJAUx0+tnpHsEImZ5lBhVAWiRHrN5AQaiC2bIMoVCAwAUQSUim1LyDIVsnLld/jSfjYmAZ7Ma10+dg3fcSVuQXMhETMvgLe6cKKNUgPiYdwc5+eR5dz26Ed8vz+MCYgrl0JvBQ+VWTwHCMATcbOsgMlFbdlXxf3jN7kaahRuTyosLmQA5lwK59O5C/fTcGqbhtIqumZ6TzXiApyjZOAcBrPGESKOo//P1vcfqdd6B45SDGBochp1bs7buL1SuXYWGOhU6/idBRdVQo5HA5xnD2zDkcudGGX7y0EalJKVhaWIj5WdmIkPsuXLqIPXv2TAEwEYRcDYaIfrxOkHNef+ttDLs9OF7fC5NGBoVShxvDiTjxxn4soEx5kMIROY7881cE8AmkpZqhJNd1W62YP5+yyuuDnwqRRkOBOInuiwFpnLXNCJ10VdQHnt+2Fe3UlGI0MRDYoaKqDw7SllGYNGMui9AlRqh8RVmg1qPHasNAfz+cVEF1Oh1GR0e55tN9J0yxAOdMN8lPgpIwVnyO5uIdKLCYgeWz0UfMGTGGk5kq1UwfI0598QVeeGEv7x1snVKhIHcUQEWBy0JO4s3m2MD0FKWEIQoEA+J/r14V9+9/jTyTwbwj/u6DP/A50p4/x29R8T8Xy8XNz2wTT35+kg+FgkHRbreLQ0NDk9bd/3dKEHJU09xC1EpbmpvR2tpE120cPHQIWq32nkYErbamlk7RfUijaF+6dOm9uWn4SUPTxoA0Of4UuZ+V1JKXENNdu/eheO1a2Gw2Ps1ihV2svLPDr4sOpy0tLXyOdOUg2HMmegwAwvj5j5hwQcQpMzMT7e3tnKeC/CunaGfEQF6/fh1FRUX8nflauvjANLfHdsHkvSzyy8rKOKCsrCwueIw+1W5UV2PP3r3IL8jncxKwyXsf/P9/A5DMyWKir68Pbko1ZhmW3/HU7UyJifzYxb4dHof+Bz/cTBmvnojyAAAAAElFTkSuQmCC') magnifyBy: 0.5! !!PhLJenkins2Entity methodsFor: 'protected'!jsonQuery: query	| queryUrl |	queryUrl := self url / 'api' / 'json' ? ('tree' -> query).	^ STONJSON		fromStream: (PhLDownloadManager default downloadToPositionableStream: queryUrl mimeType: ZnMimeType applicationJson)! !!PhLJenkins2Entity methodsFor: 'accessing'!parent: aPhLEntity	parent := aPhLEntity! !!PhLJenkins2Entity methodsFor: 'accessing'!password	^ parent password! !!PhLJenkins2Entity methodsFor: 'accessing'!properties	^ properties! !!PhLJenkins2Entity methodsFor: 'protected'!query: jenkinsType	| query |	query := jenkinsType jsonName , '[' , jenkinsType jsonFieldsQuery , ']'.	^ ((self jsonQuery: query) at: jenkinsType jsonName ifAbsent: [nil])		ifNil: [ #() ]		ifNotNil: [ :jsonObjects | 			jsonObjects				collect: [ :json | 					(jenkinsType newWithProperties: json)						parent: self;						yourself ] ]! !!PhLJenkins2Entity methodsFor: 'initialization'!setProperties: json 	properties := json! !!PhLJenkins2Entity methodsFor: 'testing'!shouldComputeChildrenLazily	"to know if the group has children, we need to send an ReST request. It can take a lot of time.	It is better to do it lazily"	^ true! !!PhLJenkins2Entity methodsFor: 'accessing'!url	"We get the URL from the json sent by Jenkins. In case of a secure Jenkins, we need to set the username and token to the URL we get."	| url |	url := (properties at: 'url') asUrl.	self username ifNotNil: [ :username | url username: username ].	self password ifNotNil: [ :token | url password: token ].	^ url! !!PhLJenkins2Entity methodsFor: 'accessing'!username	^ parent username! !!PhLJenkins2Job class methodsFor: 'protected'!jsonFields	^ {'name'.	'url'.	('lastSuccessfulBuild[' , PhLJenkins2Build jsonFieldsQuery , ']')}! !!PhLJenkins2Job class methodsFor: 'protected'!jsonName	^ 'jobs'! !!PhLJenkins2Job methodsFor: 'accessing'!builds	"Pipelines define jobs whereas standard jobs define builds"	^ (self query: PhLJenkins2Build)		ifEmpty: [ self query: PhLJenkins2Job ]! !!PhLJenkins2Job methodsFor: 'accessing'!lastSuccessfulBuild	^ (PhLJenkins2Build		newWithProperties:			(Dictionary new				at: 'number' put: self lastSuccessfulBuildNumber;				at: 'url' put: (self url / 'lastSuccessfulBuild') printString;				yourself))		parent: self;		yourself! !!PhLJenkins2Job methodsFor: 'accessing'!lastSuccessfulBuildNumber	^ properties at: 'lastSuccessfulBuild'		ifPresent: [ :dict | dict ifNil: [nil] ifNotNil: [dict at: 'number' ifPresent: [:num | num ] ifAbsent: [ nil ] ]]		ifAbsent: [ nil ]! !!PhLJenkins2Job methodsFor: 'accessing'!name	^ properties at: 'name'! !!PhLJenkins2Job methodsFor: 'accessing'!templatesAndGroups	| builds |	builds := self builds.	self lastSuccessfulBuildNumber ifNil: [ ^ builds ].	^ {(self lastSuccessfulBuild).	(PhLJenkins2BuildGroup name: 'All builds' builds: builds)}! !!PhLJenkins2Server class methodsFor: 'protected'!jsonFields	"Because the server is the root of the jenkins model"	^ self shouldNotImplement! !!PhLJenkins2Server class methodsFor: 'protected'!jsonName	"Because the server is the root of the jenkins model"	^ self shouldNotImplement! !!PhLJenkins2Server class methodsFor: 'instance creation'!name: aString url: anUrl	^ self new		setName: aString url: anUrl;		yourself! !!PhLJenkins2Server class methodsFor: 'instance creation'!name: aString url: anUrl username: anotherString password: yetAnotherString	^ (self name: aString url: anUrl)		  username: anotherString;		  password: yetAnotherString;		  yourself! !!PhLJenkins2Server methodsFor: 'accessing'!jobs	^ self query: PhLJenkins2Job! !!PhLJenkins2Server methodsFor: 'accessing'!name	^ name! !!PhLJenkins2Server methodsFor: 'accessing'!password	^ url password! !!PhLJenkins2Server methodsFor: 'accessing'!password: aString	url password: aString! !!PhLJenkins2Server methodsFor: 'initialization'!setName: aString url: aZnUrl 	name := aString.	url := aZnUrl! !!PhLJenkins2Server methodsFor: 'accessing'!templatesAndGroups	^ self jobs! !!PhLJenkins2Server methodsFor: 'accessing'!url	^ url! !!PhLJenkins2Server methodsFor: 'accessing'!username	^ url username! !!PhLJenkins2Server methodsFor: 'accessing'!username: aString	url username: aString! !!PhLJenkins2Build class methodsFor: 'protected'!jsonName	^ 'builds'! !!PhLJenkins2Build methodsFor: 'testing'!isLastSuccessful	^ self url lastPathSegment = 'lastSuccessfulBuild'! !!PhLJenkins2Build methodsFor: 'accessing'!name	^ String streamContents: [:str |		self isLastSuccessful 			ifTrue: [ str nextPutAll: 'Latest sucessful build: ' ].		str 			nextPut: $#;		 	print: self number]! !!PhLJenkins2Build methodsFor: 'private'!propagateLastSuccessfulTagTo: aRun 	| url |	url := aRun url copy.	url isDirectoryPath ifTrue: [ url := url removeLastPathSegment ].	url := url removeLastPathSegment.	url := url / 'lastSuccessfulBuild'.	url closePath.	aRun properties at: 'url' put: url! !!PhLJenkins2Build methodsFor: 'accessing'!runs	|runs|	runs := self query: PhLJenkins2Run.	^ self isLastSuccessful	ifTrue: [ runs do: [ :run | self propagateLastSuccessfulTagTo: run ] ]	ifFalse: [ runs ]! !!PhLJenkins2Build methodsFor: 'accessing'!templatesAndGroups	^ super templatesAndGroups , self runs! !!PhLJenkins2Run class methodsFor: 'protected'!jsonName	^ 'runs'! !!PhLJenkins2Run methodsFor: 'accessing'!name	^ String streamContents: [ :stream | self url jenkinsOptions printElementsOn: stream ]! !!PhLJenkins2WithArtifactsEntity class methodsFor: 'protected'!jsonFields	^ #('number' 'url')! !!PhLJenkins2WithArtifactsEntity methodsFor: 'accessing'!artifactTemplates	^ self artifacts		inject: OrderedCollection new		into: [ :templates :artifact | 			artifact isPotentialTemplate				ifTrue: [ templates add: artifact asTemplate ].			templates ]! !!PhLJenkins2WithArtifactsEntity methodsFor: 'accessing'!artifacts	^ self query: PhLJenkinsArtifact! !!PhLJenkins2WithArtifactsEntity methodsFor: 'accessing'!name	^ '#', self number printString! !!PhLJenkins2WithArtifactsEntity methodsFor: 'accessing'!number	^ properties at: 'number'! !!PhLJenkins2WithArtifactsEntity methodsFor: 'accessing'!templatesAndGroups	^ self artifactTemplates! !!PhLImage class methodsFor: 'accessing'!classForLocation: imageFileReference	^ self allSubclasses		detect: [ :cls | cls isSubclassForLocation: imageFileReference ]		ifNone: [ self ]! !!PhLImage class methodsFor: 'accessing'!descriptionFileName	^ 'description.txt'! !!PhLImage class methodsFor: 'example'!example	| fsRoot imageFile |	fsRoot := FileSystem memory root.	imageFile := fsRoot / 'foo64.image'.	imageFile binaryWriteStreamDo: 		[ :stream | 		(ZnEndianessReadWriteStream on: stream ) nextLittleEndianNumber: 4 put: PhLVirtualMachineManager imageFormat64bits ].	^ self location: imageFile! !!PhLImage class methodsFor: 'example'!example32	| fsRoot imageFile |	fsRoot := FileSystem memory root.	imageFile := fsRoot / 'foo32.image'.	imageFile binaryWriteStreamDo: 		[ :stream | 		(ZnEndianessReadWriteStream on: stream ) nextLittleEndianNumber: 4 put: PhLVirtualMachineManager imageFormat32bits ].	^ self location: imageFile! !!PhLImage class methodsFor: 'instance creation'!imageFromMetadata: imageFileReference ifAbsent: aBlock	"Will recreate the image object from its STON serialized version if possible"	^ imageFileReference parent / self metadataFileName			readStreamDo: [ :stream | 				| object |				object := (self stonReader on: stream) next.				object asPhLImage ]			ifAbsent: aBlock! !!PhLImage class methodsFor: 'initialization'!initialize	SessionManager default registerUserClassNamed: self name! !!PhLImage class methodsFor: 'testing'!isSubclassForLocation: imageFileReference	| versionFile |	versionFile := imageFileReference parent / self versionFileName.	^ versionFile exists and: [ versionFile contents beginsWith: self versionPrefix ]! !!PhLImage class methodsFor: 'validating'!isValidName: anImageName 	^ anImageName isNotEmpty and: [ (anImageName includesAny: #/\) not ]! !!PhLImage class methodsFor: 'instance creation'!location: imageFileReference	| instance |	instance := self		imageFromMetadata: imageFileReference		ifAbsent: [ (self classForLocation: imageFileReference) new ].	^ instance		setLocation: imageFileReference;		yourself! !!PhLImage class methodsFor: 'accessing'!metadataFileName	^ 'meta-inf.ston'! !!PhLImage class methodsFor: 'system startup'!startUp: isImageStarting	isImageStarting ifTrue: [ reader := nil ]! !!PhLImage class methodsFor: 'serialization'!stonAllInstVarNames	^ super stonAllInstVarNames reject: [ :varName | varName = #file ]! !!PhLImage class methodsFor: 'accessing'!stonReader	"The ston reader is building caches when reading a file. Since we read *a lot* of files, we cache a reader with all the built caches."	^ reader 		ifNil: [ reader := STONReader new ]		ifNotNil: [ reader reset; yourself ]! !!PhLImage class methodsFor: 'accessing'!versionFileName	^ 'pharo.version'! !!PhLImage class methodsFor: 'accessing'!versionPrefix	"Used in matching me to a VM. See class comment, 'VM Matching' section"	^ ''! !!PhLImage methodsFor: 'configuring'!addLaunchConfiguration: aPhLLaunchConfiguration	launchConfigurations 		detect: [ :each | each name = aPhLLaunchConfiguration name ]		ifFound: [ PhLError signal: 'Cannot add configuration!! A configuration with the same name already exists.' ]		ifNone: [ launchConfigurations add: aPhLLaunchConfiguration ]! !!PhLImage methodsFor: 'accessing'!architecture	^ architecture ifNil: [ self computeArchitecture. "Always be able to display image architecture" ]! !!PhLImage methodsFor: 'converting'!asPhLImage	^ self! !!PhLImage methodsFor: 'testing'!canBeLaunched	^ self architecture = '32' 		ifTrue: [ self os canRun32bitApp ]		ifFalse: [ true "we do not manage the case where a 64-bit image want to be launched on a 32-bit OS"]! !!PhLImage methodsFor: 'accessing'!changesFile	^ self file parent / self file basenameWithoutExtension , 'changes'! !!PhLImage methodsFor: 'computing'!computeArchitecture	self computeFormatNumber.	((PhLVirtualMachineManager is32bits: formatNumber)		or: [ PhLVirtualMachineManager isPreSpur: formatNumber ])		ifTrue: [ ^ architecture := '32' ].	(PhLVirtualMachineManager is64bits: formatNumber)		ifTrue: [ ^ architecture :='64' ].	^ architecture := 	'N/A'! !!PhLImage methodsFor: 'computing'!computeFormatNumber	formatNumber := PhLVirtualMachineManager imageFormatNumberFromFile: file! !!PhLImage methodsFor: 'computing'!computePharoVersion	pharoVersion := self vmManager imageVersion.	self computeArchitecture.	self serializeMetadata.	^ pharoVersion! !!PhLImage methodsFor: 'accessing'!defaultArguments	^ OrderedCollection new! !!PhLImage methodsFor: 'accessing'!defaultLaunchConfiguration	^ launchConfigurations 		detect: [ :each | each name = PhLLaunchConfiguration defaultName ]		ifNone: [ PhLLaunchConfiguration defaultWithImage: self ]! !!PhLImage methodsFor: 'accessing'!defaultLaunchConfigurationName	^ 'Default'! !!PhLImage methodsFor: 'accessing'!description	^ description ifNil: [ self descriptionFromFile ]! !!PhLImage methodsFor: 'accessing'!description: aString	description := aString ifNotNil: #asString. "ensure we do not get Text"	self serializeMetadata.! !!PhLImage methodsFor: 'accessing'!descriptionFromFile	| descriptionFile |	self flag: 'This method is there for backward compatibility. description.txt file has been superseded by the metainformation file meta-inf.ston'.	descriptionFile := file parent / self class descriptionFileName.		^ descriptionFile exists		ifTrue: [ descriptionFile contents withNoLineLongerThan: 80 ]		ifFalse: [ 'There is no description' ]! !!PhLImage methodsFor: 'configuring'!doNotRunInitializationScript	self shouldRunInitializationScript: false.! !!PhLImage methodsFor: 'computing'!ensurePharoVersion	^ (self pharoVersion isNil or: [ self pharoVersion = '' ])			ifFalse: [ 				self vmManager imageVersion: self pharoVersion.				self pharoVersion ]			ifTrue: [ self computePharoVersion ]	! !!PhLImage methodsFor: 'accessing'!file 	^file! !!PhLImage methodsFor: 'accessing'!formatNumber	^ formatNumber! !!PhLImage methodsFor: 'testing'!hasChildren	^ false! !!PhLImage methodsFor: 'accessing'!imageFile	^ self file! !!PhLImage methodsFor: 'accessing'!initializationScript	^ initializationScript ifNotNil: [ :script | script asFileReference ]! !!PhLImage methodsFor: 'accessing'!initializationScript: aFileReference	initializationScript := aFileReference.	self serializeMetadata! !!PhLImage methodsFor: 'initialization'!initialize	super initialize.	launchConfigurations := OrderedCollection new.	shouldRunInitializationScript := true! !!PhLImage methodsFor: 'testing'!isHighlighted	^ false! !!PhLImage methodsFor: 'testing'!isImage	^ true! !!PhLImage methodsFor: 'accessing'!lastModification	^ [ self file modificationTime ]		  on: FileDoesNotExistException		  do: [ nil ]! !!PhLImage methodsFor: 'action'!launch	^ self launchWithConfiguration: self defaultLaunchConfiguration ! !!PhLImage methodsFor: 'accessing'!launchConfigurations	^ launchConfigurations		ifEmpty: [ launchConfigurations 						add: self defaultLaunchConfiguration;						yourself ]! !!PhLImage methodsFor: 'accessing'!launchConfigurations: aCollection 	launchConfigurations := aCollection! !!PhLImage methodsFor: 'action'!launchWithConfiguration: aPhLLaunchConfiguration	| architectureWarningEnabled continue |	self canBeLaunched		ifFalse: [ PhLArchitectureError signalImage: self. ^ self ].	architectureWarningEnabled := true.	continue := true.	[ [ | processWrapper|		processWrapper := (aPhLLaunchConfiguration launchProcess) runUnwatch.		self doNotRunInitializationScript. "Just run, image already initialized"		^ processWrapper ]	on: PhLImageVersionDeterminationError	do: [ :error | error uiAlert ] ]	on: PhLArchitectureMismatchWarning	do: [ :warning |		architectureWarningEnabled ifTrue: [ 				architectureWarningEnabled := false. "only raise one warning"			continue := self showWarning: warning ].		continue ifTrue: [ warning resume ] ]! !!PhLImage methodsFor: 'accessing'!location 	^ file fullName! !!PhLImage methodsFor: 'accessing'!name	^ file basenameWithoutExtension! !!PhLImage methodsFor: 'accessing'!originTemplate	^ originTemplate! !!PhLImage methodsFor: 'accessing'!originTemplate: aPhLTemplate		self privOriginTemplate: aPhLTemplate.	self serializeMetadata.! !!PhLImage methodsFor: 'accessing'!originTemplateName	^ self originTemplate 		ifNotNil: [ :template | template name ] 		ifNil: [ #unknown ]! !!PhLImage methodsFor: 'accessing'!originTemplateUrl	^ self originTemplate 		ifNotNil: [ :template | template url asString ] 		ifNil: [ #unknown ]! !!PhLImage methodsFor: 'private - accessing'!os	^ OSPlatform current! !!PhLImage methodsFor: 'accessing'!pharoVersion	^ pharoVersion ifNil: [ self pharoVersionFromFile ]! !!PhLImage methodsFor: 'accessing'!pharoVersionFromFile	file ifNil: [ ^ '' ].	^ self versionFile exists		ifTrue: [ pharoVersion := self versionFile contents trim ]		ifFalse: [ '' ]! !!PhLImage methodsFor: 'accessing'!pharoVersionString	^ (self pharoVersion asNumber / 10.0) asFloat asString! !!PhLImage methodsFor: 'printing'!printOn: aStream	aStream		nextPutAll: 'Image (';		nextPutAll: self name;		nextPutAll: ')'! !!PhLImage methodsFor: 'accessing'!privOriginTemplate: aPhLTemplate		originTemplate := aPhLTemplate.! !!PhLImage methodsFor: 'serialization'!serializeMetadata	file exists ifFalse: [ "image deleted" ^ self ].	(file parent / self class metadataFileName)		writeStreamDo: [ :stream | stream nextPutAll: self stonString ]! !!PhLImage methodsFor: 'initialization'!setLocation: aFile 	file := aFile.! !!PhLImage methodsFor: 'accessing'!shouldRunInitializationScript	^ shouldRunInitializationScript! !!PhLImage methodsFor: 'configuring'!shouldRunInitializationScript: aBoolean	shouldRunInitializationScript := aBoolean.	self serializeMetadata.! !!PhLImage methodsFor: 'printing'!showNativeFolder	PhLFileBrowser openOn: file! !!PhLImage methodsFor: 'private ui'!showWarning: warning	| continue |	continue := true.	(PhLLaunchImageCommand warnOnArchMismatch)		ifTrue: [ 			continue := (PharoLauncherApplication default newConfirm 				title: warning name ;				message: warning longDescription;				openModalWithParent: PharoLauncherApplication default topWindow) ].				^ continue! !!PhLImage methodsFor: 'accessing'!sourcesFile	^ self file parent files 		detect: [ :fileRef | fileRef extension = 'sources' ]! !!PhLImage methodsFor: 'serialization'!stonString	^ STON toStringPretty: self! !!PhLImage methodsFor: 'printing'!summaryInfo	^ String		streamContents: [ :s | 			s nextPutAll: 'Last modified: '.			self file modificationTime printOn: s.			s				cr;				nextPutAll: self file parent fullName;				cr;				cr;				nextPutAll: self description ]! !!PhLImage methodsFor: 'accessing'!versionFile	^ self file parent / self class versionFileName! !!PhLImage methodsFor: 'private - accessing'!vmManager	^ vmManager ifNil: [ vmManager := PhLVirtualMachineManager forImage: self file ]! !!PhLObject methodsFor: 'accessing'!children	^ #()! !!PhLObject methodsFor: 'testing'!hasChildren	^ true! !!PhLObject methodsFor: 'testing'!isImage	^ false! !!PhLObject methodsFor: 'testing'!isLocalTemplate	^ false! !!PhLObject methodsFor: 'testing'!isTemplate	^ false! !!PhLObject methodsFor: 'testing'!isTemplateGroup	^ false! !!PhLROCheckStartup class methodsFor: 'initialization'!initialize	"Must be run before any write acess to the file system.	UI should already be usable!!"	"SessionManager default 		register: (ClassSessionHandler forClassNamed: self name)		inCategory: SessionManager default toolsCategory		atPriority: 1"! !!PhLROCheckStartup class methodsFor: 'system startup'!startUp		self verifyCanWrite! !!PhLROCheckStartup class methodsFor: 'system startup'!verifyCanWrite	[ (FileLocator workingDirectory / 'phl-canwrite') asFileReference  			ensureDelete; 			createDirectory;			ensureDelete. ]	on: Error	do: [ :error |		PharoLauncherApplication default newInform 			title: 'Cannot run PharoLauncher!!';			label: 'PharoLauncher cannot be run from a read-only filesystem. Please move it to a place where you have write permissions!!';			openModal.		Smalltalk exitFailure ]! !!PhLDirectoryBasedImageRepository class methodsFor: 'instance creation'!default	^ Default ifNil: [ Default := self new ]! !!PhLDirectoryBasedImageRepository class methodsFor: 'defaults'!defaultLocation	^ FileLocator launcherUserFilesLocation / 'images' ! !!PhLDirectoryBasedImageRepository class methodsFor: 'instance creation'!forDirectory: aDirectory	^ self new		setBaseDirectory: aDirectory;		yourself! !!PhLDirectoryBasedImageRepository class methodsFor: 'initialization'!initialize	PhLStartupManager addToLauncherStartUpList: self! !!PhLDirectoryBasedImageRepository class methodsFor: 'system startup'!launcherStartUp	"Fix the Location because the platform or computer can have changed"	(Location notNil and: [ Location exists not ])		ifTrue: [ 			"We could probably always set to nil without the previous checks, but I'm not sure because it may depend on #startUp order of classes (e.g., if PhLSettingBrowser class>>#startUp is first, we may have a problem)."			Location := nil ]! !!PhLDirectoryBasedImageRepository class methodsFor: 'system startup'!launcherStartUpPriority	^ 1! !!PhLDirectoryBasedImageRepository class methodsFor: 'accessing'!location	^ Location ifNil: [ Location := self defaultLocation ]! !!PhLDirectoryBasedImageRepository class methodsFor: 'accessing'!location: directory	self location resolve = directory resolve ifTrue: [ ^ self ].	self migrateFrom: self location to: directory.	Location := directory.	self default contentsChanged! !!PhLDirectoryBasedImageRepository class methodsFor: 'accessing'!locationString	^ self location pathString ! !!PhLDirectoryBasedImageRepository class methodsFor: 'accessing'!locationString: aDirectoryString	^ self location: aDirectoryString asFileReference! !!PhLDirectoryBasedImageRepository class methodsFor: 'private'!migrateFrom: oldLocation to: newLocation	(oldLocation exists and: [ (self forDirectory: oldLocation) hasImages ])		ifTrue: 			[ PhLRelocateImageDirectoryCommand new				source: oldLocation;				target: newLocation;				execute ]! !!PhLDirectoryBasedImageRepository class methodsFor: 'settings'!settingsOn: aBuilder	<systemsettings>	<pharoLauncherSettings>	(aBuilder setting: #locationString)		label: 'Location of your images' translated;		type: #Directory;		parent: #pharoLauncher;		target: self;		order: 40;		description: 'A directory where all your Pharo images will be saved and launched'! !!PhLDirectoryBasedImageRepository methodsFor: 'accessing'!baseDirectory	^ (baseDirectory ifNil: [ self class location ]) ensureCreateDirectory! !!PhLDirectoryBasedImageRepository methodsFor: 'action'!copyImage: anImage to: aString	self copyImageNamed: anImage name to: aString! !!PhLDirectoryBasedImageRepository methodsFor: 'action'!copyImageNamed: sourceName to: targetName	| sourceDirectory targetDirectory |	self ensureNoImageWithName: targetName.	targetDirectory := self prepareForNewImageNamed: targetName.	sourceDirectory := self directoryForImageNamed: sourceName.	CopyVisitor copy: sourceDirectory to: targetDirectory.	self renameImageInFolder: targetDirectory to: targetName.	self contentsChanged! !!PhLDirectoryBasedImageRepository methodsFor: 'action'!deleteImage: anImage	self deleteImageNamed: anImage name! !!PhLDirectoryBasedImageRepository methodsFor: 'action'!deleteImageNamed: aString	(self directoryForImageNamed: aString) deleteAll.	self contentsChanged.! !!PhLDirectoryBasedImageRepository methodsFor: 'action'!deleteImages: someImages	self dontNotifyDuring: [ someImages do: [ :image | self deleteImage: image ] ].	self contentsChanged! !!PhLDirectoryBasedImageRepository methodsFor: 'accessing'!directoryForImageNamed: aString	^ self baseDirectory / aString! !!PhLDirectoryBasedImageRepository methodsFor: 'action'!ensureNoImageWithName: anImageName	(self hasImageNamed: anImageName)		ifTrue: [ PhLNameNotAvailableError signalName: anImageName ]! !!PhLDirectoryBasedImageRepository methodsFor: 'action'!extractTemplate: aTemplate to: anImageName	| destination image |	self ensureNoImageWithName: anImageName.	destination := self prepareForNewImageNamed: anImageName.	image := aTemplate extractTo: destination named: anImageName.	self contentsChanged.	^ image! !!PhLDirectoryBasedImageRepository methodsFor: 'testing'!hasImageNamed: aString 	^ self includesImageNamedCaseInsensitive: aString! !!PhLDirectoryBasedImageRepository methodsFor: 'testing'!hasImages	^ self images notEmpty! !!PhLDirectoryBasedImageRepository methodsFor: 'accessing'!imageNames	^ self withImagesFilesCollect: #basenameWithoutExtension! !!PhLDirectoryBasedImageRepository methodsFor: 'accessing'!images	"Creates instances of PhLImage representing the Pharo images the launcher can manage."	^ self withImagesFilesCollect: [ :imageFile | PhLImage location: imageFile ]! !!PhLDirectoryBasedImageRepository methodsFor: 'action'!importImage: sourceImageFileRef to: targetName	| sourceDirectory targetDirectory imageLocalDirectory pharoVersionFile sourcesFiles |	self ensureNoImageWithName: targetName.	sourceDirectory := sourceImageFileRef parent.	targetDirectory := self prepareForNewImageNamed: targetName.	{ sourceImageFileRef . sourceImageFileRef withoutExtension , 'changes' }		do: [ :file | 			| targetFilename |			targetFilename := self newNameForFile: file whenRelocatingToImageNamed: targetName.			file moveTo: targetDirectory / targetFilename ].	pharoVersionFile := sourceDirectory / PhLImage versionFileName.	pharoVersionFile exists		ifTrue: [ pharoVersionFile moveTo: targetDirectory / PhLImage versionFileName ].	sourcesFiles := sourceDirectory filesMatching: '*.sources'.	sourcesFiles do: [ :file | file moveTo: targetDirectory / file basename ].	imageLocalDirectory := (sourceDirectory / SystemResolver defaultLocalDirectoryName).	imageLocalDirectory exists 		ifTrue: [ imageLocalDirectory moveTo: targetDirectory / imageLocalDirectory basename ].	sourceDirectory hasChildren 		ifFalse: [ sourceDirectory delete ].	self contentsChanged.! !!PhLDirectoryBasedImageRepository methodsFor: 'action'!importImageNamed: imagePath andSiblingFilesto: targetName	| sourceDirectory |	imagePath asFileReference exists ifFalse: [ ^ self ].		sourceDirectory := imagePath asFileReference parent.	self moveImage: sourceDirectory to: targetName! !!PhLDirectoryBasedImageRepository methodsFor: 'testing'!includesImageNamedCaseInsensitive: anImageName	"Windows OS doesnt care about case for folder names."	| lowercaseImageName |	lowercaseImageName := anImageName asLowercase.	^ self imageNames anySatisfy: [ :imageName | imageName asLowercase = lowercaseImageName ]! !!PhLDirectoryBasedImageRepository methodsFor: 'testing'!isNewImageNameValid: aString 	^ aString isEmptyOrNil not and: [ (self hasImageNamed: aString) not ]! !!PhLDirectoryBasedImageRepository methodsFor: 'action'!makeUniqueImageName: baseImageName	^ self makeUniqueImageName: baseImageName among: self imageNames.! !!PhLDirectoryBasedImageRepository methodsFor: 'action'!makeUniqueImageName: baseImageName among: existingImageNames	"Provide a reasonable default image name using the next incremental count for images with similar basenames"	"See #testMakeUniqueImageName for samples"	^ self makeUniqueName: baseImageName among: existingImageNames! !!PhLDirectoryBasedImageRepository methodsFor: 'action'!moveImage: sourceDirectory to: newName	| targetDirectory |	self ensureNoImageWithName: newName.	targetDirectory := self directoryForImageNamed: newName.	"Do not create a new directory to ensure that the moveTo will succeed"	sourceDirectory moveTo: targetDirectory.	self renameImageInFolder: targetDirectory to: newName.	self contentsChanged! !!PhLDirectoryBasedImageRepository methodsFor: 'private'!newNameForFile: file whenRelocatingToImageNamed: targetName	"Return the name that should be given to file when the file is going to be moved or copied to the image targetName. The file name is kept intact unless it must reflect the image name."	^ (#('image' 'changes') includes: file extension)		ifTrue: [ targetName , '.' , file extension ]		ifFalse: [ file basename ]! !!PhLDirectoryBasedImageRepository methodsFor: 'private'!prepareForNewImageNamed: aString	^ (self directoryForImageNamed: aString) ensureCreateDirectory! !!PhLDirectoryBasedImageRepository methodsFor: 'action'!recreateImage: anImage	| image |	anImage originTemplate ifNil: [ PhLCommandError signal ].	self deleteImage: anImage.		anImage shouldRunInitializationScript: true.	image := self extractTemplate: anImage originTemplate to: anImage name.	anImage serializeMetadata. "We keep metadata and write it again to the file system since the folder was deleted"	self contentsChanged. "Ensure the image repository has its image with up-to-date metadata"! !!PhLDirectoryBasedImageRepository methodsFor: 'action'!renameImage: anImage to: newName	self renameImageNamed: anImage name to: newName! !!PhLDirectoryBasedImageRepository methodsFor: 'private'!renameImageInFolder: targetDirectory to: newName	targetDirectory children		do: [ :file | 			| targetFilename |			targetFilename := self				newNameForFile: file				whenRelocatingToImageNamed: newName.			file basename = targetFilename				ifFalse: [ file renameTo: targetFilename ] ]! !!PhLDirectoryBasedImageRepository methodsFor: 'action'!renameImageNamed: oldName to: newName	| sourceDirectory |	(self isNewImageNameValid: newName)		ifFalse: [ PhLCommandError signal ].	sourceDirectory := self directoryForImageNamed: oldName.	self moveImage: sourceDirectory to: newName ! !!PhLDirectoryBasedImageRepository methodsFor: 'accessing'!roots	^ self images sorted: [ :image1 :image2 | image1 name asUppercase < image2 name asUppercase ]! !!PhLDirectoryBasedImageRepository methodsFor: 'initialization'!setBaseDirectory: aLocation	baseDirectory := aLocation! !!PhLDirectoryBasedImageRepository methodsFor: 'accessing'!withImagesFilesCollect: aBlock	"I iterate over all the folders in the launcher image directory. If this directory contains one image and one change file, I execute the block provided by the user and I return the list of results obtained."	^ self baseDirectory directories		inject: OrderedCollection new		into: [ :collection :aDirectory | 			| imageName imageFiles |			imageName := aDirectory basename.			imageFiles := aDirectory filesMatching: imageName , '.image'.			(imageFiles size = 1 and: [ (aDirectory filesMatching: imageName , '.changes') size = 1 ])				ifTrue: [ collection add: (aBlock value: imageFiles first) ].			collection ]! !!PhLRepository methodsFor: 'announcements'!contentsChanged	"Called me to announce that I changed"	wantNotification		ifTrue: [ announcer announce: ValueChanged new ]! !!PhLRepository methodsFor: 'private'!dontNotifyDuring: aBlock	| wantNotificationBackup |	[ 	wantNotificationBackup := wantNotification.	wantNotification := false.	aBlock value ]		ensure: [ wantNotification := wantNotificationBackup ]! !!PhLRepository methodsFor: 'visiting'!extractOn: aVisitor	self subclassResponsibility! !!PhLRepository methodsFor: 'initialization'!initialize	super initialize.	announcer := Announcer new.	wantNotification := true.! !!PhLRepository methodsFor: 'action'!makeUniqueName: baseName among: existingNames	"Provide a reasonable default name using the next incremental count for items with similar basenames"	"See #testMakeUniqueImageName for samples"	| similarbaseImageNames existingUniquifiers nextUniquifier separator |	separator := '-'.	similarbaseImageNames := existingNames select: [ :imageName | imageName beginsWith: baseName ].	existingUniquifiers := similarbaseImageNames		collect: [ :imageName | 			| suffix |			suffix := imageName allButFirst: baseName size.			(suffix beginsWith: separator)				ifTrue: [ (suffix allButFirst: separator size) initialIntegerOrNil ]				ifFalse: 0 ]		thenSelect: #notNil.	existingUniquifiers ifEmpty: [ ^ baseName ].	nextUniquifier := existingUniquifiers max + 1.	^ baseName , separator , (nextUniquifier printPaddedWith: $0 to: 2)! !!PhLRepository methodsFor: 'accessing'!roots	^ self subclassResponsibility! !!PhLRepository methodsFor: 'announcements'!unsubscribe: aReceiver	announcer unsubscribe: aReceiver! !!PhLRepository methodsFor: 'announcements'!whenChangedSend: aSelector to: aReceiver	announcer when: ValueChanged send: aSelector to: aReceiver! !!PhLTemplateGroupRepository class methodsFor: 'instance creation'!default	^ self newFromGroups: PhLTemplateGroupsBuilder build! !!PhLTemplateGroupRepository class methodsFor: 'instance creation'!newFromGroups: aCollection	^ self new		setGroups: aCollection;		yourself! !!PhLTemplateGroupRepository methodsFor: 'private'!addGroup: aGroup	| cache |	cache := PhLCacheTemplateGroup group: aGroup. "wrap all groups inside a cache."	groupCaches addLast: cache.! !!PhLTemplateGroupRepository methodsFor: 'action'!createLocalTemplateFrom: anImage named: aString	aString ifEmpty: [ PhLCommandError signal: 'Cannot give an empty name to a template' ].	(self hasLocalTemplateNamed: aString)		ifTrue: [ PhLError signal: 'A local template with the same name already exists' ].	self createZipArchiveFrom: anImage named: aString.	self createLocalTemplateNamed: aString.	self refresh! !!PhLTemplateGroupRepository methodsFor: 'action'!createLocalTemplateNamed: aString	| localTemplate |	localTemplate := PhLLocalTemplate name: aString zipFile: self localTemplatesDirectory / aString , 'zip'.	self localTemplatesGroup register: localTemplate withZip: localTemplate zipArchive! !!PhLTemplateGroupRepository methodsFor: 'action'!createZipArchiveFrom: anImage named: aString	| archive |	archive := ZipArchive new.	archive		addFile: anImage imageFile as: aString , '.image';		addFile: anImage changesFile as: aString , '.changes'.	[ archive addFile: anImage sourcesFile as: anImage sourcesFile basename ]		on: NotFound 		do: [ :e | "ignore the file" ].	anImage versionFile exists		ifTrue: [ archive addFile: anImage versionFile as: anImage versionFile basename ].	archive writeToFile: (self localTemplatesDirectory / aString , 'zip')! !!PhLTemplateGroupRepository methodsFor: 'action'!deleteTemplate: aTemplate 	aTemplate zipArchive delete.	self refresh.! !!PhLTemplateGroupRepository methodsFor: 'action'!deleteTemplates: someTemplates 	self dontNotifyDuring: [ someTemplates do: [ :template | self deleteTemplate: template ] ].	self refresh! !!PhLTemplateGroupRepository methodsFor: 'testing'!hasLocalTemplateNamed: aString	^ self localTemplates		anySatisfy: [ :each | each name = aString ]! !!PhLTemplateGroupRepository methodsFor: 'accessing'!localTemplateNamed: aString	^ self localTemplates detect: [ :each | each name = aString ]! !!PhLTemplateGroupRepository methodsFor: 'accessing'!localTemplateNames	^ self localTemplates collect: #name! !!PhLTemplateGroupRepository methodsFor: 'accessing'!localTemplates	^ self localTemplatesGroup templatesAndGroups! !!PhLTemplateGroupRepository methodsFor: 'accessing'!localTemplatesDirectory	^ self localTemplatesGroup baseDirectory! !!PhLTemplateGroupRepository methodsFor: 'accessing'!localTemplatesGroup	^ PhLDownloadedTemplateGroup default! !!PhLTemplateGroupRepository methodsFor: 'action'!makeUniqueTemplateName: aString	^ self makeUniqueTemplateName: aString among: self localTemplateNames! !!PhLTemplateGroupRepository methodsFor: 'action'!makeUniqueTemplateName: baseTemplateName among: existingTemplateNames	"Provide a reasonable default template name using the next incremental count for images with similar basenames"	"See #testMakeUniqueImageName for samples"	^ self makeUniqueName: baseTemplateName among: existingTemplateNames! !!PhLTemplateGroupRepository methodsFor: 'action'!refresh	groupCaches do: #refresh.	self contentsChanged.! !!PhLTemplateGroupRepository methodsFor: 'updating'!rename: aPhLLocalTemplate to: aString	aPhLLocalTemplate renameTo: aString.	self localTemplatesGroup register: aPhLLocalTemplate withZip: aPhLLocalTemplate zipArchive.! !!PhLTemplateGroupRepository methodsFor: 'accessing'!roots	^ groupCaches! !!PhLTemplateGroupRepository methodsFor: 'initialization'!setGroups: aCollection	| names |	names := Set new.	groupCaches := OrderedCollection new.	aCollection		do: [ :group | 			(names includes: group name)				ifTrue: [ PhLError signal: '2 groups must not have the same name' ]				ifFalse: [ self addGroup: group ] ]! !!PhLStartupManager class methodsFor: 'actions'!addToLauncherStartUpList: aClass	(self startUpClasses includes: aClass)		ifFalse: [ self startUpClasses add: aClass ]! !!PhLStartupManager class methodsFor: 'initialization'!initialize	SessionManager default registerToolClassNamed: self name! !!PhLStartupManager class methodsFor: 'actions'!removeFromStartupList: aClass	self startUpClasses remove: aClass! !!PhLStartupManager class methodsFor: 'actions'!resetStartUpClasses	StartUpClasses := nil! !!PhLStartupManager class methodsFor: 'system startup'!startUp: isANewSession	isANewSession ifFalse: [ ^ self ].		PharoLauncherApplication reset.	self startUpClasses do: [ :c | c ifNotNil: [ c launcherStartUp ] ]! !!PhLStartupManager class methodsFor: 'accessing'!startUpClasses	^ StartUpClasses ifNil: [ 		StartUpClasses := SortedCollection sortBlock: #launcherStartUpPriority ascending ]! !!PhLTemplateGroupsBuilder class methodsFor: 'instance creation'!build	^ self buildFrom: PhLTemplateSources defaultSources! !!PhLTemplateGroupsBuilder class methodsFor: 'instance creation'!buildFrom: aPhLTemplateSourcesList	^ self new 		initializeWithSources: aPhLTemplateSourcesList;		build! !!PhLTemplateGroupsBuilder methodsFor: 'building'!build	^ groups := sources		collect: [ :source | 			source asTemplateGroup 				in: [ :group |					source templatesDo: [ :templateSource | group addTemplate: templateSource asTemplate ] ];			yourself ]! !!PhLTemplateGroupsBuilder methodsFor: 'initialization'!initializeWithSources: aListOfTemplateSource 	sources := aListOfTemplateSource.	groups := OrderedCollection new.! !!PhLTemplateSource class methodsFor: 'instance creation - cache'!cacheGroup	^ self new 			type: self cacheType;		name: 'Templates';		yourself! !!PhLTemplateSource class methodsFor: 'types'!cacheType	^ #Cache! !!PhLTemplateSource class methodsFor: 'instance creation - url deprecated'!deprecatedDistributionsGroup	^ self new 			type: self urlGroupType;		name: 'Deprecated distributions';		templates: { self pharo40 .				self pharo30 .				self pharo20 .				self moose51 .				self moose50 };		yourself! !!PhLTemplateSource class methodsFor: 'types'!httpListingType	^ #HttpListing! !!PhLTemplateSource class methodsFor: 'instance creation - jenkins'!inriaMoose	^ self new 			type: self jenkinsServerType;		name: 'Moose Jenkins';		url: 'https://ci.inria.fr/moose';		yourself! !!PhLTemplateSource class methodsFor: 'instance creation - jenkins'!inriaPharoContribution	^ self new 			type: self jenkinsServerType;		name: 'Pharo Contribution Jenkins';		url: 'https://ci.inria.fr/pharo-contribution';		yourself! !!PhLTemplateSource class methodsFor: 'instance creation - jenkins'!inriaRmod	^ self new 			type: self jenkinsServerType;		name: 'RMoD Jenkins';		url: 'https://ci.inria.fr/rmod';		yourself! !!PhLTemplateSource class methodsFor: 'types'!jenkinsServerType	^ #JenkinsServer! !!PhLTemplateSource class methodsFor: 'instance creation - url mooc'!moocGroup	^ self new 			type: self urlGroupType;		name: 'Pharo Mooc';		templates: { self pharoMooc };		yourself! !!PhLTemplateSource class methodsFor: 'instance creation - url deprecated'!moose50	^ self new 			type: self urlType;		name: 'Moose Suite 5.0';		url: 'http://moosetechnology.org/res/download/moose_image_5_0.zip';		yourself! !!PhLTemplateSource class methodsFor: 'instance creation - url deprecated'!moose51	^ self new 			type: self urlType;		name: 'Moose Suite 5.1 (old stable)';		url: 'https://ci.inria.fr/moose/job/moose-5.1/lastSuccessfulBuild/artifact/moose-5.1.zip';		yourself! !!PhLTemplateSource class methodsFor: 'instance creation - url official'!moose60	^ self new 			type: self urlType;		name: 'Moose Suite 6.0 (stable)';		url: 'https://ci.inria.fr/moose/job/moose-6.0/lastSuccessfulBuild/artifact/moose-6.0.zip';		yourself! !!PhLTemplateSource class methodsFor: 'instance creation - url official'!moose61	^ self new 			type: self urlType;		name: 'Moose Suite 6.1 (beta)';		url: 'https://ci.inria.fr/moose/job/moose-6.1/lastSuccessfulBuild/artifact/moose-6.1.zip';		yourself! !!PhLTemplateSource class methodsFor: 'instance creation - url official'!officialDistributionsGroup	^ self new 			type: self urlGroupType;		name: 'Official distributions';		templates: { self pharo70x32 .				self pharo70x64 .				self pharo60x32 .				self pharo60x64 .				self pharo50 .				self moose61 .				self moose60 };		expanded: true;		yourself! !!PhLTemplateSource class methodsFor: 'instance creation - url deprecated'!pharo20	^ self new 			type: self urlType;		name: 'Pharo 2.0';		url: 'http://files.pharo.org/image/20/latest.zip';		yourself! !!PhLTemplateSource class methodsFor: 'instance creation - url deprecated'!pharo30	^ self new 			type: self urlType;		name: 'Pharo 3.0';		url: 'http://files.pharo.org/image/30/latest.zip';		yourself! !!PhLTemplateSource class methodsFor: 'instance creation - url deprecated'!pharo40	^ self new 			type: self urlType;		name: 'Pharo 4.0';		url: 'http://files.pharo.org/image/40/latest.zip';		yourself! !!PhLTemplateSource class methodsFor: 'instance creation - url official'!pharo50	^ self new 			type: self urlType;		name: 'Pharo 5.0';		url: 'http://files.pharo.org/image/50/latest.zip';		yourself! !!PhLTemplateSource class methodsFor: 'instance creation - http listing'!pharo60	^ self new 			type: self httpListingType;		name: 'Pharo 6.0 (stable)'; 		url: 'http://files.pharo.org/image/60/';		yourself! !!PhLTemplateSource class methodsFor: 'instance creation - url official'!pharo60x32	^ self new 			type: self urlType;		name: 'Pharo 6.1 - 32bit (stable)';		url: 'http://files.pharo.org/image/60/latest.zip';		yourself! !!PhLTemplateSource class methodsFor: 'instance creation - url official'!pharo60x64	^ self new 			type: self urlType;		name: 'Pharo 6.1 - 64bit (tech preview)';		url: 'http://files.pharo.org/image/60/latest-64.zip';		yourself! !!PhLTemplateSource class methodsFor: 'instance creation - http listing'!pharo70	^ self new 			type: self httpListingType;		name: 'Pharo 7.0 (development version)'; 		url: 'http://files.pharo.org/image/70/';		filterPattern: 'href="(Pharo-?7.0.0-(alpha|rc\d+).build.[^"]*.zip)"';		yourself! !!PhLTemplateSource class methodsFor: 'instance creation - url official'!pharo70x32	^ self new 			type: self urlType;		name: 'Pharo 7.0 - 32bit (development version)';		url: 'http://files.pharo.org/image/70/latest.zip';		yourself! !!PhLTemplateSource class methodsFor: 'instance creation - url official'!pharo70x64	^ self new 			type: self urlType;		name: 'Pharo 7.0 - 64bit (development version)';		url: 'http://files.pharo.org/image/70/latest-64.zip';		yourself! !!PhLTemplateSource class methodsFor: 'instance creation - url mooc'!pharoMooc	^ self new		type: self urlType;		name: 'Pharo Mooc';		url: 'http://mooc.pharo.org/image/PharoWeb.zip';		yourself! !!PhLTemplateSource class methodsFor: 'types'!urlGroupType	^ #URLGroup! !!PhLTemplateSource class methodsFor: 'types'!urlType	^ #URL! !!PhLTemplateSource methodsFor: 'comparing'!= anObject	self == anObject ifTrue: [ ^ true ].	self class = anObject class ifFalse: [ ^ false ].	^ name = anObject name		and: [ type = anObject type 		and: [ url = anObject url		and: [ filterPattern = anObject filterPattern		and: [ templates = anObject templates		and: [ self expanded = anObject expanded ] ] ] ] ]! !!PhLTemplateSource methodsFor: 'converting'!asBasicTemplateGroup	type == self class httpListingType		ifTrue: [ | pattern |					pattern := filterPattern ifNil: [ PhLHTTPListingTemplateGroup defaultFilterPattern ].					^ PhLHTTPListingTemplateGroup						name: name						url: url asZnUrl						filterPattern: pattern templateNameFormat: templateNameFormat username: username password: password].	type == self class jenkinsServerType 		ifTrue: [ ^ PhLJenkins2Server name: name url: url asZnUrl username: username password: password ].	type == self class urlGroupType		ifTrue: [ ^ PhLFixedURLsTemplateGroup new 						setName: name Templates: OrderedCollection new;						yourself ].	type == self class cacheType 		ifTrue: [ ^ PhLDownloadedTemplateGroup named: name ].			self error: 'Group type not supported!!'! !!PhLTemplateSource methodsFor: 'converting'!asTemplate	type == self class urlType ifTrue: [ 		^ PhLRemoteTemplate			  name: name			  url: url asUrl			  username: username			  password: password ].	self error: 'Template type not supported!!'! !!PhLTemplateSource methodsFor: 'converting'!asTemplateGroup	^ self asBasicTemplateGroup 		isHighlighted: expanded;		yourself! !!PhLTemplateSource methodsFor: 'accessing'!expanded	^ expanded notNil & expanded! !!PhLTemplateSource methodsFor: 'accessing'!expanded: aBoolean	"when source is a group, tell if it should be expanded as default"	expanded := aBoolean! !!PhLTemplateSource methodsFor: 'accessing'!filterPattern	^ filterPattern! !!PhLTemplateSource methodsFor: 'accessing'!filterPattern: aString 	filterPattern := aString! !!PhLTemplateSource methodsFor: 'accessing'!name	^ name! !!PhLTemplateSource methodsFor: 'accessing'!name: aString 	name := aString! !!PhLTemplateSource methodsFor: 'accessing'!password	^ password! !!PhLTemplateSource methodsFor: 'accessing'!password: anObject	password := anObject! !!PhLTemplateSource methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream 		nextPut: $(;		nextPutAll: name;		nextPut: $)! !!PhLTemplateSource methodsFor: 'accessing'!templateNameFormat	^ templateNameFormat! !!PhLTemplateSource methodsFor: 'accessing'!templateNameFormat: anObject	templateNameFormat := anObject! !!PhLTemplateSource methodsFor: 'accessing'!templates	^ templates! !!PhLTemplateSource methodsFor: 'accessing'!templates: aListOfTemplates	templates := aListOfTemplates.! !!PhLTemplateSource methodsFor: 'iterating'!templatesDo: aBlockClosure 	templates ifNotNil: [ templates do: aBlockClosure ]! !!PhLTemplateSource methodsFor: 'accessing'!type	^ type! !!PhLTemplateSource methodsFor: 'accessing'!type: aString 	type := aString! !!PhLTemplateSource methodsFor: 'accessing'!url	^ url! !!PhLTemplateSource methodsFor: 'accessing'!url: aString 	url := aString! !!PhLTemplateSource methodsFor: 'accessing'!username	^ username! !!PhLTemplateSource methodsFor: 'accessing'!username: anObject	username := anObject! !!PhLCompositeTemplateSources class methodsFor: 'instance creation'!fromFile	self shouldNotImplement! !!PhLCompositeTemplateSources methodsFor: 'initialization'!initializeWith: aListOfTemplateSources	templateSources := aListOfTemplateSources! !!PhLCompositeTemplateSources methodsFor: 'accessing'!sources	^ templateSources flatCollect: #sources! !!PhLPharoTemplateSources class methodsFor: 'accessing'!announcer	^ SourcesAnnouncer ifNil: [ SourcesAnnouncer := Announcer new ]! !!PhLPharoTemplateSources class methodsFor: 'private'!basicSourcesUrl: aUrl	SourcesUrl := aUrl.! !!PhLPharoTemplateSources class methodsFor: 'updating'!checkForUpdates	self fromFile checkForUpdates! !!PhLPharoTemplateSources class methodsFor: 'accessing'!defaultSources	^ OrderedCollection new 		add: PhLTemplateSource cacheGroup;		add: PhLTemplateSource moocGroup;		add: PhLTemplateSource officialDistributionsGroup;		add: PhLTemplateSource deprecatedDistributionsGroup;		add: PhLTemplateSource inriaPharoContribution;		add: PhLTemplateSource inriaMoose;		add: PhLTemplateSource pharo60;		add: PhLTemplateSource pharo70;		yourself! !!PhLPharoTemplateSources class methodsFor: 'accessing'!defaultSourcesUrl	^ 'https://files.pharo.org/pharo-launcher/sources.list'! !!PhLPharoTemplateSources class methodsFor: 'private'!downloadedSourcesFileLock	^  DownloadedSourcesFileLock ifNil: [ DownloadedSourcesFileLock := Semaphore forMutualExclusion ].! !!PhLPharoTemplateSources class methodsFor: 'accessing'!fromFile	^ self withFile: self sourcesFile! !!PhLPharoTemplateSources class methodsFor: 'reseting'!resetSourcesUrl	self basicSourcesUrl: self defaultSourcesUrl! !!PhLPharoTemplateSources class methodsFor: 'settings'!settingsOn: aBuilder	<systemsettings>	<pharoLauncherSettings>	(aBuilder setting: #sourcesUrl)		label: 'Template sources Url' translated;		parent: #pharoLauncher;		target: self;		order: 38;		default: self defaultSourcesUrl;		description: 'Url for downloading the template list'! !!PhLPharoTemplateSources class methodsFor: 'accessing'!sourcesFile	"File with the list of default templates sources for Pharo Launcher"	^ self launcherCoreDir / 'sources.list'! !!PhLPharoTemplateSources class methodsFor: 'accessing'!sourcesUrl	"Url of the file with the list of default templates sources for Pharo Launcher"	^ SourcesUrl ifNil: [ SourcesUrl := self defaultSourcesUrl ]! !!PhLPharoTemplateSources class methodsFor: 'accessing'!sourcesUrl: aUrl	| oldUrl |	oldUrl := SourcesUrl.	SourcesUrl := aUrl.		oldUrl = SourcesUrl ifTrue: [ ^ self "ok" ].	self checkForUpdates! !!PhLPharoTemplateSources methodsFor: 'actions'!checkForUpdates	| downloadedSources |		file exists ifFalse: [ ^ self ensureSourcesFile ].	self lockDownloadedSourcesFileDuring: [ 		self downloadedSourcesFile ensureDelete.		self fetchSourcesFile.		downloadedSources := self downloadedSources. ].		self sources = downloadedSources 		ifFalse: [ self class announcer announce: (PhLSourcesFileUpdateAvailable sources: downloadedSources) ].! !!PhLPharoTemplateSources methodsFor: 'reading'!downloadedSources	| sources |	self downloadedSourcesFile readStreamDo: [ :stream |		 sources := STON fromStream: stream].	^ sources! !!PhLPharoTemplateSources methodsFor: 'accessing'!downloadedSourcesFile	^ file parent / (file basename, '.dl')! !!PhLPharoTemplateSources methodsFor: 'accessing'!downloadedSourcesFileLock	"downloadedSourcesFileLock is a class variable because it points to a file that can only be used by one instance at a time."	^ self class downloadedSourcesFileLock! !!PhLPharoTemplateSources methodsFor: 'accessing'!downloadedSourcesFileLockFile	^ file parent / (file basename, '.dl.lock')! !!PhLPharoTemplateSources methodsFor: 'actions'!ensureSourcesFile	file exists ifTrue: [ ^ file ].		self fetchSourcesFile.	self downloadedSourcesFile exists 		ifFalse: [ PhLUIInformation new 						message: 'Cannot fetch Pharo Launcher template sources file: {1}'. ].	self replaceSourcesFileWithDownloaded.! !!PhLPharoTemplateSources methodsFor: 'actions'!fetchSourcesFile	"Avoid to have a retry dialog"	PhLDownloadManager default		basicDownload: self sourcesUrl		toFile: self downloadedSourcesFile. 	! !!PhLPharoTemplateSources methodsFor: 'accessing'!file	^ file! !!PhLPharoTemplateSources methodsFor: 'private'!lockDownloadedSourcesFileDuring: aBlock	self downloadedSourcesFileLockFile exists		ifTrue: [ | lockDate |			lockDate := DateAndTime fromString: self downloadedSourcesFileLockFile contents.			(DateAndTime now - lockDate > 1 day)				ifTrue: [ self downloadedSourcesFileLockFile ensureDelete "there was probably a problem during the update" ]				ifFalse: [ ^ self "File already locked, do not execute the block" ] ]. 		"Ensure file is locked if another Launcher instance (another image) is open".	self downloadedSourcesFileLockFile 		writeStreamDo: [ :stream | stream nextPutAll: DateAndTime now asString ]. 	"Lock working for this image."	[ self downloadedSourcesFileLock critical: aBlock ]	ensure: [ self downloadedSourcesFileLockFile ensureDelete ]! !!PhLPharoTemplateSources methodsFor: 'actions'!replaceSourcesFileWithDownloaded	file ensureDelete.	self downloadedSourcesFile moveTo: file ! !!PhLPharoTemplateSources methodsFor: 'accessing'!sources	self ensureSourcesFile.	^ super sources! !!PhLPharoTemplateSources methodsFor: 'accessing'!sourcesUrl	^ self class sourcesUrl! !!PhLPharoTemplateSources methodsFor: 'actions'!updateSourcesFile	self downloadedSourcesFile exists ifFalse: [ ^ self "nothing to update" ].		self replaceSourcesFileWithDownloaded! !!PhLTemplateSources class methodsFor: 'accessing'!defaultSources 	^ PhLCompositeTemplateSources new 			initializeWith: { PhLPharoTemplateSources fromFile . PhLUserTemplateSources fromFile };			yourself! !!PhLTemplateSources class methodsFor: 'example'!example	^ self withFile: PhLPharoTemplateSources sourcesFile! !!PhLTemplateSources class methodsFor: 'serializing'!flush: aListOfPhLTemplateSource in: aFileReference	aFileReference writeStreamDo: [ :stream |		STON 			put: aListOfPhLTemplateSource			onStreamPretty: stream ].	^ aFileReference ! !!PhLTemplateSources class methodsFor: 'serializing'!flushIn: aFileReference	self flush: self defaultSources in: aFileReference	! !!PhLTemplateSources class methodsFor: 'instance creation'!fromFile	self subclassResponsibility! !!PhLTemplateSources class methodsFor: 'serializing'!generateSourcesFile	self flushIn: self sourcesFile! !!PhLTemplateSources class methodsFor: 'accessing'!launcherCoreDir	^ (LauncherCoreDir ifNil: [ LauncherCoreDir := FileLocator launcherUserFilesLocation ]) ensureCreateDirectory! !!PhLTemplateSources class methodsFor: 'accessing'!launcherCoreDir: aFileUrl	LauncherCoreDir := aFileUrl asFileReference.	LauncherCoreDir ensureCreateDirectory! !!PhLTemplateSources class methodsFor: 'accessing'!launcherCoreDirString	" Used to display a nice file url in settings browser"	^ self launcherCoreDir pathString ! !!PhLTemplateSources class methodsFor: 'accessing'!launcherCoreDirString: aFileUrl	" Used to display a nice file url in settings browser"	self launcherCoreDir: aFileUrl! !!PhLTemplateSources class methodsFor: 'updating'!resetLauncherCoreDir	LauncherCoreDir := nil! !!PhLTemplateSources class methodsFor: 'settings'!settingsOn: aBuilder	<systemsettings>	<pharoLauncherSettings>	(aBuilder setting: #launcherCoreDirString)		label: 'Location of template sources file' translated;		type: #Directory;		parent: #pharoLauncher;		target: self;		order: 37;		default: FileLocator launcherUserFilesLocation;		description:			'Path to the directory that will contain Pharo Launcher template sources file.' , String cr				, 'You must have the read/write rights on this folder.' , String cr				, 'NOTE: This path might need to escape some whitespace characters.' translated.! !!PhLTemplateSources class methodsFor: 'instance creation'!withFile: aSourcesFile	^ self new 		initializeWith: aSourcesFile;		yourself! !!PhLTemplateSources class methodsFor: 'instance creation'!withTemplateList: aListOfPhLTemplateSource	| file |	file := FileSystem memory / 'sources.list'.	self flush: aListOfPhLTemplateSource in: file.	^ self withFile: file! !!PhLTemplateSources methodsFor: 'iterating'!collect: aBlock	^ self sources collect: aBlock! !!PhLTemplateSources methodsFor: 'initialization'!initializeWith: aSourcesFile	file := aSourcesFile.! !!PhLTemplateSources methodsFor: 'accessing'!sources	| sources |	file exists 		ifFalse: [ ^ #() ].		[ file readStreamDo: [ :stream |		 sources := STON fromStream: stream] ]	on: STONReaderError, InstanceVariableNotFound  	do: [ sources := #() ].	^ sources! !!PhLUserTemplateSources class methodsFor: 'example'!example 	^ self withTemplateList:  		{ PhLTemplateSource new 				type: PhLTemplateSource httpListingType;			name: 'User-defined http listing'; 			url: 'http://myserver.org/myimages/';			yourself }! !!PhLUserTemplateSources class methodsFor: 'accessing'!fromFile	^ self withFile: self sourcesFile! !!PhLUserTemplateSources class methodsFor: 'accessing'!sourcesFile	"File with the list of user-defined templates sources for Pharo Launcher"	^ self launcherCoreDir / 'mysources.list'! !!PhLTemplateSourcesUpdateChecker class methodsFor: 'initialization'!initialize	super initialize.	PhLStartupManager addToLauncherStartUpList: self! !!PhLTemplateSourcesUpdateChecker class methodsFor: 'launcher startup'!launcherStartUp	self run! !!PhLTemplateSourcesUpdateChecker class methodsFor: 'launcher startup'!launcherStartUpPriority	^ 500! !!PhLTemplateSourcesUpdateChecker class methodsFor: 'running'!run	self shouldRun ifFalse: [ ^ self ].		self uniqueInstance run		! !!PhLTemplateSourcesUpdateChecker class methodsFor: 'settings'!settingsOn: aBuilder	<systemsettings>	<pharoLauncherSettings>	(aBuilder setting: #shouldRun)		label: 'Check for template sources update?' translated;		parent: #pharoLauncher;		target: self;		order: 55;		description: 'Check if Pharo Launcher Template sources has an update available (needs internet access)' translated! !!PhLTemplateSourcesUpdateChecker class methodsFor: 'settings'!shouldRun	^ ShouldRun ifNil: [ ShouldRun := true ]! !!PhLTemplateSourcesUpdateChecker class methodsFor: 'settings'!shouldRun: aBoolean	ShouldRun := aBoolean.	ShouldRun 		ifTrue: [ self run ]		ifFalse: [ self terminate ].! !!PhLTemplateSourcesUpdateChecker class methodsFor: 'running'!terminate	self uniqueInstance terminate		! !!PhLTemplateSourcesUpdateChecker class methodsFor: 'running'!uniqueInstance	^ UniqueInstance ifNil: [ UniqueInstance := self new ]! !!PhLTemplateSourcesUpdateChecker methodsFor: 'updating'!basicUpdateTemplateSources	PhLPharoTemplateSources fromFile updateSourcesFile.	PharoLauncherApplication resetTemplateRepository.	PharoLauncherApplication default resetTemplateRepository.! !!PhLTemplateSourcesUpdateChecker methodsFor: 'accessing'!check	[ PhLPharoTemplateSources fromFile checkForUpdates ]	on: PhLDownloadError 	do: [ :e | "ignore. No internet connection available" ]! !!PhLTemplateSourcesUpdateChecker methodsFor: 'accessing'!name	^ 'Launcher sources update checker'! !!PhLTemplateSourcesUpdateChecker methodsFor: 'accessing'!priority	^ 20! !!PhLTemplateSourcesUpdateChecker methodsFor: 'updating'!registerOnTemplateSourcesUpdate	PhLPharoTemplateSources announcer weak		when: PhLSourcesFileUpdateAvailable		send: #updateTemplateSources:		to: self.! !!PhLTemplateSourcesUpdateChecker methodsFor: 'actions'!run	self terminate.	self registerOnTemplateSourcesUpdate.	process := [ [ self check.		self wait ] repeat ]	forkAt: self priority named: self name! !!PhLTemplateSourcesUpdateChecker methodsFor: 'actions'!terminate	self unregisterFromTemplateSourcesUpdate.	process ifNotNil: [ process isTerminating ifFalse: [ process terminate ] ]! !!PhLTemplateSourcesUpdateChecker methodsFor: 'updating'!unregisterFromTemplateSourcesUpdate	PhLPharoTemplateSources announcer		unsubscribe: self.! !!PhLTemplateSourcesUpdateChecker methodsFor: 'updating'!updateTemplateSources: announcement		PharoLauncherApplication default shouldUpdateTemplateSources ifFalse: [ ^ self ].		self basicUpdateTemplateSources! !!PhLTemplateSourcesUpdateChecker methodsFor: 'actions'!wait	24 hours wait.! !!PhLUIConfirmation methodsFor: 'action'!confirm	^ self application newConfirm 		label: message;		openModalWithParent: self relatedWindow! !!PhLUIConfirmation methodsFor: 'accessing'!message: aString 	message := aString! !!PhLUIFileRequest methodsFor: 'action'!chooseFile	^ UIManager default		chooseExistingFileReference: title		extensions: extensionsToShow		path: path		preview: false.! !!PhLUIFileRequest methodsFor: 'accessing'!extensionsToShow: anObject	extensionsToShow := anObject! !!PhLUIFileRequest methodsFor: 'accessing'!path: anObject	path := anObject! !!PhLUIFileRequest methodsFor: 'accessing'!title: anObject	title := anObject! !!PhLUIInformation methodsFor: 'action'!abort	self application newInform 		title: 'Error';		label: message;		openModalWithParent: self relatedWindow! !!PhLUIInformation methodsFor: 'action'!alert	self application newInform 		title: 'Alert';		label: message;		openModalWithParent: self relatedWindow! !!PhLUIInformation methodsFor: 'action'!deny	self application newInform 		title: 'Access Denied';		label: message;		openModalWithParent: self relatedWindow! !!PhLUIInformation methodsFor: 'action'!denyWithTitle: titleString	self application newInform 		title: titleString;		label: message;		openModalWithParent: self relatedWindow! !!PhLUIInformation methodsFor: 'action'!inform	self application newInform 		label: message;		openModalWithParent: self relatedWindow! !!PhLUIInformation methodsFor: 'accessing'!message: aMessage	message := aMessage! !!PhLUIRequest methodsFor: 'action'!chooseFrom: aListOfChoices	^ self application newSelect 		title: title;		items: aListOfChoices;		openModalWithParent: self relatedWindow! !!PhLUIRequest methodsFor: 'accessing'!initialAnswer: aString	initialAnswer := aString! !!PhLUIRequest methodsFor: 'action'!request	| answer |		[ 		answer := self application newRequest			title: title; 			text: initialAnswer;			openModalWithParent: self relatedWindow ] 	doWhileTrue: [ 		answer isNotNil 			and: [ validationBlock isNotNil 			and: [ (validationBlock value: answer) not ] ] ].	^ answer! !!PhLUIRequest methodsFor: 'accessing'!title: aString 	title := aString! !!PhLUIRequest methodsFor: 'accessing'!validateAnswer: aBlock	validationBlock := aBlock! !!PhLUserInteraction methodsFor: 'accessing'!application	^ PharoLauncherApplication default! !!PhLUserInteraction methodsFor: 'accessing'!parentWindow		^ parentWindow! !!PhLUserInteraction methodsFor: 'accessing'!parentWindow: aWindowPresenter	parentWindow := aWindowPresenter! !!PhLUserInteraction methodsFor: 'accessing'!relatedWindow		^ self parentWindow ifNil: [ self application topWindow ]! !!PhLPrivateVirtualMachine class methodsFor: 'testing'!isSubclassForDirectory: aFileReference private: isPrivateVm	^ isPrivateVm! !!PhLPrivateVirtualMachine methodsFor: 'querying'!downloadUrl	^ self manager compatibleVmUrls 		at: self name asInteger! !!PhLPrivateVirtualMachine methodsFor: 'accessing'!vmStore	^ self manager privateVmStore! !!PhLVirtualMachine class methodsFor: 'instance creation'!directory: aFileReference	^ self 		directory: aFileReference		private: false! !!PhLVirtualMachine class methodsFor: 'instance creation'!directory: aFileReference private: isPrivateVm	| targetClass |	targetClass := self allSubclasses detect: [ :cls | cls isSubclassForDirectory: aFileReference private: isPrivateVm ] ifNone: [ self ].	^ targetClass new 		initializeOn: aFileReference;		yourself ! !!PhLVirtualMachine class methodsFor: 'accessing'!elfMagicNumber	^ ByteArray newFrom: #(127 69 76 70)! !!PhLVirtualMachine class methodsFor: 'querying'!executableName	^ PlatformResolver forCurrentPlatform vmExecutableName! !!PhLVirtualMachine class methodsFor: 'accessing'!headlessOptionString	^ '--headless'! !!PhLVirtualMachine class methodsFor: 'instance creation'!id: aString	^ self new		id: aString;		initializeExecutableRef;		yourself! !!PhLVirtualMachine class methodsFor: 'testing'!isSubclassForDirectory: aFileReference private: isPrivateVm	^ isPrivateVm not and: [ aFileReference basename beginsWith: self versionPrefix ]! !!PhLVirtualMachine class methodsFor: 'accessing'!versionPrefix	"See class comment, 'Filesystem Location' section"	^ ''! !!PhLVirtualMachine methodsFor: 'comparing'!= aVM	self class = aVM class 		ifFalse: [ ^ false ]. 		^ aVM id = self id! !!PhLVirtualMachine methodsFor: 'comparing'!> aPhLVirtualMachine 	self pharoVersion = aPhLVirtualMachine pharoVersion		ifTrue: [ ^ self is64bit ].			^ self pharoVersion asNumber > aPhLVirtualMachine pharoVersion asNumber! !!PhLVirtualMachine methodsFor: 'querying'!archPath	^ self is64bit		ifTrue: [ '64' ]		ifFalse: [ '' ]! !!PhLVirtualMachine methodsFor: 'initialization'!basicInitializeOn: aFolder	id := aFolder basename.! !!PhLVirtualMachine methodsFor: 'initialization'!be64bits	arch := '64'! !!PhLVirtualMachine methodsFor: 'initialization'!beHeadless	"Set the flavour to attach to the vm download url"	flavour := self headlessFlavour! !!PhLVirtualMachine methodsFor: 'initialization'!beLatest	blessing := 'latest'! !!PhLVirtualMachine methodsFor: 'accessing'!blessing	^ blessing! !!PhLVirtualMachine methodsFor: 'querying'!downloadUrl	^ (PhLVmProvider for: self) url! !!PhLVirtualMachine methodsFor: 'updating'!ensureExecutionRights	"Unzipping with Pharo does not preserve unix rights and so, the pahro VM executable does not have the execution permission.	We have to set it explicitely on Unix and OS X."	Smalltalk os isWindows ifTrue: [ ^ self ].	PhLProcessWrapper new		shellCommand;		addArguments: 'chmod u+x';		in: [ :command | self executablesToEnsure do: [ :file | command addArgument: file fullName surroundedByDoubleQuotes ] ];		runAndWaitTimeOut: 5 seconds! !!PhLVirtualMachine methodsFor: 'setting'!executable: aPathOrfileReference	executableRef := aPathOrfileReference asFileLocatorOrReference! !!PhLVirtualMachine methodsFor: 'accessing'!executableFolderPath	^ executableRef parent fullName! !!PhLVirtualMachine methodsFor: 'accessing'!executablePath	^ executableRef fullName! !!PhLVirtualMachine methodsFor: 'accessing'!executablesToEnsure	| vmFolder |	vmFolder := self vmStore / self id.	^ vmFolder exists ifTrue: [ (vmFolder allChildrenMatching: self class executableName) select: #isFile ] ifFalse: [ #() ]! !!PhLVirtualMachine methodsFor: 'accessing'!flavour	^ flavour! !!PhLVirtualMachine methodsFor: 'ston persistence'!fromSton: stonReader	super fromSton: stonReader.		executableRef isString ifTrue: [ executableRef := executableRef asFileLocatorOrReference ].	vmBinaryRef isString ifTrue: [ vmBinaryRef := vmBinaryRef asFileLocatorOrReference ].! !!PhLVirtualMachine methodsFor: 'comparing'!hash	^ self id hash! !!PhLVirtualMachine methodsFor: 'accessing'!headlessFlavour	^ '-headless'! !!PhLVirtualMachine methodsFor: 'accessing'!id	^ id! !!PhLVirtualMachine methodsFor: 'accessing'!id: aString	id := aString.	(aString includesAll: '-x64')		ifTrue: [ self be64bits ].! !!PhLVirtualMachine methodsFor: 'testing'!ifValid: aBlockClosure 	self isValid		ifTrue: [ aBlockClosure value ]! !!PhLVirtualMachine methodsFor: 'initialization'!initialize	super initialize.	flavour := ''. "No flavour means heafull vm, it will be used to fetch the vm"	blessing := 'stable'.! !!PhLVirtualMachine methodsFor: 'initialization'!initializeExecutableRef		executableRef ifNil: [ | vmFolder |		vmFolder := self vmStore / self id.		vmFolder exists ifTrue: [ self initializeExecutableRefFrom: vmFolder ] ]! !!PhLVirtualMachine methodsFor: 'initialization'!initializeExecutableRefFrom: aFolder	| executables vmFolder |	vmFolder := aFolder asFileReference. "ensure we compare file references and not locators"	executables := vmFolder allChildrenMatching: self class executableName.	Smalltalk os isUnix		ifTrue: [ "On linux, either the VM exe is at the top level or a bash script at the top level has to be used"			executableRef := executables				detect: [ :fileRef | fileRef parent = vmFolder ]				ifNone: [ PhLExecutableNotFoundError signalKind: 'executable' inPath: vmFolder fullName ].			vmBinaryRef := executables				detect: [ :fileRef | fileRef binaryReadStreamDo: [ :stream | (stream next: 4) = self class elfMagicNumber ] ]				ifNone: [ PhLExecutableNotFoundError signalKind: 'VM binary' inPath: vmFolder fullName ] ]		ifFalse: [ executableRef := vmBinaryRef := executables 			detect: #isFile 			ifNone: [ PhLExecutableNotFoundError signalKind: 'executable' inPath: vmFolder fullName ] ].	executableRef := executableRef asFileLocatorOrReference.	vmBinaryRef := vmBinaryRef asFileLocatorOrReference.! !!PhLVirtualMachine methodsFor: 'initialization'!initializeOn: aFolder	self basicInitializeOn: aFolder.	self initializeExecutableRefFrom: aFolder.! !!PhLVirtualMachine methodsFor: 'testing'!is64bit	^ arch		ifNil: [ (self id last: 3) = 'x64' ] 		ifNotNil: [ arch = '64' ]	! !!PhLVirtualMachine methodsFor: 'testing'!isHeadless 	^ flavour = self headlessFlavour! !!PhLVirtualMachine methodsFor: 'testing'!isPreSpur	^ id includes: 'preSpur'! !!PhLVirtualMachine methodsFor: 'testing'!isValid	^ executableRef isNotNil		and: [ executableRef asFileReference isFile				and: [ vmBinaryRef isNotNil ] ]! !!PhLVirtualMachine methodsFor: 'testing'!isValidAfterUpdate	self isValid ifTrue: [ ^ true ].		self updateFromUrl.	^ self isValid! !!PhLVirtualMachine methodsFor: 'querying'!lastUpdateTime	^ executableRef modificationTime! !!PhLVirtualMachine methodsFor: 'querying'!lastUpdateTimeDescription		| timestamp |	self isValid ifFalse: [ ^ 'Not available' ].	timestamp := self lastUpdateTime.	^ timestamp asDate yyyymmdd, ' ', timestamp asTime print24! !!PhLVirtualMachine methodsFor: 'updating'!manager	^ manager ifNil: [ manager := PhLVirtualMachineManager new ]! !!PhLVirtualMachine methodsFor: 'accessing'!manager: aPhLVirtualMachineManager 	manager := aPhLVirtualMachineManager! !!PhLVirtualMachine methodsFor: 'accessing'!name	^ self id! !!PhLVirtualMachine methodsFor: 'querying'!pharoVersion	^ ($- split: self id) first! !!PhLVirtualMachine methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		nextPutAll: self id;		nextPut: $)! !!PhLVirtualMachine methodsFor: 'actions'!removeFromSystem	| vmFolder zipFile |	vmFolder := self vmStore / self name.	vmFolder exists		ifTrue: [ vmFolder ensureDeleteAll ].	zipFile := self vmStore / (self name, '.zip').	zipFile exists		ifTrue: [ zipFile ensureDelete ].! !!PhLVirtualMachine methodsFor: 'actions'!showInFolder	PhLFileBrowser openOn: self vmStore / self id! !!PhLVirtualMachine methodsFor: 'ston persistence'!stonOn: stonWriter	stonWriter writeObject: self streamMap: [ :mapWriter |		self class stonAllInstVarNames 			do: [ :each | | value | 				value := self stonValueOf: each.				value ifNotNil: [ mapWriter at: each put: value ] ] ].! !!PhLVirtualMachine methodsFor: 'ston persistence'!stonValueOf: anInstVarName	anInstVarName = #executableRef 		ifTrue: [ ^ executableRef ifNotNil: [ executableRef asFileLocatorOrReference ] ].	anInstVarName = #vmBinaryRef 		ifTrue: [ ^ vmBinaryRef ifNotNil: [ vmBinaryRef asFileLocatorOrReference ] ].	^ self instVarNamed: anInstVarName! !!PhLVirtualMachine methodsFor: 'updating'!updateFromUrl	"fetch a new version of this Virtual Machine if available"	self manager class fetch: self downloadUrl to: self vmStore / (self id , '.zip').	self initializeExecutableRefFrom: self vmStore / self id.	self ensureExecutionRights! !!PhLVirtualMachine methodsFor: 'accessing'!validityDescription		^ self isValid		ifTrue: [ 'VM available' ]		ifFalse: [ 'VM not available' ]! !!PhLVirtualMachine methodsFor: 'setting'!vmBinary: aPathOrFileReference	vmBinaryRef := aPathOrFileReference asFileReference! !!PhLVirtualMachine methodsFor: 'accessing'!vmFolder	^ vmBinaryRef parent! !!PhLVirtualMachine methodsFor: 'accessing'!vmFolderPath	^ self vmFolder fullName! !!PhLVirtualMachine methodsFor: 'accessing'!vmStore	^ self manager vmStore! !!PhLVirtualMachineManager class methodsFor: 'unzipping'!canUseSytemZip	^ PhLProcessWrapper isCommandAvailable: 'unzip'! !!PhLVirtualMachineManager class methodsFor: 'private'!fetch: aVmUrl to: targetFile	PhLDownloadManager default 		download: aVmUrl		toFile: targetFile.	self		unzip: targetFile		to: (targetFile parent / targetFile basenameWithoutExtension)! !!PhLVirtualMachineManager class methodsFor: 'instance creation'!forImage: aPharoImagePathOrFileReference	^ self new 		imageFile: aPharoImagePathOrFileReference asFileReference;		yourself				! !!PhLVirtualMachineManager class methodsFor: 'accessing'!imageFormat32bits	^ 6521! !!PhLVirtualMachineManager class methodsFor: 'accessing'!imageFormat64bits	^ 68021! !!PhLVirtualMachineManager class methodsFor: 'accessing'!imageFormat6504	^ 6504! !!PhLVirtualMachineManager class methodsFor: 'querying'!imageFormatNumberFromFile: anImagePath	| imageFile |	imageFile := anImagePath asFileReference.	imageFile exists ifFalse: [		self error: imageFile fullName, ' does not exist.' ].	^ imageFile binaryReadStreamDo: [ :stream | self imageFormatNumberFromStream: stream ].! !!PhLVirtualMachineManager class methodsFor: 'private'!imageFormatNumberFromStream: aStream	| number |	number := aStream nextLittleEndianNumber: 4.	aStream close.	^ number! !!PhLVirtualMachineManager class methodsFor: 'accessing'!imageFormatPreSpur	^ 6505! !!PhLVirtualMachineManager class methodsFor: 'testing'!is32bits: anImageFormatVersion	"32 bits Spur image format"	^ anImageFormatVersion = self imageFormat32bits! !!PhLVirtualMachineManager class methodsFor: 'testing'!is64bits	^ self is64bits: Smalltalk image imageFormatVersion! !!PhLVirtualMachineManager class methodsFor: 'testing'!is64bits: anImageFormatVersion	"64 bits Spur image format"	^ anImageFormatVersion = self imageFormat64bits! !!PhLVirtualMachineManager class methodsFor: 'testing'!isPreSpur: anImageFormatVersion	"Pre-Spur image format"	^ anImageFormatVersion = self imageFormatPreSpur! !!PhLVirtualMachineManager class methodsFor: 'unzipping'!pharoUnzip: aZipFileReference to: outputDirectory		PharoLauncherApplication default 		pushProgress: ('Unzipping {1}' format: { aZipFileReference basename })		with: [ :bar |			ZipArchive new				readFrom: aZipFileReference;				extractAllTo: outputDirectory 					informing: bar 					overwrite: true ]! !!PhLVirtualMachineManager class methodsFor: 'private'!privateVmStore	"The private store is used to fetch one VM per image format and open image to determine their pharo version number (e.g. 6.0, 7.0, etc.). Then we download the latest stable VM for the given Pharo image version."	^ (self vmStore / 'private') ensureCreateDirectory! !!PhLVirtualMachineManager class methodsFor: 'initialization'!reset	<script>	vmStore := nil! !!PhLVirtualMachineManager class methodsFor: 'settings'!settingsOn: aBuilder	<systemsettings>	<pharoLauncherSettings>	(aBuilder setting: #vmStoreString)		label: 'VMs Directory' translated;		type: #Directory;		parent: #pharoLauncher;		target: self;		order: 50;		default: (FileLocator launcherUserFilesLocation / 'vms');		description:			'Path to the directory containing all the VMs to launch your Pharo images.' , String cr				, 'You must have the read/write rights on this folder.' , String cr				, 'NOTE: This path might need to escape some whitespace characters e.g. "/Pharo\ 3.0/Pharo".' translated! !!PhLVirtualMachineManager class methodsFor: 'unzipping'!systemUnzip: aZipFileReference to: outputDirectory	PhLProcessWrapper new 		shellCommand;		addArguments: 'unzip -o -d';		addArgument: outputDirectory fullName surroundedByDoubleQuotes;		addArgument: aZipFileReference fullName surroundedByDoubleQuotes;		in: [ :process |				"on Windows, unzip logs can corrupt extracted files. 				See https://github.com/pharo-project/pharo-launcher/issues/349"				OSPlatform current isWindows					ifTrue: [ process addArgument: ' > nul' ] ];		runAndWait.! !!PhLVirtualMachineManager class methodsFor: 'unzipping'!unzip: aZipFileReference to: outputDirectory	outputDirectory ensureCreateDirectory.	self canUseSytemZip		ifTrue: [ self systemUnzip: aZipFileReference to: outputDirectory ]		ifFalse: [ self pharoUnzip: aZipFileReference to: outputDirectory ]! !!PhLVirtualMachineManager class methodsFor: 'accessing'!vmStore	^ vmStore ifNil: [ vmStore := (FileLocator launcherUserFilesLocation / 'vms') ensureCreateDirectory ]! !!PhLVirtualMachineManager class methodsFor: 'accessing'!vmStore: anObject	vmStore := anObject asFileReference.	vmStore ensureCreateDirectory! !!PhLVirtualMachineManager class methodsFor: 'accessing'!vmStoreString	" Used to display a nice file url in settings browser"	^ self vmStore pathString ! !!PhLVirtualMachineManager class methodsFor: 'accessing'!vmStoreString: aFileUrl	" Used to display a nice file url in settings browser"	self vmStore: aFileUrl! !!PhLVirtualMachineManager methodsFor: 'querying'!availableVirtualMachines	^ self availableVirtualMachinesIn: self vmStore! !!PhLVirtualMachineManager methodsFor: 'querying'!availableVirtualMachinesByImageFormat	^ [ self availableVirtualMachinesIn: self privateVmStore] 		on: PhLExecutableNotFoundError 		do: [ :ex | ex path asFileReference ensureDeleteAll. ex retry ]! !!PhLVirtualMachineManager methodsFor: 'private'!availableVirtualMachinesIn: aFileReference	| vmsOnDisk |	vmsOnDisk := Dictionary new.	aFileReference ensureCreateDirectory.	aFileReference directories		reject: [ :entry | entry basename = 'private' ]		thenDo: [ :entry | | vm |			vm := PhLVirtualMachine directory: entry private: (aFileReference = self privateVmStore).			vm ifValid: [ vmsOnDisk at: entry basename put: vm ] ].	^ vmsOnDisk! !!PhLVirtualMachineManager methodsFor: 'private'!checkImageArchitecture	"Only warn on 64-bit Linux"	Smalltalk os isUnix64 ifFalse: [ ^ self ]. 		" Most OS are now 64-bits. Do not warn if a Pharo Launcher 32-bit tries to run a 64-bit image. "		(self class is64bits and: [ self class is32bits: self imageFormatNumber ])		ifTrue: [ PhLArchitectureMismatchWarning signalLauncherArch: '64-bit' imageArch: '32-bit' ]! !!PhLVirtualMachineManager methodsFor: 'private'!compatibleVm	"Do not get the exact VM for the given image but only an image able to run the image to get its version number"	^ self availableVirtualMachinesByImageFormat		at: self imageFormatNumber asString		ifAbsent: [ self fetchCompatibleVm.			self fetchSourcesFileForCompatibleVm.			self availableVirtualMachinesByImageFormat at: self imageFormatNumber asString ]! !!PhLVirtualMachineManager methodsFor: 'private'!compatibleVmUrl	^ self compatibleVmUrls at: self imageFormatNumber! !!PhLVirtualMachineManager methodsFor: 'private'!compatibleVmUrls	| vmProvider |	vmProvider := PhLVmProviderUntilPharo80 new.	"50-preSpur stable is not the latest stable pre-Spur VM. 40 vm is the latest stable pre-Spur"	^ Dictionary newFromPairs: { 		self class imageFormat6504 . vmProvider compatibleUrlForPharo: '13' arch64: false .		self class imageFormatPreSpur . vmProvider compatibleUrlForPharo: '40' arch64: false .		self class imageFormat32bits . vmProvider compatibleUrlForPharo: '70' arch64: false .		self class imageFormat64bits . vmProvider compatibleUrlForPharo: '70' arch64: true	}	! !!PhLVirtualMachineManager methodsFor: 'querying'!defaultVirtualMachines	^ { 		(PhLVirtualMachine id: '100-x64')			be64bits;			yourself.		(PhLVirtualMachine id: '90-x64')			be64bits;			yourself.		(PhLVirtualMachine id: '80-x64')			be64bits;			yourself.		(PhLVirtualMachine id: '80-x86')			yourself.	}! !!PhLVirtualMachineManager methodsFor: 'private'!fetchCompatibleVm	[ self class 		fetch: self compatibleVmUrl		to: self privateVmStore / (self imageFormatNumber asString , '.zip') ]	on: KeyNotFound	do: [ self error: 'No Virtual Machine available for ' , self imageFormatNumber asString, ' image format. Maybe you need to update known formats?' ]! !!PhLVirtualMachineManager methodsFor: 'private'!fetchSourcesFileForCompatibleVm	" We need to fetch the sources file to be able to determine the Pharo version of an image for Pharo versions < 2.0.	Indeed, a blocking warning (about missing sources file) prevents the execution of any command line evaluation ..."	(self imageFormatNumber = self class imageFormatPreSpur or: [ self imageFormatNumber = self class imageFormat6504 ])		ifTrue: [ self 			fetchSourcesFilesFor: '14' 			in: self privateVmStore / self imageFormatNumber asString ]! !!PhLVirtualMachineManager methodsFor: 'private'!fetchSourcesFiles	| previousVersion |	"Do not download sources for Pharo versions > 70 as they come along with the image."	self imageVersion asInteger >= 70		ifTrue: [ ^ self ].	self fetchSourcesFilesFor: self imageVersion.	self imageVersion = '11' 		ifTrue: [  ^ self ]. "No support for Pharo versions < 1.1"	"Images for alpha/beta versions (Pharo < 70) require sources for the previous version of Pharo"	previousVersion := self imageVersion asNumber - 10.	"But the previous version for 61 is 50, not 51"	self imageVersion = '61'		ifTrue: [ previousVersion := 50 ].	"Pharo 1.0 does not exists: 2.0 => 1.4 => 1.3 => 1.2 => 1.1"	self imageVersion = '20'		ifTrue: [ previousVersion := 14 ].	previousVersion < 10		ifTrue: [ previousVersion := previousVersion + 9 ]. "bad - 10, should have done -1"	self fetchSourcesFilesFor: previousVersion asString! !!PhLVirtualMachineManager methodsFor: 'private'!fetchSourcesFilesFor: anImageVersionString	| vmFolder |		vmFolder := anImageVersionString asInteger < 30		ifTrue: [ self vmStore / self vmId ]		ifFalse: [ (self availableVirtualMachines at: self vmId) vmFolder ].	self fetchSourcesFilesFor: anImageVersionString in: vmFolder! !!PhLVirtualMachineManager methodsFor: 'private'!fetchSourcesFilesFor: anImageVersionString in: folder	[ | sourcesZip |	sourcesZip := folder / ('sourcesV' , anImageVersionString , '.zip').	PhLDownloadManager default		download: (self sourcesFileUrlFor: anImageVersionString)		toFile: sourcesZip.	self class		unzip: sourcesZip		to: folder ]		on: KeyNotFound		do: [ self error: 'No Sources file available for ' , anImageVersionString , ' image.' ]! !!PhLVirtualMachineManager methodsFor: 'private'!fetchVm	[ self class 		fetch: self vmUrl 		to: self vmStore / (self vmId , '.zip') ]	on: KeyNotFound	do: [ self error: 'No Virtual Machine available for ' , self imageVersion , ' image.' ]! !!PhLVirtualMachineManager methodsFor: 'accessing'!flavour	^ ''! !!PhLVirtualMachineManager methodsFor: 'accessing'!imageFile: anImagePathOrFileReference	imageFile := anImagePathOrFileReference asFileLocatorOrReference! !!PhLVirtualMachineManager methodsFor: 'accessing'!imageFormatNumber	^ imageFormatNumber		ifNil: [ imageFormatNumber := self class imageFormatNumberFromFile: imageFile ]! !!PhLVirtualMachineManager methodsFor: 'accessing'!imageFormatNumber: anInteger 	imageFormatNumber := anInteger! !!PhLVirtualMachineManager methodsFor: 'accessing'!imageVersion	"get the Pharo version of the image"	^ imageVersion ifNil: 		[ [ self imageVersionFromFile ]			on: PhLImageVersionDeterminationError			do: [ "no version file, generate it"					[ self imageVersionFromFileWith: (self imageVersionCommandWithPreferences: false) ]						on: PhLImageVersionDeterminationError, PhLProcessTimeOut						do: [ "Command probably failed, try to run without --no-default-preferences option (only available since Pharo 3.0)"								self imageVersionFromFileWith: (self imageVersionCommandWithPreferences: true) ] ] ]! !!PhLVirtualMachineManager methodsFor: 'accessing'!imageVersion: aString 	imageVersion := aString! !!PhLVirtualMachineManager methodsFor: 'accessing'!imageVersionCommandWithPreferences: shouldUsePreferences	| process |	process := PhLProcessWrapper new.	process workingDirectory: self compatibleVm executableFolderPath.	Smalltalk os isUnix			ifTrue: [ process 							shellCommand;							addArguments: 'export SQUEAK_PLUGINS="" && ';							addArgument: self compatibleVm executablePath surroundedByDoubleQuotes. ]			ifFalse: [ process command: self compatibleVm executablePath ].	process 		addArgument: (Smalltalk os isUnix			ifTrue: [ '--nodisplay' ]			ifFalse: [ '--headless' ]);		addArgument: imageFile fullName surroundedByDoubleQuotes.	shouldUsePreferences ifFalse: [ process addArgument: '--no-default-preferences' ].	process addArgument: self imageVersionDeterminationScriptPath surroundedByDoubleQuotes.	^ process! !!PhLVirtualMachineManager methodsFor: 'private'!imageVersionDeterminationScript	| imageFolder |	SystemVersion current major isNil "Pharo 1.1"		ifTrue: [ SystemVersion current major: 1. 					SystemVersion current minor: 1 ]. 	(SystemVersion current major = 1 and: [ SystemVersion current minor < 4 ])		ifTrue: [ imageFolder := (Smalltalk at: #FileDirectory) on: Smalltalk imagePath.			imageFolder forceNewFileNamed: 'pharo.version' do: [ :stream |				stream 					<< SystemVersion current major;					<< SystemVersion current minor ] ]		ifFalse: [ imageFolder := Smalltalk imagePath asFileReference. 			SystemVersion current major = 1				ifFalse: [ imageFolder := imageFolder parent ].			imageFolder / 'pharo.version' 				writeStreamDo: [ :stream | |major minor|					major := SystemVersion current major.					minor := SystemVersion current minor.					"Pharo 6 images >= 60509 need 61 VM, even though the image states 60"					(major = 6 and: [ SystemVersion current highestUpdate >= 60509 ])						ifTrue: [ minor := 1 ].					stream 						<< major asString;						<< minor asString ] ].	Smalltalk snapshot: false andQuit: true! !!PhLVirtualMachineManager methodsFor: 'private'!imageVersionDeterminationScriptFile	^ self vmStore parent / 'pharo-version.st'! !!PhLVirtualMachineManager methodsFor: 'private'!imageVersionDeterminationScriptFileNeedsUpdate	| file |	file := self imageVersionDeterminationScriptFile.	^ (file exists and: [ file contents = self imageVersionDeterminationScriptSourceCode ]) not! !!PhLVirtualMachineManager methodsFor: 'private'!imageVersionDeterminationScriptPath	| file |	file := self imageVersionDeterminationScriptFile.	self imageVersionDeterminationScriptFileNeedsUpdate		ifTrue: [ file 						ensureDelete;						writeStreamDo: [ :stream | stream << self imageVersionDeterminationScriptSourceCode ] ].	^ file fullName! !!PhLVirtualMachineManager methodsFor: 'private'!imageVersionDeterminationScriptSourceCode	^ (self class >> #imageVersionDeterminationScript) sourceCode		allButFirst: #imageVersionDeterminationScript size	"remove method name"! !!PhLVirtualMachineManager methodsFor: 'private'!imageVersionFile	^ imageFile parent / PhLImage versionFileName! !!PhLVirtualMachineManager methodsFor: 'accessing'!imageVersionFromFile	self imageVersionFile 			readStreamDo: [ :stream | imageVersion := stream contents asInteger asString ]			ifAbsent: [ PhLImageVersionDeterminationError signal: 				('Cannot determine image version: image version file "{1}" not found!!' format: { self imageVersionFile pathString }) ].	^ imageVersion! !!PhLVirtualMachineManager methodsFor: 'accessing'!imageVersionFromFileWith: aPhLProcessWrapperCommand	aPhLProcessWrapperCommand runAndWaitTimeOut: 10 seconds.	self imageVersionFile 			readStreamDo: [ :stream | imageVersion := stream contents asInteger asString ]			ifAbsent: [ PhLImageVersionDeterminationError signalCommand: aPhLProcessWrapperCommand printString ].	^ imageVersion! !!PhLVirtualMachineManager methodsFor: 'testing'!is64bit 	^ self class is64bits: self imageFormatNumber ! !!PhLVirtualMachineManager methodsFor: 'testing'!isPreSpur	^ self class isPreSpur: self imageFormatNumber! !!PhLVirtualMachineManager methodsFor: 'accessing'!pharoVersion	^ self imageVersion! !!PhLVirtualMachineManager methodsFor: 'accessing'!privateVmStore	^ self class privateVmStore! !!PhLVirtualMachineManager methodsFor: 'accessing'!sourcesFileUrlFor: anImageVersionString	"$1: IMAGE_VERSION"	^ 'https://files.pharo.org/get-files/{1}/sources.zip'		format: {anImageVersionString}! !!PhLVirtualMachineManager methodsFor: 'querying'!virtualMachine	^ self virtualMachines		detect: [ :vm | vm id = self vmId ]		ifNone: [ PhLVirtualMachine id: self vmId ]! !!PhLVirtualMachineManager methodsFor: 'querying'!virtualMachines	| vmsInVmStore defaultVms |	defaultVms := self defaultVirtualMachines.	vmsInVmStore := self availableVirtualMachines values reject: [ :vm | defaultVms anySatisfy: [ :diskVM | diskVM id = vm id ] ].	^ vmsInVmStore , defaultVms! !!PhLVirtualMachineManager methodsFor: 'querying'!vm	| vm |	PharoLauncherApplication default 		pushProgress: 'UNNAMED'		with: [ :bar | 			bar label: 'Determining Image version'.			vm := self availableVirtualMachines 				at: self vmId 				ifAbsent: [					bar 						label: 'Fetching VM to run Pharo ', self imageVersion , ' images';						current: 25.					self fetchVm.					vm := self availableVirtualMachines at: self vmId.					bar 						label: 'Fetching sources files for Pharo ', self imageVersion;						current: 50.					self fetchSourcesFiles.					bar 						label: 'Running the image';						current: 100.					vm ] ].	^ vm executablePath! !!PhLVirtualMachineManager methodsFor: 'accessing'!vmId	| architecture pharoVersion |	self checkImageArchitecture.	architecture := self is64bit ifTrue: [ 'x64' ] ifFalse: [ 'x86' ].	pharoVersion  := (self isPreSpur and: [ self imageVersion = '50' ])		ifTrue: [ '50-preSpur' ]		ifFalse: [ self imageVersion ].	^ pharoVersion , '-' , architecture.! !!PhLVirtualMachineManager methodsFor: 'accessing'!vmStore	^ self class vmStore! !!PhLVirtualMachineManager methodsFor: 'private'!vmUrl	^ (PhLVmProvider for: self) url! !!PhLVirtualMachinesDataSource class methodsFor: 'accessing'!default 	| vmsBlock privateVmsBlock |	vmsBlock := [ PhLVirtualMachineManager new virtualMachines 		asSortedCollection: [ :vm1 :vm2 | vm1 > vm2 ] ].	privateVmsBlock := [ PhLVirtualMachineManager new availableVirtualMachinesByImageFormat 		asSortedCollection: [ :vm1 :vm2 | vm1 > vm2 ] ].	^ self vmsBlock: vmsBlock privateVmsBlock: privateVmsBlock ! !!PhLVirtualMachinesDataSource class methodsFor: 'instance creation'!vmsBlock: aBlock	^ self new 		vmsBlock: aBlock;		yourself! !!PhLVirtualMachinesDataSource class methodsFor: 'instance creation'!vmsBlock: vmsBlock privateVmsBlock: privateVmsBlock	^ (self vmsBlock: vmsBlock)		privateVmsBlock: privateVmsBlock;		yourself! !!PhLVirtualMachinesDataSource methodsFor: 'querying'!privateVirtualMachines 	^ privateVmsBlock 		ifNil: [ #() ]		ifNotNil: [ privateVmsBlock value ]! !!PhLVirtualMachinesDataSource methodsFor: 'accessing'!privateVmsBlock: aBlock	privateVmsBlock := aBlock! !!PhLVirtualMachinesDataSource methodsFor: 'querying'!virtualMachines 	^ vmsBlock value! !!PhLVirtualMachinesDataSource methodsFor: 'accessing'!vmsBlock: aBlock	vmsBlock := aBlock! !!PhLVmProvider class methodsFor: 'instance creation'!for: aPhLVirtualMachineOrManager	| class |	class := aPhLVirtualMachineOrManager pharoVersion asInteger < 90		ifTrue: [ PhLVmProviderUntilPharo80 ]		ifFalse: [ self ].		^ class new		vmManager: aPhLVirtualMachineOrManager;		yourself.! !!PhLVmProvider class methodsFor: 'accessing - os'!osDarwin	^ 'Darwin'! !!PhLVmProvider class methodsFor: 'accessing - os'!osLinux	^ 'Linux'! !!PhLVmProvider class methodsFor: 'accessing - os'!osWindows	^ 'Windows'! !!PhLVmProvider class methodsFor: 'accessing - os'!supportedOs	^ { self osDarwin . self osLinux . self osWindows }! !!PhLVmProvider methodsFor: 'accessing'!hostArchitecture	^ OSPlatform current hostArchitecture! !!PhLVmProvider methodsFor: 'accessing'!hostOS	^ OSPlatform current uname! !!PhLVmProvider methodsFor: 'accessing'!url 	^ self urlForStable: true! !!PhLVmProvider methodsFor: 'private'!urlForPharo: pharoVersionNumber stable: useStableVm 	| vmStatus |	vmStatus := useStableVm ifTrue: [ 'stable' ] ifFalse: [ 'latest' ].		^ self urlTemplate 		format: (Dictionary 			with: #IMAGE_VERSION -> pharoVersionNumber			with: #HOST_OS -> self hostOS			with: #HOST_ARCH -> self hostArchitecture			with: #VM_STATUS -> vmStatus)! !!PhLVmProvider methodsFor: 'private'!urlForStable: useStableVm 			^ self urlForPharo: vmManager pharoVersion stable: useStableVm ! !!PhLVmProvider methodsFor: 'private - accessing'!urlTemplate	^ 'https://files.pharo.org/get-files/{IMAGE_VERSION}/pharo-vm-{HOST_OS}-{HOST_ARCH}-{VM_STATUS}.zip'! !!PhLVmProvider methodsFor: 'initialization'!vmManager: aPhLVirtualMachineManager 	vmManager := aPhLVirtualMachineManager! !!PhLVmProviderUntilPharo80 methodsFor: 'accessing'!compatibleUrlForPharo: pharoVersion arch64: is64bit  	^ self urlTemplate 		format: (Dictionary 			with: #IMAGE_VERSION -> pharoVersion			with: #IMAGE_ARCH -> (is64bit ifTrue: [ '64' ] ifFalse: [ '' ])			with: #OS_PATH_SEGMENT -> self downloadPathOSTypeSegment			with: #VM_FLAVOUR -> ''			with: #VM_STATUS -> 'stable')! !!PhLVmProviderUntilPharo80 methodsFor: 'private - accessing'!downloadPathOSTypeSegment	| os |	os := Smalltalk os.	(os isMacOS or: [ os isMacOSX ]) ifTrue: [ ^ 'mac' ].		os isUnix ifTrue: [ ^ 'linux' ].	os isWindows ifTrue: [ ^ 'win' ].! !!PhLVmProviderUntilPharo80 methodsFor: 'private - accessing'!imageArchitecture	^ vmManager is64bit ifTrue: [ '64' ] ifFalse: [ '' ]! !!PhLVmProviderUntilPharo80 methodsFor: 'private'!urlForPharo: pharoVersion stable: useStableVm 	| vmStatus |	vmStatus := useStableVm ifTrue: [ 'stable' ] ifFalse: [ 'latest' ].			^ self urlTemplate 		format: (Dictionary 			with: #IMAGE_VERSION -> pharoVersion			with: #IMAGE_ARCH -> self imageArchitecture			with: #OS_PATH_SEGMENT -> self downloadPathOSTypeSegment			with: #VM_FLAVOUR -> self vmFlavour			with: #VM_STATUS -> vmStatus)! !!PhLVmProviderUntilPharo80 methodsFor: 'private'!urlForStable: useStableVm 	| pharoVersion |	pharoVersion  := (vmManager isPreSpur and: [ vmManager imageVersion = '50' ])		ifTrue: [ '50-preSpur' ]		ifFalse: [ vmManager pharoVersion ].			^ self urlForPharo: pharoVersion stable: useStableVm ! !!PhLVmProviderUntilPharo80 methodsFor: 'private - accessing'!urlTemplate	"IMAGE_VERSION (11 .. 70, 80)	 IMAGE_ARCH (32 or 64)	 OS_PATH_SEGEMENT (win mac or linux)	 VM_FLAVOUR? (-headless or empty)	 VM_STATUS (stable or latest)"	^ 'https://files.pharo.org/get-files/{IMAGE_VERSION}/pharo{IMAGE_ARCH}-{OS_PATH_SEGMENT}{VM_FLAVOUR}-{VM_STATUS}.zip'! !!PhLVmProviderUntilPharo80 methodsFor: 'private - accessing'!vmFlavour	^ vmManager flavour! !!PharoLauncherModel class methodsFor: 'settings'!deactivateDeployed	IsDeployed := false! !!PharoLauncherModel class methodsFor: 'settings'!isDeployed	^ IsDeployed ifNil: [ IsDeployed := false ]! !!PharoLauncherModel class methodsFor: 'settings'!makeDeployed	IsDeployed := true! !!PharoLauncherModel class methodsFor: 'instance creation'!selection: aSelection imageRepository: imageRepository templateRepository: templateRepository	^ self new		setSelection: aSelection imageRepository: imageRepository templateRepository: templateRepository;		yourself! !!PharoLauncherModel methodsFor: 'private'!ensure: aBoolean	aBoolean		ifFalse: [ PhLCommandError signal ]! !!PharoLauncherModel methodsFor: 'testing selection'!hasAtLeastOneImageSelected	^ selection anySatisfy: #isImage! !!PharoLauncherModel methodsFor: 'testing selection'!hasAtLeastOneTemplateGroupSelected	^ selection anySatisfy: #isTemplateGroup! !!PharoLauncherModel methodsFor: 'testing'!hasImageNamed: aString 	^ imageRepository hasImageNamed: aString! !!PharoLauncherModel methodsFor: 'testing selection'!hasNoSelection	^ selection size = 0! !!PharoLauncherModel methodsFor: 'testing selection'!hasSingleImageSelected	^ (selection size = 1) and: [ selection anyOne isImage ]! !!PharoLauncherModel methodsFor: 'testing selection'!hasSingleLocalTemplateSelected	^ (selection size = 1) and: [ selection anyOne isLocalTemplate ]! !!PharoLauncherModel methodsFor: 'testing selection'!hasSingleTemplateSelected	^ (selection size = 1) and: [ selection anyOne isTemplate ]! !!PharoLauncherModel methodsFor: 'testing'!hasTemplateNamed: aString 	^ templateRepository hasLocalTemplateNamed: aString! !!PharoLauncherModel methodsFor: 'accessing'!imageRepository	^ imageRepository! !!PharoLauncherModel methodsFor: 'announcements'!imageRepositoryChanged	self imageRepository contentsChanged! !!PharoLauncherModel methodsFor: 'testing'!isNewImageNameValid: aString 	^ aString isEmptyOrNil not and: [ (self hasImageNamed: aString) not ]! !!PharoLauncherModel methodsFor: 'testing'!isNewLocalTemplateNameValid: aString 	^ aString isEmptyOrNil not and: [ (self hasTemplateNamed: aString) not ]! !!PharoLauncherModel methodsFor: 'action'!makeUniqueImageName	self shouldBeImplemented.! !!PharoLauncherModel methodsFor: 'accessing'!makeUniqueImageName: aString	^ imageRepository makeUniqueImageName: aString! !!PharoLauncherModel methodsFor: 'accessing'!makeUniqueTemplateName: aString	^ templateRepository makeUniqueTemplateName: aString! !!PharoLauncherModel methodsFor: 'user interaction'!newConfirmation	^ PhLUIConfirmation new! !!PharoLauncherModel methodsFor: 'user interaction'!newInformation	^ PhLUIInformation new! !!PharoLauncherModel methodsFor: 'user interaction'!newRequest	^ PhLUIRequest new! !!PharoLauncherModel methodsFor: 'user interaction'!requestNewImageName: aString	self halt. "should not be used"	^ self newRequest		title: 'Image name?';		initialAnswer: aString;		validateAnswer: [ :answer | (self hasImageNamed: answer) not ];		request! !!PharoLauncherModel methodsFor: 'user interaction'!requestNewTemplateName: aString 	self halt. "should not be used"	^ self newRequest		title: 'Template name?';		initialAnswer: (self makeUniqueTemplateName: aString);		validateAnswer: [ :answer | 			(self hasTemplateNamed: answer) 				ifTrue: [ UIManager default confirm: 'Do you want to override exisiting template?' ]				ifFalse: [ true ] ];		request! !!PharoLauncherModel methodsFor: 'selection'!selectedImages	^ selection select: #isImage! !!PharoLauncherModel methodsFor: 'selection'!selectedTemplateGroups	^ selection select: #isTemplateGroup! !!PharoLauncherModel methodsFor: 'selection'!selectedTemplates	^ selection select: #isTemplate! !!PharoLauncherModel methodsFor: 'initialization'!setSelection: aSelection imageRepository: anImageRepository templateRepository: aTemplateRepository	selection := aSelection. 	imageRepository := anImageRepository.	templateRepository := aTemplateRepository.! !!PharoLauncherModel methodsFor: 'selection'!singleImage	self		ensure: self hasSingleImageSelected.	^ selection anyOne! !!PharoLauncherModel methodsFor: 'selection'!singleImageName	self		ensure: self hasSingleImageSelected.			^ selection pathNames anyOne! !!PharoLauncherModel methodsFor: 'selection'!singleTemplate	self		ensure: self hasSingleTemplateSelected.	^ selection anyOne! !!PharoLauncherModel methodsFor: 'accessing'!templateRepository	^ templateRepository! !!PharoLauncherModel methodsFor: 'announcements'!templateRepositoryChanged	self templateRepository contentsChanged! !!PharoLauncherModel methodsFor: 'copying'!withNewSelection: aSelection	^ self copy		setSelection: aSelection imageRepository: imageRepository templateRepository: templateRepository;		yourself! !!UnixResolver methodsFor: '*PharoLauncher-Core'!launcherUserFilesLocation	"Documents folder is not a standard on Unix. Put files in the $HOME directory"	^ self home / 'Pharo'! !!UnixResolver methodsFor: '*PharoLauncher-Core'!vmExecutableName	^ 'pharo'! !!FileLocator class methodsFor: '*PharoLauncher-Core'!launcherImagesLocation	^ self origin: #launcherImagesLocation! !!FileLocator class methodsFor: '*PharoLauncher-Core'!launcherUserFilesLocation	^ self origin: #launcherUserFilesLocation! !!FileLocator class methodsFor: '*PharoLauncher-Core'!launcherVMsLocation	^ self origin: #launcherVMsLocation! !!FileLocator class methodsFor: '*PharoLauncher-Core' prior: 26075215!supportedOrigins	| origins current |	origins := IdentitySet new.	current := Resolver.	[current notNil] whileTrue:		[origins addAll: current supportedOrigins.		current := current next].	^ origins		remove: #vmDirectory ifAbsent: [  ];		remove: #vmBinary ifAbsent: [  ];		remove: #localDirectory ifAbsent: [  ];		remove: #imageDirectory ifAbsent: [  ];		yourself! !"PharoLauncher-Core"!!TPhLInteractionTrait commentStamp: '' prior: 0!This behavior should be handled in Spec. Onde done, this trait could be removed.This trait provides an abstraction to provide user interaction (confirm, inform, etc.)!!PhLAbstractDateDisplayStrategy commentStamp: '' prior: 0!Description--------------------I am an abstract class to manage the display of dates in the Pharo launcher UI. My subclasses should each implement a different format strategy.!!PhLDateAndTimeDisplayStrategy commentStamp: '' prior: 0!Description--------------------Display date with the date and time. Example:2018-07-03 10:37:53!!PhLTimeUntilNowStrategy commentStamp: '' prior: 0!Description--------------------Display date by its delta with the current date.Example:1 year ago2 weeks ago3 days ago!!PharoLauncherApplication commentStamp: '' prior: 0!Application that allows users to choose a template from a set of templates (potentially on the web). From a template, the user can create a Pharo image and launch it. This application also list the existing images.PharoLauncherApplication open!!PhLAppearanceSettings commentStamp: '' prior: 0!I provide Appearance seetingsfor the PhLSettingsBrowser (pragma pharoLauncherSettings).!!PhLDeploymentScript commentStamp: '' prior: 0!I'm responsible for preparing the image to be a Pharo Launcher image. Namely, I make sure that- one Pharo Launcher window is open and centered- this window can't be closed easily- the user-defined startup scripts are not executed!!PhLNullImage commentStamp: '' prior: 0!Null pattern for a PhLImage.Used to display information when no image is selected.!!PhLNullLaunchConfiguration commentStamp: '' prior: 0!Null pattern for a PhLLaunchConfiguration.Used to display information when no launch configuration is selected.!!PhLImageCreationPresenter commentStamp: '' prior: 0!I'm the view displayed to create an image from a template.Implementation points:To give feedback to the user, we display an icon helping the user to know if he already has an image of the same name or not.At each keystroke in the image title field we check if we already have an image with this name. If we have, we display a red cross to the user.!!PhLImageDetailPresenter commentStamp: '' prior: 0!Presenter of a Pharo image detail : description, template, VM, etc.I'm part of the main Pharo Launcher window.To open me:(self on: PhLImage example) openWithSpec!!PhLImagesPresenter commentStamp: '' prior: 0!Pharo Launcher main window presenting the list of managed images as well as a toolbar and a status bar.To open me:	(self on: PhLDirectoryBasedImageRepository default) openWithSpec!!PhLScriptPresenter commentStamp: '' prior: 0!I present a list of scripts and allow to edit, remove or add a new script.!!PhLTemplatesPresenter commentStamp: '' prior: 0!Pharo Launcher templates window presenting the list of available templates.Templates are used to create images.To open me:	self example!!PhLVMPresenter commentStamp: '' prior: 0!A simple UI to show locally available Virtual Machines to launch Pharo images.!!PhLAboutPresenter commentStamp: '' prior: 0!Pharo Launcher About dialog UI.Example: 	self example!!PhLLaunchConfigurationPresenter commentStamp: '' prior: 0!Window used to present the list of launch configurations of an image.You can edit it, add a new one or remove a configuration.To open me:	self example!!PhlRetryPresenter commentStamp: '' prior: 0!A simple presenter to allow to retry or cancel an action. You can provide an explanation text.!!PharoLauncherConfiguration commentStamp: '' prior: 0!I define the configuration for Pharo Launcher application.For now, I only define new styles.!!TPhLInteractionTrait methodsFor: 'user interaction'!newConfirmation	^ PhLUIConfirmation new! !!TPhLInteractionTrait methodsFor: 'user interaction'!newFileRequest	^ PhLUIFileRequest new! !!TPhLInteractionTrait methodsFor: 'user interaction'!newInformation	^ PhLUIInformation new! !!TPhLInteractionTrait methodsFor: 'user interaction'!newRequest	^ PhLUIRequest new! !!ZipArchive methodsFor: '*PharoLauncher-Spec2'!directoryMembersDo: aBlock	self members		select: [ :each | each isDirectory ]		thenDo: aBlock! !!ZipArchive methodsFor: '*PharoLauncher-Spec2'!fileMembersDo: aBlock	self members		reject: [ :each | each isDirectory ]		thenDo: aBlock! !!PhLAbstractDateDisplayStrategy class methodsFor: 'accessing'!allStrategies	^ self allSubclasses reject: #isAbstract! !!PhLAbstractDateDisplayStrategy class methodsFor: 'accessing'!allStrategiesWithNames	^ self allStrategies collect: [ :each | each label -> each ]! !!PhLAbstractDateDisplayStrategy class methodsFor: 'accessing'!displayStringOf: aDateAndTime	"Takes as parameter a DateAndTime and return a Text describing this date and time to the user."		^ self subclassResponsibility! !!PhLAbstractDateDisplayStrategy class methodsFor: 'testing'!isAbstract	^ self = PhLAbstractDateDisplayStrategy! !!PhLAbstractDateDisplayStrategy class methodsFor: 'accessing'!label	^ self subclassResponsibility! !!PhLDateAndTimeDisplayStrategy class methodsFor: 'accessing'!displayStringOf: aDateAndTime	^ (String		streamContents: [ :s | 			s				nextPutAll: aDateAndTime asDate yyyymmdd;				space.			aDateAndTime asTime print24: true on: s ]) asText! !!PhLDateAndTimeDisplayStrategy class methodsFor: 'accessing'!label	^ 'Date and time'! !!PhLTimeUntilNowStrategy class methodsFor: 'accessing'!displayStringOf: aDateAndTime	aDateAndTime ifNil: [ ^ 'N/A' ].	^ (DateAndTime now - aDateAndTime) simpleTimeAgo asText! !!PhLTimeUntilNowStrategy class methodsFor: 'accessing'!label	^ 'Time since now'! !!PharoLauncherApplication class methodsFor: 'accessing'!applicationName	^ 'pharo-launcher'! !!PharoLauncherApplication class methodsFor: 'testing'!beDeployed	IsDeployed := true! !!PharoLauncherApplication class methodsFor: 'testing'!beUndeployed	IsDeployed := false! !!PharoLauncherApplication class methodsFor: 'accessing'!default	^ Default ifNil: [ Default := self new ]! !!PharoLauncherApplication class methodsFor: 'accessing'!default: aPharoLauncherApplication	Default := aPharoLauncherApplication! !!PharoLauncherApplication class methodsFor: 'settings'!defaultInitializationScriptLocation	^ FileLocator launcherUserFilesLocation / 'scripts' ! !!PharoLauncherApplication class methodsFor: 'settings'!hardResetPersistanceState	^false! !!PharoLauncherApplication class methodsFor: 'settings'!hardResetPersistanceState: isClickedFromSettings 	|packages|		isClickedFromSettings ifFalse: [ ^ self ]. "Important: this code should not be run when loading stored preferences, else PharoLauncher deployment mode is set to not deployed!!"		SystemWindow allSubInstances do:[ :window | window delete].	self inform: 'PharoLauncher state reset'.	World doOneCycle.	500 milliSeconds wait. "To help user perception that *something* was reset"			packages := RPackageOrganizer default packages select:[ :package | 		(package name includesSubstring: 'PharoLauncher') ].	packages do: 		[ :package | 		package definedClasses 			reject: [ :class | class = PhLStartupManager ] "Do not reset this class, else Pharo settings will not be loaded at startup and repository location couldbe wrong!!"			thenDo: [ :class | class classPool keys do: [ :key | class classPool at: key put: nil ] ] ].	self openFull.! !!PharoLauncherApplication class methodsFor: 'accessing'!initializationScriptsDirectory	^ self default scriptsDirectory! !!PharoLauncherApplication class methodsFor: 'accessing'!initializationScriptsDirectory: aFileUrl	| directory |	directory := aFileUrl asFileReference.	self default scriptsDirectory: directory.	^ directory ensureCreateDirectory	! !!PharoLauncherApplication class methodsFor: 'settings'!initializationScriptsLocation	" Used to display a nice file url in settings browser"	^ self initializationScriptsDirectory pathString 	! !!PharoLauncherApplication class methodsFor: 'settings'!initializationScriptsLocation: aFileUrl	" Used to display a nice file url in settings browser"	^ self initializationScriptsDirectory: aFileUrl! !!PharoLauncherApplication class methodsFor: 'testing'!isDeployed	^ IsDeployed ifNil: [ IsDeployed := false ]! !!PharoLauncherApplication class methodsFor: 'world menu'!menuCommandOn: aBuilder 	<worldMenu> 	(aBuilder item: #'Pharo Launcher')		icon: self pharoIcon16x16;		parent: #Tools;		order: 110;		action: [ self open ];		withSeparatorAfter! !!PharoLauncherApplication class methodsFor: 'opening'!open	<script>		^ (Default := self new)		openAsWorld: false;		run! !!PharoLauncherApplication class methodsFor: 'opening'!openFull 	<script>		^ (Default := self new) 		beOpenedAsWorld;		run! !!PharoLauncherApplication class methodsFor: 'world menu'!pharoIcon16x16	^ pharoIcon 		ifNil: [ pharoIcon := (self iconNamed: #pharo) scaledToSize: 16@16 ].! !!PharoLauncherApplication class methodsFor: 'accessing'!reset	Default := nil! !!PharoLauncherApplication class methodsFor: 'initialization'!resetTemplateRepository	TemplateRepository := nil! !!PharoLauncherApplication class methodsFor: 'settings'!settingsOn: aBuilder	<systemsettings>	<pharoLauncherSettings>	(aBuilder group: #pharoLauncher)		label: 'Pharo Launcher' translated;		description: 'General application settings' translated;		with: [ 					(aBuilder setting: #templatesClearedOnStartup)						label: 'Templates cleared at startup' translated;						order: 20;						target: self;						description:								'When enabled, Launcher startup clears the Templates List. ' , String cr										, 'When disabled, Launcher startup retains the Templates List from last run.' translated.							(aBuilder setting: #initializationScriptsLocation)						label: 'Location of your image initialization scripts' translated;						type: #Directory;						parent: #pharoLauncher;						target: self;						order: 40;						description: 'A directory where all your Pharo images initialization scripts will be saved (executed once at image creation)'.							(aBuilder setting: #hardResetPersistanceState)						label: 'Hard reset persistent state' translated;						target: self;						order: 70;						description:								'When PharoLauncher is updated through Monticello ' , 								'sometimes you need to clear persistent state to pick up new changes.' , String cr, 								'Clicking this box is a one-shot action, i.e. this state is also reset.', String cr, 								'Note, all open windows are clsoed and the application restarted.'								translated 				]! !!PharoLauncherApplication class methodsFor: 'accessing'!templatesClearedOnStartup	^ TemplatesClearedOnStartup ifNil: [ TemplatesClearedOnStartup := false ].! !!PharoLauncherApplication class methodsFor: 'settings'!templatesClearedOnStartup: aBoolean 	TemplatesClearedOnStartup := aBoolean! !!PharoLauncherApplication methodsFor: 'configuring'!beOpenedAsWorld	self openAsWorld: true! !!PharoLauncherApplication methodsFor: 'accessing'!defaultTemplateRepository	^ TemplateRepository ifNil: [ TemplateRepository := PhLTemplateGroupRepository default ]! !!PharoLauncherApplication methodsFor: 'accessing'!imageRepository	^ imageRepository! !!PharoLauncherApplication methodsFor: 'accessing'!imageRepository: aPhlImageRepository	imageRepository := aPhlImageRepository! !!PharoLauncherApplication methodsFor: 'announcements'!imageRepositoryChanged	imagesPresenter ifNotNil: #refresh! !!PharoLauncherApplication methodsFor: 'announcements'!imageRepositoryChanged: newImage	self imageRepositoryChanged.	imagesPresenter ifNotNil: [ imagesPresenter selectImage: newImage ].! !!PharoLauncherApplication methodsFor: 'initialization'!initialize 	super initialize.	"I want to register windows in order to be able to know which one is the last opened 	 This can be use to push progress bars (they stack)."	windows := OrderedCollection new. 	openAsWorld := false.	self		useBackend: #Morphic 		with: PharoLauncherConfiguration new.	imageRepository :=  PhLDirectoryBasedImageRepository default.	self templatesClearedOnStartup 		ifTrue: [ self class resetTemplateRepository ].	self resetTemplateRepository! !!PharoLauncherApplication methodsFor: 'initialization - private'!initializeImagesPresenter	^ imagesPresenter := PhLImagesPresenter		newApplication: self		model: imageRepository! !!PharoLauncherApplication methodsFor: 'events'!launchConfigurationEdited: aLaunchConfiguration	"set the last edited launch configuration in the toolbar "	imagesPresenter refreshLaunchConfigurationList.	aLaunchConfiguration isNullConfiguration 		ifFalse: [ imagesPresenter selectConfiguration: aLaunchConfiguration ].! !!PharoLauncherApplication methodsFor: 'configuring'!openAsWorld: aBoolean	openAsWorld := aBoolean! !!PharoLauncherApplication methodsFor: 'ui'!pushProgress: aString with: aBlock	self newJobList pushJob: (SpJob newTitle: aString block: aBlock)! !!PharoLauncherApplication methodsFor: 'initialization'!resetTemplateRepository	templateRepository := nil.! !!PharoLauncherApplication methodsFor: 'accessing'!scriptsDirectory	^ (scriptsDirectory ifNil: [ 		   self class initializationScriptsDirectory: self class defaultInitializationScriptLocation ])		  ensureCreateDirectory! !!PharoLauncherApplication methodsFor: 'accessing'!scriptsDirectory: aFileReference	scriptsDirectory := aFileReference! !!PharoLauncherApplication methodsFor: 'ui'!shouldUpdateTemplateSources	^ self newConfirm		title: 'Update';		label: 'Update available for Pharo Launcher templates sources!!';		acceptLabel: 'Update';		cancelLabel: 'Remind me later';		openModal! !!PharoLauncherApplication methodsFor: 'ui'!showError: anError	self newInform 		title: anError name;		label: anError longDescription;		openModalWithParent: self topWindow! !!PharoLauncherApplication methodsFor: 'running'!start	self initializeImagesPresenter.	openAsWorld ifTrue: [ 		self startFull.		^ self ].	imagesPresenter open! !!PharoLauncherApplication methodsFor: 'running'!startFull		imagesPresenter asWorldWindow 		title: 'Pharo Launcher';		open.! !!PharoLauncherApplication methodsFor: 'accessing'!templateRepository	^ 	templateRepository ifNil: [ templateRepository := self defaultTemplateRepository ] ! !!PharoLauncherApplication methodsFor: 'accessing'!templateRepository: aPhLTemplateGroupRepository	templateRepository := aPhLTemplateGroupRepository! !!PharoLauncherApplication methodsFor: 'accessing'!templatesClearedOnStartup	^ self class templatesClearedOnStartup! !!PharoLauncherApplication methodsFor: 'ui'!topWindow	"The window that will accept a modal window related to it. 	 This is usually the top window, but in case of stacking dialogs, some times this is lost. 	 In that case, I want still choose one window"		super topWindow ifNotNil: [ :topWindow | ^ topWindow ].	^ self windows 		ifNotEmpty: [ :aCollection | aCollection last ]		ifEmpty: [ nil ]! !!PhLAppearanceSettings class methodsFor: 'settings'!appearanceSettingsOn: aBuilder 	<pharoLauncherSettings>	(aBuilder group: #appearance)		label: 'Appearance' ;  		description: 'All settings concerned with the look''n feel of your system';		target: PolymorphSystemSettings;		with: [			(aBuilder pickOne: #uiThemeClass)				label: 'User interface theme';				target: self;				default: UITheme standardThemeClass;				order: 1;				domainValues: PolymorphSystemSettings uiThemeClassChoices. ]! !!PhLAppearanceSettings class methodsFor: 'settings'!standardFontsSettingsOn: aBuilder	<pharoLauncherSettings>	(aBuilder group: #standardFonts)		label: 'Standard fonts';		target: StandardFonts;		dialog: [GraphicFontSettings fontSizeRow];		parent: #appearance;		order: 4.! !!PhLAppearanceSettings class methodsFor: 'morphic'!uiThemeClass	^ PolymorphSystemSettings uiThemeClass! !!PhLAppearanceSettings class methodsFor: 'morphic'!uiThemeClass: aUIThemeClass	PolymorphSystemSettings uiThemeClass: aUIThemeClass.	"force UI re-creation to adopt new theme. Spec is not yet ready to react to theme changes."	PharoLauncherApplication 		reset;		openFull.! !!PhLDeploymentScript class methodsFor: 'actions'!activateDeprecationWarnings	Deprecation raiseWarning: true! !!PhLDeploymentScript class methodsFor: 'actions'!activateErrorCatching	DefaultDebuggerRank := StDebugger rank.	StDebugger rank: 9.! !!PhLDeploymentScript class methodsFor: 'actions'!activateLostChangesDetector	EpLostChangesDetector initialize! !!PhLDeploymentScript class methodsFor: 'actions'!activateStartupActions	StartupPreferencesLoader allowStartupScript: true.! !!PhLDeploymentScript class methodsFor: 'actions'!addToStartupList	PhLStartupManager addToLauncherStartUpList: self! !!PhLDeploymentScript class methodsFor: 'actions'!askForConfirmationWhenQuitting	self flag: 'TODO'.	"Since UserManager is now over, there is no clean way to avoid warning when we juast ask to quit the image. More general, there should be a way to have an image in read/only mode"	Save := true! !!PhLDeploymentScript class methodsFor: 'actions'!closeAllWindows	"We make sure we always close without asking for confirmation. It looks like #closeAllWindowsDiscardingChanges doesn't work as a startup action."	[ World closeAllWindowsDiscardingChanges ]		on: ProvideAnswerNotification		do: [ :err | err return: false ].	PharoLauncherApplication default closeAllWindows.! !!PhLDeploymentScript class methodsFor: 'actions'!closeWindowsAndOpenDevelopmentEnvironment	PanelMorph allInstancesDo: [  :pm | pm delete ].	self closeAllWindows.	TaskbarMorph reset.	Smalltalk tools workspace openContents: 'PharoLauncherApplication open.'.	"PanelMorph comes from use of #openWorldWithSpec"! !!PhLDeploymentScript class methodsFor: 'actions'!closeWindowsAndOpenLauncher	self 		closeAllWindows;		openLauncher! !!PhLDeploymentScript class methodsFor: 'actions'!deactivateDeprecationWarnings	Deprecation raiseWarning: false! !!PhLDeploymentScript class methodsFor: 'actions'!deactivateErrorCatching	StDebugger rank: DefaultDebuggerRank! !!PhLDeploymentScript class methodsFor: 'actions'!deactivateLostChangesDetector	SessionManager default unregisterClassNamed: #EpLostChangesDetector! !!PhLDeploymentScript class methodsFor: 'actions'!deactivateStartupActions	StartupPreferencesLoader allowStartupScript: false.! !!PhLDeploymentScript class methodsFor: 'settings'!developmentEnvironmentEnabled	^ self isDeployed not! !!PhLDeploymentScript class methodsFor: 'settings'!developmentEnvironmentEnabled: aBoolean	aBoolean 		ifTrue: 		[	self undoAll.  				self closeWindowsAndOpenDevelopmentEnvironment 		]		ifFalse: 		[ 	self doAll. 			self closeWindowsAndOpenLauncher.			self isDeployed ifFalse: [ Smalltalk snapshot: true andQuit: false "save deployed mode" ]		].! !!PhLDeploymentScript class methodsFor: 'public'!doAll	self		closeAllWindows;		removeAllMorphs;		setTheme;		deactivateStartupActions;		dontRaiseWarningForMissingChangesOrSourcesFiles;		deactivateDeprecationWarnings;		deactivateLostChangesDetector;		activateErrorCatching;		makeDeployed;		resetImageDescriptionUpdater;		addToStartupList;		dontAskForConfirmationWhenQuitting;		setProgressBarSizeAndPosition! !!PhLDeploymentScript class methodsFor: 'actions'!doRaiseWarningForMissingChangesOrSourcesFiles	PharoFilesOpener default setInformAboutReadOnlyChanges.! !!PhLDeploymentScript class methodsFor: 'actions'!dontAskForConfirmationWhenQuitting	self flag: 'TODO'.	"Since UserManager is now over, there is no clean way to avoid warning when we juast ask to quit the image. More general, there should be a way to have an image in read/only mode"	Save := false! !!PhLDeploymentScript class methodsFor: 'actions'!dontRaiseWarningForMissingChangesOrSourcesFiles	PharoFilesOpener default unsetInformAboutReadOnlyChanges.! !!PhLDeploymentScript class methodsFor: 'initialization'!initialize	Save := false! !!PhLDeploymentScript class methodsFor: 'public'!initializeLibgit	LGitLibrary uniqueInstance initializeLibGit2! !!PhLDeploymentScript class methodsFor: 'settings'!isDeployed	^ PharoLauncherApplication isDeployed! !!PhLDeploymentScript class methodsFor: 'system startup'!launcherStartUp	self isDeployed		ifTrue: [ self closeWindowsAndOpenLauncher ]! !!PhLDeploymentScript class methodsFor: 'system startup'!launcherStartUpPriority	^ 300! !!PhLDeploymentScript class methodsFor: 'settings'!makeDeployed	PharoLauncherApplication beDeployed! !!PhLDeploymentScript class methodsFor: 'settings'!makeUndeployed	PharoLauncherApplication beUndeployed! !!PhLDeploymentScript class methodsFor: 'actions'!openLauncher	PharoLauncherApplication openFull! !!PhLDeploymentScript class methodsFor: 'actions'!quitSession	self flag: 'TODO'.	"Since UserManager is now over, there is no clean way to avoid warning when we juast ask to quit the image. More general, there should be a way to have an image in read/only mode"	Save 		ifTrue: [Smalltalk snapshot: true andQuit: true] 		ifFalse: [Smalltalk snapshot: false andQuit: true] ! !!PhLDeploymentScript class methodsFor: 'actions'!removeAllMorphs 	" Don't keep unnecessary stuff.	  Also there is a bug popping with FT2 when trying to send #changed to the MenuBar. Removing morphs will workaround this problem"	World removeAllMorphs! !!PhLDeploymentScript class methodsFor: 'actions'!removeFromStartupList	[ PhLStartupManager removeFromStartupList: self ]		on: NotFound 		do: [ :e | "Not there, just ignore!!" ]! !!PhLDeploymentScript class methodsFor: 'actions'!resetImageDescriptionUpdater	PhLImageDescriptionUpdater default terminateProcess.	PhLImageDescriptionUpdater reset.! !!PhLDeploymentScript class methodsFor: 'actions'!resetPharoLauncherIcebergRepositoryLocation	| phLCorePackage |	phLCorePackage := RPackageOrganizer default packageNamed: 'PharoLauncher-Core'.	(IceRepository registeredRepositoryIncludingPackage: phLCorePackage)		name: 'pharo-launcher';		location: nil! !!PhLDeploymentScript class methodsFor: 'actions'!setProgressBarSizeAndPosition	"increase size and reposition progress bar to the middle of screen to make it more visible"	SystemProgressMorph uniqueInstance		minWidth: 600;		minHeight: 50;		layoutInset: 30 @ 20;		position: 150 @ 200	! !!PhLDeploymentScript class methodsFor: 'actions'!setTheme	PharoLightTheme beCurrent.! !!PhLDeploymentScript class methodsFor: 'settings'!settingsOn: aBuilder	<systemsettings>	<pharoLauncherSettings>	(aBuilder setting: #developmentEnvironmentEnabled) 		parent: #pharoLauncher;		target: self;		order: 60;		label: 'Enable development environment' translated;		description: 'Missing a feature?  Hey come join in!!  Add your custom feature.When enabled, exits the Launcher application into the Pharo development environment.When disabled, closes all windows and locks Launcher as the only running application. ' translated.! !!PhLDeploymentScript class methodsFor: 'public'!undoAll	self		activateStartupActions;		doRaiseWarningForMissingChangesOrSourcesFiles;		activateDeprecationWarnings;		activateLostChangesDetector;		deactivateErrorCatching;		makeUndeployed;		removeFromStartupList;		askForConfirmationWhenQuitting;		initializeLibgit! !!PhLNullImage methodsFor: 'accessing'!architecture		^ ''! !!PhLNullImage methodsFor: 'accessing'!description		^ '<no description given>'! !!PhLNullImage methodsFor: 'accessing'!initializationScript	^ nil! !!PhLNullImage methodsFor: 'accessing'!lastModification		^ 'N/A'! !!PhLNullImage methodsFor: 'accessing'!location	^ ''! !!PhLNullImage methodsFor: 'accessing'!name	^ 'No image selected'! !!PhLNullImage methodsFor: 'accessing'!originTemplateName		^ ''! !!PhLNullImage methodsFor: 'accessing'!originTemplateUrl		^ ''! !!PhLNullImage methodsFor: 'accessing'!shouldRunInitializationScript	^ false! !!PhLNullLaunchConfiguration methodsFor: 'accessing'!imageArguments 	^ #()! !!PhLNullLaunchConfiguration methodsFor: 'testing'!isNullConfiguration	^ true! !!PhLNullLaunchConfiguration methodsFor: 'accessing'!name	^ ''! !!PhLNullLaunchConfiguration methodsFor: 'accessing'!vm	^ nil! !!PhLNullLaunchConfiguration methodsFor: 'accessing'!vmArguments 	^ #()! !!PhLImageCreationPresenter class methodsFor: 'layout'!defaultLayout	^ SpBoxLayout newVertical		borderWidth: 5;		spacing: 5;		add: 'Image name:' expand: false;		add: (SpBoxLayout newHorizontal 				spacing: 5;				add: #imageName;				add: #imageNameCheck expand: false;				yourself)			expand: false;		add: 'Image description:' expand: false;		add: #descriptionText height: 60;		add: 'Initialization script:' expand: false;		add: (SpBoxLayout newHorizontal 				spacing: 5;				add: #initScript;				add: #editInitScriptButton expand: false;				yourself)			expand: false;		add: #initScriptText height: 100;		addLast: #createButton expand: false;		yourself! !!PhLImageCreationPresenter class methodsFor: 'example'!example	(self 		newApplication: PharoLauncherApplication new		model: {PhLRemoteTemplate example}) open! !!PhLImageCreationPresenter methodsFor: 'initialization'!checkNewName: name	"If the image name is taken we display a red cross. Else we display a validation sign. 	I am called to validate the image displayed is in the right state. If not, I update it. 	I use a variable to know the state during the last validation."	| isValid |	isValid := (PhLImage isValidName: name) 						and: [ reservedImagesNamesCache ifNotNil: [ (reservedImagesNamesCache includes: name asLowercase) not ] ].	"Image already in the right state. We skip."	isNameValid = isValid ifTrue: [ ^ self ].	(isNameValid := isValid ) ifTrue: [ self showNameOk ] ifFalse: [ self showNameError ]! !!PhLImageCreationPresenter methodsFor: 'closing'!close 	self withWindowDo: [ :window | window close ]! !!PhLImageCreationPresenter methodsFor: 'initialization'!connectPresenters	imageName whenTextChangedDo: [ :name | self checkNewName: name ]! !!PhLImageCreationPresenter methodsFor: 'action'!createImageWithCommand: createCommand		[ 		createCommand execute.		self close ] 	on: PhLNameNotAvailableError 	do: [ 		self newInformation 			message: 'An image with the same name already exists!! Please choose a new one.';			alert ] ! !!PhLImageCreationPresenter methodsFor: 'accessing'!description	^ descriptionText text asString! !!PhLImageCreationPresenter methodsFor: 'configuring'!disable	createButton disable.		imageName text: ''! !!PhLImageCreationPresenter methodsFor: 'private'!ifValidTemplate: aBlock	"execute the block if the template isValid "	self template ifNil: [ ^ self ].	self template isTemplate		ifTrue: [ aBlock value ]! !!PhLImageCreationPresenter methodsFor: 'accessing'!imageName	^ imageName text! !!PhLImageCreationPresenter methodsFor: 'accessing'!initializationScript	^ initScript selectedItem! !!PhLImageCreationPresenter methodsFor: 'initialization'!initializationScriptItems	^ self initializationScripts copyWithFirst: self noInitializationScriptItem! !!PhLImageCreationPresenter methodsFor: 'initialization'!initializationScripts	^ self application scriptsDirectory files 		select: [ :file | file extension = 'st' ]! !!PhLImageCreationPresenter methodsFor: 'initialization'!initialize	super initialize.	reservedImagesNamesCache := self application imageRepository imageNames collect: #asLowercase! !!PhLImageCreationPresenter methodsFor: 'initialization'!initializePresenters	| createCommand |		imageName := self newTextInput.	imageNameCheck := self newImage.	initScriptText := self newText		disable;		yourself.	initScript := self newDropList		items: self initializationScriptItems;		display: [ :file | file basename ];		whenSelectionChangedDo: [ :selection |			selection selectedItem ifNotNil: [ :item |				initScriptText text: item model contents ] ];		yourself.	descriptionText := self newText.	editInitScriptButton := self newButton		addStyle: 'small';		action: [ self openScriptPresenter ];		icon: (self iconNamed: #edit);		yourself.		createCommand := PhLCreateImageFromTemplateCommand forSpecContext: owner.	(createButton := createCommand asButtonPresenter)		action: [ self createImageWithCommand: createCommand ].	createButton disable! !!PhLImageCreationPresenter methodsFor: 'testing'!isNameValid	^ isNameValid! !!PhLImageCreationPresenter methodsFor: 'initialization'!modelChanged 	self template ifNil: [ ^ self ].		self template isTemplate		ifTrue: [ imageName text: self template suggestedImageName ]		ifFalse: [ self disable ]! !!PhLImageCreationPresenter methodsFor: 'initialization'!noInitializationScriptItem	^ (FileSystem memory root / 'No initialization script') ensureCreateFile! !!PhLImageCreationPresenter methodsFor: 'accessing'!okIcon	^ self application iconNamed: #smallOk! !!PhLImageCreationPresenter methodsFor: 'action'!openScriptPresenter	^ (PhLScriptPresenter		   newApplication: self application		   model: self application scriptsDirectory)		  whenScriptListChanged: [ self refreshInitializationScriptList ];		  open;		  yourself! !!PhLImageCreationPresenter methodsFor: 'refreshing'!refreshInitializationScriptList	initScript items: self initializationScriptItems.! !!PhLImageCreationPresenter methodsFor: 'private'!showNameError	createButton disable.	imageNameCheck 		image: (self application iconNamed: #smallCancel);		help: 'An image with the same name already exists!!'! !!PhLImageCreationPresenter methodsFor: 'private'!showNameOk	self ifValidTemplate: [ createButton enable ].	imageNameCheck 		image: self okIcon;		help: 'Image name is valid!!'! !!PhLImageCreationPresenter methodsFor: 'initialization'!template	"Multiple selection is allowed in templates pane => we get a list of templates"		^ self model! !!PhLImageDetailPresenter class methodsFor: 'specs'!labelConstraintsBlock	^ [ :constraints | 	constraints		height: self labelHeight;		width: self labelWidth ]! !!PhLImageDetailPresenter class methodsFor: 'labelled-presenters'!labelWidth	^ 110! !!PhLImageDetailPresenter methodsFor: 'initialization'!connectPresenters		description whenTextChangedDo: [ :text | self updateImageDescription: text ].	shouldRunInitializationScript whenChangedDo: [ :state | self updateImageRunScript: state ].! !!PhLImageDetailPresenter methodsFor: 'layout'!defaultLayout 		^ SpBoxLayout newTopToBottom 		borderWidth: 5;		add: imageLabel expand: false fill: false padding: 10;		add: self descriptionLayout;		yourself! !!PhLImageDetailPresenter methodsFor: 'accessing'!description	^ description! !!PhLImageDetailPresenter methodsFor: 'layout'!descriptionLayout 	^ SpGridLayout build: [ :builder |		builder		beRowNotHomogeneous;		beColumnNotHomogeneous;		borderWidth: 0;		"column: 1 withConstraints: [ :c | c beNotExpand ];"		column: 2 withConstraints: [ :c | c beExpand ];			add: 'Description'; add: description; nextRow;			add: 'Origin template'; add: template; nextRow;			add: ''; add: templateUrl; nextRow;			add: 'Initialization script'; add: (SpBoxLayout newLeftToRight																add: initializationScript expand: false; 																add: shouldRunInitializationScript expand: false;																yourself); nextRow;			add: 'Location'; add: location ]! !!PhLImageDetailPresenter methodsFor: 'accessing'!image 	^ self model! !!PhLImageDetailPresenter methodsFor: 'accessing'!imageLabel	^ imageLabel! !!PhLImageDetailPresenter methodsFor: 'initialization'!initialize	updating := false.	super initialize.! !!PhLImageDetailPresenter methodsFor: 'initialization'!initializePresenters	imageLabel := self newLabel.	imageLabel addStyle: 'greenOnGray'.	description := self newText.	template := self newLabel.	templateUrl := self newLabel.	initializationScript := self newLabel.	shouldRunInitializationScript := self newCheckBox		help: 'Run the initialization script at next launch?';		disable.	location := self newLabel.	vm := self newTextInput.! !!PhLImageDetailPresenter methodsFor: 'accessing'!location	^ location! !!PhLImageDetailPresenter methodsFor: 'updating'!modelChanged 	| image |		updating := true.		image := self image ifNil: [ PhLNullImage new ].		imageLabel label: image name, ' image, last edited ', image lastModification asString.	description text: image description.	template label: (image originTemplateName ifEmpty: [ '(noname)' ]).	templateUrl label: image originTemplateUrl.	image initializationScript 		ifNil: [ 			initializationScript label: '<none>'.			shouldRunInitializationScript disable. ] 		ifNotNil: [ :script | 			initializationScript label: script basename.			shouldRunInitializationScript 				enable;				state: image shouldRunInitializationScript. ].	location label: image location.	vm text: 'N/A'. "self image vm."		updating := false! !!PhLImageDetailPresenter methodsFor: 'accessing'!template	^ template! !!PhLImageDetailPresenter methodsFor: 'accessing'!templateUrl	^ templateUrl! !!PhLImageDetailPresenter methodsFor: 'initialization'!updateImageDescription: text		updating ifTrue: [ ^ self ].	PhLImageDescriptionUpdater 		image: self image 		description: text! !!PhLImageDetailPresenter methodsFor: 'initialization'!updateImageRunScript: state	updating ifTrue: [ ^ self ].		self image shouldRunInitializationScript: state! !!PhLImageDetailPresenter methodsFor: 'accessing'!vm	^ vm! !!PhLImagesPresenter class methodsFor: 'commands'!buildCommandsGroupWith: anImagesPresenter forRoot: rootCommandGroup	rootCommandGroup		register: (self buildToolbarGroupContext: anImagesPresenter);		register: (self buildContextualMenuGroupContext: anImagesPresenter)! !!PhLImagesPresenter class methodsFor: 'commands'!buildContextualMenuGroupContext: aContext	^ (CmCommandGroup named: 'Context Menu') asSpecGroup		beDisplayedAsGroup;		description: 'Images table contextual menu';		register: ((CmCommandGroup named: 'launch') asSpecGroup			beDisplayedAsGroup;			register: (PhLLaunchImageCommand forSpecContext: aContext);			register: (PhLLaunchImageCommand new asSpecLaunchWithoutSettingsCommand				context: aContext;				name: 'Launch without settings';				yourself);			yourself);		register: ((CmCommandGroup named: 'edition') asSpecGroup			beDisplayedAsGroup;			register: (PhLRenameImageCommand forSpecContext: aContext);			register: (PhLCopyImageCommand forSpecContext: aContext);			register: (PhLDeleteImageCommand forSpecContext: aContext);			yourself);		register: (PhLRecreateImageCommand forSpecContext: aContext);		register: (PhLShowImageInFolderCommand forSpecContext: aContext);		register: (PhLCopyPathname forSpecContext: aContext);		register: (PhLCopyLaunchCommand forSpecContext: aContext);		register: (PhLCreateTemplateFromImageCommand forSpecContext: aContext);		register: (PhLCreateTemplateFromImageCommand new asSpecCommandWithImageRemoval			context: aContext;			yourself);		register: ((CmCommandGroup named: 'extra') asSpecGroup			register: (PhLInspectCommand forSpecContext: aContext);			yourself);		yourself! !!PhLImagesPresenter class methodsFor: 'commands'!buildToolbarGroupContext: aContext	^ (CmCommandGroup named: 'Toolbar') asSpecGroup		description: 'Pharo Launcher toolbar';		register: ((CmCommandGroup named: 'Create') asSpecGroup			beDisplayedAsGroup;			register: (PhLOpenNewImageWindowCommand forSpecContext: aContext);			yourself);		register: ((CmCommandGroup named: 'Image') asSpecGroup			beDisplayedAsGroup;			register: (PhLLaunchImageCommand forSpecContext: aContext);			register: (PhLLaunchImageCommand new asSpecLaunchWithoutSettingsCommand				context: aContext;				yourself);			register: (PhLLaunchImageFromDiskCommand forSpecContext: aContext);			register: (PhLImportImageCommand forSpecContext: aContext);			register: (PhLRefreshImageRepositoryCommand forSpecContext: aContext);			register: ((PhLShowImageInFolderCommand forSpecContext: aContext)				name: 'Show';				yourself);			register: (PhLDeleteImageCommand forSpecContext: aContext);			yourself);		register: ((CmCommandGroup named: 'Settings') asSpecGroup			register: ((PhLOpenVmManagerCommand forSpecContext: aContext)				name: 'VMs';				yourself);			register: ((PhLOpenSettingsCommand forSpecContext: aContext)				name: 'Settings';				yourself);			register: (PhLAboutCommand forSpecContext: aContext);			register: (PhLQuitCommand forSpecContext: aContext);			yourself;		yourself)! !!PhLImagesPresenter methodsFor: 'api - actions'!actionFilter	^ imageFilter		takeKeyboardFocus! !!PhLImagesPresenter methodsFor: 'api - actions'!actionLaunch	| cmd |	cmd := PhLLaunchImageCommand forContext: self.	cmd execute! !!PhLImagesPresenter methodsFor: 'initialization'!buildDescriptionPanel	^ self		instantiate: PhLImageDetailPresenter		on: PhLNullImage new! !!PhLImagesPresenter methodsFor: 'initialization'!buildImageFilter				^ self newTextInput		placeholder: 'Enter image name filter ...';		whenTextChangedDo: [ :filterString | self filter: filterString asLowercase ];		yourself! !!PhLImagesPresenter methodsFor: 'initialization'!buildImageTable	^ self newTable		activateOnDoubleClick;		alternateRowsColor;		items: self imageRepository images;		sortingBlock: #lastModification descending;		whenActivatedDo: [ self actionLaunch ];		bindKeyCombination: Character cr asShortcut toAction: [ self actionLaunch ];		addColumn: ((SpStringTableColumn title: 'Name' evaluated: #name)			width: 350;			beSortable;			yourself);		addColumn: ((SpStringTableColumn title: 'Architecture' evaluated: #architecture)			width: 90;			beSortable;			yourself);		addColumn: ((SpStringTableColumn title: 'Pharo Version' evaluated: #pharoVersion)			width: 90;			beSortable;			yourself);		addColumn: ((SpStringTableColumn			title: 'Last modified'			evaluated: [ :image | self readableDateFor: image lastModification ])			sortFunction: #lastModification descending;			yourself);		contextMenuFromCommandsGroup: [ self rootCommandsGroup / 'Context Menu' ];		beResizable;		beMultipleSelection;		yourself! !!PhLImagesPresenter methodsFor: 'initialization'!buildToolbar	| toolbarGroup |		toolbarGroup := self toolbarGroup.	^ self newPresenter		layout: (SpBoxLayout newLeftToRight			add: (self newLaunchToolbar fillWith: toolbarGroup / 'Create') expand: false;			add: (SpBoxLayout newTopToBottom 				vAlignCenter;				add: self newLaunchConfigurationDropList expand: false;				yourself);			add: (self newLaunchToolbar fillWith: toolbarGroup / 'Image') expand: false;			add: self newLabel; "to create a space"			addLast: (self newLaunchToolbar fillWith: toolbarGroup / 'Settings') expand: false;			yourself);		yourself! !!PhLImagesPresenter methodsFor: 'initialization'!connectPresenters	imageTable transmitDo: [ :image |		self 			refreshLaunchConfigurationList;			updateToolbarCommandsAvailability ].			imageTable 		transmitTo: descriptionPanel		transform: [ :images | 					images size = 1				ifTrue: [ images first ]				ifFalse: [ PhLNullImage new ] ]! !!PhLImagesPresenter methodsFor: 'api - actions'!createLocalTemplateFromSelectionNamed: aString	^ self templateRepository createLocalTemplateFrom: self singleImage named: aString! !!PhLImagesPresenter methodsFor: 'layout'!defaultLayout	^ SpBoxLayout newTopToBottom		add: toolbar expand: false;		add: imageFilter expand: false;		add: (SpPanedLayout newTopToBottom			positionOfSlider: 55 percent;			add: imageTable;			add: descriptionPanel;			yourself);		yourself! !!PhLImagesPresenter methodsFor: 'private'!editLaunchConfigurations	^ (PhLOpenLaunchConfigurationEditorCommand forContext: self) execute! !!PhLImagesPresenter methodsFor: 'private'!ensure: aBoolean	aBoolean		ifFalse: [ PhLCommandError signal ]! !!PhLImagesPresenter methodsFor: 'private'!filter: regexMatcher	| images |	images := regexMatcher		ifNil: [ self imageRepository images ]		ifNotNil: [ self imageRepository images				select: [ :each | regexMatcher search: each name asString asLowercase ] ].	imageTable items: images! !!PhLImagesPresenter methodsFor: 'api - selection'!hasSingleImageSelected	^ (imageTable selectedItems size = 1) and: [ imageTable selectedItems first notNil ]! !!PhLImagesPresenter methodsFor: 'api - accessing'!imageRepository	^ self model! !!PhLImagesPresenter methodsFor: 'initialization'!initializePresenters	toolbar := self buildToolbar.	imageFilter := self buildImageFilter.	imageTable := self buildImageTable.	descriptionPanel := self buildDescriptionPanel.		self imageRepository whenChangedSend: #refresh to: self! !!PhLImagesPresenter methodsFor: 'initialization'!initializeWindow: aWindowPresenter	aWindowPresenter		title: 'Pharo Launcher';		initialExtent: 900@550;		centered;		whenClosedDo: [ self imageRepository unsubscribe: self ].	self rootCommandsGroup installShortcutsIn: aWindowPresenter.	aWindowPresenter 		bindKeyCombination: $f meta		toAction: [ self actionFilter ]! !!PhLImagesPresenter methodsFor: 'initialization'!newLaunchConfigurationDropList	^ launchConfigurationList := SpDropListPresenter new			items: #();			yourself! !!PhLImagesPresenter methodsFor: 'private'!readableDateFor: aDateAndTime 		^ PhLTimeUntilNowStrategy displayStringOf: aDateAndTime! !!PhLImagesPresenter methodsFor: 'updating'!refresh 	imageTable items: self imageRepository images.	self refreshLaunchConfigurationList! !!PhLImagesPresenter methodsFor: 'updating'!refreshLaunchConfigurationList	| image items |		[ image := self singleImage ]	on: PhLCommandError	do: [ 		self resetLaunchConfigurationList.		^ self ].		items := image launchConfigurations 		collect: [ :each | 			SpDropListItem new				model: each;				display: [ :config | config name ];				icon: (self application iconNamed: #configuration);				yourself ]		as: OrderedCollection.		items addFirst: (SpDropListItem new				model: 'Edit configurations ...';				action: [ 					self 						editLaunchConfigurations;						refreshLaunchConfigurationList ];				icon: (self application iconNamed: #edit);				yourself ).		launchConfigurationList		resetSelection;		dropListItems: items.		[ launchConfigurationList selectItem: image defaultLaunchConfiguration ]		on: NotFound "Default configuration has been deleted but there are still other configurations"		do: [ launchConfigurationList selectIndex: 2 ]! !!PhLImagesPresenter methodsFor: 'updating'!resetLaunchConfigurationList	launchConfigurationList		resetSelection;		items: #() "no image selected".! !!PhLImagesPresenter methodsFor: 'initialization'!rootCommandsGroup 	^ rootCommandsGroup ifNil: [ rootCommandsGroup := super rootCommandsGroup ]! !!PhLImagesPresenter methodsFor: 'api - selection'!selectConfiguration: aPhLLaunchConfiguration	launchConfigurationList selectItem: aPhLLaunchConfiguration! !!PhLImagesPresenter methodsFor: 'api - selection'!selectImage: aPhLImage	imageTable items 		detect: [ :image | image name = aPhLImage name ]		ifFound: [ :item | imageTable selectItem: item ]! !!PhLImagesPresenter methodsFor: 'api - selection'!selectImageAt: anIndex	imageTable selectIndex: anIndex! !!PhLImagesPresenter methodsFor: 'api - selection'!selectedImages	^ imageTable selectedItems! !!PhLImagesPresenter methodsFor: 'api - accessing'!selectedLaunchConfiguration		^ launchConfigurationList selectedItem! !!PhLImagesPresenter methodsFor: 'api - selection'!singleImage	self ensure: self hasSingleImageSelected.	^ imageTable selection selectedItems first! !!PhLImagesPresenter methodsFor: 'api - selection'!singleImageName	^ self singleImage name! !!PhLImagesPresenter methodsFor: 'api - accessing'!templateRepository	^ self application templateRepository! !!PhLImagesPresenter methodsFor: 'accessing'!toolbarGroup	^ self rootCommandsGroup / 'Toolbar'! !!PhLImagesPresenter methodsFor: 'initialization'!updatePresenter	self imageRepository hasImages 		ifTrue: [ imageTable selectFirst ]! !!PhLImagesPresenter methodsFor: 'updating'!updateToolbarCommandsAvailability	self withToolbarDo: [ :toolbar |		self toolbarGroup allCommands do: #updateEnableStatus ]! !!PhLImagesPresenter methodsFor: 'private'!withToolbarDo: aBlock	self withWindowDo: [ :window | aBlock value: window toolbar ]! !!PhLScriptPresenter class methodsFor: 'example'!example	| fs |	fs := FileSystem memory.	fs root / 'loadSpec.st'		writeStreamDo: [ :s | s nextPutAll: 'Metacello new    baseline: ''Iceberg'';    repository: ''filetree://./'';    load.' ].	fs root / 'icebergLoadExample.st'		writeStreamDo: [ :s | s nextPutAll: self icebergLoadExample ].	^ (self newApplication: PharoLauncherApplication new 		model: fs root) 		open;		yourself! !!PhLScriptPresenter class methodsFor: 'example'!icebergLoadExample	^ 'Metacello new  baseline: ''Tonel'';  repository: ''github://pharo-vcs/tonel:v1.0.12'';  load.'! !!PhLScriptPresenter methodsFor: 'layout'!defaultLayout	^ SpPanedLayout newHorizontal		  positionOfSlider: 30 percent;		  add: scriptTable withConstraints: [ :constraints | 			  constraints spec: #withoutOrderingBar ];		  add: (SpBoxLayout newVertical				   add: fileEditor;				   add: saveButton expand: false;				   yourself);		  yourself! !!PhLScriptPresenter methodsFor: 'user interaction'!defaultSaveShortCut	^ SpAcceptChangesCommand defaultShortcutKey ! !!PhLScriptPresenter methodsFor: 'initialization'!initializePresenters 	scriptTable := (self instantiate: SpEditableListPresenter)		items: self scripts;		display: [ :file | file basename ];		whenSelectionChangedDo: [ :selection | 			selection isEmpty				ifTrue: [ fileEditor 								text: '' ;								disable. ]				ifFalse: [ fileEditor 								text: selection selectedItem contents;								enable. ] ];		addItemBlock: [ self newScript ];		removeItemBlock: [ :item | self removeScript: item ];		yourself.	fileEditor := self newCode		disable;		bindKeyCombination: self defaultSaveShortCut			toAction: [ self saveSelectedScript ];		yourself.	saveButton := self newButton		label: 'Save';		icon: (self iconNamed: #smallSave);		action: [ self saveSelectedScript ];		yourself.		! !!PhLScriptPresenter methodsFor: 'initialization'!initializeWindow: aWindowPresenter	aWindowPresenter		title: 'Available initialization scripts';		initialExtent: 800@550.! !!PhLScriptPresenter methodsFor: 'action'!newScript	| newName |		newName := self application newRequest			title: 'New script name?';			validateAnswer: [ :answer | (self scriptDirectory / answer) exists not ];			request.		^ self newScriptNamed: newName! !!PhLScriptPresenter methodsFor: 'action'!newScriptNamed: aName	| file |	aName ifNil: [ ^ nil ].		file := self scriptDirectory / aName.	file extension = 'st'		ifFalse: [ file := file, 'st' ].	file ensureCreateFile.	self scriptListChanged.	^ file! !!PhLScriptPresenter methodsFor: 'action'!removeScript: aFileReference 		aFileReference ifNil: [ ^ self ].	(self application newConfirmation		parentWindow: self window;		message: 'Do you want to remove ', aFileReference fullName, ' script?';		confirm) 		ifFalse: [ ^ self ].			aFileReference ensureDelete.	scriptTable	removeItem: aFileReference.	self scriptListChanged! !!PhLScriptPresenter methodsFor: 'action'!saveSelectedScript	| file |	file := scriptTable selectedItem.	file ifNil: [ ^ self application newInformation		message: 'Cannot save: no script selected!!';		inform ].	file		ensureDelete;		writeStreamDo: [ :stream | stream nextPutAll: fileEditor text asString ]! !!PhLScriptPresenter methodsFor: 'accessing'!scriptDirectory	^ self model ! !!PhLScriptPresenter methodsFor: 'action'!scriptListChanged	scriptTable refresh.	scriptListChangedBlock ifNotNil: [ scriptListChangedBlock cull: self ].! !!PhLScriptPresenter methodsFor: 'accessing'!scripts	^ (self scriptDirectory files 		select: [ :file | file extension = 'st' ])			asSortedCollection ! !!PhLScriptPresenter methodsFor: 'action'!selectScript: aFileReference	^ scriptTable selectItem: aFileReference! !!PhLScriptPresenter methodsFor: 'events'!whenScriptListChanged: aBlock 	scriptListChangedBlock := aBlock.! !!PhLTemplatesPresenter class methodsFor: 'commands'!buildCommandsGroupWith: anImagesPresenter forRoot: rootCommandGroup	rootCommandGroup		register: (self buildContextualMenuGroup)! !!PhLTemplatesPresenter class methodsFor: 'commands'!buildContextualMenuGroup	^ (CmCommandGroup named: 'Context Menu') asSpecGroup		description: 'Templates tree contextual menu';		register: PhLRenameTemplateCommand forSpec;		register: PhLRemoveTemplateCommand forSpec;		beDisplayedAsGroup;		yourself! !!PhLTemplatesPresenter class methodsFor: 'example'!example	| app |	app := PharoLauncherApplication new 		imageRepository: (PhLDirectoryBasedImageRepository forDirectory: FileSystem memory root);		yourself.	^ (self 			newApplication: app			model: PhLTemplateGroupRepository default)		open;		yourself! !!PhLTemplatesPresenter methodsFor: 'initialization'!buildCategoryTable		^ self newTable		hideColumnHeaders;		items: self templateRepository roots;		addColumn: ((SpImageTableColumn evaluated: #icon) width: 30);		addColumn: (SpStringTableColumn evaluated: #name);		yourself! !!PhLTemplatesPresenter methodsFor: 'initialization'!buildDescriptionPanel	| panel |	panel := self instantiate: PhLImageCreationPresenter on: nil.	panel disable.		^ panel! !!PhLTemplatesPresenter methodsFor: 'initialization'!buildTemplateTable		^ self newTreeTable		hideColumnHeaders;		"alternateRowsColor;"		children: [ :aTemplateGroup | self childrenOf: aTemplateGroup ];		addColumn: (SpStringTableColumn evaluated: #name);		contextMenuFromCommandsGroup: [ self rootCommandsGroup / 'Context Menu' ];		beMultipleSelection; "bulk delete templates for example"		whenRootsChangedDo: [ :roots | 			templateTable lazilyComputeChildren: (roots anySatisfy: #shouldComputeChildrenLazily) ];		whenSelectionChangedDo: [ :selection | 			descriptionPanel enabled: selection isEmpty not ]		yourself! !!PhLTemplatesPresenter methodsFor: 'private'!childrenOf: aTemplateGroup			^ [ aTemplateGroup children ]		on: PhLDownloadError		do: [ :error | 			| children |			(PhlRetryPresenter newApplication: self application)				explanation: error longDescription;				retryBlock: [ children := aTemplateGroup children ];				cancelBlock: [ children := #() ];				openModal.			children ]	! !!PhLTemplatesPresenter methodsFor: 'initialization'!connectPresenters	super connectPresenters.	categoryTable 		transmitTo: templateTable 		transform: [ :group | 			group 				ifNil: [ #() ]				ifNotNil: [ group children ] ].	templateTable 		transmitTo: descriptionPanel		transform: [ :selectionArray | 			selectionArray				ifNotEmpty: [ selectionArray last ]				ifEmpty: [ nil ] ].! !!PhLTemplatesPresenter methodsFor: 'layout'!defaultLayout	^ SpPanedLayout newHorizontal		positionOfSlider: 60 percent;		add: (SpPanedLayout newHorizontal			positionOfSlider: 40 percent;			add: (SpBoxLayout newVertical 				add: '1. Choose a template category:' expand: false;				add: categoryTable;				yourself);			add: (SpBoxLayout newVertical 				add: '2. Choose a template:' expand: false;				add: templateTable;				yourself);			yourself);		add: (SpBoxLayout newVertical 			add: descriptionPanel;			yourself);		yourself		! !!PhLTemplatesPresenter methodsFor: 'accessing'!description	^ descriptionPanel description! !!PhLTemplatesPresenter methodsFor: 'api - selection'!hasLocalTemplateSelected	| items |	items := templateTable selectedItems.	^ items size = 1		and: [ items first isLocalTemplate ]! !!PhLTemplatesPresenter methodsFor: 'api - selection'!hasLocalTemplatesSelected	| items |	items := templateTable selectedItems.	^ items size > 0 		and: [ items allSatisfy: #isLocalTemplate ]! !!PhLTemplatesPresenter methodsFor: 'api - selection'!hasSingleTemplateSelected	^ (templateTable selection selectedItems size = 1) 			and: [ templateTable selectedItem isTemplate ]! !!PhLTemplatesPresenter methodsFor: 'api - accessing'!imageName 	^ descriptionPanel imageName! !!PhLTemplatesPresenter methodsFor: 'api - accessing'!imageRepository	^ self application imageRepository! !!PhLTemplatesPresenter methodsFor: 'accessing'!initializationScript	^ descriptionPanel initializationScript! !!PhLTemplatesPresenter methodsFor: 'initialization'!initialize	super initialize.	self selectCategory: 3! !!PhLTemplatesPresenter methodsFor: 'initialization'!initializePresenters	categoryTable := self buildCategoryTable.	templateTable := self buildTemplateTable.	descriptionPanel := self buildDescriptionPanel! !!PhLTemplatesPresenter methodsFor: 'initialization'!initializeWindow: aWindowPresenter	aWindowPresenter		title: 'Pharo Launcher - Image creation';		initialExtent: 800@400;		"toolBar: (self rootCommandsGroup / 'Toolbar') asToolbarPresenter;"		centered.		"self rootCommandsGroup installShortcutsIn: aWindowPresenter"! !!PhLTemplatesPresenter methodsFor: 'updating'!refresh	| selectedCategory |	selectedCategory := categoryTable selection selectedItem.	self templateRepository refresh. "refresh caches"	categoryTable items: categoryTable items.	categoryTable selectItem: selectedCategory! !!PhLTemplatesPresenter methodsFor: 'reseting'!refreshInitializationScriptList	descriptionPanel refreshInitializationScriptList! !!PhLTemplatesPresenter methodsFor: 'api - selection'!selectCategory: anIndex	categoryTable selectIndex: anIndex! !!PhLTemplatesPresenter methodsFor: 'api - selection'!selectedTemplateCategory	^ categoryTable selection selectedItem! !!PhLTemplatesPresenter methodsFor: 'api - selection'!selectedTemplates	^ templateTable selectedItems! !!PhLTemplatesPresenter methodsFor: 'api - selection'!singleTemplate	self hasSingleTemplateSelected		ifFalse: [ PhLCommandError  signal: 'Only one template must be selected!!' ].	^ templateTable selectedItems first "multiple selection enabled, always return a collection"! !!PhLTemplatesPresenter methodsFor: 'api - accessing'!templateRepository	^ self model! !!PhLVMPresenter class methodsFor: 'commands'!buildCommandsGroupWith: anImagesPresenter forRoot: rootCommandGroup	rootCommandGroup		register: (self buildToolbarGroup);		register: (self buildContextualMenuGroup)! !!PhLVMPresenter class methodsFor: 'commands'!buildContextualMenuGroup	^ (CmCommandGroup named: 'Context Menu') asSpecGroup		register: PhLUpdateVmCommand forSpec;		register: PhLShowVmInFolderCommand forSpec;		register: PhLDeleteVmCommand forSpec;		yourself! !!PhLVMPresenter class methodsFor: 'commands'!buildToolbarGroup	^ (CmCommandGroup named: 'Toolbar') asSpecGroup		description: 'Pharo Launcher VM Manager toolbar';		register: PhLUpdateVmCommand forSpec;		register:			(PhLShowVmInFolderCommand forSpec				name: 'Show';				yourself);		register: PhLDeleteVmCommand forSpec;		register: PhLToggleVmPrivateVmCommand forSpec;		beDisplayedAsGroup;		yourself! !!PhLVMPresenter class methodsFor: 'examples'!example	<example>	(self on: PhLVirtualMachinesDataSource default) open! !!PhLVMPresenter methodsFor: 'initialization'!connectPresenters	super connectPresenters.	shouldShowPrivateVms := false.	! !!PhLVMPresenter methodsFor: 'accessing'!datasource	^ self model! !!PhLVMPresenter methodsFor: 'layout'!defaultLayout	^ SpBoxLayout newVertical		add: vmTable;		yourself! !!PhLVMPresenter methodsFor: 'initialization'!initializePresenters	vmTable := self newTable		whenActivatedDo: [ PhLShowVmInFolderCommand new									context: self;									execute  ];		addColumn: ((SpImageTableColumn title: '' evaluated: 			[ :vm | | icon |			icon := vm isValid				ifTrue: [ self iconNamed: #testGreen ]				ifFalse: [ self iconNamed: #testNotRun ].			icon asMorph				setBalloonText: vm validityDescription;				yourself.			]) 			width: 20);		addColumn: ((SpStringTableColumn title: 'Name' evaluated: #name) width: 100; yourself);		addColumn: ((SpStringTableColumn 			title: 'Last update' 			evaluated: #lastUpdateTimeDescription) width: 120; yourself);		addColumn: (SpStringTableColumn title: 'Download URL' evaluated: #downloadUrl);		showColumnHeaders;		alternateRowsColor;		contextMenuFromCommandsGroup: [ self rootCommandsGroup / 'Context Menu' ];		beResizable;		beMultipleSelection;		items: self datasource virtualMachines;		yourself! !!PhLVMPresenter methodsFor: 'initialization'!initializeWindow: aWindowPresenter	aWindowPresenter		title: 'Locally available Virtual Machines';		initialExtent: 720 @ 300;		toolbar:			(self newLaunchToolbar fillWith: self rootCommandsGroup / 'Toolbar');		centered.	self rootCommandsGroup installShortcutsIn: aWindowPresenter.	self privateVmsTogglePresenter		whenDeactivatedDo: [ 			self privateVmsTogglePresenter				label: 'public';				icon: (self iconNamed: #remote) ];		whenActivatedDo: [ 			self privateVmsTogglePresenter				label: 'private';				icon: (self iconNamed: #smallLock) ];		beUnselected! !!PhLVMPresenter methodsFor: 'initialization'!privateVmsTogglePresenter	^ (self rootCommandsGroup / 'Toolbar') allCommands last presenter! !!PhLVMPresenter methodsFor: 'private'!readableDateFor: aTimestamp	^ aTimestamp asDate yyyymmdd , ' ' , aTimestamp asTime print24! !!PhLVMPresenter methodsFor: 'accessing'!refresh 	| vms |	vms := shouldShowPrivateVms		ifTrue: [ self datasource privateVirtualMachines ]		ifFalse: [ self datasource virtualMachines ].	vmTable items: vms.! !!PhLVMPresenter methodsFor: 'initialization'!rootCommandsGroup 	^ rootCommandsGroup ifNil: [ rootCommandsGroup := super rootCommandsGroup ]! !!PhLVMPresenter methodsFor: 'accessing'!selectedVms	^ vmTable selectedItems! !!PhLVMPresenter methodsFor: 'configuring'!showPrivateVms	shouldShowPrivateVms := true.	self refresh.! !!PhLVMPresenter methodsFor: 'configuring'!showVms	shouldShowPrivateVms := false.	self refresh.! !!PhLVMPresenter methodsFor: 'configuring'!toggleShowVmPrivateVm	shouldShowPrivateVms := shouldShowPrivateVms not.	self refresh! !!PhLAboutPresenter class methodsFor: 'instance creation'!example	| text |	text := PhLAboutCommand new aboutText.		(self text: text iconName: #pharo) openDialog! !!PhLAboutPresenter class methodsFor: 'instance creation'!text: aText iconName: anIconName	^ self new 		text: aText;		iconName: anIconName;		yourself! !!PhLAboutPresenter class methodsFor: 'specs'!title 	^ 'About'! !!PhLAboutPresenter methodsFor: 'layout'!defaultLayout	^ SpBoxLayout newHorizontal		add: icon width: 90;		add: 			(SpBoxLayout newVertical				spacing: 15;				add: description;				add: documentationLink expand: false;			yourself);		yourself! !!PhLAboutPresenter methodsFor: 'accessing'!description 	^ description! !!PhLAboutPresenter methodsFor: 'accessing'!icon 	^ icon! !!PhLAboutPresenter methodsFor: 'accessing'!iconName: anIconName	iconName := anIconName! !!PhLAboutPresenter methodsFor: 'initialization'!initializeDialogWindow: aDialogWindow	self initializeWindow: aDialogWindow.	aDialogWindow addButton: 'Ok'		do: [ :presenter | presenter close ].! !!PhLAboutPresenter methodsFor: 'initialization'!initializePresenters 	description := self newText.	icon := self newImage.	documentationLink := self newLink		url: 'https://pharo-project.github.io/pharo-launcher';		label: 'Open Pharo Launcher documentation (web)';		yourself.! !!PhLAboutPresenter methodsFor: 'initialization'!initializeWindow: aWindow	aWindow title: 'About Pharo Launcher'.	description 		text: text;		disable.   icon image: (self iconNamed: iconName).! !!PhLAboutPresenter methodsFor: 'accessing'!text: aText	text := aText! !!PhLLaunchConfigurationPresenter class methodsFor: 'specs'!configurationDetailSpec	^ SpBoxLayout newVertical		spacing: 5;		add:			(SpBoxLayout newHorizontal				add: 'Configuration name:' withConstraints: self labelConstraintsBlock;				add: #selectedConfigurationNameField;				yourself)			height: self inputTextHeight;		add:			(SpBoxLayout newHorizontal				add: 'VM:' withConstraints: self labelConstraintsBlock;				add: #vmList;				yourself)			height: self inputTextHeight;		add:			(SpBoxLayout newHorizontal				add: 'VM arguments:' withConstraints: self labelConstraintsBlock;				add: #vmArgumentList;				yourself)			height: 200"80";		add:			(SpBoxLayout newHorizontal				add: 'Image arguments:' withConstraints: self labelConstraintsBlock;				add: #imageArgumentList;				yourself)			height: 200"150";		add: 			(SpBoxLayout newHorizontal				add: ''; "work-around to center the button"				add: #applyChangesButton expand: false;				add: '   ' expand: false;				add: #saveAndSelectsButton expand: false;				add: '  '; "work-around to center the button"				yourself)			height: self buttonHeight;		yourself! !!PhLLaunchConfigurationPresenter class methodsFor: 'layout'!defaultLayout	^ SpBoxLayout newHorizontal		spacing: 5;		add: #configurationTable 			withConstraints: [ :constraints | 				constraints 					spec: #withoutOrderingBar; 					width: 200 ];		add: self configurationDetailSpec;		yourself! !!PhLLaunchConfigurationPresenter class methodsFor: 'specs'!example	| image |	image := PhLImage example.	image versionFile 		writeStreamDo: [ :stream | stream nextPutAll: '70' ].	(self 		newApplication: PharoLauncherApplication new 		model: image) open! !!PhLLaunchConfigurationPresenter class methodsFor: 'specs'!labelConstraintsBlock	^ [ :constraints | 	constraints		height: self labelHeight;		width: self labelWidth ]! !!PhLLaunchConfigurationPresenter class methodsFor: 'specs'!labelWidth	^ 120! !!PhLLaunchConfigurationPresenter methodsFor: 'private'!addInteractiveImageArgument	| interactiveFlag |	interactiveFlag := '--interactive'.	(imageArgumentList items includes: interactiveFlag)		ifTrue: [ ^ self ].	imageArgumentList items add: interactiveFlag.	imageArgumentList refresh.! !!PhLLaunchConfigurationPresenter methodsFor: 'accessing'!configurationName	^ selectedConfigurationNameField text! !!PhLLaunchConfigurationPresenter methodsFor: 'initialization'!connectPresenters	configurationTable selectIndex: 1! !!PhLLaunchConfigurationPresenter methodsFor: 'accessing'!image	^ image! !!PhLLaunchConfigurationPresenter methodsFor: 'accessing'!imageArguments	^ imageArgumentList items! !!PhLLaunchConfigurationPresenter methodsFor: 'initialization'!initializePresenters	configurationTable := (self instantiate: SpEditableListPresenter)		addItemBlock: [ self newConfiguration ];		label: 'Launch configurations';		items: self image launchConfigurations;		display: [ :each | each name ];		whenSelectionChangedDo: [ :selection | 			selectedConfiguration := selection selectedItem ifNil: [ PhLNullLaunchConfiguration new ].			self selectedConfigurationChanged ];		yourself.	selectedConfigurationNameField := self newTextInput		disable;		yourself.	vmList := self newDropList		sortingBlock: [ :a :b | a model id > b model id ];		display: [ :each | each id ];		whenSelectedItemChangedDo: [ :vm | 			vm ifNotNil: 				[ vm isHeadless 					ifTrue: [ self addInteractiveImageArgument ] ] ];		yourself.	"Run in a separate process to do not block UI. Can take some seconds."	[ self initializeVmListContent ] fork.	vmArgumentList := (self instantiate: SpEditableListPresenter)		addItemBlock: [ 			self newRequest				title: 'New VM argument?';				request ];		yourself.	imageArgumentList := (self instantiate: SpEditableListPresenter)		addItemBlock: [ 			self newRequest				title: 'New image argument?';				request ];		yourself.	applyChangesButton := self newButton		label: 'Apply';		icon: (self application iconNamed: #scriptManager);		action: [ self saveSelectedConfiguration ];		yourself.	saveAndSelectsButton := self newButton		label: 'Save & select';		icon: (self application iconNamed: #smallSave);		action: [ 			self saveSelectedConfiguration.			self delete ];		yourself! !!PhLLaunchConfigurationPresenter methodsFor: 'initialization'!initializeVmListContent	vmList items: image vmManager virtualMachines.	self setVmFromConfiguration.! !!PhLLaunchConfigurationPresenter methodsFor: 'initialization'!initializeWindow: aWindowPresenter	aWindowPresenter		title: self image name, ' image launch configurations';		initialExtent: 800@550;		whenClosedDo: [ self application launchConfigurationEdited: self selectedConfiguration ].! !!PhLLaunchConfigurationPresenter methodsFor: 'action'!newConfiguration	| newName configuration |		newName := self application newRequest			title: 'New Launch configuration name?';			validateAnswer: [ :answer | 				self image launchConfigurations noneSatisfy: [ :each | each name = answer ] ];			request.	newName ifNil: [ ^ nil ].		configuration := (PhLLaunchConfiguration  withImage: self image)		name: newName;		yourself.	^ configuration! !!PhLLaunchConfigurationPresenter methodsFor: 'action'!saveSelectedConfiguration	| config |	config := self selectedConfiguration.	config isNullConfiguration ifTrue: [ ^ self ].		config imageArguments: imageArgumentList items.	config vmArguments: vmArgumentList items.	config vm: vmList selectedItem.	self image serializeMetadata.	self application launchConfigurationEdited: config.! !!PhLLaunchConfigurationPresenter methodsFor: 'action'!selectImageArgumentAt: anIndex	imageArgumentList selectIndex: anIndex! !!PhLLaunchConfigurationPresenter methodsFor: 'action'!selectVMArgumentAt: anIndex	vmArgumentList selectIndex: anIndex! !!PhLLaunchConfigurationPresenter methodsFor: 'accessing'!selectedConfiguration	^ selectedConfiguration! !!PhLLaunchConfigurationPresenter methodsFor: 'updating'!selectedConfigurationChanged	selectedConfigurationNameField text: self selectedConfiguration name.	self setVmFromConfiguration.	vmArgumentList items: self selectedConfiguration vmArguments.	imageArgumentList items: self selectedConfiguration imageArguments.	self selectImageArgumentAt: 1.	self selectVMArgumentAt: 1.! !!PhLLaunchConfigurationPresenter methodsFor: 'initialization'!setModelBeforeInitialization: aPhLImage	image := aPhLImage ! !!PhLLaunchConfigurationPresenter methodsFor: 'updating'!setVmFromConfiguration	| vm |	vm := self selectedConfiguration 		ifNil: [ ^ self "abort if no launch configuration selected" ]		ifNotNil: [ :config | config vm ].	[ vmList selectItem: vm ]		on: NotFound		do: [ vmList				addItemLabeled: vm do: [ "no action" ];				selectItem: vm ]! !!PhLLaunchConfigurationPresenter methodsFor: 'accessing'!vmArguments	^ vmArgumentList items! !!PhlRetryPresenter class methodsFor: 'example'!example	(self new		explanation: 'Download error (probably a network error)';		retryBlock: [ "nothing" ];		cancelBlock: [ #() ]	) openModal! !!PhlRetryPresenter methodsFor: 'accessing'!cancelBlock: aBlock	cancelBlock := aBlock! !!PhlRetryPresenter methodsFor: 'layout'!defaultLayout 	^ SpBoxLayout newLeftToRight 		spacing: 10;		add: iconPresenter expand: false;		add:  explanationText;		yourself! !!PhlRetryPresenter methodsFor: 'accessing'!explanation: aString 	explanationText text: aString! !!PhlRetryPresenter methodsFor: 'initialization'!initializeDialogWindow: aWindowPresenter	aWindowPresenter		title: 'Retry?';		initialExtent: 400 @ 200;		addButton: 'Retry' do: [ :presenter | presenter close. retryBlock value. ];		addButton: 'Cancel' do: [ :presenter | presenter beCancel; close. cancelBlock value. ];		centeredRelativeToTopWindow	! !!PhlRetryPresenter methodsFor: 'initialization'!initializePresenters	explanationText := self newText		beNotEditable;		yourself.			iconPresenter := self newImage 		image: (self iconNamed: #smallUpdate);		yourself! !!PhlRetryPresenter methodsFor: 'accessing'!retryBlock: aBlock	retryBlock := aBlock! !!SpPresenter methodsFor: '*PharoLauncher-Spec2'!newLaunchToolbar	^ self newToolbar		addStyle: 'compact';		yourself! !!SettingDeclaration methodsFor: '*PharoLauncher-Spec2' prior: 61117749!inputWidgetForFileOrDirectoryWithAction: aSymbol	"Small update from the original version to get text auto-accepted as default"	| list button |	list := EditableDropListMorph		on: self		list: #list		selected: #index		changeSelected: #index:		useIndex: true		addToList: #addToList:		class: String		getEnabled: #enabled		default: self defaultValue.	list		ghostText: self ghostHelp;		hResizing: #rigid;		width: 450;		wantsFrameAdornments: true.	list contentMorph autoAccept.	button := self theme		newButtonIn: self currentWorld		for: self		getState: nil		action: aSymbol		arguments: nil		getEnabled: nil		label:			(AlphaImageMorph new				image: (self iconNamed: #smallOpenIcon))		help: 'Open directory chooser dialog' translated.	^ self theme		newRowIn: self currentWorld		for:			{list.			button}! !!PharoLauncherConfiguration methodsFor: 'styling'!customStyleSheet	^ (SpStyleVariableSTONReader fromString: '.application [        	   .greenOnGray [ Draw { #color: #lightGreen} , Draw { #backgroundColor: #gray } ] ]	')! !!PharoLauncherConfiguration methodsFor: 'private - factory'!newStyleSheet	^ SpStyle defaultStyleSheet copy, self customStyleSheet! !!SpRequestDialog methodsFor: '*PharoLauncher-Spec2'!request	^ self openModal! !!SDLOSXPlatform methodsFor: '*PharoLauncher-Spec2' prior: 60245145!afterSetWindowTitle: aString onWindow: aOSSDLWindow	"Do not set the window title with the document name.	It will change the app title and the icon."! !!OSWorldRenderer methodsFor: '*PharoLauncher-Spec2' prior: 52167701!doActivate	| attributes initialExtent |		initialExtent := world worldState realWindowExtent ifNil: [976@665].	attributes := OSWindowAttributes new.	attributes		extent: initialExtent;		title: 'Pharo Launcher';		windowCentered:true.	display := Form extent: initialExtent depth: 32.	world extent: initialExtent.	driver := self pickMostSuitableWindowDriver.	attributes preferableDriver: driver.	osWindow := OSWindow createWithAttributes: attributes eventHandler: (OSWindowMorphicEventHandler for: world).		driver afterMainPharoWindowCreated: osWindow.	driver afterSetWindowTitle: Smalltalk image imageFile fullName onWindow: osWindow.			osWindow focus. 		world worldState doFullRepaint.	world displayWorld.		OSWindowClipboard new beDefault.! !!OSWorldRenderer methodsFor: '*PharoLauncher-Spec2' prior: 52172266!updateWindowTitle	"do nothing"! !!SpWorldPresenter methodsFor: '*PharoLauncher-Spec2'!close	self application windowClosed: self.	"We could remove all morphs from the world but it is already done by PhLDeploymentScript	self adapter ifNotNil: [ :adapter | adapter removeSubWidgets ]"! !!SpWorldPresenter methodsFor: '*PharoLauncher-Spec2'!title: aString	titleHolder := aString.	self adapter ifNotNil: [ :worldAdapter | worldAdapter title: self title ]! !!Duration methodsFor: '*PharoLauncher-Spec2'!simpleTime: aString ago: aCount	^ aCount asFloat floor asString , ' ' , (aString asPluralBasedOn: aCount) , ' ago'! !!Duration methodsFor: '*PharoLauncher-Spec2'!simpleTimeAgo	"Maybe there is a better way to do that, but for now I'll let it like this."		self days > 365		ifTrue: [ ^ 'more than a year ago' ].	self days > 30		ifTrue: [ ^ self simpleTime: 'month' ago: self days / 30 ].	self days > 14		ifTrue: [ ^ self simpleTime: 'week' ago: self days / 7 ].	self days > 7		ifTrue: [ ^ 'last week' ].	self days > 1		ifTrue: [ ^ self simpleTime: 'day' ago: self days ].	self days = 1		ifTrue: [ ^ 'yesterday' ].	self hours > 1		ifTrue: [ ^ self simpleTime: 'hour' ago: self hours ].	self hours = 1		ifTrue: [ ^ 'an hour ago' ].	self minutes > 1		ifTrue: [ ^ self simpleTime: 'minute' ago: self minutes ].	self minutes = 1		ifTrue: [ ^ 'a minute ago' ].		^ 'just now'! !!WorldState class methodsFor: '*PharoLauncher-Spec2' prior: 88624496!quitSession	self flag: 'TODO'.	"Since UserManager is now over, there is no clean way to avoid warning when we just ask to quit the image. More general, there should be a way to have an image in read/only mode" 	PhLDeploymentScript quitSession! !!SettingTreeBuilder methodsFor: '*PharoLauncher-Spec2'!pharoLauncherSettings	"Process a <pharoLauncherSettings> pragma"	self systemsettings! !"PharoLauncher-Spec2"!!PhLGToolkitImage commentStamp: '' prior: 0!See PhLImage comment for setup details. GToolkit VM/image bundles can be downloaded at https://gtoolkit.com/download/.!!PhLGToolkitVirtualMachine commentStamp: '' prior: 0!See PhLVirtualMachine's comment for general details. GToolkit VM/image bundles can be downloaded at https://gtoolkit.com/download/#SetupTwo things unique to GToolkit setup:1. Gtoolkit currently puts some libraries in non-standard locations e.g. on Mac, several dylibs are outside the .app bundle in its parent folder. Make sure to include all these libraries and any other needed resources - like the sources file - when placing the VM in the Launcher VM folder.2. For the time being, each image must be launched with the VM distributed with that image version, even for minor and patch releases*. No assumptions can be made about compatibility other than that because the VM may change with every image version.* Per the GToolkit team on 8/28/2020 on the GT Discord Server, general channel!!PhLGToolkitImage class methodsFor: 'testing'!versionPrefix	^ PhLGToolkitVirtualMachine versionPrefix! !!PhLGToolkitImage methodsFor: 'accessing'!defaultArguments	^ super defaultArguments		add: '--no-quit';		add: '--interactive';		yourself! !!PhLGToolkitVirtualMachine class methodsFor: 'querying'!executableName	^ 'GlamorousToolkit'! !!PhLGToolkitVirtualMachine class methodsFor: 'accessing'!versionPrefix	^ 'gt-'! !"PharoLauncher-GToolkit"!!PhLSqueakImage commentStamp: '' prior: 0!See PhLImage comment for setup details. Squeak VM/image bundles can be downloaded at https://squeak.org/downloads/!!PhLSqueakVirtualMachine commentStamp: '' prior: 0!See PhLVirtualMachine's comment for general details. Squeak VM/image bundles can be downloaded at https://squeak.org/downloads/!!PhLSqueakImage class methodsFor: 'testing'!versionPrefix	^ PhLSqueakVirtualMachine versionPrefix! !!PhLSqueakVirtualMachine class methodsFor: 'querying'!executableName	^ 'Squeak'! !!PhLSqueakVirtualMachine class methodsFor: 'testing'!versionPrefix	^ 'sq-'! !"PharoLauncher-Squeak"!!PhLPluggableTemplateGroup commentStamp: '' prior: 0!I'm a kind of template group that is completely defined by my instance variables. Useful for testing.!!PhLImageDescriptionUpdaterMock commentStamp: '' prior: 0!I override the save method to remember the number of time the real ImageDescriptionUpdater would have saved the image metadata.!!PhLImageDescriptionUpdaterTest commentStamp: '' prior: 0!A PhLImageDescriptionUpdaterTest is a test class for testing the behavior of PhLImageDescriptionUpdater!!PhLAbstractTemplateTest commentStamp: '' prior: 0!Give me unit tests and I will make sure they are run for all subclasses of PhLAbstractTemplate!!PhLDirectoryBasedImageRepositoryTest commentStamp: '' prior: 0!A PhLDirectoryBasedImageGroupTest is a test class for testing the behavior of PhLDirectoryBasedImageGroup!!ManifestPharoLauncherTests commentStamp: '' prior: 0!I stores metadata on true and false positive critics. These meta data are used by the SmalllintManifestChecker and the critics Browser!!PhLPluggableTemplateGroup class methodsFor: 'instance creation'!name: aString	^ self name: aString templates: #() groups: #()! !!PhLPluggableTemplateGroup class methodsFor: 'instance creation'!name: aString groups: anotherCollection	^ self new		setName: aString templates: #() groups: anotherCollection;		yourself! !!PhLPluggableTemplateGroup class methodsFor: 'instance creation'!name: aString templates: aCollection	^ self name: aString templates: aCollection groups: #()! !!PhLPluggableTemplateGroup class methodsFor: 'instance creation'!name: aString templates: aCollection groups: anotherCollection	^ self new		setName: aString templates: aCollection groups: anotherCollection;		yourself! !!PhLPluggableTemplateGroup methodsFor: 'accessing'!groups	^ groups! !!PhLPluggableTemplateGroup methodsFor: 'accessing'!name	^ name! !!PhLPluggableTemplateGroup methodsFor: 'initialization'!setName: aString templates: aCollection groups: anotherCollection	name := aString.	templates := aCollection.	groups := anotherCollection.! !!PhLPluggableTemplateGroup methodsFor: 'accessing'!templates	^ templates! !!PhLPluggableTemplateGroup methodsFor: 'accessing'!templatesAndGroups	^ self templates, self groups! !!PhLImageDescriptionUpdaterMock methodsFor: 'saving'!doSave	saves add: { image name -> description }! !!PhLImageDescriptionUpdaterMock methodsFor: 'initialization'!initialize	super initialize.	saves := OrderedCollection new.	nbProcessKilled := 0.! !!PhLImageDescriptionUpdaterMock methodsFor: 'accessing'!nbProcessKilled	^ nbProcessKilled! !!PhLImageDescriptionUpdaterMock methodsFor: 'accessing'!nbSave	^ saves size! !!PhLImageDescriptionUpdaterMock methodsFor: 'private'!terminateProcess 	super terminateProcess.	process ifNotNil: [ nbProcessKilled := nbProcessKilled + 1 ].! !!PhLImageDescriptionUpdaterMock methodsFor: 'accessing'!waitDelay	^ 100 milliSeconds! !!PhLFileBrowserTest methodsFor: 'tests'!testCanOpenAFileBrowserOnImageFolder	| path |	path := Smalltalk image imageDirectory fullName.	PhLFileBrowser openOn: path.! !!PhLImageDescriptionUpdaterTest methodsFor: 'running'!setUp	super setUp.	updater := PhLImageDescriptionUpdaterMock		reset;		default.	rootFs := FileSystem memory root.	image := PhLImage location: rootFs / 'one'.	image2 := PhLImage location: rootFs / 'two'! !!PhLImageDescriptionUpdaterTest methodsFor: 'tests'!testDoNotSaveNullImage	updater image: PhLNullImage new description: 'desc'.		self assert: updater nbSave equals: 0! !!PhLImageDescriptionUpdaterTest methodsFor: 'tests'!testDoNotSaveWhenImageIsNil	updater image: nil description: 'desc'.		self assert: updater nbSave equals: 0! !!PhLImageDescriptionUpdaterTest methodsFor: 'tests'!testNoSaveWhenDescriptionIsTheSame	image description: 'desc'.	updater image: image description: 'desc'.	updater image: image description: 'desc'.	self waitUpdate.		self assert: updater nbSave equals: 0.! !!PhLImageDescriptionUpdaterTest methodsFor: 'tests'!testSaveBothImagesWhenUpdatingDescriptionOfTwoDifferentImages	updater image: image description: 'desc'.	updater image: image2 description: 'desc imag2'.	self waitUpdate.		self assert: updater nbSave equals: 2! !!PhLImageDescriptionUpdaterTest methodsFor: 'tests'!testSaveOnceWhenDescriptionChangeOnce	updater image: image description: 'desc'.	self waitUpdate.		self assert: updater nbSave equals: 1! !!PhLImageDescriptionUpdaterTest methodsFor: 'tests'!testSaveOnceWhenDescriptionChangesManyTimesWithDelayShorterThanWaitDelay	3 timesRepeat: 		[ updater image: image description: 'desc'.		 (updater waitDelay / 5) wait ].	self waitUpdate.		self assert: updater nbSave equals: 1! !!PhLImageDescriptionUpdaterTest methodsFor: 'tests'!testSaveTwiceWhenDescriptionChangesManyTimesWithDelayLongerThanWaitDelay	3 timesRepeat: 		[ updater image: image description: 'desc'.		 self waitUpdate. ].		self assert: updater nbSave equals: 3! !!PhLImageDescriptionUpdaterTest methodsFor: 'utilities'!waitUpdate	(updater waitDelay + 100 milliSeconds) wait.! !!PhLImageTest methodsFor: 'utilities'!createFakeVM	^ PhLVirtualMachine new 		basicInitializeOn: FileLocator launcherVMsLocation / '100-x64';		executable: FileLocator launcherVMsLocation / '100-x64' / 'Pharo';		yourself! !!PhLImageTest methodsFor: 'accessing'!currentImageVersion 	^  SystemVersion current major asString		, SystemVersion current minor asString! !!PhLImageTest methodsFor: 'running'!setUp	super setUp.	fs := FileSystem memory root.	imageFileRef := fs / 'foo.image'.	imageFileRef binaryWriteStreamDo: [ :stream | (ZnEndianessReadWriteStream on: stream) nextLittleEndianNumber: 4 put: 68021 ].	image := PhLImage location: imageFileRef! !!PhLImageTest methodsFor: 'tests'!testCanGetDefaultLaunchConfigurationWhenNoLaunchConfiguration	| config |	config := image defaultLaunchConfiguration.		self 		assert: config name		equals: 'Default'.! !!PhLImageTest methodsFor: 'tests'!testCanInitializeImageFromMetadatafile	| deserializedImage |	image 		description: 'An image for testing purpose';		computeArchitecture;		originTemplate: (PhLRemoteTemplate name: 'Foo test template' url: 'https://foo.bar.org/abc/foo.zip' asZnUrl).			deserializedImage := PhLImage location: fs / 'foo.image'.	self 		assert: deserializedImage description		equals: image description.	self 		assert: deserializedImage architecture		equals: image architecture.	self 		assert: deserializedImage formatNumber 		equals: image formatNumber.	self 		assert: deserializedImage pharoVersion		equals: image pharoVersion.	self 		assert: deserializedImage originTemplate name		equals: image originTemplate name.	self 		assert: deserializedImage originTemplate url asString		equals: image originTemplate url asString.! !!PhLImageTest methodsFor: 'tests'!testCanSerializeAndDeserializeImageLaunchConfigurationMetadata	| deserializedImage launchConfig deserializedLaunchConfig |	image 	launchConfigurations. "Add default launch ocnfig to the list of configurations"	launchConfig := image defaultLaunchConfiguration 		imageArguments: #('foo');		vmArguments: #(1 2);		yourself.			deserializedImage := STON fromString: image stonString.	deserializedLaunchConfig := deserializedImage defaultLaunchConfiguration.	self		assert: deserializedLaunchConfig name 		equals: launchConfig name.	self		assertCollection: deserializedLaunchConfig imageArguments  		hasSameElements: launchConfig imageArguments.	self		assertCollection: deserializedLaunchConfig vmArguments  		hasSameElements: launchConfig vmArguments.! !!PhLImageTest methodsFor: 'tests'!testCanSerializeAndDeserializeImageMetadata	| deserializedImage |	image 		description: 'An image for testing purpose';		computeArchitecture;		originTemplate: (PhLRemoteTemplate name: 'Foo test template' url: 'https://foo.bar.org/abc/foo.zip' asZnUrl).			deserializedImage := STON fromString: image stonString.	self 		assert: deserializedImage description		equals: image description.	self 		assert: deserializedImage architecture		equals: image architecture.	self 		assert: deserializedImage formatNumber 		equals: image formatNumber.	self 		assert: deserializedImage pharoVersion		equals: image pharoVersion.	self 		assert: deserializedImage originTemplate name		equals: image originTemplate name.	self 		assert: deserializedImage originTemplate url asString		equals: image originTemplate url asString.! !!PhLImageTest methodsFor: 'tests'!testDefaultLaunchConfigurationIsRetrievedFromConfigurationListWhenAvailable	| config |	config := image defaultLaunchConfiguration.	config imageArguments: #( #foo ).	image launchConfigurations: { config }.			self 		assert: image defaultLaunchConfiguration		equals: config.			self 		assert: image defaultLaunchConfiguration imageArguments		equals: #( #foo ).! !!PhLImageTest methodsFor: 'tests'!testDescriptionIsSetWhenNoDescriptionInMetadataButDescriptionFileExists	| desc |	image description: nil.	desc := 'A description from description file description.txt'.	fs / PhLImage descriptionFileName 		writeStreamDo: [ :stream | stream nextPutAll: desc ].	self 		assert: image description		equals: desc.! !!PhLImageTest methodsFor: 'tests'!testImageNameIsNotValidWhenContainingFileSeparator	self deny: (PhLImage isValidName: 'fo/o').	self deny: (PhLImage isValidName: '123\4').! !!PhLImageTest methodsFor: 'tests'!testImageNameIsValidWithLettersAndNumbers	self assert: (PhLImage isValidName: 'foo').	self assert: (PhLImage isValidName: '1234').	self assert: (PhLImage isValidName: 'Fo23')! !!PhLImageTest methodsFor: 'tests'!testPhLImageSerialization	| stonString |	(image file parent / image class versionFileName)		writeStreamDo: [ :stream | stream nextPutAll: self currentImageVersion ].	image launchConfigurations. "create default configuration"	image defaultLaunchConfiguration vm: self createFakeVM. "Avoid to download a VM"	image vmManager imageFile: FileLocator launcherImagesLocation / (image name , '.image'). "do not serialize a memory FS"		stonString := image stonString.		"ensure we get a file locator"	self assert: (stonString includesSubstring: '#executableRef : FileLocator {') description: 'missing executableRef: ', stonString.	self assert: (stonString includesSubstring: '#origin : #launcherVMsLocation') description: 'missing #launcherVMsLocation origin: ', stonString.	self assert: (stonString withInternetLineEndings includesSubstring: '#imageFile : FileLocator {			#path : RelativePath [ ''foo.image'' ],			#origin : #launcherImagesLocation		}' withInternetLineEndings) description: 'missing or wrong #imageFile: ', stonString.	"ensure VM manager is a reference"	self assert: (stonString includesSubstring: '#manager : @2,') description: 'VM manager is not a reference: ', stonString.! !!PhLImageTest methodsFor: 'tests'!testPharoVersionIsSetWhenNoVersionInMetadataButPharoVersionFileExists	| version |		version := '60'.	image versionFile 		writeStreamDo: [ :stream | stream nextPutAll: version ].	self 		assert: image pharoVersion		equals: version.! !!PhLImageTest methodsFor: 'tests'!testTemplateIsSetWhenMetadataFileInOldFormat	"Old metadata file was a STON file with a dictionary with only one entry:		template -> ston representation of the template	"	| oldMetadataString template |		image originTemplate: nil.	oldMetadataString := '{''template'':PhLRemoteTemplate{#name:''Pharo 7.0 (development version)'',#url:ZnUrl{#scheme:#http,#host:''files.pharo.org'',#segments:OrderedCollection[''image'',''70'',''latest.zip'']}}}'.	fs / PhLImage metadataFileName writeStreamDo: [ :stream | stream nextPutAll: oldMetadataString ].	template := (STON fromString: oldMetadataString) at: #template.	image := PhLImage location: fs / 'foo.image'.		self 		assert: image originTemplate class		equals: template class.	self 		assert: image originTemplate name		equals: template name.	self 		assert: image originTemplate url		equals: template url.! !!PhLLaunchConfigurationTest methodsFor: 'helper'!pharo80HeadlessVm	^ (PhLVirtualMachine id: '80-x64-headless')			beHeadless;			beLatest;			be64bits;			isValidAfterUpdate;			yourself! !!PhLLaunchConfigurationTest methodsFor: 'running'!setUp	super setUp.	(fs / PhLImage versionFileName)		binaryWriteStreamDo: [ :stream | stream nextPutAll: '70' ].	! !!PhLLaunchConfigurationTest methodsFor: 'helper'!stripExportFrom: arguments 	^ arguments first = 'export'		ifTrue: [ self stripExportFrom: (arguments allButFirst: 3) "export foo=bar &&" ]		ifFalse: [ arguments ]! !!PhLLaunchConfigurationTest methodsFor: 'tests'!testCanGetDefaultVm	| launchConfig vm |	launchConfig := PhLLaunchConfiguration defaultWithImage: image.		vm := launchConfig vm.		self assert: (vm isKindOf: PhLVirtualMachine).	self 		assert: vm id		equals: '70-x64'.! !!PhLLaunchConfigurationTest methodsFor: 'tests'!testCanGetDefaultVmWhenVMNotListedInVmManager	| launchConfig vm |	launchConfig := PhLLaunchConfiguration defaultWithImage: image.	(fs / PhLImage versionFileName)		binaryWriteStreamDo: [ :stream | stream nextPutAll: '770' ].	vm := launchConfig vm.		self assert: (vm isKindOf: PhLVirtualMachine).	self 		assert: vm id		equals: '770-x64'.! !!PhLLaunchConfigurationTest methodsFor: 'tests'!testCanSerializeLaunchConfiguration	| launchConfig deserializedConfig |	launchConfig := PhLLaunchConfiguration defaultWithImage: image.	launchConfig vm executable: 'pharo'.	launchConfig		vmArguments: #(1 2 3);		imageArguments: #(#A #B).		deserializedConfig := STON fromString: (STON toStringPretty: launchConfig).		self		assert: deserializedConfig name 		equals: launchConfig name.	self		assertCollection: deserializedConfig vmArguments		hasSameElements: launchConfig vmArguments.	self		assertCollection: deserializedConfig imageArguments		hasSameElements: launchConfig imageArguments.	self 		assert: deserializedConfig vm		equals: launchConfig vm! !!PhLLaunchConfigurationTest methodsFor: 'tests'!testImageLaunchProcessDoesNotHaveInitializationScriptArgumentsIfInitializationScriptIsNil	| command launchConfig arguments |	image versionFile writeStreamDo: [ :stream | stream nextPutAll: '80' ].	launchConfig := image defaultLaunchConfiguration.	launchConfig vm executable: 'pharo'.		[ command := launchConfig launchProcess ]	on: PhLMissingVirtualMachineError 	do: [ :error | error resume. "ignore. We are just testing command arguments" ].	arguments := self stripExportFrom: command arguments.		self 		assert: arguments size	 	equals: 2.	self deny: (arguments includes: 'eval').! !!PhLLaunchConfigurationTest methodsFor: 'tests'!testImageLaunchProcessDoesNotHaveInitializationScriptArgumentsIfInitializationScriptShouldNotBeRun	| command launchConfig arguments |	image versionFile writeStreamDo: [ :stream | stream nextPutAll: '80' ].	image 		initializationScript: (FileSystem memory root / 'foo.st') asFileReference;		doNotRunInitializationScript.	launchConfig := image defaultLaunchConfiguration.	launchConfig vm executable: 'pharo'.		[ command := launchConfig launchProcess ]	on: PhLMissingVirtualMachineError 	do: [ :error | error resume. "ignore. We are just testing command arguments" ].	arguments := self stripExportFrom: command arguments.		self 		assert: arguments size	 	equals: 2.	self deny: (arguments includesAny: #('eval' '"/foo.st')).! !!PhLLaunchConfigurationTest methodsFor: 'tests'!testImageLaunchProcessHasImageArguments	| command launchConfig |	image versionFile writeStreamDo: [ :stream | stream nextPutAll: '80' ].	launchConfig := image defaultLaunchConfiguration.	launchConfig imageArguments: #( 1 2 3 ).	launchConfig vm executable: 'pharo'.		[ command := launchConfig launchProcess ]	on: PhLMissingVirtualMachineError 	do: [ :error | error resume. "ignore. We are just testing command arguments" ].		self assert: (command arguments includesAll: #( 1 2 3 )).! !!PhLLaunchConfigurationTest methodsFor: 'tests'!testImageLaunchProcessHasInitializationScriptArgumentsIfInitializationScriptNotNil	| command launchConfig |	image versionFile writeStreamDo: [ :stream | stream nextPutAll: '80' ].	image initializationScript: (FileSystem memory root / 'foo.st') asFileReference.	launchConfig := image defaultLaunchConfiguration.	launchConfig vm executable: 'pharo'.		[ command := launchConfig launchProcess ]	on: PhLMissingVirtualMachineError 	do: [ :error | error resume. "ignore. We are just testing command arguments" ].		self 		assertCollection: (command arguments last: 2) "remove vm and image argument (and possible exports)"	 	hasSameElements: #('eval' '"/foo.st"').! !!PhLLaunchConfigurationTest methodsFor: 'tests'!testImageLaunchProcessHasVmArguments	| command launchConfig |	image versionFile writeStreamDo: [ :stream | stream nextPutAll: '80' ].	launchConfig := image defaultLaunchConfiguration.	launchConfig 		doNotUseSettings;		vm: self pharo80HeadlessVm.	launchConfig vm executable: 'pharo'.		[ command := launchConfig launchProcess ]	on: PhLMissingVirtualMachineError 	do: [ :error | error resume. "ignore. We are just testing command arguments" ].		self assert: (command arguments includes: PhLVirtualMachine headlessOptionString)! !!PhLLaunchConfigurationTest methodsFor: 'tests'!testImageLaunchWitSettingsDoesNotHaveNoPreferencesFlag	| command launchConfig |	image := PhLImage example.	image versionFile writeStreamDo: [ :stream | stream nextPutAll: '70' ].	launchConfig := image defaultLaunchConfiguration.	launchConfig vm executable: 'pharo'.		[ command := launchConfig launchProcess ]	on: PhLMissingVirtualMachineError 	do: [ :error | error resume. "ignore. We are just testing command arguments" ].		self deny: (command arguments includes: '--no-default-preferences')! !!PhLLaunchConfigurationTest methodsFor: 'tests'!testImageLaunchWithoutSettingsDoesNotHavePreferencesFlagIfNotSupportedByImage	| command launchConfig |	image := PhLImage example32.	image versionFile writeStreamDo: [ :stream | stream nextPutAll: '20' ].	launchConfig := image defaultLaunchConfiguration.	launchConfig doNotUseSettings.	[ launchConfig vm executable: 'pharo' ]		on: PhLArchitectureMismatchWarning 		do: [ :error | error resume. "ignore" ].		[ command := launchConfig launchProcess ]	on: PhLMissingVirtualMachineError 	do: [ :error | error resume. "ignore. We are just testing command arguments" ].		self deny: (command arguments includes: '--no-default-preferences')! !!PhLLaunchConfigurationTest methodsFor: 'tests'!testImageLaunchWithoutSettingsHasNoPreferencesFlag	| command launchConfig |	image := PhLImage example.	image versionFile writeStreamDo: [ :stream | stream nextPutAll: '70' ].	launchConfig := image defaultLaunchConfiguration.	launchConfig doNotUseSettings.	launchConfig vm executable: 'pharo'.		[ command := launchConfig launchProcess ]	on: PhLMissingVirtualMachineError 	do: [ :error | error resume. "ignore. We are just testing command arguments" ].		self assert: (command arguments includes: '--no-default-preferences')! !!PhLLaunchConfigurationTest methodsFor: 'tests'!testVmHasSameVmManagerAsImage	| launchConfig |	launchConfig := PhLLaunchConfiguration defaultWithImage: image.	launchConfig vm executable: 'pharo'.		self 		assert: launchConfig image vmManager		identicalTo: launchConfig vm manager! !!PhLStringTest methodsFor: 'tests'!testCanformatTemplateNameFromComplexUrl	| result |	result := '{6} ({5})' formatTemplateName: '/pharo-ide/TelePharo/releases/download/v0.4.2/Pharo7.0-32bit-TelePharo.zip'.		self		assert: result		equals: 'Pharo7.0-32bit-TelePharo (v0.4.2)'! !!PhLStringTest methodsFor: 'tests'!testCanformatTemplateNameFromComplexUrl2	| result |	result := '{1}-{2}-{3}-{5}' formatTemplateName: '/pharo-ide/TelePharo/releases/download/v0.4.2/Pharo7.0-32bit-TelePharo.zip'.		self		assert: result		equals: 'pharo-ide-TelePharo-releases-v0.4.2'! !!PhLStringTest methodsFor: 'tests'!testCanformatTemplateNameFromSimpleUrl	| result |	result := '{1}' formatTemplateName: '/foo.zip'.		self		assert: result		equals: 'foo'! !!PhLStringTest methodsFor: 'tests'!testFormatTemplateNameDoesNotSubsituteWhenNoSubstitutionPatternFound	| result |	result := 'foo-bar-1' formatTemplateName: '/pharo-ide/TelePharo/releases/download/v0.4.2/Pharo7.0-32bit-TelePharo.zip'.		self		assert: result		equals: 'foo-bar-1'! !!PhLTemplateGroupsBuilderTest methodsFor: 'tests'!testCanBuildListWhenNoSourceTemplate	| list sources |	sources := PhLTemplateSources withTemplateList: #().		list := PhLTemplateGroupsBuilder buildFrom: sources.		self 		assert: list size 		equals: 0! !!PhLTemplateGroupsBuilderTest methodsFor: 'tests'!testCanBuildListWithFixedUrlGroup	| groups group sources |	sources := PhLTemplateSources withTemplateList: { PhLTemplateSource officialDistributionsGroup }.		groups := PhLTemplateGroupsBuilder buildFrom: sources.		self 		assert: groups size		equals: 1.	group := groups anyOne.		self assert: group isTemplateGroup.	self 		assert: group class		equals: PhLFixedURLsTemplateGroup! !!PhLTemplateGroupsBuilderTest methodsFor: 'tests'!testCanBuildListWithFixedUrlTemplate	| groups group sources |		group := PhLTemplateSource officialDistributionsGroup.	group templates: { PhLTemplateSource pharo70x64 }.	sources := PhLTemplateSources withTemplateList: { group }.	groups := PhLTemplateGroupsBuilder buildFrom: sources.		self 		assert: groups size		equals: 1.	group := groups anyOne.		self assert: group templatesAndGroups size		equals: 1.	self assert: group templatesAndGroups first class		equals: PhLRemoteTemplate.! !!PhLTemplateGroupsBuilderTest methodsFor: 'tests'!testCanBuildListWithHttpListingGroup	| groups group sources |	sources := PhLTemplateSources withTemplateList: { PhLTemplateSource pharo70 }.		groups := PhLTemplateGroupsBuilder buildFrom: sources.		self 		assert: groups size		equals: 1.	group := groups anyOne.		self assert: group isTemplateGroup.	self 		assert: group class		equals: PhLHTTPListingTemplateGroup! !!PhLTemplateGroupsBuilderTest methodsFor: 'tests'!testCanBuildListWithJenkinsGroup	| groups group sources |	sources := PhLTemplateSources withTemplateList: { PhLTemplateSource inriaPharoContribution }.			groups := PhLTemplateGroupsBuilder buildFrom: sources.		self 		assert: groups size		equals: 1.	group := groups anyOne.		self assert: group isTemplateGroup.	self 		assert: group class		equals: PhLJenkins2Server! !!PhLTemplateSourcesTest methodsFor: 'running'!setUp	super setUp.	sourcesFile := FileSystem memory / 'templates-sources.test'.	"Avoid blocking modal dialogs when a source update is available"	defaultPharoLauncherApp := PharoLauncherApplication default.	PharoLauncherApplication default: PhLTestApplication new. ! !!PhLTemplateSourcesTest methodsFor: 'running'!tearDown	PhLPharoTemplateSources resetSourcesUrl.	PharoLauncherApplication default: defaultPharoLauncherApp.	super tearDown! !!PhLTemplateSourcesTest methodsFor: 'tests'!testAlmostIdenticalTemplateSourcesAreDifferent	| templatesSources1 templatesSources2 |	templatesSources1 := (PhLPharoTemplateSources withTemplateList: PhLPharoTemplateSources defaultSources) sources.	templatesSources2 := (PhLPharoTemplateSources withTemplateList: PhLPharoTemplateSources defaultSources) sources.	templatesSources2 second templates first name: 'changed'.	self deny: templatesSources1 equals: templatesSources2! !!PhLTemplateSourcesTest methodsFor: 'tests'!testCanCreateInstanceFromAListOfTemplateSource	| tplSources sources |		tplSources := PhLTemplateSources withTemplateList: { PhLTemplateSource officialDistributionsGroup }.	sources := tplSources sources.		self 		assert: sources size		equals: 1	! !!PhLTemplateSourcesTest methodsFor: 'tests'!testCanFetchSourcesFileWhenAbsent	self deny: sourcesFile exists.		(PhLPharoTemplateSources withFile: sourcesFile) ensureSourcesFile. 		self assert: sourcesFile exists! !!PhLTemplateSourcesTest methodsFor: 'tests'!testGivenUserSourcesFileAbsentWhenAskingUserSourcesThenGetEmptyCollection	| sources |	self deny: sourcesFile exists.	sources := (PhLUserTemplateSources withFile: sourcesFile) sources.	self assertEmpty: sources! !!PhLTemplateSourcesTest methodsFor: 'tests'!testGivenUserSourcesFileWithErrorsWhenAskingUserSourcesThenGetEmptyCollection	| sources |	sourcesFile writeStreamDo: [ :stream | stream nextPutAll: 'foobar' ].	sources := (PhLTemplateSources withFile: sourcesFile) sources.	self assertEmpty: sources! !!PhLTemplateSourcesTest methodsFor: 'tests'!testGivenUserSourcesFileWithReferencesToUnknownVariablesWhenAskingUserSourcesThenGetEmptyCollection	| sources |	sourcesFile writeStreamDo: [ :stream | stream nextPutAll: '[PhLHTTPListingTemplateGroup{#nonexistingiv:''http://foo.org'',#name:''foo''}]' ].	self shouldnt: [ sources := (PhLTemplateSources withFile: sourcesFile) sources ] raise: InstanceVariableNotFound.	self assertEmpty: sources! !!PhLTemplateSourcesTest methodsFor: 'tests'!testIdenticalTemplateSourcesAreEquals	| templatesSources1 templatesSources2 |	templatesSources1 := (PhLTemplateSources withTemplateList: PhLPharoTemplateSources defaultSources) sources.	templatesSources2 := (PhLTemplateSources withTemplateList: PhLPharoTemplateSources defaultSources) sources.		self 		assert: templatesSources1		equals: templatesSources2	! !!PhLTemplateSourcesTest methodsFor: 'tests'!testNoUpdateAnnouncedWhenDownloadedSourcesIsSameAsSources	| announcements sources |	sourcesFile writeStreamDo: [ :stream | stream nextPutAll: (STON toString: true) ].	announcements := OrderedCollection new.	ZnClientTest new		withServerDo: [ :server | 			server onRequestRespond: [ :request | ZnResponse ok: (ZnEntity text: (STON toString: true)) ].			sources := PhLPharoTemplateSources withFile: sourcesFile.			PhLPharoTemplateSources sourcesUrl: server localUrl.			PhLPharoTemplateSources announcer weak when: PhLSourcesFileUpdateAvailable send: #add: to: announcements.			sources checkForUpdates.			self assertEmpty: announcements ]! !!PhLTemplateSourcesTest methodsFor: 'tests'!testSourcesFileNotFetchIfPresentWhenCallingEnsureSourcesFile	sourcesFile ensureCreateFile.			(PhLPharoTemplateSources withFile: sourcesFile) ensureSourcesFile. 		self 		assert: sourcesFile parent children size		equals: 1! !!PhLTemplateSourcesTest methodsFor: 'tests'!testSourcesFileNotUpdatedWhenDownloadedSourcesFileIsAbsent	| sources sourcesFileModificationTime |	sourcesFile writeStreamDo: [ :stream | stream nextPutAll: 'foobar' ].	sourcesFileModificationTime := sourcesFile modificationTime.	sources := PhLPharoTemplateSources withFile: sourcesFile.	sources downloadedSourcesFile ensureDelete.		sources updateSourcesFile.		self 		assert: sources file modificationTime 		equals: sourcesFileModificationTime! !!PhLTemplateSourcesTest methodsFor: 'tests'!testSourcesFileUpdateAvailableIsAnnouncedWhenDownloadedSourcesDifferentFromSources	| announcements sources |		sourcesFile writeStreamDo: [ :stream | stream nextPutAll: (STON toString: true) ].		announcements := OrderedCollection new. 	ZnClientTest new 	withServerDo: [ :server |		server onRequestRespond: [ :request | 			ZnResponse ok: (ZnEntity text: (STON toString: false)) ].			sources := PhLPharoTemplateSources withFile: sourcesFile.	PhLPharoTemplateSources sourcesUrl: server localUrl.		PhLPharoTemplateSources announcer weak		when: PhLSourcesFileUpdateAvailable		send: #add:		to: announcements.	sources checkForUpdates.	self 		assert: announcements size 		equals: 1 ].! !!PhLTemplateSourcesTest methodsFor: 'tests'!testUserTemplatesAreListedAfterPharoTemplates	| userSources pharoSources sources |	userSources := PhLUserTemplateSources example.	pharoSources := PhLPharoTemplateSources fromFile.		sources := (PhLCompositeTemplateSources new initializeWith: { pharoSources . userSources }) sources.		self 		assert: sources size		equals: pharoSources sources size + 1.	self 		assert: sources last		equals: userSources sources last! !!PhLAbstractTemplateTest class methodsFor: 'testing'!isAbstract	^ self name = #PhLAbstractTemplateTest! !!PhLAbstractTemplateTest methodsFor: 'instance creation'!newTemplate	^ self subclassResponsibility! !!PhLAbstractTemplateTest methodsFor: 'running'!setUp	super setUp.	root := FileSystem memory workingDirectory! !!PhLAbstractTemplateTest methodsFor: 'tests'!testHandleEOCDErrorWhenTemplateIsCorrupted	| template archive |	template := self newTemplate.	"simulate a broken zip archive)"	archive := (ByteArray readHexFrom: ((1 to: 50) collect: [ :x| '0123456789ABCDEF' atRandom ])) readStream.	self 		should: [ template extractZipArchive: archive to: root ]		raise: PhLCorruptedTemplateError ! !!PhLAbstractTemplateTest methodsFor: 'tests'!testNoEOCDErrorWhenTemplateIsOk	| template archive archiveFile |	template := self newTemplate.	archiveFile := root / 'phl-abstract-template-test-no-eocd-error-arch.zip'.	archive := ZipArchive new.	archive addDeflateString: 'foo' as: 'bar'.	archiveFile asFileReference binaryWriteStreamDo: [ :stream |		archive writeTo: stream ].		self 		shouldnt: [ template extractZipArchive: archiveFile to: root ]		raise: PhLCorruptedTemplateError! !!PhLAbstractTemplateTest methodsFor: 'tests'!testRelocateImageFilesFromToWithName	| template source destination imageName |	template := self newTemplate.	source := (root / 'old') ensureCreateDirectory.	destination := (root / 'new') ensureCreateDirectory.	(source / 'file.image') ensureCreateFile.	(source / 'file.changes') ensureCreateFile.	imageName := 'new'.	self deny: (destination / imageName , 'image') exists.	self deny: (destination / imageName , 'changes') exists.	template relocateImageFilesFrom: source to: destination withName: imageName.	self assert: (destination / imageName , 'image') exists.	self assert: (destination / imageName , 'changes') exists! !!PhLLocalTemplateTest methodsFor: 'coverage'!classToBeTested	^ PhLLocalTemplate ! !!PhLLocalTemplateTest methodsFor: 'instance creation'!newTemplate	^ PhLLocalTemplate name: 'Test' zipFile: root / 'Test.zip'! !!PhLLocalTemplateTest methodsFor: 'tests'!testDeserializationGivesAFileReferenceToTheTemplate	| template |	template := STON fromString: 'PhLLocalTemplate{#name:''Test'',#zipFile:''/phl-abstract-template-test-template-extraction.zip''}'.		self assert: (template zipArchive isKindOf: FileReference).! !!PhLLocalTemplateTest methodsFor: 'tests'!testSerializationDoesNotIncludeZipFileButAFileReferenceToIt	| template zipFile stonString |	zipFile := '/phl-abstract-template-test-template-extraction.zip' asFileReference.	template := PhLLocalTemplate name: 'Test' zipFile: zipFile.		stonString := STON toString: template.		self assert: stonString equals: 'PhLLocalTemplate{#name:''Test'',#zipFile:FILE[''/phl-abstract-template-test-template-extraction.zip'']}'.! !!PhLLocalTemplateTest methodsFor: 'tests'!testTemplateExtractionGenerateImageMetadata	| template destination archive zipFile metadataFile |	zipFile := root / 'phl-abstract-template-test-template-extraction.zip'.	template := PhLLocalTemplate name: 'Test' zipFile: zipFile.	archive := ZipArchive new.	archive		addDeflateString: 'foo' as: 'bar.image';		addDeflateString: 'foo' as: 'bar.changes'.	template zipArchive asFileReference		binaryWriteStreamDo: [ :stream | archive writeTo: stream ].	destination := (root / 'new') ensureCreateDirectory.		template extractTo: destination named: 'new'.		metadataFile := destination / PhLImage metadataFileName.	self assert: metadataFile exists.	self assert: (metadataFile contents includesSubstring: zipFile basename).	zipFile ensureDelete.! !!PhLRemoteTemplateTest methodsFor: 'coverage'!classToBeTested	^ PhLRemoteTemplate ! !!PhLRemoteTemplateTest methodsFor: 'instance creation'!newTemplate	^ self classToBeTested name: 'Test' url: 'http://foo.example.com/Test.zip'! !!PhLDirectoryBasedImageRepositoryTest methodsFor: 'coverage'!classToBeTested	^ PhLDirectoryBasedImageRepository! !!PhLDirectoryBasedImageRepositoryTest methodsFor: 'instance creation'!emptyGroup	^ self classToBeTested forDirectory: FileSystem memory workingDirectory! !!PhLDirectoryBasedImageRepositoryTest methodsFor: 'instance creation'!newGroupWithAnImage	| group baseDirectory |	group := self emptyGroup.	baseDirectory := group baseDirectory.	(baseDirectory / 'test') ensureCreateDirectory.	(baseDirectory / 'test' / 'test.image') ensureCreateFile.	(baseDirectory / 'test' / 'test.changes') ensureCreateFile.	^ group! !!PhLDirectoryBasedImageRepositoryTest methodsFor: 'tests-action'!testCopyImageNamedTo	| group |	group := self newGroupWithAnImage.	self assert: group imageNames asSet equals: #('test') asSet.	group copyImageNamed: 'test' to: 'test2'.	self assert: group imageNames asSet equals: #('test' 'test2') asSet.	! !!PhLDirectoryBasedImageRepositoryTest methodsFor: 'tests-action'!testDeleteImageNamed	| group |	group := self newGroupWithAnImage.	self assert: group imageNames asSet equals: #('test') asSet.	group deleteImageNamed: 'test'.	self assertEmpty: group imageNames! !!PhLDirectoryBasedImageRepositoryTest methodsFor: 'tests'!testDirectoryForImageNamed	| group |	group := self emptyGroup.	self assertEmpty: group images.	self assertEmpty: group imageNames! !!PhLDirectoryBasedImageRepositoryTest methodsFor: 'tests'!testEmptyByDefault	| group |	group := self emptyGroup.	self assertEmpty: group images.	self assertEmpty: group imageNames! !!PhLDirectoryBasedImageRepositoryTest methodsFor: 'tests'!testIgnoreNonConformDirectories	| group baseDirectory |	group := self emptyGroup.	baseDirectory := group baseDirectory.	self assert: group images size equals: 0.	(baseDirectory / 'foo1') ensureCreateDirectory.	self assert: group images size equals: 0.	(baseDirectory / 'foo1' / 'foo.txt') ensureCreateFile.	self assert: group images size equals: 0.	(baseDirectory / 'foo1' / 'foo1.image') ensureCreateFile.	self assert: group images size equals: 0.	(baseDirectory / 'foo1' / 'foo1.image') delete.	(baseDirectory / 'foo1' / 'foo1.changes') ensureCreateFile.	self assert: group images size equals: 0.	(baseDirectory / 'foo1' / 'foo1.image') ensureCreateFile.	self assert: group images size equals: 1.! !!PhLDirectoryBasedImageRepositoryTest methodsFor: 'tests-action'!testImageNames	| group |	group := self newGroupWithAnImage.	self assert: group imageNames asSet equals: #('test') asSet.! !!PhLDirectoryBasedImageRepositoryTest methodsFor: 'tests-action'!testImages	| group |	group := self newGroupWithAnImage.	self assert: group images size equals: 1.	self assert: group images anyOne name equals: 'test'! !!PhLDirectoryBasedImageRepositoryTest methodsFor: 'tests-action'!testMakeUniqueImageName		{ 	"	{ basename . 	expectedResult .	{existingNames} } "			{ '30444' .		'30444' . 			{ } } .	 	{ '30444' .		'30444' . 			{ 'test' } } .		{ '30444' .		'30444-01' .		{ 'test' . '30444' } } .		{ '30444' .		'30444-02' .		{ 'test' . '30444' . '30444-01' } } .		{ '30444' .		'30444-03' .		{ 'test' . '30444' . '30444-01' . '30444-02' } } .		{ '30444' .		'30444-10' .		{ 'test' . '30444' . '30444-01' . '30444-09' } } .		{ '30444' .		'30444-12' .		{ 'test' . '30444' . '30444-11' . '30444-09' } } .		{ '30444' . 		'30444-12' .		{ 'test' . '30444' . '30444-11' . '30444-09' . '30444-test' . '30644-Case12954' } } .			} do:	[ 	:testdata |  		| basename expectedResult existingNames result |		basename := testdata first.		expectedResult := testdata second. 		existingNames := testdata third.				result := self emptyGroup makeUniqueImageName: basename among: existingNames.		self assert: result equals: expectedResult.	] ! !!PhLDirectoryBasedImageRepositoryTest methodsFor: 'tests-action'!testRenameImageNamedTo	| group |	group := self newGroupWithAnImage.	self assert: group imageNames asSet equals: #('test') asSet.	group renameImageNamed: 'test' to: 'test2'.	self assert: group imageNames asSet equals: #('test2') asSet.	! !!ManifestPharoLauncherTests class methodsFor: 'meta data'!rejectClasses^ #()! !!ManifestPharoLauncherTests class methodsFor: 'meta data'!rejectRules^ #()! !"PharoLauncher-Tests-Core"!!PhLTemplateGroupTestRepository commentStamp: '' prior: 0!TemplateGroupRepository used for test purposes.I override the default location of templates.!!PhLTestTemplatesPresenter commentStamp: '' prior: 0!A presenter for Pharo Launcher templates used for test purposes!!PhLTestLaunchConfiguration commentStamp: '' prior: 0!I'm used to simulate a launch of an image in Tests.I run a command (external process) that will run fast on the Operating System to keep tests running fast.!!PhLTestImagesPresenter commentStamp: '' prior: 0!A presenter for Pharo Launcher images used for test purposes!!PhLTestVirtualMachineManager commentStamp: '' prior: 0!Virtual Machine manager for test purposes.I mock network calls.!!PhLTestConfirmation commentStamp: '' prior: 0!Mock for a user confirmation interaction!!PhLTestRequest commentStamp: '' prior: 0!Mock for a user request interaction!!PhLTestVmPresenter commentStamp: '' prior: 0!A presenter for Pharo Launcher VMs used for test purposes!!PhLTemplateGroupTestRepository methodsFor: 'initialization'!initialize 	super initialize.	fileSystem := FileSystem memory.	localTemplateGroup := self newLocalTemplatesGroup.	remoteTemplatesGroup := self newRemoteTemplatesGroup.	self setGroups: { localTemplateGroup . remoteTemplatesGroup }.! !!PhLTemplateGroupTestRepository methodsFor: 'accessing'!localTemplatesGroup	^ localTemplateGroup! !!PhLTemplateGroupTestRepository methodsFor: 'accessing'!newLocalTemplatesGroup	^ PhLDownloadedTemplateGroup new 		baseDirectory: fileSystem root;		setName: 'Local test templates';		yourself! !!PhLTemplateGroupTestRepository methodsFor: 'accessing'!newRemoteTemplatesGroup	^ PhLFixedURLsTemplateGroup new 			setName: 'Remote test templates' Templates: OrderedCollection new;			yourself! !!PhLTemplateGroupTestRepository methodsFor: 'accessing'!remoteTemplatesGroup	^ remoteTemplatesGroup! !!PhLTestTemplatesPresenter methodsFor: 'user interaction'!clickOnCreateButton	self createButton click! !!PhLTestTemplatesPresenter methodsFor: 'private'!createButton	^ descriptionPanel instVarNamed: 'createButton'! !!PhLTestTemplatesPresenter methodsFor: 'accessing'!createButtonEnabled	^ self createButton isEnabled! !!PhLTestTemplatesPresenter methodsFor: 'configuring'!createLocalTemplateNamed: aName	| zipFile template |		zipFile := self localTemplatesGroup baseDirectory / (aName , '.zip').	template := PhLLocalTemplate name: aName zipFile: zipFile.	self localTemplatesGroup		register: template		withZip: zipFile.	self newZipArchive: zipFile.	self refresh.	^ template! !!PhLTestTemplatesPresenter methodsFor: 'configuring'!createRemoteTemplateNamed: aName	self remoteTemplatesGroup		addTemplate: (PhLRemoteTemplate name: aName url: 'http://', aName, '.foo').	self refresh.! !!PhLTestTemplatesPresenter methodsFor: 'api - accessing'!imageName	^ 'TestCreateImage'! !!PhLTestTemplatesPresenter methodsFor: 'api - accessing'!imageRepository	^ imageRepository ifNil: [ imageRepository := PhLDirectoryBasedImageRepository forDirectory: FileSystem memory root ]	! !!PhLTestTemplatesPresenter methodsFor: 'initialization'!initialize	self model: (PhLTemplateGroupTestRepository new).	self application: (PharoLauncherApplication new		scriptsDirectory: FileSystem memory root;		yourself).	request := PhLTestRequest new.	templates := OrderedCollection new.		super initialize.! !!PhLTestTemplatesPresenter methodsFor: 'accessing'!localTemplatesGroup	^ self templateRepository localTemplatesGroup! !!PhLTestTemplatesPresenter methodsFor: 'user interaction'!newConfirmation	^ PhLTestConfirmation new! !!PhLTestTemplatesPresenter methodsFor: 'user interaction'!newRequest	^ request! !!PhLTestTemplatesPresenter methodsFor: 'private'!newZipArchive: aFileReference	| archive |	archive := ZipArchive new.	archive		addDeflateString: 'foo' as: 'bar.image';		addDeflateString: 'foo' as: 'bar.changes'.	aFileReference		binaryWriteStreamDo: [ :stream | archive writeTo: stream ].! !!PhLTestTemplatesPresenter methodsFor: 'accessing'!remoteTemplatesGroup	^ self templateRepository remoteTemplatesGroup! !!PhLTestTemplatesPresenter methodsFor: 'configuring'!requestAnswer: answer	request answer: answer! !!PhLTestTemplatesPresenter methodsFor: 'configuring'!selectInitializationScript: anIndex	descriptionPanel selectInitializationScript: anIndex! !!PhLTestTemplatesPresenter methodsFor: 'configuring'!selectLocalGroup	self selectCategory: 1! !!PhLTestTemplatesPresenter methodsFor: 'configuring'!selectRemoteGroup	self selectCategory: 2! !!PhLTestTemplatesPresenter methodsFor: 'configuring'!selectTemplateNamed: aTemplateName	templateTable selectItem: (self templates detect: [ :each | each name = aTemplateName ])! !!PhLTestTemplatesPresenter methodsFor: 'accessing'!templateNames	^ self templates collect: #name! !!PhLTestTemplatesPresenter methodsFor: 'accessing'!templateRoots	^ templateTable roots! !!PhLTestTemplatesPresenter methodsFor: 'accessing'!templates	^ self localTemplatesGroup templatesAndGroups asOrderedCollection, self remoteTemplatesGroup templatesAndGroups! !!PhLTestLaunchConfiguration methodsFor: 'querying'!launchProcess	"dummy call, only requirement is that the command is available on supported Operating Systems."	^ PhLProcessWrapper new		  command: 'cd';		  yourself! !!PhLAboutCommandTest methodsFor: 'accessing'!application    ^ SpMockApplication new! !!PhLAboutCommandTest methodsFor: 'running'!tearDown	presenter window 		ifNotNil: [ :window | window close].	super tearDown! !!PhLAboutCommandTest methodsFor: 'tests'!testCanOpenAboutDialog	| command |	command := PhLAboutCommand forContext: self.		presenter := command execute.	self assert: (presenter description text includesSubstring: 'Pharo Launcher')! !!PhLCopyImageCommandTest methodsFor: 'running'!setUp	super setUp.	presenter := PhLTestImagesPresenter new! !!PhLCopyImageCommandTest methodsFor: 'tests'!testCanCopyImageLaunchCommand	| image config |	presenter selectImageAt: 1.	image := presenter singleImage.	config := image defaultLaunchConfiguration		          doNotUseSettings;		          yourself.	image launchConfigurations: { config }.	presenter 		selection: { image };		requestAnswer: 'foo'.		PhLCopyImageCommand new		context: presenter;		execute.			self assert: (presenter imageRepository hasImageNamed: 'foo').! !!PhLCopyLaunchCommandTest methodsFor: 'running'!setUp	super setUp.	presenter := PhLTestImagesPresenter new! !!PhLCopyLaunchCommandTest methodsFor: 'tests'!testCanCopyImageLaunchCommand	| image config commandString |	presenter selectImageAt: 1.	image := presenter singleImage.	config := image defaultLaunchConfiguration		          doNotUseSettings;		          yourself.	image launchConfigurations: { config }.	presenter selection: image.		PhLCopyLaunchCommand new		context: presenter;		execute.			commandString := Clipboard clipboardText asString.	self assert:		(commandString beginsWith: 'bash -c ''cd "/TestImage" && ').	self assert: (commandString endsWith:			 ' "/TestImage/TestImage.image" --no-default-preferences''')! !!PhLCopyPathnameCommandTest methodsFor: 'running'!setUp	super setUp.	presenter := PhLTestImagesPresenter new! !!PhLCopyPathnameCommandTest methodsFor: 'tests'!testCanCopyImagePathname	presenter selectImageAt: 1.	PhLCopyPathname new		context: presenter;		execute.		self		assertCollection: Clipboard clipboardText asString		equals: '"/TestImage/TestImage.image"'.! !!PhLCreateImageFromTemplateCommandTest methodsFor: 'helper'!createInitScriptNamed: aString 	presenter application scriptsDirectory / aString		writeStreamDo: [ :s | s nextPutAll: 'Transcript show: ''init done!!''' ].	presenter refreshInitializationScriptList.! !!PhLCreateImageFromTemplateCommandTest methodsFor: 'running'!setUp	super setUp.	presenter := PhLTestTemplatesPresenter new! !!PhLCreateImageFromTemplateCommandTest methodsFor: 'tests'!testCanCreateAnImageWhenSingleTemplateSelected	| command images |	command := PhLCreateImageFromTemplateCommand new.	command context: presenter.	presenter 		createLocalTemplateNamed: 'Foo';		selectCategory: 1;		selectTemplateNamed: 'Foo'.			command execute.		images := presenter imageRepository imageNames.	self 		assert: images size 		equals: 1.	self 		assertCollection: images		hasSameElements: #('TestCreateImage').! !!PhLCreateImageFromTemplateCommandTest methodsFor: 'tests'!testCanCreateAnImageWithAnInitializationScript	| command image |	command := PhLCreateImageFromTemplateCommand new.	command context: presenter.	self createInitScriptNamed: 'foo-init.st'.		presenter 		createLocalTemplateNamed: 'Foo';		selectCategory: 1;		selectTemplateNamed: 'Foo';		selectInitializationScript: 2.			image := command execute.		self		assert: image initializationScript basename		equals: 'foo-init.st'.			self assert: image shouldRunInitializationScript.! !!PhLCreateImageFromTemplateCommandTest methodsFor: 'tests'!testCannotCreateAnImageWhenManyTemplatesSelected	| command |	command := PhLCreateImageFromTemplateCommand new.	command context: presenter.	presenter 		createLocalTemplateNamed: 'Foo';		createLocalTemplateNamed: 'Bar';		selectTemplateNamed: 'Foo';		selectTemplateNamed: 'Bar'.			self 		should: [ command execute ]		raise: PhLCommandError! !!PhLCreateImageFromTemplateCommandTest methodsFor: 'tests'!testCannotCreateAnImageWhenNoTemplateSelected	| command |	command := PhLCreateImageFromTemplateCommand new.	command context: presenter.	self		should: [ command execute ]		raise: PhLCommandError! !!PhLCreateTemplateFromImageCommandTest methodsFor: 'running'!setUp	super setUp.	presenter := PhLTestImagesPresenter new! !!PhLCreateTemplateFromImageCommandTest methodsFor: 'tests'!testCanCreateATemplateAndRemoveImageWhenSingleImageSelected	| command templates |	command := PhLCreateTemplateFromImageCommand new		willRemoveImage;		yourself.	command context: presenter.	presenter		selectImageAt: 1;		requestAnswer: 'TestTemplate'.	self assertEmpty: presenter templateRepository localTemplates.	self assert: (presenter imageRepository hasImageNamed: 'TestImage').	command execute.	templates := presenter templateRepository localTemplateNames.	self assert: templates size equals: 1.	self assertCollection: templates hasSameElements: #('TestTemplate').	self deny: (presenter imageRepository hasImageNamed: 'TestImage')! !!PhLCreateTemplateFromImageCommandTest methodsFor: 'tests'!testCanCreateATemplateWhenSingleImageSelected	| command templates |	command := PhLCreateTemplateFromImageCommand new.	command context: presenter.	presenter		selectImageAt: 1;		requestAnswer: 'TestTemplate'.	self assertEmpty: presenter templateRepository localTemplates.	command execute.	templates := presenter templateRepository localTemplateNames.	self assert: templates size equals: 1.	self assertCollection: templates hasSameElements: #('TestTemplate')! !!PhLDeleteImageCommandTest methodsFor: 'as yet unclassified'!createMoreImagesAndEnableSorting	presenter createImageNamed: 'Zoo'.	presenter createImageNamed: 'Abc'.	presenter application imageRepositoryChanged.	presenter		open;		selectImageAt: 1.	presenter		clickOnColumnHeaderAt: 1;		selectImageAt: 3 "Zoo"! !!PhLDeleteImageCommandTest methodsFor: 'running'!setUp	super setUp.	presenter := PhLTestImagesPresenter new! !!PhLDeleteImageCommandTest methodsFor: 'running'!tearDown	presenter delete.	super tearDown! !!PhLDeleteImageCommandTest methodsFor: 'tests'!testCanDeleteAnImage	| command images |	command := PhLDeleteImageCommand new.	command context: presenter.	presenter 		createImageNamed: 'Foo';		selectImageAt: 1.			command execute.		images := command imagesPresenter imageNames.	self		assertCollection: images		hasSameElements: #('Foo').! !!PhLDeleteImageCommandTest methodsFor: 'tests'!testDeleteTheRightImageIfImagesSortingIsNotTheDefaultOne	| command images |	command := PhLDeleteImageCommand new.	command context: presenter.	self createMoreImagesAndEnableSorting. "xx image is selected"	command execute.	images := command imagesPresenter imageNames.	self deny: (images includes: 'Zoo')! !!PhLDeleteImageCommandTest methodsFor: 'tests'!testImagesPresenterIsRefreshedWhenImageDeleted	| command images |	command := PhLDeleteImageCommand new.	command context: presenter.	presenter		open;		selectImageAt: 1.	command execute.	images := command imagesPresenter imageNames.	self		assertEmpty: images;		assert: (presenter imageLabel beginsWith: 'No image selected')! !!PhLDeleteVmCommandTest methodsFor: 'running'!setUp	super setUp.	presenter := PhLTestVmPresenter new! !!PhLDeleteVmCommandTest methodsFor: 'running'!tearDown	PhLTestVirtualMachineManager reset.	"reset vm store to use for tests"	super tearDown! !!PhLDeleteVmCommandTest methodsFor: 'tests'!testCanDeleteAPrivateVM	| command vms |			command := PhLDeleteVmCommand new.	command context: presenter.	presenter 		showPrivateVms;		createVmNamed: 'Bar' private: true;		selection: { presenter vmFor: 'Bar' private: true }.		command execute.		vms := command vmsPresenter vmNames.	self		assertCollection: vms		hasSameElements: #().! !!PhLDeleteVmCommandTest methodsFor: 'tests'!testCanDeleteAVM	| command vms |	command := PhLDeleteVmCommand new.	command context: presenter.	presenter createVmNamed: 'Foo'.		command execute.		vms := command vmsPresenter vmNames.	self		assertCollection: vms		hasSameElements: #('Foo').! !!PhLDeleteVmCommandTest methodsFor: 'tests'!testCanDeleteManyPrivateVms	| command vms |			command := PhLDeleteVmCommand new.	command context: presenter.	presenter 		showPrivateVms;		createVmNamed: 'Foo' private: true;		createVmNamed: 'Bar' private: true;		createVmNamed: 'Zee' private: true;		selection: { presenter vmFor: 'Foo' private: true .						presenter vmFor: 'Bar' private: true }.		command execute.		vms := command vmsPresenter vmNames.	self		assertCollection: vms		hasSameElements: #('Zee').! !!PhLDeleteVmCommandTest methodsFor: 'tests'!testCanDeleteManyVms	| command vms |			command := PhLDeleteVmCommand new.	command context: presenter.	presenter createVmNamed: 'Foo'.	vms := {presenter singleVmName . 'Foo'}		collect: [:each | presenter vmFor: each private: false ].	presenter selection: vms.		command execute.		vms := command vmsPresenter vmNames.	self		assertCollection: vms		hasSameElements: #().! !!PhLImportImageCommandTest methodsFor: 'running'!setUp	super setUp.	presenter := PhLTestImagesPresenter new! !!PhLImportImageCommandTest methodsFor: 'tests'!testCanImportAnImage	| command images |	command := PhLImportImageCommand new.	command context: presenter.	presenter 		createImageNamed: 'foo' in: presenter fileSystem / 'tmp';		requestAnswer: presenter fileSystem / 'tmp' / 'foo.image'.		command execute.		images := presenter imageRepository imageNames.	self 		assert: images size 		equals: 2.	self 		assertCollection: images		hasSameElements: #('TestImage' 'foo').! !!PhLImportImageCommandTest methodsFor: 'tests'!testImportImageImportsImageSourcesFile	| command importedImageName tmpDirectory importedImageDirectory sourcesFileName |		importedImageName := 'foo'.	tmpDirectory := presenter fileSystem / 'tmp'.	sourcesFileName := 'ae2b.sources'.	command := PhLImportImageCommand new.	command context: presenter.	presenter 		createImageNamed: 'foo' in: tmpDirectory;		requestAnswer: tmpDirectory / importedImageName , 'image'.	(tmpDirectory / sourcesFileName) ensureCreateFile.		command execute.		importedImageDirectory := presenter imageRepository directoryForImageNamed: importedImageName.	self assert: (importedImageDirectory / sourcesFileName) exists! !!PhLImportImageCommandTest methodsFor: 'tests'!testImportImageImportsImageVersionFile	| command importedImageName tmpDirectory importedImageDirectory |		importedImageName := 'foo'.	tmpDirectory := presenter fileSystem / 'tmp'.	command := PhLImportImageCommand new.	command context: presenter.	presenter 		createImageNamed: 'foo' in: tmpDirectory;		requestAnswer: tmpDirectory / importedImageName , 'image'.	(tmpDirectory / PhLImage versionFileName) ensureCreateFile.		command execute.		importedImageDirectory := presenter imageRepository directoryForImageNamed: importedImageName.	self assert: (importedImageDirectory / PhLImage versionFileName) exists! !!PhLImportImageCommandTest methodsFor: 'tests'!testImportNonExistingImage	| command |	command := PhLImportImageCommand new.	command context: presenter.	presenter := presenter requestAnswer:		             presenter fileSystem / 'tmp' / 'does_not_exists.image'.	self 		should: [ command execute ]		raise: FileDoesNotExistException! !!PhLLaunchImageCommandTest methodsFor: 'helper'!addInitializationScriptToImage	image initializationScript: self initScript! !!PhLLaunchImageCommandTest methodsFor: 'helper'!initScript	^ FileSystem memory root / 'foo.st'! !!PhLLaunchImageCommandTest methodsFor: 'helper'!launchImage	self selectImage.	process ifNotNil: [ self error: 'Currently one execution of image per test case.' ].	process := runCommand execute! !!PhLLaunchImageCommandTest methodsFor: 'helper'!recreateImage	recreateCommand execute.	self selectImage.	^ presenter selectedImages anyOne! !!PhLLaunchImageCommandTest methodsFor: 'helper'!selectImage	presenter		unselectAll;		selectImageAt: 1! !!PhLLaunchImageCommandTest methodsFor: 'running'!setUp	super setUp.	presenter := PhLTestImagesPresenter new.	imageDir := FileLocator temp / 'pharo-launcher-tests-launch-image-command' , UUIDGenerator next asString.	imageDir ensureCreateDirectory.		runCommand := PhLLaunchImageCommand new.	runCommand context: presenter.	recreateCommand := PhLRecreateImageCommand new.	recreateCommand context: presenter.		image := presenter singleImage.	image versionFile 		writeStreamDo: [ :stream | 			SystemVersion current major asString putOn: stream.			SystemVersion current minor asString putOn: stream ].	image 		originTemplate: (PhLTestTemplatesPresenter new createLocalTemplateNamed: 'testTemplate');		launchConfigurations: { PhLTestLaunchConfiguration withImage: image }.! !!PhLLaunchImageCommandTest methodsFor: 'running'!tearDown	imageDir ensureDeleteAll.	(process isNotNil and: [ process isRunning ]) 		ifTrue: [ process terminate ].	super tearDown! !!PhLLaunchImageCommandTest methodsFor: 'tests'!testAttachingAnInitializationScriptIsOk		self addInitializationScriptToImage.		self assert: image initializationScript isNotNil! !!PhLLaunchImageCommandTest methodsFor: 'tests'!testAttachingInitializationScriptSetFlagToShouldRun	self addInitializationScriptToImage.		self assert: image shouldRunInitializationScript.! !!PhLLaunchImageCommandTest methodsFor: 'tests'!testCanLaunchImage	FileLocator image copyTo: imageDir / FileLocator image basename.	image := PhLImage location: imageDir / FileLocator image basename.	image versionFile 		writeStreamDo: [ :stream | 			SystemVersion current major asString putOn: stream.			SystemVersion current minor asString putOn: stream ].			presenter 		unselectAll;		selection: { image }.	image addLaunchConfiguration: 		(image defaultLaunchConfiguration 			vmArguments: #('--headless');  "be able to run test without X session"			imageArguments: #('--no-quit');			yourself).			process := runCommand execute.	2 seconds wait. "let time to the image to be opened by the VM"		self assert: process isRunning.! !!PhLLaunchImageCommandTest methodsFor: 'tests'!testExecutingImageWithScriptShouldSetFlagToShouldNotRun	self addInitializationScriptToImage.	self launchImage.		self deny: image shouldRunInitializationScript.! !!PhLLaunchImageCommandTest methodsFor: 'tests'!testRecreateAnImageWithoutOpeningItShouldStillExecuteScript	| recreatedImage |	self addInitializationScriptToImage.	recreatedImage := self recreateImage.		self assert: recreatedImage shouldRunInitializationScript.! !!PhLLaunchImageCommandTest methodsFor: 'tests'!testRecreateAnOpenedImageShouldStillExecuteScript	| recreatedImage |	self addInitializationScriptToImage.	self launchImage.	recreatedImage := self recreateImage.		self assert: recreatedImage shouldRunInitializationScript! !!PhLLaunchImageCommandTest methodsFor: 'tests'!testRunningAnImageRemovesTheInitializationScript	self addInitializationScriptToImage.	image := self recreateImage.		self assert: image initializationScript path equals: self initScript path! !!PhLLaunchImageFromDiskCommandTest methodsFor: 'running'!setUp	super setUp.	presenter := PhLTestImagesPresenter new.	imageDir := FileLocator temp / 'pharo-launcher-tests-launch-image-from-disk-command' , UUIDGenerator next asString.	imageDir ensureCreateDirectory! !!PhLLaunchImageFromDiskCommandTest methodsFor: 'running'!tearDown	imageDir ensureDeleteAll.	presenter delete.	(process isNotNil and: [ process isRunning ]) ifTrue: [ process terminate ].	super tearDown! !!PhLLaunchImageFromDiskCommandTest methodsFor: 'tests'!testCanLaunchImageFromDisk	| command image |	command := PhLLaunchImageFromDiskCommand new.	command context: presenter.	FileLocator image copyTo: imageDir / FileLocator image basename.	image := PhLImage location: imageDir / FileLocator image basename.	image versionFile 		writeStreamDo: [ :stream | 			SystemVersion current major asString putOn: stream.			SystemVersion current minor asString putOn: stream ].	presenter requestAnswer: image file.	presenter open.	image addLaunchConfiguration: 		(image defaultLaunchConfiguration 			vmArguments: #('--headless');  "be able to run test without X session"			imageArguments: #('--no-quit');			yourself).	process := command launchImage: image. "allow to specify arguments to the default configuration for test purposes"	2 seconds wait. "let time to the image to be opened by the VM"		self assert: process isRunning.! !!PhLOpenNewImageWindowTest methodsFor: 'running'!setUp	| imagesDirectory app repository |	super setUp.	fs := FileSystem memory.	imagesDirectory := (fs root / 'images') ensureCreateDirectory.	repository := PhLDirectoryBasedImageRepository forDirectory: imagesDirectory.	app := PharoLauncherApplication new		imageRepository: repository;		yourself.	imagesPresenter := PhLImagesPresenter newApplication: app model: repository! !!PhLOpenNewImageWindowTest methodsFor: 'running'!tearDown	presenter ifNotNil: [ presenter window close ].	super tearDown! !!PhLOpenNewImageWindowTest methodsFor: 'tests'!testOfficialTemplatesCategoryIsSelectedWhenOpeningPresenter	presenter := PhLOpenNewImageWindowCommand new 		context: imagesPresenter;		execute.	self 		assert: presenter selectedTemplateCategory name		equals: 'Official distributions'! !!PhLOpenNewImageWindowTest methodsFor: 'tests'!testTemplatesPresenterOpenWhenClickingOnNewImage	presenter := PhLOpenNewImageWindowCommand new 		context: imagesPresenter;		execute.	self 		assert: presenter className		equals: #PhLTemplatesPresenter.! !!PhLOpenSettingsCommandTest methodsFor: 'running'!tearDown	settingsBrowser ifNotNil: [ settingsBrowser close ].	super tearDown! !!PhLOpenSettingsCommandTest methodsFor: 'tests'!testCanOpenSettingsBrowser	settingsBrowser := PhLOpenSettingsCommand new execute.	self assert: (settingsBrowser model isKindOf: PhLSettingBrowser)! !!PhLRecreateImageCommandTest methodsFor: 'running'!setUp	super setUp.	presenter := PhLTestImagesPresenter new! !!PhLRecreateImageCommandTest methodsFor: 'tests'!testCanRecreateAnImage	| command images archive zipFile image |	command := PhLRecreateImageCommand new.	command context: presenter.	presenter selectImageAt: 1.	images := presenter selectedImages.	archive := ZipArchive new.	archive addDeflateString: 'foo' as: 'bar.image'.	archive addDeflateString: 'foo' as: 'bar.changes'.	zipFile := presenter fileSystem / 'template.zip'. 	zipFile binaryWriteStreamDo: [ :stream | archive writeTo: stream ].	images do: [ :img | img originTemplate: (PhLLocalTemplate name: 'Foo test template' zipFile: zipFile)].	presenter selection: images.		command execute.		images := command imagesPresenter imageNames.	self		assertCollection: images		hasSameElements: #('TestImage').	image := presenter fileSystem / 'TestImage' /'TestImage.image'.	self assert: image exists.	self assert: image contents equals: 'foo'.! !!PhLRecreateImageCommandTest methodsFor: 'tests'!testErrorRaiseWhenImageTemplateNotSet	| command |	command := PhLRecreateImageCommand new.	command context: presenter.	presenter selectImageAt: 1.		self		should: [ command execute ]		raise: PhLError 		! !!PhLRefreshImagerepositoryCommandTest methodsFor: 'running'!setUp	super setUp.	presenter := PhLTestImagesPresenter new! !!PhLRefreshImagerepositoryCommandTest methodsFor: 'tests'!testCanRefreshImageList	| command images |	command := PhLRefreshImageRepositoryCommand new.	command context: presenter.	images := presenter imageRepository imageNames.	presenter createImageNamed: 'Foo'.		command execute.		self 		assertCollection: presenter imageNames		hasSameElements: (images copyWith: 'Foo').	! !!PhLRemoveTemplateCommandTest methodsFor: 'accessing'!removeTemplateMenuItem	| menu menuItems |	menu := (presenter rootCommandsGroup / 'Context Menu')		asMenuPresenter.	menuItems := menu menuGroups flatCollect: #menuItems.	^ menuItems detect: [ :item | item name = 'Remove template' ]! !!PhLRemoveTemplateCommandTest methodsFor: 'running'!setUp	super setUp.	presenter := PhLTestTemplatesPresenter new.	presenter selectLocalGroup! !!PhLRemoveTemplateCommandTest methodsFor: 'tests'!testCanRemoveALocalTemplate	| command |	command := PhLRemoveTemplateCommand new.	command context: presenter.	presenter		createLocalTemplateNamed: 'Foo';		selectTemplateNamed: 'Foo'.	command execute.	self assertCollection: presenter templateNames hasSameElements: #().	self assertEmpty: presenter templateRoots! !!PhLRemoveTemplateCommandTest methodsFor: 'tests'!testCanRemoveManyLocalTemplates	| command |	command := PhLRemoveTemplateCommand new.	command context: presenter.	presenter		createLocalTemplateNamed: 'Foo';		createLocalTemplateNamed: 'Bar';		createLocalTemplateNamed: 'Zee';		selectTemplateNamed: 'Foo';		selectTemplateNamed: 'Bar'.			command execute.		self 		assertCollection: presenter templateNames		hasSameElements: #('Zee').			self 		assertCollection: (presenter templateRoots collect: #name)		hasSameElements: #('Zee').! !!PhLRemoveTemplateCommandTest methodsFor: 'tests'!testCommandAvailableWhenThereIsALocalTemplateSelected	| command |	command := PhLRemoveTemplateCommand new.	command context: presenter.	presenter		createLocalTemplateNamed: 'Foo';		selectTemplateNamed: 'Foo'.		self assert: self removeTemplateMenuItem isEnabled! !!PhLRemoveTemplateCommandTest methodsFor: 'tests'!testCommandHasNoEffectWhenNoTemplateSelected	| command |	command := PhLRemoveTemplateCommand new.	command context: presenter.	presenter createLocalTemplateNamed: 'Foo'. 	command execute.		self 		assertCollection: presenter templateNames		hasSameElements: #( #Foo )! !!PhLRemoveTemplateCommandTest methodsFor: 'tests'!testCommandNotAvailableWhenThereIsARemoteTemplateSelected	| command |	command := PhLRemoveTemplateCommand new.	command context: presenter.	presenter	 	createRemoteTemplateNamed: 'Foo';		selectRemoteGroup;		selectTemplateNamed: 'Foo'. 	 	self deny: self removeTemplateMenuItem isEnabled! !!PhLRemoveTemplateCommandTest methodsFor: 'tests'!testCommandNotAvailableWhenThereIsNoTemplateSelected	| command |	command := PhLRemoveTemplateCommand new.	command context: presenter.	 	self deny: self removeTemplateMenuItem isEnabled! !!PhLRenameImageCommandTest methodsFor: 'running'!setUp	super setUp.	presenter := PhLTestImagesPresenter new! !!PhLRenameImageCommandTest methodsFor: 'tests'!testCanRenameAnImage	| command images |	command := PhLRenameImageCommand new.	presenter 		selectImageAt: 1;		requestAnswer: 'TestRenameImage'.	command context: presenter.	command execute.		images := command imagesPresenter imageNames.		self		assertCollection: images		hasSameElements: #('TestRenameImage').! !!PhLRenameImageCommandTest methodsFor: 'tests'!testCannotRenameAnImageWithAnExistingName	| command images |	command := PhLRenameImageCommand new.	presenter requestAnswer: 'TestImage'.	command context: presenter.	command execute.		images := command imagesPresenter imageNames.		self		assertCollection: images		hasSameElements: #('TestImage')! !!PhLRenameTemplateCommandTest methodsFor: 'as yet unclassified'!renameTemplateMenuItem	| menu menuItems |	menu := (presenter rootCommandsGroup / 'Context Menu')		asMenuPresenter.	menuItems := menu menuGroups flatCollect: #menuItems.	^ menuItems detect: [ :item | item name = 'Rename template' ]! !!PhLRenameTemplateCommandTest methodsFor: 'running'!setUp	super setUp.	presenter := PhLTestTemplatesPresenter new.	presenter selectLocalGroup! !!PhLRenameTemplateCommandTest methodsFor: 'tests'!testCanRenameALocalTemplate	| command |	command := PhLRenameTemplateCommand new.	command context: presenter.	presenter		createLocalTemplateNamed: 'Foo';		selectTemplateNamed: 'Foo';		requestAnswer: 'Bar'.			command execute.		self 		assertCollection: presenter templateNames		hasSameElements: #(Bar).			self 		assert: presenter templateRoots size		equals: 1.! !!PhLRenameTemplateCommandTest methodsFor: 'tests'!testCommandAvailableWhenThereIsALocalTemplateSelected	| command |	command := PhLRenameTemplateCommand new.	command context: presenter.	presenter		createLocalTemplateNamed: 'Foo';		selectTemplateNamed: 'Foo'.		self assert: self renameTemplateMenuItem isEnabled! !!PhLRenameTemplateCommandTest methodsFor: 'tests'!testCommandHasNoEffectWhenNoTemplateSelected	| command |	command := PhLRenameTemplateCommand new.	command context: presenter.	presenter createLocalTemplateNamed: 'Foo'. 	self		should: [ command execute ]		raise: PhLCommandError.		self 		assertCollection: presenter templateNames		hasSameElements: #( #Foo )! !!PhLRenameTemplateCommandTest methodsFor: 'tests'!testCommandNotAvailableWhenThereIsARemoteTemplateSelected	| command |	command := PhLRenameTemplateCommand new.	command context: presenter.	presenter	 	createRemoteTemplateNamed: 'Foo';		selectRemoteGroup;		selectTemplateNamed: 'Foo'. 	 	self deny: self renameTemplateMenuItem isEnabled! !!PhLRenameTemplateCommandTest methodsFor: 'tests'!testCommandNotAvailableWhenThereIsNoTemplateSelected	| command |	command := PhLRenameTemplateCommand new.	command context: presenter.	 	self deny: self renameTemplateMenuItem isEnabled! !!PhLShowImageInFolderCommandTest methodsFor: 'tests'!testCommandRaisesCommandErrorIfNoImageSelected	| command |	presenter := PhLTestImagesPresenter new.	presenter unselectAll.	command := PhLShowImageInFolderCommand new.	command context: presenter.	self		should: [ command execute ]		raise: PhLCommandError! !!PhLToggleVmPrivateVmCommandTest methodsFor: 'running'!setUp	super setUp.	presenter := PhLTestVmPresenter new! !!PhLToggleVmPrivateVmCommandTest methodsFor: 'running'!tearDown	PhLTestVirtualMachineManager reset.	super tearDown! !!PhLToggleVmPrivateVmCommandTest methodsFor: 'tests'!testPrivateVmsShownWhenButtonToggledOnce	| command vms |	command := PhLToggleVmPrivateVmCommand new.	command context: presenter.	presenter createVmNamed: 'PrivateTestVM' private: true.		command execute.		vms := command vmsPresenter vmNames.	self		assertCollection: vms		hasSameElements: #('PrivateTestVM').! !!PhLToggleVmPrivateVmCommandTest methodsFor: 'tests'!testVmsShownAtStartup	| command vms |	command := PhLToggleVmPrivateVmCommand new.	command context: presenter.	presenter createVmNamed: 'PrivateTestVM' private: true.		"NOOP we are testing the initial state"		vms := command vmsPresenter vmNames.	self		assertCollection: vms		hasSameElements: {presenter singleVmName}.! !!PhLToggleVmPrivateVmCommandTest methodsFor: 'tests'!testVmsShownWhenButtonToggledTwice	| command vms |	command := PhLToggleVmPrivateVmCommand new.	command context: presenter.	presenter createVmNamed: 'Foo'.	presenter createVmNamed: 'PrivateTestVM' private: true.		command		execute;		execute.		vms := command vmsPresenter vmNames.	self		assertCollection: vms		hasSameElements: {presenter singleVmName . 'Foo'}.! !!PhLUpdateVmCommandTest methodsFor: 'running'!setUp	super setUp.	presenter := PhLTestVmPresenter new! !!PhLUpdateVmCommandTest methodsFor: 'running'!tearDown	PhLTestVirtualMachineManager reset.	super tearDown! !!PhLUpdateVmCommandTest methodsFor: 'tests'!testCanUpdateManyPrivateVms	| command vms vmFolderEntries |	command := PhLUpdateVmCommand new.	command context: presenter.	presenter 		showPrivateVms;		createVmNamed: '6504' private: true;		createVmNamed: '68021' private: true;		selection: { 			presenter vmFor: '6504' private: true .			presenter vmFor: '68021' private: true }.		command execute.		vms := presenter vmNames.	self		assertCollection: vms		hasSameElements: #('68021' '6504').	vmFolderEntries := (presenter selectedVms first vmStore / '68021') entries.	self 		assertCollection: (vmFolderEntries collect: #name)		hasSameElements: #('pharo' 'Pharo.app' 'fetched!!').! !!PhLUpdateVmCommandTest methodsFor: 'tests'!testCanUpdateManyVms	| command fooVmName vms vmFolderEntries |	command := PhLUpdateVmCommand new.	command context: presenter.	fooVmName := '90-Foo'.	presenter createVmNamed: fooVmName.	vms := {fooVmName . presenter singleVmName}		collect: [:each | presenter vmFor: each private: false ].	presenter selection: vms.		command execute.		vms := presenter vmNames.	self		assertCollection: vms		hasSameElements: {fooVmName . presenter singleVmName}.	presenter selectedVms do: [ :vm |		vmFolderEntries := (vm vmStore / vm name) entries.		self 			assertCollection: (vmFolderEntries collect: #name)			hasSameElements: #('pharo' 'Pharo.app' 'fetched!!'). ]! !!PhLUpdateVmCommandTest methodsFor: 'tests'!testCanUpdateOneVm	| command vms vmFolderEntries |	command := PhLUpdateVmCommand new.	command context: presenter.		command execute.		vms := presenter vmNames.	self		assertCollection: vms		hasSameElements: { presenter singleVmName }.	vmFolderEntries := (presenter selectedVms first vmStore / presenter singleVmName) entries.	self 		assertCollection: (vmFolderEntries collect: #name)		hasSameElements: #('pharo' 'Pharo.app' 'fetched!!').! !!PhLTestImagesPresenter methodsFor: 'sorting'!clickOnColumnHeaderAt: anIndex	imageTable clickOnColumnHeaderAt: anIndex! !!PhLTestImagesPresenter methodsFor: 'configuring'!createImageNamed: aName	^ self createImageNamed: aName in:  (fileSystem root / aName)! !!PhLTestImagesPresenter methodsFor: 'configuring'!createImageNamed: aName in: aFolder	| imageFile |	imageFile := aFolder / (aName , '.image').	aFolder ensureCreateDirectory.	imageFile binaryWriteStreamDo: [:stream | stream nextPutAll: #(105 25 0 0)].	(aFolder / (aName , '.changes')) ensureCreateFile.	(aFolder / PhLImage versionFileName) writeStreamDo: [ :stream | stream nextPutAll: '70' ].	^ imageFile! !!PhLTestImagesPresenter methodsFor: 'private'!fileSystem	^ fileSystem! !!PhLTestImagesPresenter methodsFor: 'api - selection'!hasSingleImageSelected	^ super hasSingleImageSelected or: [ selection notNil ]! !!PhLTestImagesPresenter methodsFor: 'acccessing'!imageLabel	^ descriptionPanel imageLabel label! !!PhLTestImagesPresenter methodsFor: 'acccessing'!imageNames	^ imageTable items collect: #name! !!PhLTestImagesPresenter methodsFor: 'initialization'!initialize	fileSystem := FileSystem memory.	self model: (PhLDirectoryBasedImageRepository forDirectory: fileSystem root).	templateRepository := PhLTemplateGroupTestRepository new.	self application: (PharoLauncherApplication new		imageRepository: self model;		instVarNamed: 'imagesPresenter' put: self;		yourself).	self createImageNamed: self singleImageName.	super initialize.	self createImageNamed: self singleImageName.	request := PhLTestRequest new.! !!PhLTestImagesPresenter methodsFor: 'acccessing'!launchConfigurations	^ launchConfigurationList listItems allButFirst! !!PhLTestImagesPresenter methodsFor: 'user interaction'!newConfirmation	^ PhLTestConfirmation new! !!PhLTestImagesPresenter methodsFor: 'user interaction'!newFileRequest	^ request! !!PhLTestImagesPresenter methodsFor: 'user interaction'!newInformation	self flag: 'TODO: spec should offer a way to open the inform dialog and accept it.'.	^ PhLTestConfirmation new! !!PhLTestImagesPresenter methodsFor: 'user interaction'!newRequest	^ request! !!PhLTestImagesPresenter methodsFor: 'updating'!refreshLaunchConfigurationList	launchConfigurationList ifNotNil: [ super refreshLaunchConfigurationList ]! !!PhLTestImagesPresenter methodsFor: 'configuring'!requestAnswer: answer	request answer: answer! !!PhLTestImagesPresenter methodsFor: 'selection'!selectedLaunchConfiguration	^ launchConfigurationList 		ifNil: [ self singleImage defaultLaunchConfiguration ]		ifNotNil: [ launchConfigurationList selectedItem  ifNil: [ self singleImage defaultLaunchConfiguration ] ]! !!PhLTestImagesPresenter methodsFor: 'configuring'!selection: aListOfImages	selection := aListOfImages! !!PhLTestImagesPresenter methodsFor: 'configuring'!selectionNames: aListOfImageNames	selection := aListOfImageNames collect: [ :name | PhLImage location: fileSystem root / name ].! !!PhLTestImagesPresenter methodsFor: 'api - accessing'!singleImage 	^ [ super singleImage ]		on: SubscriptOutOfBounds "no selection in real presenter"		do: [ :error |			 selection 				ifNil: [ error pass ]				ifNotNil: [ selection first ] ]! !!PhLTestImagesPresenter methodsFor: 'selection'!singleImageName	^ 'TestImage'! !!PhLTestImagesPresenter methodsFor: 'api - accessing'!templateRepository 	^ templateRepository! !!PhLTestImagesPresenter methodsFor: 'selecting'!unselectAll	imageTable unselectAll.! !!PhLTestVirtualMachineManager class methodsFor: 'private'!fetch: aVmUrl to: targetFile	| vmFolder |	vmFolder := targetFile parent / targetFile basenameWithoutExtension.	vmFolder ensureCreateDirectory.	(vmFolder / 'fetched!!') ensureCreateFile.! !!PhLTestVirtualMachineManager class methodsFor: 'private'!vmStore	^ vmStore ifNil: [ vmStore := FileSystem memory root ]! !!PhLTestConfirmation methodsFor: 'action'!confirm	^ true! !!PhLTestConfirmation methodsFor: 'action'!inform	self noop ! !!PhLTestConfirmation methodsFor: 'accessing'!message: aString 	self noop! !!PhLTestConfirmation methodsFor: 'private'!noop	"nothing to do"! !!PhLTestConfirmation methodsFor: 'accessing'!parentWindow: aWindowPresenter 	"no need to keep the parent"! !!PhLTestRequest methodsFor: 'accessing'!answer	^ answer! !!PhLTestRequest methodsFor: 'accessing'!answer: anObject	answer := anObject! !!PhLTestRequest methodsFor: 'accessing'!chooseFile	^ answer! !!PhLTestRequest methodsFor: 'accessing'!chooseFrom: aCollection 	^ 1! !!PhLTestRequest methodsFor: 'noop'!extensionsToShow: aCollection 	"noop"! !!PhLTestRequest methodsFor: 'accessing'!initialAnswer: aString 	self noop! !!PhLTestRequest methodsFor: 'private'!noop	"do nothing"! !!PhLTestRequest methodsFor: 'accessing'!parentWindow: aWindowPresenter 	"no need to keep the parent"! !!PhLTestRequest methodsFor: 'noop'!path: aFileLocator 	"noop"! !!PhLTestRequest methodsFor: 'accessing'!request	^ (validationBlock value: self answer)		ifTrue: [ self answer ]		ifFalse: [ nil ]! !!PhLTestRequest methodsFor: 'accessing'!title: aString 	self noop! !!PhLTestRequest methodsFor: 'accessing'!validateAnswer: aBlock	validationBlock := aBlock! !!PhLTestVmPresenter methodsFor: 'adding'!createVmNamed: aName	self createVmNamed: aName private: false! !!PhLTestVmPresenter methodsFor: 'adding'!createVmNamed: aName private: isPrivateVm	| vmDirectory appDir root |	root := isPrivateVm 		ifTrue: [ vmStoreRoot / 'private' ] 		ifFalse: [ vmStoreRoot ].	vmDirectory := root / aName.	vmDirectory ensureCreateDirectory.	"needed on OS X"	appDir := (vmDirectory / 'Pharo.app') ensureCreateDirectory.	(appDir / 'Pharo') ensureCreateFile.	"needed on Linux"	(vmDirectory / 'pharo') binaryWriteStreamDo: [ :stream | stream nextPutAll: PhLVirtualMachine elfMagicNumber ].	 ! !!PhLTestVmPresenter methodsFor: 'initialization'!initialize	| datasource |	vmManager := PhLTestVirtualMachineManager new.	vmStoreRoot := vmManager vmStore.	(vmStoreRoot / 'private') ensureCreateDirectory.	datasource := PhLVirtualMachinesDataSource		vmsBlock:			[ vmStoreRoot directoryNames reject: [ :name | name = 'private' ] ]		privateVmsBlock: [ (vmStoreRoot / 'private') directoryNames ].	self model: datasource.	self createVmNamed: self singleVmName.	super initialize! !!PhLTestVmPresenter methodsFor: 'user interaction'!newConfirmation	^ PhLTestConfirmation new! !!PhLTestVmPresenter methodsFor: 'accessing'!selectedVms	^ selection 		ifNotNil: [ selection ]		ifNil: [ { self vmFor: self singleVmName private: false } ]! !!PhLTestVmPresenter methodsFor: 'configuring'!selection: aListOfVms	selection := aListOfVms! !!PhLTestVmPresenter methodsFor: 'initialization'!singleVmName	^ '80-TestVM'! !!PhLTestVmPresenter methodsFor: 'private'!vmFor: aName private: isPrivateVm	| root vm |	root := isPrivateVm 		ifTrue: [ vmStoreRoot / 'private' ] 		ifFalse: [ vmStoreRoot ].	vm := PhLVirtualMachine		directory: root / aName		private: isPrivateVm.	vm manager: PhLTestVirtualMachineManager new.	^ vm! !!PhLTestVmPresenter methodsFor: 'querying'!vmNames	^ shouldShowPrivateVms 		ifTrue:[ self datasource privateVirtualMachines ]		ifFalse: [ self datasource virtualMachines ]! !"PharoLauncher-Tests-Commands"!!PhLErrorDialogPresenter commentStamp: '' prior: 0!A small presenter to catch errors and present them nicely to the user.I provide an acknowledge button ('ok') and a debug button that will open the Pharo debugger.To use me, install me as the default debugger tool.I use GTGenericStackDebugger debugger as default.To try me:currentDebugger := Smalltalk tools debugger.Smalltalk tools debuggerTool: PhLErrorDialogPresenter.[ NotFound signal: 'foo'.	self inform: 'execution not aborted' ]on: Error do: [ :e | UIManager default handleError: e].Smalltalk tools debuggerTool: currentDebugger.!!PhLTestApplication commentStamp: '' prior: 0!A spec application used for test purposes.I can answer pre-arranged responses to UI requests.!!PhLScriptPresenter methodsFor: '*PharoLauncher-Tests-SpecUI'!clickAddScriptButton	scriptTable addButton click! !!PhLScriptPresenter methodsFor: '*PharoLauncher-Tests-SpecUI'!clickRemoveScriptButton	scriptTable removeButton click! !!PhLScriptPresenter methodsFor: '*PharoLauncher-Tests-SpecUI'!fileEditor	^ fileEditor! !!PhLTestTemplatesPresenter methodsFor: '*PharoLauncher-Tests-SpecUI'!imageName: aString	descriptionPanel imageName: aString! !!PhLErrorDialogPresenter class methodsFor: 'accessing' prior: 85004380!closeAllDebuggers	<script>	self allInstancesDo: [ :dbg | dbg close ]! !!PhLErrorDialogPresenter class methodsFor: 'instance creation' prior: 85005381!debugSession: aDebugSession	PharoLauncherApplication isDeployed		ifTrue: [ (self on: aDebugSession) openDialog ]		ifFalse: [ self openDebuggerOn: aDebugSession ]! !!PhLErrorDialogPresenter class methodsFor: 'opening api'!openDebuggerOn: aDebugSession	StDebugger debugSession: aDebugSession.! !!PhLErrorDialogPresenter class methodsFor: 'accessing' prior: 85003675!rank	^rank ifNil:[rank := 10]! !!PhLErrorDialogPresenter methodsFor: 'accessing'!debugSession 	^ debugSession! !!PhLErrorDialogPresenter methodsFor: 'layout'!defaultLayout	^ SpBoxLayout newVertical		add: description;		yourself! !!PhLErrorDialogPresenter methodsFor: 'initialization'!initializeDialogWindow: aDialogWindowPresenter	super initializeDialogWindow: aDialogWindowPresenter.	aDialogWindowPresenter buttons		detect: [ :button | button label = 'Ok' ]		ifFound: [ :button | button label: 'Debug' ].	aDialogWindowPresenter buttons		detect: [ :button | button label = 'Cancel' ]		ifFound: [ :button | button label: 'Ignore' ].	aDialogWindowPresenter		cancelAction: [ self debugSession terminate ];		okAction: [ self class openDebuggerOn: self debugSession ]! !!PhLErrorDialogPresenter methodsFor: 'initialization'!initializePresenters 	description := self newText		beNotEditable;		text: self debugSession name;		yourself.! !!PhLErrorDialogPresenter methodsFor: 'initialization'!initializeWindow: aWindowPresenter	super initializeWindow: aWindowPresenter.	aWindowPresenter 		title: 'An error occured!!';		initialExtent: 390 @ 167.! !!PhLErrorDialogPresenter methodsFor: 'initialization'!setModelBeforeInitialization: aDebugSession	debugSession := aDebugSession! !!PhLImageCreationPresenterTest methodsFor: 'running'!setUp	super setUp.	presenter := PhLImageCreationPresenter		newApplication:			(PharoLauncherApplication new				scriptsDirectory: FileSystem memory root;				yourself)! !!PhLImageCreationPresenterTest methodsFor: 'tests'!testImageNameIsNotValidWhenContainingFileSeparator 	presenter checkNewName: 'foo/'.		self deny: presenter isNameValid.! !!PhLImageCreationPresenterTest methodsFor: 'tests'!testImageNameIsValid	presenter checkNewName: 'nonExistingImageName'.		self assert: presenter isNameValid.! !!PhLImageCreationPresenterTest methodsFor: 'tests'!testInitializationScriptListUpdatedWhenScriptPresenterDoChange	| scriptPresenter |	self		assert: presenter initializationScriptItems size		equals: 1. "No script"			scriptPresenter := presenter openScriptPresenter.	scriptPresenter newScriptNamed: 'foo.st'.			self		assert: presenter initScriptPresenter listItems size		equals: 2.	self		assert: presenter initScriptPresenter listItems second basename		equals: 'foo.st'.			scriptPresenter withWindowDo: #close.! !!PhLImagesPresenterTest methodsFor: 'running'!tearDown	presenter window ifNotNil: #close.	super tearDown! !!PhLImagesPresenterTest methodsFor: 'tests'!testFirstImageIsSelectedAtOpening	presenter := PhLTestImagesPresenter new.	presenter open.	self assert: presenter hasSingleImageSelected.	self		assert: presenter singleImage name		equals: presenter singleImageName! !!PhLImagesPresenterTest methodsFor: 'tests'!testImageLaunchConfigurationsAreUpdatedAfterLaunchConfigurationEdition	| launchConfigurationPresenter |	presenter := PhLTestImagesPresenter new.	presenter		open;		selectImageAt: 1.	self assert: presenter launchConfigurations size equals: 1.	launchConfigurationPresenter := presenter editLaunchConfigurations.	presenter singleImage addLaunchConfiguration:		((PhLLaunchConfiguration withImage: presenter singleImage)			 name: 'foo';			 yourself).	launchConfigurationPresenter clickApplyChangesButton.	launchConfigurationPresenter window close.	self assert: presenter launchConfigurations size equals: 2! !!PhLImagesPresenterTest methodsFor: 'tests'!testImageLaunchConfigurationsIsUpdatedAfterSortingOfImages	presenter := PhLTestImagesPresenter new.	presenter createImageNamed: 'Zoo'.	presenter application imageRepositoryChanged.	presenter		open;		selectImageAt: 1.	presenter		clickOnColumnHeaderAt: 1;		selectImageAt: 1.	self assert: presenter singleImage name equals: 'TestImage'.	self		assert: presenter launchConfigurations first image name		equals: 'TestImage'! !!PhLImagesPresenterTest methodsFor: 'tests'!testImagesPresenterIsRefreshedWhenApplicationNotifyImageRepositoryChanged	presenter := PhLTestImagesPresenter new.	presenter open.	presenter createImageNamed: 'Foo'.	presenter application imageRepositoryChanged.	self		assertCollection: presenter imageNames		hasSameElements: #( 'TestImage' 'Foo' )! !!PhLImagesPresenterTest methodsFor: 'tests'!testLaunchCommandIsDisabledWhenNoSelection	| enabled |	presenter := PhLTestImagesPresenter new.	presenter		open;		unselectAll.	presenter withToolbarDo: [ :toolbar | 		presenter toolbarGroup allCommands			detect: [ :cmd | cmd name = 'Launch' ]			ifFound: [ :cmd | enabled := cmd presenter isEnabled ] ].	self deny: enabled! !!PhLImagesPresenterTest methodsFor: 'tests'!testNewImagesIsSelectedWhenNewImageJustCreated	| image |	presenter := PhLTestImagesPresenter new.	presenter open.	image := PhLImage location: (presenter createImageNamed: 'Foo').	presenter application imageRepositoryChanged: image.	self assert: presenter singleImage name equals: 'Foo'! !!PhLLaunchConfigurationPresenterTest methodsFor: 'accessing'!defaultTimeLimit	^ 20 seconds! !!PhLLaunchConfigurationPresenterTest methodsFor: 'running'!setUp	super setUp.	image := PhLImage example.	image versionFile writeStreamDo: [ :s | s nextPutAll: '80' ].	self setUpPresenter! !!PhLLaunchConfigurationPresenterTest methodsFor: 'running'!setUpPresenter	self setUpPresenterWithApplication: PhLTestApplication new.! !!PhLLaunchConfigurationPresenterTest methodsFor: 'running'!setUpPresenterWithApplication: anSpApplication	application := anSpApplication.	presenter := PhLLaunchConfigurationPresenter		             newApplication: anSpApplication		             model: image! !!PhLLaunchConfigurationPresenterTest methodsFor: 'running'!tearDown	presenter window ifNotNil: #close.	super tearDown! !!PhLLaunchConfigurationPresenterTest methodsFor: 'tests'!testCanOpenAPresenterWithVMNotInDefaultListNorOnDisk	| config |	config := (PhLLaunchConfiguration withImage: image)				name: 'test config';				vm: (PhLVirtualMachine id: '01-x86')				yourself.	image addLaunchConfiguration: config.	self setUpPresenter.	presenter initializeVmListContent.	self assert: (presenter vmListItems noneSatisfy: [ :each | each id = config vm id]). "ensure we test with vm not listed in presenter"	presenter selectConfiguration: config.		self 		assert: presenter selectedVm id 		equals: config vm id		! !!PhLLaunchConfigurationPresenterTest methodsFor: 'tests'!testConfigurationDetailIsCleanedWhenConfigurationDeleted	| config |	self setUpPresenter.	config := image defaultLaunchConfiguration.	presenter		selectConfiguration: config;		clickDeleteConfigurationButton.	self assertEmpty: presenter imageArguments.	self assertEmpty: presenter vmArguments.	self assertEmpty: presenter configurationName! !!PhLLaunchConfigurationPresenterTest methodsFor: 'tests'!testEditingAndSavingAConfigurationSelectsItInImagesPresenterToolbar	| config imagesPresenter |	imagesPresenter := PhLTestImagesPresenter new.	presenter application imagesPresenter: imagesPresenter.	imagesPresenter		open;		selectImageAt: 1.	image := imagesPresenter singleImage.	config := (PhLLaunchConfiguration withImage: image)		          name: 'test config';		          yourself.	image addLaunchConfiguration: config.	self setUpPresenterWithApplication: imagesPresenter application.	presenter connectPresenters. "Select first config"	self		assert: imagesPresenter selectedLaunchConfiguration name		equals: 'Default'.	presenter selectConfiguration: config.	presenter saveSelectedConfiguration.	self		assert: imagesPresenter selectedLaunchConfiguration name		equals: config name.	imagesPresenter delete! !!PhLLaunchConfigurationPresenterTest methodsFor: 'tests'!testImageInteractiveArgumentIsAddedWhenHeadlessVMSelectedAndArgumentNotAlreadyPresent	| headlessVm |	headlessVm := presenter vmListItems anyOne beHeadless.		presenter selectVm: headlessVm.		self assert: (presenter imageArguments includes: '--interactive')! !!PhLLaunchConfigurationPresenterTest methodsFor: 'tests'!testImageInteractiveArgumentIsNotAddedWhenHeadlessVMSelectedAndArgumentAlreadyPresent	| headlessVm |	headlessVm := presenter vmListItems anyOne beHeadless.	presenter imageArguments add: '--interactive'.		presenter selectVm: headlessVm.		self 		assert: (presenter imageArguments select: [ :arg | arg = '--interactive' ]) size 		equals: 1! !!PhLLaunchConfigurationPresenterTest methodsFor: 'tests'!testImageLaunchConfigurationsUpdatedWhenConfigurationAdded	self setUpPresenter.	application requestAnswer: 'foo'.	self		assert: image launchConfigurations size 		equals: 1. "Default"			presenter clickAddConfigurationButton.			self		assert: image launchConfigurations size 		equals: 2. "Default foo"	self		assert: image launchConfigurations second name		equals: 'foo'.! !!PhLLaunchConfigurationPresenterTest methodsFor: 'tests'!testImageLaunchConfigurationsUpdatedWhenConfigurationRemoved	| configuration |	configuration := (PhLLaunchConfiguration withImage: presenter image)		                 name: 'foo';		                 yourself.	image addLaunchConfiguration: configuration.	self setUpPresenter.	self		assert: image launchConfigurations size 		equals: 2. "Default + foo"	presenter		selectConfiguration: configuration;		clickDeleteConfigurationButton.			self		assert: image launchConfigurations size 		equals: 1.	self		assert: image launchConfigurations first name		equals: PhLLaunchConfiguration defaultName.! !!PhLLaunchConfigurationPresenterTest methodsFor: 'tests'!testRemoveImageArgument	presenter imageArguments add: '--interactive'.	self assert: presenter imageArguments size equals: 1.	presenter selectImageArgumentAt: 1.	presenter clickDeleteImageArgumentButton.	self assertEmpty: presenter imageArguments! !!PhLLaunchConfigurationPresenterTest methodsFor: 'tests'!testRemoveImageArgumentWithoutSelectionDoesNotThrowError	presenter imageArguments add: '--interactive'.	"Unselect"	presenter selectImageArgumentAt: 0.	self shouldnt: [ presenter clickDeleteImageArgumentButton ] raise: NotFound! !!PhLLaunchConfigurationPresenterTest methodsFor: 'tests'!testRemoveVMArgument	presenter vmArguments add: '--interactive'.	self assert: presenter vmArguments size equals: 1.	presenter selectVMArgumentAt: 1.	presenter clickDeleteVMArgumentButton.	self assertEmpty: presenter vmArguments! !!PhLLaunchConfigurationPresenterTest methodsFor: 'tests'!testRemoveVMArgumentWithoutSelectionDoesNotThrowError	presenter vmArguments add: '--interactive'.	"Unselect"	presenter selectVMArgumentAt: 0.	self shouldnt: [ presenter clickDeleteVMArgumentButton ] raise: NotFound! !!PhLLaunchConfigurationPresenterTest methodsFor: 'tests'!testSelectingAConfigurationAndClosingWindowSelectsItInImagesPresenterToolbar	| config imagesPresenter window |	imagesPresenter := PhLTestImagesPresenter new.	imagesPresenter selectImageAt: 1.	image := imagesPresenter singleImage.	image launchConfigurations. "generate default configuration"	config := (PhLLaunchConfiguration withImage: image)		          name: 'test config';		          yourself.	image addLaunchConfiguration: config.	presenter application imagesPresenter: imagesPresenter.	imagesPresenter		open;		selectImageAt: 1.	self setUpPresenterWithApplication: imagesPresenter application.	window := presenter open.	presenter selectConfiguration: config.	window close.	self		assert: imagesPresenter selectedLaunchConfiguration name		equals: config name.	imagesPresenter delete! !!PhLLaunchConfigurationPresenterTest methodsFor: 'tests'!testVmsAreSortedById	| vms sortedVms |	self setUpPresenter.	presenter initializeVmListContent.		vms := presenter vmListItems.	sortedVms := vms sorted: [ :a :b | a id > b id ].		vms withIndexDo: [ :vm :index |		self assert: vm id equals: (sortedVms at: index) id ].! !!PhLLaunchConfigurationPresenterTest methodsFor: 'tests'!testWhenOpeningPresenterThenSelectedConfigurationIsDefaultConfiguration	self setUpPresenter.	self deny: presenter selectedConfiguration isNil.	self 		assert: presenter selectedConfiguration name		equals: 'Default'! !!PhLScriptPresenterTest methodsFor: 'running'!setUp	super setUp.	scriptFolder := FileSystem memory root.	file := (scriptFolder / 'foo.st') ensureCreateFile.	self setUpPresenter.! !!PhLScriptPresenterTest methodsFor: 'running'!setUpPresenter	application := PhLTestApplication new.	presenter := PhLScriptPresenter		             newApplication: application		             model: scriptFolder.! !!PhLScriptPresenterTest methodsFor: 'running'!tearDown 	window ifNotNil: [ window delete ].	super tearDown! !!PhLScriptPresenterTest methodsFor: 'tests'!testCanAddNewScript	application requestAnswer: 'bar.st'.	self		assert: scriptFolder files size 		equals: 1.			presenter clickAddScriptButton.			self		assert: scriptFolder files size		equals: 2.	self assert: (scriptFolder / 'foo.st') exists.! !!PhLScriptPresenterTest methodsFor: 'tests'!testCanRemoveScript	self		assert: scriptFolder files size 		equals: 1.			presenter 		selectScript: file;		clickRemoveScriptButton.			self		assert: scriptFolder files size		equals: 0.! !!PhLScriptPresenterTest methodsFor: 'tests'!testCanSaveScript	presenter selectScript: file.	presenter fileEditor text: 'bar'.		presenter saveSelectedScript.			self		assert: file contents		equals: 'bar'.! !!PhLScriptPresenterTest methodsFor: 'tests'!testCannotRemoveScriptIfNoneSelected	self		assert: scriptFolder files size 		equals: 1.			presenter clickRemoveScriptButton.			self		assert: scriptFolder files size		equals: 1.! !!PhLScriptPresenterTest methodsFor: 'tests'!testNewScriptEndsWithStExtension	application requestAnswer: 'bar'.	self		assert: scriptFolder files size 		equals: 1.			presenter clickAddScriptButton.			self		assert: scriptFolder files size		equals: 2.	self assert: (scriptFolder / 'bar.st') exists.! !!PhLScriptPresenterTest methodsFor: 'tests'!testSaveScriptUsingKeybind	presenter selectScript: file.	presenter fileEditor text: 'bar'.	window := presenter open.		presenter fileEditor adapter		keyDown: $s		shift: false 		meta: true		control: false		option: false.			self		assert: file contents		equals: 'bar'.! !!PhLTemplatesPresenterTest methodsFor: 'running'!setUp	"Hooks that subclasses may override to define the fixture of test."	super setUp.	presenter := PhLTestTemplatesPresenter new.! !!PhLTemplatesPresenterTest methodsFor: 'running'!tearDown	presenter window ifNotNil: #close.	super tearDown! !!PhLTemplatesPresenterTest methodsFor: 'tests'!testCanCreateImageIfOneTemplateSelected	presenter 		createLocalTemplateNamed: 'Foo';		selectCategory: 1;		selectTemplateNamed: 'Foo';		imageName: 'foo'.		presenter clickOnCreateButton.		self assert: presenter createButtonEnabled.! !!PhLTemplatesPresenterTest methodsFor: 'tests'!testCannotCreateImageIfNoTemplateSelected	presenter imageName: 'foo'.		presenter clickOnCreateButton.		self deny: presenter createButtonEnabled.! !!PhLTemplatesPresenterTest methodsFor: 'tests'!testTemplatesPresenterClosesWhenClickingOnCreateImage	presenter		createLocalTemplateNamed: 'Foo';		selectCategory: 1;		selectTemplateNamed: 'Foo';		open.	self assert: presenter window isOpen.	presenter clickOnCreateButton.	self deny: presenter window isOpen! !!PhLLaunchConfigurationPresenter methodsFor: '*PharoLauncher-Tests-SpecUI'!clickAddConfigurationButton	configurationTable addButton click! !!PhLLaunchConfigurationPresenter methodsFor: '*PharoLauncher-Tests-SpecUI'!clickApplyChangesButton	applyChangesButton click! !!PhLLaunchConfigurationPresenter methodsFor: '*PharoLauncher-Tests-SpecUI'!clickDeleteConfigurationButton	configurationTable removeButton click! !!PhLLaunchConfigurationPresenter methodsFor: '*PharoLauncher-Tests-SpecUI'!clickDeleteImageArgumentButton	imageArgumentList removeButton click! !!PhLLaunchConfigurationPresenter methodsFor: '*PharoLauncher-Tests-SpecUI'!clickDeleteVMArgumentButton	vmArgumentList removeButton click! !!PhLLaunchConfigurationPresenter methodsFor: '*PharoLauncher-Tests-SpecUI'!selectConfiguration: aPhLLaunchConfiguration	configurationTable selectItem: aPhLLaunchConfiguration! !!PhLLaunchConfigurationPresenter methodsFor: '*PharoLauncher-Tests-SpecUI'!selectVm: aPhLVirtualMachine	vmList selectItem: aPhLVirtualMachine! !!PhLLaunchConfigurationPresenter methodsFor: '*PharoLauncher-Tests-SpecUI'!selectedVm	^ vmList selectedItem ! !!PhLLaunchConfigurationPresenter methodsFor: '*PharoLauncher-Tests-SpecUI'!vmListItems	^ vmList listItems! !!PhLImageCreationPresenter methodsFor: '*PharoLauncher-Tests-SpecUI'!imageName: aString	imageName text: aString! !!PhLImageCreationPresenter methodsFor: '*PharoLauncher-Tests-SpecUI'!initScriptPresenter	^ initScript! !!PhLImageCreationPresenter methodsFor: '*PharoLauncher-Tests-SpecUI'!selectInitializationScript: anIndex	initScript selectIndex: anIndex! !!PhLTestApplication methodsFor: 'confirmation'!confirm	^ true! !!PhLTestApplication methodsFor: '*PharoLauncher-Tests-SpecUI'!imagesPresenter: aPhLImagesPresenter	imagesPresenter := aPhLImagesPresenter! !!PhLTestApplication methodsFor: 'request'!inform	"do nothing"! !!PhLTestApplication methodsFor: 'events'!launchConfigurationEdited: aPhLLaunchConfiguration 	"do nothing"! !!PhLTestApplication methodsFor: 'confirmation'!message: aString 	"do nothing"! !!PhLTestApplication methodsFor: 'confirmation'!newConfirm	"do nothing"! !!PhLTestApplication methodsFor: 'confirmation'!newConfirmation	^ PhLTestConfirmation new! !!PhLTestApplication methodsFor: 'confirmation'!newInformation	"do nothing"! !!PhLTestApplication methodsFor: 'request'!newRequest	"do nothing"! !!PhLTestApplication methodsFor: 'ui'!pushProgress: aString with: aFullBlockClosure 	"do not display progress, only evaluate the block"	aFullBlockClosure value: DummySystemProgressItem new! !!PhLTestApplication methodsFor: 'request'!request	^ requestAnswer! !!PhLTestApplication methodsFor: 'accessing'!requestAnswer: aString	requestAnswer := aString! !!PhLTestApplication methodsFor: 'asserting'!shouldUpdateTemplateSources	^ false! !!PhLTestApplication methodsFor: 'request'!title: aString 	"do nothing"! !!PhLTestApplication methodsFor: 'request'!validateAnswer: aBlockClosure 	"do nothing"! !"PharoLauncher-Tests-SpecUI"!!PhLDownloadManagerMock commentStamp: '' prior: 0!I have the same interface as PhLDownloadManager but I don't do anything. Useful for testing without relying on network.!!TPhLVirtualMachineTestUtil methodsFor: 'tests'!replaceOSByMacIn: url	^ (url copyReplaceAll: 'linux' with: 'mac') copyReplaceAll: 'win' with: 'mac'! !!PhLJenkins2BuildTest class methodsFor: 'instance creation'!newInstance	^ self newWithoutParent		  parent: PhLJenkins2JobTest newInstance;		  yourself! !!PhLJenkins2BuildTest class methodsFor: 'instance creation'!newSecureInstance	^ self newWithoutParent		  parent: PhLJenkins2JobTest newSecureInstance;		  yourself! !!PhLJenkins2BuildTest class methodsFor: 'instance creation'!newWithoutParent	^ PhLJenkins2Build newWithProperties: (STONJSON fromString:			   '{"_class":"hudson.matrix.MatrixBuild","url":"https://ci.inria.fr/moose/job/ClassNamesAnalyzer/223/","number":223}')! !!PhLJenkins2BuildTest methodsFor: 'helpers'!artifactRelativePath	^ 'foo.zip'! !!PhLJenkins2BuildTest methodsFor: 'helpers'!buildNumber	^ 52! !!PhLJenkins2BuildTest methodsFor: 'helpers'!buildUrlString	^ 'http://server/build'! !!PhLJenkins2BuildTest methodsFor: 'instance creation'!emptyBuild	^ (PhLJenkins2Build newWithProperties: (Dictionary new				    at: 'number' put: self buildNumber;				    at: 'url' put: self buildUrlString;				    yourself))		  parent: PhLJenkins2JobTest newSecureInstance;		  yourself! !!PhLJenkins2BuildTest methodsFor: 'instance creation'!emptyLastSuccessfulBuild	^ (PhLJenkins2Build newWithProperties: (Dictionary new				    at: 'number' put: self buildNumber;				    at: 'url' put: self lastSuccessfulBuildUrlString;				    yourself))		  parent: PhLJenkins2JobTest newSecureInstance;		  yourself! !!PhLJenkins2BuildTest methodsFor: 'helpers'!lastSuccessfulBuildUrlString	^ 'http://server/lastSuccessfulBuild'! !!PhLJenkins2BuildTest methodsFor: 'responses'!oneArtifactResponse	^ '{"artifacts" : [		{ "relativePath" : "', self artifactRelativePath,'" }		]}'! !!PhLJenkins2BuildTest methodsFor: 'responses'!oneRunResponse	^ '{"runs" : [		{ "number" : ',self runNumber printString,',		   "url" : "', self runUrlString,'" }		]}' ! !!PhLJenkins2BuildTest methodsFor: 'helpers'!runNumber	^ 52! !!PhLJenkins2BuildTest methodsFor: 'helpers'!runUrlString	^ 'http://server/run'! !!PhLJenkins2BuildTest methodsFor: 'tests'!testBuildWithArtifacts	| artifact |	self setUpResponse: self oneArtifactResponse.	self assertEmpty: self emptyBuild runs.	self assert: self emptyBuild artifacts size equals: 1.	artifact := self emptyBuild artifacts first.	self assert: artifact relativePath equals: self artifactRelativePath.	self assert: artifact url equals: self buildUrlString asUrl / 'artifact' / self artifactRelativePath! !!PhLJenkins2BuildTest methodsFor: 'tests'!testBuildWithRuns	| run |	self setUpResponse: self oneRunResponse.	self assertEmpty: self emptyBuild artifacts.	self assert: self emptyBuild runs size equals: 1.	run := self emptyBuild runs first.	self assert: run number equals: self runNumber! !!PhLJenkins2BuildTest methodsFor: 'tests'!testEmptyBuild	self setUpResponse: '{}'.	self assertEmpty: self emptyBuild artifacts.	self assertEmpty: self emptyBuild runs! !!PhLJenkins2BuildTest methodsFor: 'tests'!testLastSuccessfulBuildPropagateTag	| run build |	self setUpResponse: self oneRunResponse.	build := self emptyLastSuccessfulBuild.	self assert: build runs size equals: 1.	run := build runs first.	self assert: run url copy removeLastPathSegment lastPathSegment equals: 'lastSuccessfulBuild'! !!PhLJenkins2EntityTest class methodsFor: 'testing'!isAbstract	^ self = PhLJenkins2EntityTest! !!PhLJenkins2EntityTest class methodsFor: 'instance creation'!newInstance	^ self subclassResponsibility! !!PhLJenkins2EntityTest class methodsFor: 'instance creation'!newSecureInstance	^ self subclassResponsibility! !!PhLJenkins2EntityTest class methodsFor: 'testing'!shouldInheritSelectors	^ true! !!PhLJenkins2EntityTest methodsFor: 'helpers'!downloadManager	| manager |	manager := PhLDownloadManager default.	"If this assertion fails, you probably need to add a setUp method which calls PhLDownloadManagerMock>>install."	self assert: (manager isKindOf: PhLDownloadManagerMock).	^ manager! !!PhLJenkins2EntityTest methodsFor: 'instance creation'!newInstance	^ self class newInstance! !!PhLJenkins2EntityTest methodsFor: 'instance creation'!newSecureInstance	^ self class newSecureInstance! !!PhLJenkins2EntityTest methodsFor: 'running'!setUp	super setUp.	PhLDownloadManagerMock install.! !!PhLJenkins2EntityTest methodsFor: 'running'!setUpResponse: aResponse	"Setup the mock Jenkins server to answer ==aResponse==."	self downloadManager defaultResponse: aResponse! !!PhLJenkins2EntityTest methodsFor: 'running'!tearDown	PhLDownloadManagerMock remove.	super tearDown! !!PhLJenkins2EntityTest methodsFor: 'tests'!testNonSecureJenkinsDoesNotIncludesIdentifiersInUrl	self deny: self newInstance url hasUsername.	self deny: self newInstance url hasPassword! !!PhLJenkins2EntityTest methodsFor: 'tests'!testSecureJenkinsIncludesIdentifiersInUrl	self assert: self newSecureInstance url hasUsername.	self assert: self newSecureInstance url hasPassword! !!PhLJenkins2JobTest class methodsFor: 'helpers'!newInstance	^ self newWithoutParent		  parent: PhLJenkins2ServerTest newInstance;		  yourself! !!PhLJenkins2JobTest class methodsFor: 'helpers'!newSecureInstance	^ self newWithoutParent		  parent: PhLJenkins2ServerTest newSecureInstance;		  yourself! !!PhLJenkins2JobTest class methodsFor: 'helpers'!newWithoutParent	^ PhLJenkins2Job newWithProperties: (STONJSON fromString:			   '{"_class":"hudson.matrix.MatrixBuild","url":"https://ci.inria.fr/pharo-contribution/job/A4BP/1304/","number":1304}')! !!PhLJenkins2JobTest methodsFor: 'helpers'!lastSuccessfulBuildNumber	^ 52! !!PhLJenkins2JobTest methodsFor: 'helpers'!lastSuccessfulBuildUrlString	^ 'http://server/build'! !!PhLJenkins2JobTest methodsFor: 'instance creation'!newJobWithNoSuccessfulBuild	^ (PhLJenkins2Job newWithProperties: (Dictionary new				    at: 'url' put: 'url' asUrl;				    at: 'name' put: 'thejob';				    yourself))		  parent: PhLJenkins2ServerTest newInstance;		  yourself! !!PhLJenkins2JobTest methodsFor: 'instance creation'!newJobWithNullSuccessfulBuild	^ (PhLJenkins2Job newWithProperties: (Dictionary new				    at: 'url' put: 'url' asUrl;				    at: 'name' put: 'thejob';				    at: 'lastSuccessfulBuild' put: nil;				    yourself))		  parent: PhLJenkins2ServerTest newInstance;		  yourself! !!PhLJenkins2JobTest methodsFor: 'instance creation'!newJobWithSuccessfulBuild	^ (PhLJenkins2Job newWithProperties: (Dictionary new				    at: 'url' put: 'url' asUrl;				    at: 'name' put: 'thejob';				    at: 'lastSuccessfulBuild' put: (Dictionary newFromPairs: { 								     'number'.								     self lastSuccessfulBuildNumber.								     'url'.								     self lastSuccessfulBuildUrlString });				    yourself))		  parent: PhLJenkins2ServerTest newInstance;		  yourself! !!PhLJenkins2JobTest methodsFor: 'instance creation'!newPipelineJob	^ (PhLJenkins2Job newWithProperties: (Dictionary new				    at: 'url' put: 'url' asUrl;				    at: 'name' put: 'thejob';				    yourself))		  parent: PhLJenkins2ServerTest newInstance;		  yourself! !!PhLJenkins2JobTest methodsFor: 'responses'!noBuildsResponse	^ '{"builds" : []}'! !!PhLJenkins2JobTest methodsFor: 'responses'!oneBuildResponse	^ '{"builds" : [    {      "number" : ',self lastSuccessfulBuildNumber printString,',      "url" : "',self lastSuccessfulBuildUrlString,'"    }]}'! !!PhLJenkins2JobTest methodsFor: 'responses'!pipelineResponse	^ '{"jobs":[		{			"name":"1.1",			"url":"https://server/job/pipeline-name/job/1.1/",			"lastSuccessfulBuild":null		}		]}'! !!PhLJenkins2JobTest methodsFor: 'tests'!testJobWithNoSuccessfulBuild	self setUpResponse: self noBuildsResponse.	self assertEmpty: self newJobWithNoSuccessfulBuild builds! !!PhLJenkins2JobTest methodsFor: 'tests'!testJobWithNullSuccessfulBuild	self setUpResponse: self noBuildsResponse.	self assert: self newJobWithNullSuccessfulBuild lastSuccessfulBuildNumber isNil! !!PhLJenkins2JobTest methodsFor: 'tests'!testJobWithSuccessfulBuild	| job lastSuccessfulBuild |	self setUpResponse: self oneBuildResponse.	job := self newJobWithSuccessfulBuild.	self assert: job builds size equals: 1.	self assert: job builds first number equals: self lastSuccessfulBuildNumber.	self assert: job lastSuccessfulBuildNumber equals: self lastSuccessfulBuildNumber.	lastSuccessfulBuild := job lastSuccessfulBuild.	self assert: lastSuccessfulBuild number equals: self lastSuccessfulBuildNumber.		"This assertion makes sure the url of the lastSuccessfulBuild will always refer to the latest successful build."	self assert: lastSuccessfulBuild url lastPathSegment equals: 'lastSuccessfulBuild'! !!PhLJenkins2JobTest methodsFor: 'tests'!testPipelineJob	| build |	self setUpResponse: self pipelineResponse.		self assert: self newPipelineJob builds size equals: 1.	build := self newPipelineJob builds first.	self		assert: build url asString		equals: 'https://server/job/pipeline-name/job/1.1/'! !!PhLJenkins2RunTest class methodsFor: 'instance creation'!newInstance	^ self newWithoutParent		  parent: PhLJenkins2BuildTest newInstance;		  yourself! !!PhLJenkins2RunTest class methodsFor: 'instance creation'!newSecureInstance	^ self newWithoutParent		  parent: PhLJenkins2BuildTest newSecureInstance;		  yourself! !!PhLJenkins2RunTest class methodsFor: 'instance creation'!newWithoutParent	^ PhLJenkins2Run newWithProperties: (STONJSON fromString:			   '{"url":"https://ci.inria.fr/pharo-contribution/job/MaterialDesignLite/PHARO=61,VERSION=development/1140/","number":1140}')! !!PhLJenkins2ServerTest class methodsFor: 'instance creation'!newInstance	^ PhLJenkins2Server name: 'foo' url: 'bar' asUrl! !!PhLJenkins2ServerTest class methodsFor: 'instance creation'!newSecureInstance	^ self newInstance		username: 'BadetitouTheUnicorn';		password: 'dkewjdcnriuwefjncreiuhf';		yourself! !!PhLJenkins2ServerTest methodsFor: 'responses'!defaultJobName	^ 'theJobName'! !!PhLJenkins2ServerTest methodsFor: 'responses'!defaultJobUrlString	^ 'http://server/segment'! !!PhLJenkins2ServerTest methodsFor: 'responses'!noJobsResponse	^ '{"jobs" : []}'! !!PhLJenkins2ServerTest methodsFor: 'responses'!oneJobResponse	^ '{"jobs" : [		{			"name" : "',self defaultJobName,'",			"url" : "' , self defaultJobUrlString, '"		}		]}'! !!PhLJenkins2ServerTest methodsFor: 'tests'!testNoJob	self setUpResponse: self noJobsResponse.	self assertEmpty: self newInstance jobs! !!PhLJenkins2ServerTest methodsFor: 'tests'!testWith1Job	| job server |	self setUpResponse: self oneJobResponse.	server := self newInstance.	self assert: server jobs size equals: 1.	job := server jobs first.	self assert: job name equals: self defaultJobName.	self assert: job url equals: self defaultJobUrlString asUrl! !!PhLVirtualMachineManagerTest class methodsFor: 'as yet unclassified'!availaibleVirtualMachines	Smalltalk vm imageVersionNumber! !!PhLVirtualMachineManagerTest methodsFor: 'expected results'!currentImageVersion		"This test must be rewritten to a controlable version not depending on current image version"	self skip. 	^ (SystemVersion current major = 6		and: [ SystemVersion current highestUpdate >= 60509 ])		ifTrue: [ '61' ]		ifFalse: [ SystemVersion current major asString				, SystemVersion current minor asString ]! !!PhLVirtualMachineManagerTest methodsFor: 'utilities'!getImageHeader: anImageUrl	| archive image |	archive := ZipArchive new 		readFrom: (ZnEasy get: anImageUrl) contents readStream.	image:= archive members detect: [ :each | each  fileName endsWith: '.image' ].	^ (image binaryContentsFrom: 1 to: 4) readStream! !!PhLVirtualMachineManagerTest methodsFor: 'input data'!sixtyFourBitsHeader	" too long to process this request		^ self getImageHeader: 'http://files.pharo.org/image/60/latest-64.zip'	"		" Retrieved with:		'pharo64.image' asFileReference binaryReadStream next: 20	"		^ #[181 9 1 0 128 0 0 0 112 37 248 2 0 0 0 0 0 64 128 0] readStream "truncated image file"! !!PhLVirtualMachineManagerTest methodsFor: 'tests'!testCanDetect32BitsImage	| version |	self timeLimit: 60 seconds.	version := PhLVirtualMachineManager imageFormatNumberFromStream: self thirtyTwoBitsHeader.	self assert: (PhLVirtualMachineManager is32bits: version)! !!PhLVirtualMachineManagerTest methodsFor: 'tests'!testCanDetect64BitsImage	| version |	self timeLimit: 60 seconds.	version := PhLVirtualMachineManager imageFormatNumberFromStream: self sixtyFourBitsHeader.	self assert: (PhLVirtualMachineManager is64bits: version)! !!PhLVirtualMachineManagerTest methodsFor: 'tests'!testCanGetImageFormatNumber	| version |	version := PhLVirtualMachineManager imageFormatNumberFromFile: Smalltalk image lastImagePath.			self assert: version isInteger.	self		assert: version		equals: Smalltalk imageFormatVersion! !!PhLVirtualMachineManagerTest methodsFor: 'tests'!testCanGetImageVersionFromFile	| vmManager |	vmManager := PhLVirtualMachineManager forImage: Smalltalk image lastImagePath.	vmManager imageVersionFile 		ensureDelete;		writeStreamDo: [ :stream | stream << '60' ].			self		assert: vmManager imageVersionFromFile		equals: '60'! !!PhLVirtualMachineManagerTest methodsFor: 'tests'!testGetExceptionWhenRunningImageVersionFromFileWhenFileIsAbsent	| vmManager |	vmManager := PhLVirtualMachineManager forImage: Smalltalk image lastImagePath.	vmManager imageVersionFile ensureDelete.			self		should: [ vmManager imageVersionFromFile ]		raise: PhLImageVersionDeterminationError ! !!PhLVirtualMachineManagerTest methodsFor: 'tests'!testImageVersionDeterminationScriptIsUpdatedWhenFileContentDifferentFromScriptInImage	| vmManager scriptPath |	vmManager := PhLVirtualMachineManager new.	scriptPath := vmManager imageVersionDeterminationScriptPath.		scriptPath asFileReference		ensureDelete;		writeStreamDo: [ :stream | stream nextPutAll: 'foo' ].	self 		assert: scriptPath asFileReference contents 		equals: 'foo'.			vmManager imageVersionDeterminationScriptPath. "Should update the file with right content"		self deny: (scriptPath asFileReference contents includesSubstring: 'foo')! !!PhLVirtualMachineManagerTest methodsFor: 'tests'!testPharo50PreSpurImageUrlIsCorrect	| url |	url := PhLVirtualMachineManager new		imageFormatNumber: PhLVirtualMachineManager imageFormatPreSpur;		imageVersion: '50';		vmUrl.	self assert: (self replaceOSByMacIn: url) equals: 'https://files.pharo.org/get-files/50-preSpur/pharo-mac-stable.zip'! !!PhLVirtualMachineManagerTest methodsFor: 'tests'!testPharo60VmUrlIsCorrect	| url |	url := PhLVirtualMachineManager new		imageFormatNumber: PhLVirtualMachineManager imageFormat32bits;		imageVersion: '60';		vmUrl.	self assert: (self replaceOSByMacIn: url) equals: 'https://files.pharo.org/get-files/60/pharo-mac-stable.zip'! !!PhLVirtualMachineManagerTest methodsFor: 'tests'!testPharo70Vm64BitsUrlIsCorrect	| url |	url := (PhLVirtualMachineManager new 		imageFormatNumber: PhLVirtualMachineManager imageFormat64bits;		imageVersion: '70';		vmUrl).	self 		assert: (self replaceOSByMacIn: url)		equals: 'https://files.pharo.org/get-files/70/pharo64-mac-stable.zip' ! !!PhLVirtualMachineManagerTest methodsFor: 'tests'!testPharo70VmUrlIsCorrect	| url |	url := (PhLVirtualMachineManager new 		imageFormatNumber: PhLVirtualMachineManager imageFormat32bits;		imageVersion: '70';		vmUrl).	self 		assert: (self replaceOSByMacIn: url)		equals: 'https://files.pharo.org/get-files/70/pharo-mac-stable.zip' ! !!PhLVirtualMachineManagerTest methodsFor: 'tests'!testPreSpurImageUrlIsCorrect	| url |	url := (PhLVirtualMachineManager new 		imageFormatNumber: PhLVirtualMachineManager imageFormatPreSpur;		imageVersion: '40';		vmUrl).	self 		assert: (self replaceOSByMacIn: url)		equals: 'https://files.pharo.org/get-files/40/pharo-mac-stable.zip' ! !!PhLVirtualMachineManagerTest methodsFor: 'input data'!thirtyTwoBitsHeader	" too long to process this request		^ self getImageHeader: 'http://files.pharo.org/image/60/latest.zip'	"		" Retrieved with:		'pharo.image' asFileReference binaryReadStream next: 20	"	^ #[121 25 0 0 64 0 0 0 8 84 50 2 112 76 76 10 216 156 254 11] readStream "truncated image file"! !!PhLVmProviderTest methodsFor: 'running'!setUp	vmProvider := PhLVmProvider new.! !!PhLVmProviderTest methodsFor: 'tests'!testCanDetectArchitecture	self assert: (vmProvider hostArchitecture includesSubstring: '64')! !!PhLVmProviderTest methodsFor: 'tests'!testCanDetectOS	self assert: (vmProvider class supportedOs includes: vmProvider hostOS)! !!PhLVmProviderTest methodsFor: 'tests'!testLatestUrlIsValidAndAvailable	| url |	url := vmProvider urlForPharo: 90 stable: false.		self assert: (url asString includesSubstring: 'latest').	self assert: (ZnEasy head: url) isSuccess! !!PhLVmProviderTest methodsFor: 'tests'!testStableUrlIsValidAndAvailable	| url |	url := vmProvider urlForPharo: 90 stable: true.		self assert: (url asString includesSubstring: 'stable').	self assert: (ZnEasy head: url) isSuccess! !!PhLVmProviderUntilPharo80Test methodsFor: 'running'!setUp	vmProvider := PhLVmProviderUntilPharo80 new.! !!PhLVmProviderUntilPharo80Test methodsFor: 'tests'!testUrlIsValidAndAvailable	| url vm |	vm := (PhLVirtualMachine id: '80-x64')			be64bits;			yourself.	vmProvider := PhLVmProvider for: vm.	url := vmProvider url.		self assert: (url asString includesSubstring: '80').	self assert: (url asString includesSubstring: '64').	self assert: (ZnEasy head: url) isSuccess! !!PhLDownloadManagerMock class methodsFor: 'actions'!install	PhLDownloadManager setDefault: self new! !!PhLDownloadManagerMock class methodsFor: 'actions'!remove	PhLDownloadManager reset! !!PhLDownloadManagerMock methodsFor: 'configuration'!atUrl: anUrl answer: aDocument	self documents at: anUrl put: aDocument! !!PhLDownloadManagerMock methodsFor: 'accessing'!defaultResponse	^ defaultResponse! !!PhLDownloadManagerMock methodsFor: 'accessing'!defaultResponse: aString 	defaultResponse := aString! !!PhLDownloadManagerMock methodsFor: 'accessing'!documents	^ documents ifNil: [ documents := Dictionary new ]! !!PhLDownloadManagerMock methodsFor: 'action'!downloadToPositionableStream: anUrl	^ self documents at: anUrl ifPresent: [:document | document readStream] ifAbsent: [ self defaultResponse readStream ]! !!PhLDownloadManagerMock methodsFor: 'action'!downloadToPositionableStream: anUrl mimeType: aMimeType 	"Ignore mime type"	^ self downloadToPositionableStream: anUrl! !"PharoLauncher-Tests-Download"!!TestMacOSXMojavePlatform commentStamp: '' prior: 0!I'm used to represent a Mac OS X Mojave operating system for test purposes!!PhLUnixSubprocessTest commentStamp: '' prior: 0!This class contains tests to ensure we can expected behaviour from the library used!!PhLAbstractTemplateGroupTest commentStamp: '' prior: 0!Give me unit tests and I will make sure they are run for all subclasses of PhLAbstractTemplateGroup!!PhLOsXMojaveTestImage commentStamp: '' prior: 0!Class used for test purpose.I override the default OS to return OS X Mojave 10.15 (used to test support of 32-bit app)!!PhLVirtualMachineManagerTestResource commentStamp: '' prior: 0!I'm a test resource that mutualize download of image and VMs and provide temporary folders to host them as well as a workspace.self reset.self current downloadCompatibleVm64Bit; downloadPharo90Image!!PhLVirtualMachineManagerFunctionalTest commentStamp: '' prior: 0!A PhLVirtualMachineManagerTest is a test class for testing the behavior of PhLVirtualMachineManager!!TestMacOSXMojavePlatform methodsFor: 'accessing'!version 	^ '1015.1'! !!PhLCreateTemplateFromImageTest class methodsFor: 'accessing'!defaultTimeLimit	^ 1 minute! !!PhLCreateTemplateFromImageTest methodsFor: 'running'!tearDown	template ifNotNil: [ template zipArchive ensureDelete ].	super tearDown! !!PhLCreateTemplateFromImageTest methodsFor: 'tests'!testCanCreateATemplateFromImage	| image templateName templateRepository zipMemberNames fs fileNames |		templateName := 'newTemplate'.	fs := FileSystem memory root.	fileNames := {'a.image' . 'a.changes' . PhLImage versionFileName . 'a-23456ef.sources'}.	fileNames do: [ :fileName | (fs / fileName) ensureCreateFile ].	image := PhLImage location: fs / fileNames first.	templateRepository := PhLTemplateGroupRepository newFromGroups: { PhLDownloadedTemplateGroup named: 'cache group' }.		templateRepository createLocalTemplateFrom: image named: templateName.		self assert: (templateRepository hasLocalTemplateNamed: templateName).	template := templateRepository localTemplateNamed:templateName.	zipMemberNames := (ZipArchive new readFrom: template zipArchive) memberNames.	self 		assertCollection: zipMemberNames 	 	hasSameElements: {templateName , '.image' . templateName , '.changes'} , (fileNames allButFirst: 2).	! !!PhLDownloadManagerTest methodsFor: 'running'!setUp	super setUp.		downloadManager := PhLDownloadManager new.! !!PhLDownloadManagerTest methodsFor: 'tests'!testCanDownload	| downloadedFile |	downloadedFile := FileSystem memory root / 'dwl'.		downloadManager download: 'http://files.pharo.org/web-images/carousel/inspector.gif' toFile: downloadedFile.		self assert: downloadedFile exists.	self assert: downloadedFile size equals: 1330326.	self assert: downloadManager numberOfErrors equals: 0.	! !!PhLLaunchImageTest methodsFor: 'tests'!copyCurrentImageToTestDir	| image |		FileLocator image copyTo: imageDir / FileLocator image basename.	image := PhLImage location: imageDir / FileLocator image basename.		"avoid to download a compatible VM to determine image pharo version"	image vmManager imageVersionFile writeStreamDo: [ :stream | 		stream			nextPutAll: SystemVersion current major asString;			nextPutAll: SystemVersion current minor asString ].			^ image			! !!PhLLaunchImageTest methodsFor: 'utils'!copyCurrentVmTo: aDirectory	| vmDirectory imageVersion vmId |		vmDirectory := Smalltalk vmDirectory asFileReference.	imageVersion := SystemVersion current major asString , SystemVersion current minor asString.	vmId := imageVersion, '-x64'.	vmDirectory basename = 'pharo-vm'		ifTrue: [ vmDirectory renameTo: vmId ].		LibC runCommand: 'cp -R ' , vmDirectory fullName , ' ' , aDirectory fullName, '/' , vmId! !!PhLLaunchImageTest methodsFor: 'utils'!pharo80x86Vm	^ PhLVirtualMachineManager new virtualMachines		detect: [ :each | each id = '80-x86' ]		ifFound: [ :vm | vm isValidAfterUpdate. vm ]		ifNone: [ self fail: 'cannot find VM!!' ]! !!PhLLaunchImageTest methodsFor: 'running'!setUp	| uuid |	super setUp.	launchInALoginShellBackup := PhLLaunchConfiguration launchInALoginShell.	PhLLaunchConfiguration launchInALoginShell: false.	uuid := UUIDGenerator next asString.	imageDir := FileLocator temp / 'Yann-Gaël Bérès' , uuid.	self deny: imageDir exists.	imageDir ensureCreateDirectory.	vmStoreBackup := PhLVirtualMachineManager vmStore.	tempVmStoreFolder := FileLocator temp / self class name , uuid.	PhLVirtualMachineManager vmStore: tempVmStoreFolder.	self copyCurrentVmTo: tempVmStoreFolder.! !!PhLLaunchImageTest methodsFor: 'running'!tearDown 	PhLLaunchConfiguration launchInALoginShell: launchInALoginShellBackup.	tempVmStoreFolder ensureDeleteAll.	PhLVirtualMachineManager vmStore: vmStoreBackup.	imageDir ensureDeleteAll.	process ifNotNil: [ process isRunning ifTrue: [ process terminate ] ].	super tearDown! !!PhLLaunchImageTest methodsFor: 'tests'!testArchitectureErrorSignaledWhenTryingToRun32BitImageOn64BitOnlyOS	| image |	image := PhLOsXMojaveTestImage example32.		self 		should: [ process := image launchWithConfiguration: nil ]		raise: PhLArchitectureError	! !!PhLLaunchImageTest methodsFor: 'tests'!testCanLaunchImageWithNonAsciiCharacters	| image |	image := self copyCurrentImageToTestDir.	image launch.	"ensure image determination succeeded"	self		assert: (imageDir / PhLImage versionFileName) contents		equals: SystemVersion current major asString			, SystemVersion current minor asString	"image is run but tearDown could delete the image before it is run leading to the dialog to choose the image"	"for now, no simple way to test that the image is actually launched"! !!PhLLaunchImageTest methodsFor: 'tests'!testCanLaunchImageWithNonAsciiCharactersUsingLoginShell		PhLLaunchConfiguration launchInALoginShell: true.	self testCanLaunchImageWithNonAsciiCharacters.! !!PhLLaunchImageTest methodsFor: 'tests'!testCanRun64bitImageOn64BitOnlyOS	| image config commandToEval |	image := PhLOsXMojaveTestImage example.	commandToEval := '"''' , imageDir fullName , '/result'' asFileReference writeStreamDo:[ :s | s nextPutAll: (1 + 1) asString ]"'.	config := image defaultLaunchConfiguration.	config		vm: self pharo80x86Vm;		imageArguments: {'eval' . commandToEval}.		self 		shouldnt: [ process := image launchWithConfiguration: config ]		raise: PhLArchitectureError		! !!PhLLaunchImageTest methodsFor: 'tests'!testLaunchImageSetShouldRunInitilizationScriptToFalse	| image |		image := self copyCurrentImageToTestDir.		image launch.		image := PhLImage location: imageDir / FileLocator image basename. "read image metadata from disk"	self deny: image shouldRunInitializationScript.! !!PhLLaunchedImagesWatcherTest methodsFor: 'tests'!testCanCatchProcessError	| process image |	process := PhLProcessWrapper new		command: '/bin/ls';		addArgument: '/foo/bar';		yourself.	image := PhLImage location: FileSystem memory root.		process runUnwatch.		self		should:			[ (PhLLaunchedImagesWatcher process: process image: image) basicCheckProcess ]		raise: PhLLaunchError! !!PhLLaunchedImagesWatcherTest methodsFor: 'tests'!testProcessSuccessfulDoesNotThrowError	| process image |	process := PhLProcessWrapper new		command: '/bin/ls';		yourself.	image := PhLImage location: FileSystem memory root.		process runUnwatch.		self		shouldnt:			[ (PhLLaunchedImagesWatcher process: process image: image) basicCheckProcess ]		raise: PhLLaunchError! !!PhLPrivateVirtualMachineTest methodsFor: 'tests'!testCanGetDownloadUrl	| vm |	vm := PhLPrivateVirtualMachine new 		basicInitializeOn: FileSystem memory / '6521';		yourself.	self 		assert: (self replaceOSByMacIn: vm downloadUrl)		equals: 'https://files.pharo.org/get-files/70/pharo-mac-stable.zip'! !!PhLProcessWrapperTest methodsFor: 'tests'!testCanDetectAvailableCommandOnLinux	Smalltalk os isWindows ifTrue: [ self skip. ^ self ].	self assert: (PhLProcessWrapper isCommandAvailable: 'ls').	self deny: (PhLProcessWrapper isCommandAvailable: 'foobar').! !!PhLProcessWrapperTest methodsFor: 'tests'!testCanDetectAvailableCommandOnWindows	Smalltalk os isWindows ifFalse: [ self skip. ^ self  ].	self assert: (PhLProcessWrapper isCommandAvailable: 'dir').	self deny: (PhLProcessWrapper isCommandAvailable: 'foobar').! !!PhLProcessWrapperTest methodsFor: 'tests'!testCanRunCommandWithNonAsciiCharacters	| process fileRef |	fileRef := (FileLocator temp / 'Yann-Gaël Bérès.bat') asFileReference.	fileRef ensureCreateFile.	[ process := PhLProcessWrapper new 		shellCommand;		addArgument: (Smalltalk os isWindows 			ifTrue: [ 'dir' ]			ifFalse: [ 'ls' ]);		addArgument: fileRef fullName surroundedByDoubleQuotes;		runAndWait.		self assert: process isSuccess. ]		ensure: [ fileRef ensureDelete ]! !!PhLProcessWrapperTest methodsFor: 'tests'!testLinuxCommandLineString	| process commandString |	process := PhLProcessWrapper new 		command: '/home/me/Pharo/pharo';		addArgument: '/tmp/ba r.image' surroundedByDoubleQuotes;		prepareProcess;		yourself.		commandString := PhLProcessWrapperCommandStringGenerator new 		processWrapper: process;		visit.		self assert: commandString equals: '"/home/me/Pharo/pharo" /tmp/ba r.image'	! !!PhLProcessWrapperTest methodsFor: 'tests'!testLinuxCommandLineStringWhenUsingShell	| process commandString |	process := PhLProcessWrapper new 		shellCommand;		addArgument: 'ls';		addArgument: '/foo/ba r' surroundedByDoubleQuotes;		prepareProcess;		yourself.		commandString := PhLProcessWrapperCommandStringGenerator new 		processWrapper: process;		visit.		self assert: commandString equals: 'bash -c ''ls "/foo/ba r"'''	! !!PhLProcessWrapperTest methodsFor: 'tests'!testLinuxCommandRemoveDoubleQuotesFromArguments	"OSSubProcess gets an array of arguments as input. If arguments are protected with double-quotes, they are interpreted as part of the argument. Protecting arguments with double quotes only works when using a shell command with an arguments string. The shell the interprets double-quotes and remove them to run the command."	| process argument |	Smalltalk os isWindows ifTrue: [ self skip. ^ self ].	process := PhLProcessWrapper new 		command: 'sleep';		addArgument: '1'.		argument := process arguments first.	self deny: (argument includes: $").	process runAndWait.	self assert: process isSuccess! !!PhLProcessWrapperTest methodsFor: 'tests'!testLinuxShellCommandDoesNotRemoveDoubleQuotesFromArguments	"OSSubProcess gets an array of arguments as input. If arguments are protected with double-quotes, they are interpreted as part of the argument. Protecting arguments with double quotes only works when using a shell command with an arguments string. The shell the interprets double-quotes and remove them to run the command."	| process pathArgument |	Smalltalk os isWindows ifTrue: [ self skip. ^ self ].	process := PhLProcessWrapper new 		shellCommand;		addArgument: 'ls';		addArgument: FileLocator home fullName surroundedByDoubleQuotes.		pathArgument := process arguments second.	self assert: pathArgument first equals: $".	self assert: pathArgument last equals: $".	process runAndWait.	self assert: process isSuccess! !!PhLProcessWrapperTest methodsFor: 'tests'!testRunningInfiniteProcessThrowsTimeout	| process |	process := PhLProcessWrapper new 		shellCommand;		yourself.	Smalltalk os isWindows 		ifTrue: [ process addArgument: 'FOR /L %N IN () DO @echo Oops' ]		ifFalse: [ process addArgument: 'bash -c " while true; do echo ''Hit CTRL+C''; sleep 1; done"' ].	self 		should: [ process runAndWaitTimeOut: 300 milliSeconds. ]		raise: PhLProcessTimeOut.! !!PhLProcessWrapperTest methodsFor: 'tests'!testRunningShortProcessDoesNotTimeout	| cmd |	 cmd := Smalltalk os isWindows 		ifTrue: [ 'timeout 1' ]		ifFalse: [ 'sleep 1' ].	self 		shouldnt: [ PhLProcessWrapper new 			shellCommand;			addArguments: cmd;			runAndWaitTimeOut: 2 seconds ]		raise: PhLProcessTimeOut.! !!PhLProcessWrapperTest methodsFor: 'tests'!testWindowsCommandDoesNotRemoveDoubleQuotesFromArguments	"Windows API takes a single String with all arguments as parameter. Paths have to be protected by double quotes."	| process argument |	Smalltalk os isWindows ifFalse: [ self skip. ^ self ].	process := PhLProcessWrapper new 		command: Smalltalk vmBinary fullName;		addArgument: Smalltalk imagePath surroundedByDoubleQuotes;		addArgument: '--headless'.		argument := process arguments first.	self assert: argument first equals: $".	self assert: argument last equals: $".	process runAndWait.	self assert: process isSuccess! !!PhLProcessWrapperTest methodsFor: 'tests'!testWindowsCommandLineString	| process commandString osPlatform |	osPlatform := OSPlatform current.	[ OSPlatform classVarNamed: 'Current' put: Win64Platform new.	process := PhLProcessWrapper new 		command: 'C:\Users\me\pharo\Pharo.exe';		addArgument: '"D:\foo\ba r\ba r.image"';		prepareProcess;		yourself.		commandString := PhLProcessWrapperCommandStringGenerator new 		processWrapper: process;		visit. ]	ensure: [ OSPlatform classVarNamed: 'Current' put: osPlatform ].		self assert: commandString equals: '"C:\Users\me\pharo\Pharo.exe" "D:\foo\ba r\ba r.image"'	! !!PhLProcessWrapperTest methodsFor: 'tests'!testWindowsCommandLineStringWhenUsingShell	| process commandString osPlatform |	osPlatform := OSPlatform current.	[ OSPlatform classVarNamed: 'Current' put: Win64Platform new.	process := PhLProcessWrapper new 		shellCommand;		addArgument: 'dir';		addArgument: '/foo/ba r';		prepareProcess;		yourself.		commandString := PhLProcessWrapperCommandStringGenerator new 		processWrapper: process;		visit. ]	ensure: [ OSPlatform classVarNamed: 'Current' put: osPlatform ].		self assert: commandString equals: 'C:\Windows\System32\cmd.exe /C "dir /foo/ba r"'	! !!PhLProcessWrapperTest methodsFor: 'tests'!testWindowsShellCommandOnWindowsDoesNotRemoveDoubleQuotesFromArguments	"Windows API takes a single String with all arguments as parameter. Paths have to be protected by double quotes."	| process argument |	Smalltalk os isWindows ifFalse: [ self skip. ^ self ].	process := PhLProcessWrapper new 		shellCommand;		addArgument: 'timeout';		addArgument: '"/?"'.		argument := process arguments last.	self assert: argument first equals: $".	self assert: argument last equals: $".	process runAndWait.	self assert: process isSuccess! !!PhLUnixSubprocessTest methodsFor: 'tests'!testCanGetExitStatusFromLaunchCommand	| process |	process := OSSUnixSubprocess new 		command: '/bin/ls';		arguments: #( '/foo/bar' );		yourself.			process run.	500 milliSeconds wait.		self assert: process isComplete.	self deny: process isSuccess.	self assert: process exitStatusInterpreter isExited.	"Exit code is 1 on OS X, 2 on Linux"	self assert: (#(1 2) includes: process exitStatusInterpreter statusIfExited).! !!PhLUnixSubprocessTest methodsFor: 'tests'!testCanGetStdErrFromLaunchCommand	| process stdErrString |	process := OSSUnixSubprocess new 		command: '/bin/ls';		arguments: #( '/foo/bar' );		redirectStderr;		yourself.			process run.	500 milliSeconds wait.		self assert: process isComplete.	self deny: process isSuccess.	stdErrString := process stderrStream upToEndOfFile.	self 		assert: ( stdErrString includesSubstring: 'No such file or directory')		description: 'Cannot find "No such file or directory" in std err stream'.	self 		assert: (stdErrString includesSubstring: '/foo/bar')		description: 'Cannot find "/foo/bar" in std err stream'.	self 		assert: (stdErrString includesSubstring: 'ls')		description: 'Cannot find "ls" in std err stream'.! !!PhLVirtualMachineTest methodsFor: 'tests'!testCanDetect32BitArchPath	| vm |	vm := PhLVirtualMachine new 		basicInitializeOn: FileSystem memory / '70-x86';		yourself.	self 		assert: vm archPath		equals: ''! !!PhLVirtualMachineTest methodsFor: 'tests'!testCanDetect64BitArchPath	| vm |	vm := PhLVirtualMachine new 		basicInitializeOn: FileSystem memory / '70-x64';		yourself.	self 		assert: vm archPath		equals: '64'! !!PhLVirtualMachineTest methodsFor: 'tests'!testCanDetectExecutablePath	"WARNING: this test is Linux specific!!"	| vm vmFolder |	Smalltalk os isWindows ifTrue: [ self skip. ^ self  ].		vmFolder := FileLocator imageDirectory asFileReference / 'pharo-vm'.	vm := PhLVirtualMachine directory: vmFolder.	self 		assert: vm executablePath		equals: (vmFolder / PhLVirtualMachine executableName) fullName! !!PhLVirtualMachineTest methodsFor: 'tests'!testCanDetectVMDirectory	"WARNING: this test is Linux specific!!"	| vm |	Smalltalk os isWindows ifTrue: [ self skip. ^ self  ].		vm := PhLVirtualMachine directory: FileLocator imageDirectory asFileReference / 'pharo-vm'.	self		assert: vm vmFolderPath		equals: FileLocator vmDirectory fullName! !!PhLVirtualMachineTest methodsFor: 'tests'!testCanGetDownloadUrl	| vm |	vm := PhLVirtualMachine new 		basicInitializeOn: FileSystem memory / '70-x64';		yourself.	self 		assert: (self replaceOSByMacIn: vm downloadUrl) 		equals: 'https://files.pharo.org/get-files/70/pharo64-mac-stable.zip'! !!PhLVirtualMachineTest methodsFor: 'tests'!testCanGetExecutablePathWhenBeeingSerializedAsString	| vm |	vm := STON fromString: 'PhLVirtualMachine {				#executableRef : ''/Users/me/Documents/Pharo/vms/80-x64/Pharo.app/Contents/MacOS/Pharo'',				#vmBinaryRef : ''/Users/me/Documents/Pharo/vms/80-x64/Pharo.app/Contents/MacOS/Pharo'',				#flavour : '''',				#id : ''80-x64'',				#blessing : ''stable'',				#arch : ''64''}'.		self assert: vm executablePath equals: '/Users/me/Documents/Pharo/vms/80-x64/Pharo.app/Contents/MacOS/Pharo'! !!PhLVirtualMachineTest methodsFor: 'tests'!testCanGetPharoVersion	| vm |	vm := PhLVirtualMachine new 		basicInitializeOn: FileSystem memory / '70-x64';		yourself.	self 		assert: vm pharoVersion		equals: '70'! !!PhLVirtualMachineTest methodsFor: 'tests'!testSerialization	| vm vmDirectory deserializedVm vmBinaryRef |		vmDirectory := (FileSystem memory root / '80-x64') ensureCreateDirectory.	(vmDirectory / PhLVirtualMachine executableName) 		binaryWriteStreamDo: [ :stream | stream nextPutAll: PhLVirtualMachine elfMagicNumber ].	vm := PhLVirtualMachine directory: vmDirectory.	vmBinaryRef := (FileLocator documents / 'Pharo' / 'vms' / '80-x64' / 'pharo') asFileReference.	vm vmBinary: vmBinaryRef. "do not serialize a memory FS"	deserializedVm := STON fromString: (STON toStringPretty: vm).		self assert: deserializedVm vmFolder class equals: FileLocator.	self assert: deserializedVm vmFolder fullName equals: vmBinaryRef parent fullName.	self assert: deserializedVm id equals: vm id.	self assert: deserializedVm blessing equals: vm blessing.	self assert: deserializedVm archPath equals: vm archPath.	self assert: deserializedVm flavour equals: vm flavour.! !!PhLVirtualMachineTest methodsFor: 'tests'!testvm10IsGreaterThanVm1	| vm10 vm1 |	vm10 := (PhLVirtualMachine id: '100-x64')			be64bits;			yourself.	vm1 :=  (PhLVirtualMachine id: '10').		self assert: vm10 > vm1! !!PhLVirtualMachineTest methodsFor: 'tests'!testvm64IsGreaterThanVm32	| vm vm64 |	vm := PhLVirtualMachine id: '90-x86'.	vm64 :=  (PhLVirtualMachine id: '90')			be64bits;			yourself.		self assert: vm64 > vm! !!ZipArchiveMember methodsFor: '*PharoLauncher-Tests-Functional'!binaryContentsFrom: start to: finish	"Answer my contents as a string."	| s |	s := (ByteArray new: finish - start + 1) writeStream.	self extractTo: s from: start to: finish.	^s contents! !!PhLAbstractTemplateGroupTest class methodsFor: 'testing'!isAbstract	^ self name = 'PhLAbstractTemplateGroupTest'! !!PhLAbstractTemplateGroupTest methodsFor: 'helpers'!downloadManager	^ PhLDownloadManager default! !!PhLAbstractTemplateGroupTest methodsFor: 'instance creation'!newGroup	^ self subclassResponsibility! !!PhLAbstractTemplateGroupTest methodsFor: 'running'!setUp	super setUp.	PhLDownloadManagerMock install! !!PhLAbstractTemplateGroupTest methodsFor: 'running'!tearDown	PhLDownloadManagerMock remove.	super tearDown! !!PhLAbstractTemplateGroupTest methodsFor: 'tests'!testTemplatesAndGroupsIsACollection	| group templateAndGroups |	group := self newGroup.	templateAndGroups := group templatesAndGroups.	self assert: templateAndGroups isCollection.	self assert: templateAndGroups size > 0.	group templatesAndGroups		do: [ :templateOrGroup | templateOrGroup isTemplateGroup	"we just make sure the message can be sent without checking its result" ]! !!PhLHTTPListingTemplateGroupTest methodsFor: 'coverage'!classToBeTested	^ PhLHTTPListingTemplateGroup! !!PhLHTTPListingTemplateGroupTest methodsFor: 'helpers'!exampleContent	^ '<html>	<head></head><body>	<a href="foo.html">foo.zip</a>	<a href="bla1.zip">bla1.zip</a>	... bla bla ...	<a href="bla2.zip">bla2.zip</a>	... bla bla ...	</body>	</html>'! !!PhLHTTPListingTemplateGroupTest methodsFor: 'helpers'!exampleUrl	^ 'http://foo.example.com/bar' asZnUrl! !!PhLHTTPListingTemplateGroupTest methodsFor: 'instance creation'!newGroup	^ PhLHTTPListingTemplateGroup name: 'Test' url: self exampleUrl! !!PhLHTTPListingTemplateGroupTest methodsFor: 'running'!setUp	super setUp.	self downloadManager atUrl: self exampleUrl answer: self exampleContent! !!PhLHTTPListingTemplateGroupTest methodsFor: 'tests'!testIsGroup	self assert: self newGroup isTemplateGroup! !!PhLHTTPListingTemplateGroupTest methodsFor: 'tests'!testTemplatesAndGroups	| group templatesAndGroups |	group := self newGroup.	templatesAndGroups := group templatesAndGroups.	self assert: templatesAndGroups size equals: 2.	"<- 2 archive links in exampleContent"	self assert: (templatesAndGroups noneSatisfy: [ :template | template isTemplateGroup ]).	self assert: (templatesAndGroups collect: #name) asSet equals: #('bla1' 'bla2') asSet! !!PhLOsXMojaveTestImage class methodsFor: 'testing'!isSubclassForLocation: aFileReference 	^ false! !!PhLOsXMojaveTestImage methodsFor: 'private - accessing'!os	^ TestMacOSXMojavePlatform new! !!PhLVirtualMachineManagerTestResource methodsFor: 'configuring'!backupCurrentVmStore	vmStoreBackup := PhLVirtualMachineManager vmStore! !!PhLVirtualMachineManagerTestResource methodsFor: 'running'!cleanWorkspace	self workspace 		ensureDeleteAll;		ensureCreateDirectory.! !!PhLVirtualMachineManagerTestResource methodsFor: 'downloading'!downloadCompatibleVm64Bit	| vmManager |	vmManager := PhLVirtualMachineManager forImage: self pharo90image.	vmManager availableVirtualMachinesByImageFormat		at: vmManager imageFormatNumber asString		ifAbsent: [ vmManager fetchCompatibleVm ]  ! !!PhLVirtualMachineManagerTestResource methodsFor: 'downloading'!downloadPharo14Image	ZipArchive new 		readFrom: (ZnEasy get: 'http://files.pharo.org/image/14/latest.zip') contents readStream;		extractAllTo: self pharo14imageFolder ensureCreateDirectory.! !!PhLVirtualMachineManagerTestResource methodsFor: 'downloading'!downloadPharo90Image	| httpClient |		httpClient := ZnClient new		beOneShot;		maximumEntitySize: 30 * 1024 * 1024;		url: 'https://files.pharo.org/image/90/stable-64.zip';		get;		yourself.	ZipArchive new 		readFrom: httpClient response contents readStream;		extractAllTo: self pharo90imageFolder ensureCreateDirectory.! !!PhLVirtualMachineManagerTestResource methodsFor: 'accessing'!pharo14image	self pharo14imageFolder exists		ifFalse: [ self downloadPharo14Image ].			^ self pharo14imageFolder allFiles 		detect: [ :each | each basename endsWith: '.image' ]! !!PhLVirtualMachineManagerTestResource methodsFor: 'accessing'!pharo14imageFolder	^ imagesFolder / '14'! !!PhLVirtualMachineManagerTestResource methodsFor: 'accessing'!pharo90image	self pharo90imageFolder exists		ifFalse: [ self downloadPharo90Image ].			^ self pharo90imageFolder allFiles 		detect: [ :each | each basename endsWith: '.image' ]! !!PhLVirtualMachineManagerTestResource methodsFor: 'accessing'!pharo90imageFolder	^ imagesFolder / '90'! !!PhLVirtualMachineManagerTestResource methodsFor: 'configuring'!restoreVmStore	PhLVirtualMachineManager vmStore: vmStoreBackup! !!PhLVirtualMachineManagerTestResource methodsFor: 'running'!setUp	super setUp.	tempFolder := (FileLocator temp / self class name, UUIDGenerator next asString) ensureCreateDirectory.	imagesFolder := (tempFolder / 'images') ensureCreateDirectory.	workspace := (tempFolder / 'workspace') ensureCreateDirectory.	self setUpTemporaryVmStore.	self useTemporaryVmStore.! !!PhLVirtualMachineManagerTestResource methodsFor: 'initialization'!setUpTemporaryVmStore	self backupCurrentVmStore.	tempVmStoreFolder := (tempFolder / 'vmStore') ensureCreateDirectory.! !!PhLVirtualMachineManagerTestResource methodsFor: 'running'!tearDown	tempFolder ensureDeleteAll.	self restoreVmStore.	super tearDown! !!PhLVirtualMachineManagerTestResource methodsFor: 'configuring'!useTemporaryVmStore	PhLVirtualMachineManager vmStore: tempVmStoreFolder! !!PhLVirtualMachineManagerTestResource methodsFor: 'running'!withCopyOfPharo14ImageDo: aBlock	| imageRef |	imageRef := self workspace / 'Pharo.image'.	self pharo14image copyTo: imageRef.		[ aBlock value: imageRef ]	ensure: [ imageRef ensureDelete ]! !!PhLVirtualMachineManagerTestResource methodsFor: 'running'!withCopyOfPharo90ImageDo: aBlock	| imageRef |	imageRef := self workspace / 'Pharo.image'.	self pharo90image copyTo: imageRef.		[ aBlock value: imageRef ]	ensure: [ imageRef ensureDelete ]! !!PhLVirtualMachineManagerTestResource methodsFor: 'accessing'!workspace	"The workspace folder is used as a temporary folder by tests and must be reset at the end of the test"		^ workspace! !!PhLVirtualMachineManagerFunctionalTest class methodsFor: 'accessing'!resources	^ Array with: PhLVirtualMachineManagerTestResource ! !!PhLVirtualMachineManagerFunctionalTest methodsFor: 'support'!preSpurHeader	^ self getImageHeader: 'http://files.pharo.org/image/50-preSpur/latest.zip'! !!PhLVirtualMachineManagerFunctionalTest methodsFor: 'running'!setUp	super setUp.		PhLVirtualMachineManagerTestResource current cleanWorkspace.! !!PhLVirtualMachineManagerFunctionalTest methodsFor: 'tests'!testCanDetectPreSpurImage	| version |	self timeLimit: 60 seconds.	version := PhLVirtualMachineManager imageFormatNumberFromStream: self preSpurHeader.		self assert: (PhLVirtualMachineManager isPreSpur: version)! !!PhLVirtualMachineManagerFunctionalTest methodsFor: 'tests'!testCanDetectSystemUnzip	self assert: PhLVirtualMachineManager canUseSytemZip! !!PhLVirtualMachineManagerFunctionalTest methodsFor: 'tests'!testCanGetImageVersion	| version |	self timeLimit: 30 seconds.	PhLVirtualMachineManagerTestResource current 		withCopyOfPharo90ImageDo: [ :imageRef | 			version := (PhLVirtualMachineManager forImage: imageRef)				           imageVersion.			self assert: version equals: '90' ]! !!PhLVirtualMachineManagerFunctionalTest methodsFor: 'tests'!testCanGetImageVersionFromFileWhenRunningExtraVM	| vmManager |	self timeLimit: 30 seconds.	PhLVirtualMachineManagerTestResource current		withCopyOfPharo90ImageDo: [ :imageRef | 			vmManager := PhLVirtualMachineManager forImage: imageRef.			vmManager imageVersionFile ensureDelete.			self assert: vmManager imageVersion equals: '90' ]! !!PhLVirtualMachineManagerFunctionalTest methodsFor: 'tests'!testCanGetImageVersionFromFileWithRightCommand	| vmManager command |	self timeLimit: 30 seconds.		vmManager := PhLVirtualMachineManager forImage: Smalltalk image lastImagePath.	vmManager imageVersionFile ensureDelete.	command := PhLProcessWrapper new 		shellCommand;		addArguments: 'echo 60 >';		addArgument: vmManager imageVersionFile fullName surroundedByDoubleQuotes.			self		assert: (vmManager imageVersionFromFileWith: command)		equals: '60'! !!PhLVirtualMachineManagerFunctionalTest methodsFor: 'tests'!testCanGetImageVersionFromPharo14Image	| vmManager |	self skip: 'skip this test for now to allow a release soon'.	self timeLimit: 60 seconds.	PhLVirtualMachineManagerTestResource current 		withCopyOfPharo14ImageDo: [ :imageRef | 			vmManager := PhLVirtualMachineManager forImage: imageRef.			vmManager imageVersionFile ensureDelete.			self assert: vmManager imageVersion equals: '14' ]! !!PhLVirtualMachineManagerFunctionalTest methodsFor: 'tests'!testGetExceptionWhenRunningImageVersionFromFileWithBadCommand	| vmManager command |	command := PhLProcessWrapper new		           shellCommand;		           addArgument: 'foo'.	PhLVirtualMachineManagerTestResource current 		withCopyOfPharo90ImageDo: [ :imageRef | 			vmManager := PhLVirtualMachineManager forImage: imageRef.			vmManager imageVersionFile ensureDelete.			self				should: [ vmManager imageVersionFromFileWith: command ]				raise: PhLImageVersionDeterminationError ]! !!PhLVirtualMachineManagerFunctionalTest methodsFor: 'tests'!testImageVersionDeterminationIsRunWithoutSettings	| manager command |	manager := PhLVirtualMachineManager forImage: Smalltalk image lastImagePath.		command := manager imageVersionCommandWithPreferences: false.		self assert: (command arguments includes: '--no-default-preferences')! !!PhLVirtualMachineManagerFunctionalTest methodsFor: 'tests'!withCopyOfCurrentImageDo: aBlock	| imagePath imageRef |	imageRef := Smalltalk image lastImagePath asFileReference.	imagePath := FileLocator temp / imageRef basename.	imageRef copyTo: imagePath.		[ aBlock value: imagePath ]	ensure: [ imagePath asFileReference ensureDelete ]! !"PharoLauncher-Tests-Functional"!----QUIT----2022-04-28T15:11:08.604541+02:00 PharoLauncher.image priorSource: 198!----QUIT/NOSAVE----2022-04-28T15:11:45.244354+02:00 PharoLauncher.image priorSource: 1676803!----QUIT----2022-04-28T15:11:46.576374+02:00 PharoLauncher.image priorSource: 1676803!----QUIT----2022-04-28T15:11:47.444278+02:00 PharoLauncher.image priorSource: 1676982!----QUIT----2022-04-28T15:11:48.350818+02:00 PharoLauncher.image priorSource: 1677070!